import {
  Portal_default,
  init_PopperUnstyled,
  init_Portal
} from "./chunk-5NBHMOMA.js";
import {
  clsx_m_default,
  createTheme_default,
  darken,
  getContrastRatio,
  init_clsx_m,
  init_esm as init_esm2,
  lighten
} from "./chunk-3D3V2OFD.js";
import {
  _objectWithoutPropertiesLoose,
  init_objectWithoutPropertiesLoose
} from "./chunk-LCB5PCMX.js";
import {
  init_ClickAwayListener
} from "./chunk-LL52ORA6.js";
import {
  HTMLElementType,
  capitalize,
  chainPropTypes,
  createChainedFunction,
  debounce,
  deepmerge,
  elementAcceptingRef_default,
  exactProp,
  getScrollbarSize,
  init_esm,
  ownerDocument,
  ownerWindow,
  setRef,
  useControlled,
  useEnhancedEffect_default,
  useEventCallback,
  useForkRef,
  useId,
  useIsFocusVisible,
  usePreviousProps_default,
  visuallyHidden_default
} from "./chunk-V6TB36QP.js";
import {
  require_react_is
} from "./chunk-WHLCKNSX.js";
import {
  _extends,
  init_extends
} from "./chunk-S4J2UMZF.js";
import {
  require_jsx_runtime
} from "./chunk-LDDDBTIY.js";
import {
  require_prop_types
} from "./chunk-P6ODHCVW.js";
import {
  require_react
} from "./chunk-LBQWZZ6Z.js";
import {
  __esm,
  __toESM
} from "./chunk-TFWDKVI3.js";

// node_modules/@mui/base/utils/isHostComponent.js
function isHostComponent(element) {
  return typeof element === "string";
}
var isHostComponent_default;
var init_isHostComponent = __esm({
  "node_modules/@mui/base/utils/isHostComponent.js"() {
    isHostComponent_default = isHostComponent;
  }
});

// node_modules/@mui/base/utils/appendOwnerState.js
function appendOwnerState(elementType, existingProps = {}, ownerState) {
  if (isHostComponent_default(elementType)) {
    return existingProps;
  }
  return _extends({}, existingProps, {
    ownerState: _extends({}, existingProps.ownerState, ownerState)
  });
}
var init_appendOwnerState = __esm({
  "node_modules/@mui/base/utils/appendOwnerState.js"() {
    init_extends();
    init_isHostComponent();
  }
});

// node_modules/@mui/base/utils/extractEventHandlers.js
function extractEventHandlers(object, excludeKeys = []) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop) => prop.match(/^on[A-Z]/) && typeof object[prop] === "function" && !excludeKeys.includes(prop)).forEach((prop) => {
    result[prop] = object[prop];
  });
  return result;
}
var init_extractEventHandlers = __esm({
  "node_modules/@mui/base/utils/extractEventHandlers.js"() {
  }
});

// node_modules/@mui/base/utils/index.js
var init_utils = __esm({
  "node_modules/@mui/base/utils/index.js"() {
    init_appendOwnerState();
    init_extractEventHandlers();
    init_isHostComponent();
  }
});

// node_modules/@mui/base/AutocompleteUnstyled/useAutocomplete.js
function stripDiacritics(string) {
  return typeof string.normalize !== "undefined" ? string.normalize("NFD").replace(/[\u0300-\u036f]/g, "") : string;
}
function createFilterOptions(config = {}) {
  const {
    ignoreAccents = true,
    ignoreCase = true,
    limit,
    matchFrom = "any",
    stringify,
    trim = false
  } = config;
  return (options, {
    inputValue,
    getOptionLabel
  }) => {
    let input = trim ? inputValue.trim() : inputValue;
    if (ignoreCase) {
      input = input.toLowerCase();
    }
    if (ignoreAccents) {
      input = stripDiacritics(input);
    }
    const filteredOptions = options.filter((option) => {
      let candidate = (stringify || getOptionLabel)(option);
      if (ignoreCase) {
        candidate = candidate.toLowerCase();
      }
      if (ignoreAccents) {
        candidate = stripDiacritics(candidate);
      }
      return matchFrom === "start" ? candidate.indexOf(input) === 0 : candidate.indexOf(input) > -1;
    });
    return typeof limit === "number" ? filteredOptions.slice(0, limit) : filteredOptions;
  };
}
function findIndex(array, comp) {
  for (let i = 0; i < array.length; i += 1) {
    if (comp(array[i])) {
      return i;
    }
  }
  return -1;
}
function useAutocomplete(props) {
  const {
    autoComplete = false,
    autoHighlight = false,
    autoSelect = false,
    blurOnSelect = false,
    disabled: disabledProp,
    clearOnBlur = !props.freeSolo,
    clearOnEscape = false,
    componentName = "useAutocomplete",
    defaultValue = props.multiple ? [] : null,
    disableClearable = false,
    disableCloseOnSelect = false,
    disabledItemsFocusable = false,
    disableListWrap = false,
    filterOptions = defaultFilterOptions,
    filterSelectedOptions = false,
    freeSolo = false,
    getOptionDisabled,
    getOptionLabel: getOptionLabelProp = (option) => {
      var _option$label;
      return (_option$label = option.label) != null ? _option$label : option;
    },
    isOptionEqualToValue = (option, value2) => option === value2,
    groupBy,
    handleHomeEndKeys = !props.freeSolo,
    id: idProp,
    includeInputInList = false,
    inputValue: inputValueProp,
    multiple = false,
    onChange,
    onClose,
    onHighlightChange,
    onInputChange,
    onOpen,
    open: openProp,
    openOnFocus = false,
    options,
    selectOnFocus = !props.freeSolo,
    value: valueProp
  } = props;
  const id = useId(idProp);
  let getOptionLabel = getOptionLabelProp;
  getOptionLabel = (option) => {
    const optionLabel = getOptionLabelProp(option);
    if (typeof optionLabel !== "string") {
      if (true) {
        const erroneousReturn = optionLabel === void 0 ? "undefined" : `${typeof optionLabel} (${optionLabel})`;
        console.error(`MUI: The \`getOptionLabel\` method of ${componentName} returned ${erroneousReturn} instead of a string for ${JSON.stringify(option)}.`);
      }
      return String(optionLabel);
    }
    return optionLabel;
  };
  const ignoreFocus = React.useRef(false);
  const firstFocus = React.useRef(true);
  const inputRef = React.useRef(null);
  const listboxRef = React.useRef(null);
  const [anchorEl, setAnchorEl] = React.useState(null);
  const [focusedTag, setFocusedTag] = React.useState(-1);
  const defaultHighlighted = autoHighlight ? 0 : -1;
  const highlightedIndexRef = React.useRef(defaultHighlighted);
  const [value, setValueState] = useControlled({
    controlled: valueProp,
    default: defaultValue,
    name: componentName
  });
  const [inputValue, setInputValueState] = useControlled({
    controlled: inputValueProp,
    default: "",
    name: componentName,
    state: "inputValue"
  });
  const [focused, setFocused] = React.useState(false);
  const resetInputValue = React.useCallback((event, newValue) => {
    const isOptionSelected = multiple ? value.length < newValue.length : newValue !== null;
    if (!isOptionSelected && !clearOnBlur) {
      return;
    }
    let newInputValue;
    if (multiple) {
      newInputValue = "";
    } else if (newValue == null) {
      newInputValue = "";
    } else {
      const optionLabel = getOptionLabel(newValue);
      newInputValue = typeof optionLabel === "string" ? optionLabel : "";
    }
    if (inputValue === newInputValue) {
      return;
    }
    setInputValueState(newInputValue);
    if (onInputChange) {
      onInputChange(event, newInputValue, "reset");
    }
  }, [getOptionLabel, inputValue, multiple, onInputChange, setInputValueState, clearOnBlur, value]);
  const prevValue = React.useRef();
  React.useEffect(() => {
    const valueChange = value !== prevValue.current;
    prevValue.current = value;
    if (focused && !valueChange) {
      return;
    }
    if (freeSolo && !valueChange) {
      return;
    }
    resetInputValue(null, value);
  }, [value, resetInputValue, focused, prevValue, freeSolo]);
  const [open, setOpenState] = useControlled({
    controlled: openProp,
    default: false,
    name: componentName,
    state: "open"
  });
  const [inputPristine, setInputPristine] = React.useState(true);
  const inputValueIsSelectedValue = !multiple && value != null && inputValue === getOptionLabel(value);
  const popupOpen = open;
  const filteredOptions = popupOpen ? filterOptions(
    options.filter((option) => {
      if (filterSelectedOptions && (multiple ? value : [value]).some((value2) => value2 !== null && isOptionEqualToValue(option, value2))) {
        return false;
      }
      return true;
    }),
    // we use the empty string to manipulate `filterOptions` to not filter any options
    // i.e. the filter predicate always returns true
    {
      inputValue: inputValueIsSelectedValue && inputPristine ? "" : inputValue,
      getOptionLabel
    }
  ) : [];
  const listboxAvailable = open && filteredOptions.length > 0;
  if (true) {
    if (value !== null && !freeSolo && options.length > 0) {
      const missingValue = (multiple ? value : [value]).filter((value2) => !options.some((option) => isOptionEqualToValue(option, value2)));
      if (missingValue.length > 0) {
        console.warn([`MUI: The value provided to ${componentName} is invalid.`, `None of the options match with \`${missingValue.length > 1 ? JSON.stringify(missingValue) : JSON.stringify(missingValue[0])}\`.`, "You can use the `isOptionEqualToValue` prop to customize the equality test."].join("\n"));
      }
    }
  }
  const focusTag = useEventCallback((tagToFocus) => {
    if (tagToFocus === -1) {
      inputRef.current.focus();
    } else {
      anchorEl.querySelector(`[data-tag-index="${tagToFocus}"]`).focus();
    }
  });
  React.useEffect(() => {
    if (multiple && focusedTag > value.length - 1) {
      setFocusedTag(-1);
      focusTag(-1);
    }
  }, [value, multiple, focusedTag, focusTag]);
  function validOptionIndex(index, direction) {
    if (!listboxRef.current || index === -1) {
      return -1;
    }
    let nextFocus = index;
    while (true) {
      if (direction === "next" && nextFocus === filteredOptions.length || direction === "previous" && nextFocus === -1) {
        return -1;
      }
      const option = listboxRef.current.querySelector(`[data-option-index="${nextFocus}"]`);
      const nextFocusDisabled = disabledItemsFocusable ? false : !option || option.disabled || option.getAttribute("aria-disabled") === "true";
      if (option && !option.hasAttribute("tabindex") || nextFocusDisabled) {
        nextFocus += direction === "next" ? 1 : -1;
      } else {
        return nextFocus;
      }
    }
  }
  const setHighlightedIndex = useEventCallback(({
    event,
    index,
    reason = "auto"
  }) => {
    highlightedIndexRef.current = index;
    if (index === -1) {
      inputRef.current.removeAttribute("aria-activedescendant");
    } else {
      inputRef.current.setAttribute("aria-activedescendant", `${id}-option-${index}`);
    }
    if (onHighlightChange) {
      onHighlightChange(event, index === -1 ? null : filteredOptions[index], reason);
    }
    if (!listboxRef.current) {
      return;
    }
    const prev = listboxRef.current.querySelector('[role="option"].Mui-focused');
    if (prev) {
      prev.classList.remove("Mui-focused");
      prev.classList.remove("Mui-focusVisible");
    }
    const listboxNode = listboxRef.current.parentElement.querySelector('[role="listbox"]');
    if (!listboxNode) {
      return;
    }
    if (index === -1) {
      listboxNode.scrollTop = 0;
      return;
    }
    const option = listboxRef.current.querySelector(`[data-option-index="${index}"]`);
    if (!option) {
      return;
    }
    option.classList.add("Mui-focused");
    if (reason === "keyboard") {
      option.classList.add("Mui-focusVisible");
    }
    if (listboxNode.scrollHeight > listboxNode.clientHeight && reason !== "mouse") {
      const element = option;
      const scrollBottom = listboxNode.clientHeight + listboxNode.scrollTop;
      const elementBottom = element.offsetTop + element.offsetHeight;
      if (elementBottom > scrollBottom) {
        listboxNode.scrollTop = elementBottom - listboxNode.clientHeight;
      } else if (element.offsetTop - element.offsetHeight * (groupBy ? 1.3 : 0) < listboxNode.scrollTop) {
        listboxNode.scrollTop = element.offsetTop - element.offsetHeight * (groupBy ? 1.3 : 0);
      }
    }
  });
  const changeHighlightedIndex = useEventCallback(({
    event,
    diff,
    direction = "next",
    reason = "auto"
  }) => {
    if (!popupOpen) {
      return;
    }
    const getNextIndex = () => {
      const maxIndex = filteredOptions.length - 1;
      if (diff === "reset") {
        return defaultHighlighted;
      }
      if (diff === "start") {
        return 0;
      }
      if (diff === "end") {
        return maxIndex;
      }
      const newIndex = highlightedIndexRef.current + diff;
      if (newIndex < 0) {
        if (newIndex === -1 && includeInputInList) {
          return -1;
        }
        if (disableListWrap && highlightedIndexRef.current !== -1 || Math.abs(diff) > 1) {
          return 0;
        }
        return maxIndex;
      }
      if (newIndex > maxIndex) {
        if (newIndex === maxIndex + 1 && includeInputInList) {
          return -1;
        }
        if (disableListWrap || Math.abs(diff) > 1) {
          return maxIndex;
        }
        return 0;
      }
      return newIndex;
    };
    const nextIndex = validOptionIndex(getNextIndex(), direction);
    setHighlightedIndex({
      index: nextIndex,
      reason,
      event
    });
    if (autoComplete && diff !== "reset") {
      if (nextIndex === -1) {
        inputRef.current.value = inputValue;
      } else {
        const option = getOptionLabel(filteredOptions[nextIndex]);
        inputRef.current.value = option;
        const index = option.toLowerCase().indexOf(inputValue.toLowerCase());
        if (index === 0 && inputValue.length > 0) {
          inputRef.current.setSelectionRange(inputValue.length, option.length);
        }
      }
    }
  });
  const syncHighlightedIndex = React.useCallback(() => {
    if (!popupOpen) {
      return;
    }
    const valueItem = multiple ? value[0] : value;
    if (filteredOptions.length === 0 || valueItem == null) {
      changeHighlightedIndex({
        diff: "reset"
      });
      return;
    }
    if (!listboxRef.current) {
      return;
    }
    if (valueItem != null) {
      const currentOption = filteredOptions[highlightedIndexRef.current];
      if (multiple && currentOption && findIndex(value, (val) => isOptionEqualToValue(currentOption, val)) !== -1) {
        return;
      }
      const itemIndex = findIndex(filteredOptions, (optionItem) => isOptionEqualToValue(optionItem, valueItem));
      if (itemIndex === -1) {
        changeHighlightedIndex({
          diff: "reset"
        });
      } else {
        setHighlightedIndex({
          index: itemIndex
        });
      }
      return;
    }
    if (highlightedIndexRef.current >= filteredOptions.length - 1) {
      setHighlightedIndex({
        index: filteredOptions.length - 1
      });
      return;
    }
    setHighlightedIndex({
      index: highlightedIndexRef.current
    });
  }, [
    // Only sync the highlighted index when the option switch between empty and not
    filteredOptions.length,
    // Don't sync the highlighted index with the value when multiple
    // eslint-disable-next-line react-hooks/exhaustive-deps
    multiple ? false : value,
    filterSelectedOptions,
    changeHighlightedIndex,
    setHighlightedIndex,
    popupOpen,
    inputValue,
    multiple
  ]);
  const handleListboxRef = useEventCallback((node) => {
    setRef(listboxRef, node);
    if (!node) {
      return;
    }
    syncHighlightedIndex();
  });
  if (true) {
    React.useEffect(() => {
      if (!inputRef.current || inputRef.current.nodeName !== "INPUT") {
        console.error([`MUI: Unable to find the input element. It was resolved to ${inputRef.current} while an HTMLInputElement was expected.`, `Instead, ${componentName} expects an input element.`, "", componentName === "useAutocomplete" ? "Make sure you have binded getInputProps correctly and that the normal ref/effect resolutions order is guaranteed." : "Make sure you have customized the input component correctly."].join("\n"));
      }
    }, [componentName]);
  }
  React.useEffect(() => {
    syncHighlightedIndex();
  }, [syncHighlightedIndex]);
  const handleOpen = (event) => {
    if (open) {
      return;
    }
    setOpenState(true);
    setInputPristine(true);
    if (onOpen) {
      onOpen(event);
    }
  };
  const handleClose = (event, reason) => {
    if (!open) {
      return;
    }
    setOpenState(false);
    if (onClose) {
      onClose(event, reason);
    }
  };
  const handleValue = (event, newValue, reason, details) => {
    if (value === newValue) {
      return;
    }
    if (onChange) {
      onChange(event, newValue, reason, details);
    }
    setValueState(newValue);
  };
  const isTouch = React.useRef(false);
  const selectNewValue = (event, option, reasonProp = "selectOption", origin = "options") => {
    let reason = reasonProp;
    let newValue = option;
    if (multiple) {
      newValue = Array.isArray(value) ? value.slice() : [];
      if (true) {
        const matches = newValue.filter((val) => isOptionEqualToValue(option, val));
        if (matches.length > 1) {
          console.error([`MUI: The \`isOptionEqualToValue\` method of ${componentName} do not handle the arguments correctly.`, `The component expects a single value to match a given option but found ${matches.length} matches.`].join("\n"));
        }
      }
      const itemIndex = findIndex(newValue, (valueItem) => isOptionEqualToValue(option, valueItem));
      if (itemIndex === -1) {
        newValue.push(option);
      } else if (origin !== "freeSolo") {
        newValue.splice(itemIndex, 1);
        reason = "removeOption";
      }
    }
    resetInputValue(event, newValue);
    handleValue(event, newValue, reason, {
      option
    });
    if (!disableCloseOnSelect && !event.ctrlKey && !event.metaKey) {
      handleClose(event, reason);
    }
    if (blurOnSelect === true || blurOnSelect === "touch" && isTouch.current || blurOnSelect === "mouse" && !isTouch.current) {
      inputRef.current.blur();
    }
  };
  function validTagIndex(index, direction) {
    if (index === -1) {
      return -1;
    }
    let nextFocus = index;
    while (true) {
      if (direction === "next" && nextFocus === value.length || direction === "previous" && nextFocus === -1) {
        return -1;
      }
      const option = anchorEl.querySelector(`[data-tag-index="${nextFocus}"]`);
      if (!option || !option.hasAttribute("tabindex") || option.disabled || option.getAttribute("aria-disabled") === "true") {
        nextFocus += direction === "next" ? 1 : -1;
      } else {
        return nextFocus;
      }
    }
  }
  const handleFocusTag = (event, direction) => {
    if (!multiple) {
      return;
    }
    handleClose(event, "toggleInput");
    let nextTag = focusedTag;
    if (focusedTag === -1) {
      if (inputValue === "" && direction === "previous") {
        nextTag = value.length - 1;
      }
    } else {
      nextTag += direction === "next" ? 1 : -1;
      if (nextTag < 0) {
        nextTag = 0;
      }
      if (nextTag === value.length) {
        nextTag = -1;
      }
    }
    nextTag = validTagIndex(nextTag, direction);
    setFocusedTag(nextTag);
    focusTag(nextTag);
  };
  const handleClear = (event) => {
    ignoreFocus.current = true;
    setInputValueState("");
    if (onInputChange) {
      onInputChange(event, "", "clear");
    }
    handleValue(event, multiple ? [] : null, "clear");
  };
  const handleKeyDown = (other) => (event) => {
    if (other.onKeyDown) {
      other.onKeyDown(event);
    }
    if (event.defaultMuiPrevented) {
      return;
    }
    if (focusedTag !== -1 && ["ArrowLeft", "ArrowRight"].indexOf(event.key) === -1) {
      setFocusedTag(-1);
      focusTag(-1);
    }
    if (event.which !== 229) {
      switch (event.key) {
        case "Home":
          if (popupOpen && handleHomeEndKeys) {
            event.preventDefault();
            changeHighlightedIndex({
              diff: "start",
              direction: "next",
              reason: "keyboard",
              event
            });
          }
          break;
        case "End":
          if (popupOpen && handleHomeEndKeys) {
            event.preventDefault();
            changeHighlightedIndex({
              diff: "end",
              direction: "previous",
              reason: "keyboard",
              event
            });
          }
          break;
        case "PageUp":
          event.preventDefault();
          changeHighlightedIndex({
            diff: -pageSize,
            direction: "previous",
            reason: "keyboard",
            event
          });
          handleOpen(event);
          break;
        case "PageDown":
          event.preventDefault();
          changeHighlightedIndex({
            diff: pageSize,
            direction: "next",
            reason: "keyboard",
            event
          });
          handleOpen(event);
          break;
        case "ArrowDown":
          event.preventDefault();
          changeHighlightedIndex({
            diff: 1,
            direction: "next",
            reason: "keyboard",
            event
          });
          handleOpen(event);
          break;
        case "ArrowUp":
          event.preventDefault();
          changeHighlightedIndex({
            diff: -1,
            direction: "previous",
            reason: "keyboard",
            event
          });
          handleOpen(event);
          break;
        case "ArrowLeft":
          handleFocusTag(event, "previous");
          break;
        case "ArrowRight":
          handleFocusTag(event, "next");
          break;
        case "Enter":
          if (highlightedIndexRef.current !== -1 && popupOpen) {
            const option = filteredOptions[highlightedIndexRef.current];
            const disabled = getOptionDisabled ? getOptionDisabled(option) : false;
            event.preventDefault();
            if (disabled) {
              return;
            }
            selectNewValue(event, option, "selectOption");
            if (autoComplete) {
              inputRef.current.setSelectionRange(inputRef.current.value.length, inputRef.current.value.length);
            }
          } else if (freeSolo && inputValue !== "" && inputValueIsSelectedValue === false) {
            if (multiple) {
              event.preventDefault();
            }
            selectNewValue(event, inputValue, "createOption", "freeSolo");
          }
          break;
        case "Escape":
          if (popupOpen) {
            event.preventDefault();
            event.stopPropagation();
            handleClose(event, "escape");
          } else if (clearOnEscape && (inputValue !== "" || multiple && value.length > 0)) {
            event.preventDefault();
            event.stopPropagation();
            handleClear(event);
          }
          break;
        case "Backspace":
          if (multiple && inputValue === "" && value.length > 0) {
            const index = focusedTag === -1 ? value.length - 1 : focusedTag;
            const newValue = value.slice();
            newValue.splice(index, 1);
            handleValue(event, newValue, "removeOption", {
              option: value[index]
            });
          }
          break;
        default:
      }
    }
  };
  const handleFocus = (event) => {
    setFocused(true);
    if (openOnFocus && !ignoreFocus.current) {
      handleOpen(event);
    }
  };
  const handleBlur = (event) => {
    if (listboxRef.current !== null && listboxRef.current.parentElement.contains(document.activeElement)) {
      inputRef.current.focus();
      return;
    }
    setFocused(false);
    firstFocus.current = true;
    ignoreFocus.current = false;
    if (autoSelect && highlightedIndexRef.current !== -1 && popupOpen) {
      selectNewValue(event, filteredOptions[highlightedIndexRef.current], "blur");
    } else if (autoSelect && freeSolo && inputValue !== "") {
      selectNewValue(event, inputValue, "blur", "freeSolo");
    } else if (clearOnBlur) {
      resetInputValue(event, value);
    }
    handleClose(event, "blur");
  };
  const handleInputChange = (event) => {
    const newValue = event.target.value;
    if (inputValue !== newValue) {
      setInputValueState(newValue);
      setInputPristine(false);
      if (onInputChange) {
        onInputChange(event, newValue, "input");
      }
    }
    if (newValue === "") {
      if (!disableClearable && !multiple) {
        handleValue(event, null, "clear");
      }
    } else {
      handleOpen(event);
    }
  };
  const handleOptionMouseOver = (event) => {
    setHighlightedIndex({
      event,
      index: Number(event.currentTarget.getAttribute("data-option-index")),
      reason: "mouse"
    });
  };
  const handleOptionTouchStart = () => {
    isTouch.current = true;
  };
  const handleOptionClick = (event) => {
    const index = Number(event.currentTarget.getAttribute("data-option-index"));
    selectNewValue(event, filteredOptions[index], "selectOption");
    isTouch.current = false;
  };
  const handleTagDelete = (index) => (event) => {
    const newValue = value.slice();
    newValue.splice(index, 1);
    handleValue(event, newValue, "removeOption", {
      option: value[index]
    });
  };
  const handlePopupIndicator = (event) => {
    if (open) {
      handleClose(event, "toggleInput");
    } else {
      handleOpen(event);
    }
  };
  const handleMouseDown = (event) => {
    if (event.target.getAttribute("id") !== id) {
      event.preventDefault();
    }
  };
  const handleClick = () => {
    inputRef.current.focus();
    if (selectOnFocus && firstFocus.current && inputRef.current.selectionEnd - inputRef.current.selectionStart === 0) {
      inputRef.current.select();
    }
    firstFocus.current = false;
  };
  const handleInputMouseDown = (event) => {
    if (inputValue === "" || !open) {
      handlePopupIndicator(event);
    }
  };
  let dirty = freeSolo && inputValue.length > 0;
  dirty = dirty || (multiple ? value.length > 0 : value !== null);
  let groupedOptions = filteredOptions;
  if (groupBy) {
    const indexBy = /* @__PURE__ */ new Map();
    let warn = false;
    groupedOptions = filteredOptions.reduce((acc, option, index) => {
      const group = groupBy(option);
      if (acc.length > 0 && acc[acc.length - 1].group === group) {
        acc[acc.length - 1].options.push(option);
      } else {
        if (true) {
          if (indexBy.get(group) && !warn) {
            console.warn(`MUI: The options provided combined with the \`groupBy\` method of ${componentName} returns duplicated headers.`, "You can solve the issue by sorting the options with the output of `groupBy`.");
            warn = true;
          }
          indexBy.set(group, true);
        }
        acc.push({
          key: index,
          index,
          group,
          options: [option]
        });
      }
      return acc;
    }, []);
  }
  if (disabledProp && focused) {
    handleBlur();
  }
  return {
    getRootProps: (other = {}) => _extends({
      "aria-owns": listboxAvailable ? `${id}-listbox` : null,
      role: "combobox",
      "aria-expanded": listboxAvailable
    }, other, {
      onKeyDown: handleKeyDown(other),
      onMouseDown: handleMouseDown,
      onClick: handleClick
    }),
    getInputLabelProps: () => ({
      id: `${id}-label`,
      htmlFor: id
    }),
    getInputProps: () => ({
      id,
      value: inputValue,
      onBlur: handleBlur,
      onFocus: handleFocus,
      onChange: handleInputChange,
      onMouseDown: handleInputMouseDown,
      // if open then this is handled imperativeley so don't let react override
      // only have an opinion about this when closed
      "aria-activedescendant": popupOpen ? "" : null,
      "aria-autocomplete": autoComplete ? "both" : "list",
      "aria-controls": listboxAvailable ? `${id}-listbox` : void 0,
      // Disable browser's suggestion that might overlap with the popup.
      // Handle autocomplete but not autofill.
      autoComplete: "off",
      ref: inputRef,
      autoCapitalize: "none",
      spellCheck: "false"
    }),
    getClearProps: () => ({
      tabIndex: -1,
      onClick: handleClear
    }),
    getPopupIndicatorProps: () => ({
      tabIndex: -1,
      onClick: handlePopupIndicator
    }),
    getTagProps: ({
      index
    }) => ({
      key: index,
      "data-tag-index": index,
      tabIndex: -1,
      onDelete: handleTagDelete(index)
    }),
    getListboxProps: () => ({
      role: "listbox",
      id: `${id}-listbox`,
      "aria-labelledby": `${id}-label`,
      ref: handleListboxRef,
      onMouseDown: (event) => {
        event.preventDefault();
      }
    }),
    getOptionProps: ({
      index,
      option
    }) => {
      const selected = (multiple ? value : [value]).some((value2) => value2 != null && isOptionEqualToValue(option, value2));
      const disabled = getOptionDisabled ? getOptionDisabled(option) : false;
      return {
        key: getOptionLabel(option),
        tabIndex: -1,
        role: "option",
        id: `${id}-option-${index}`,
        onMouseOver: handleOptionMouseOver,
        onClick: handleOptionClick,
        onTouchStart: handleOptionTouchStart,
        "data-option-index": index,
        "aria-disabled": disabled,
        "aria-selected": selected
      };
    },
    id,
    inputValue,
    value,
    dirty,
    popupOpen,
    focused: focused || focusedTag !== -1,
    anchorEl,
    setAnchorEl,
    focusedTag,
    groupedOptions
  };
}
var React, defaultFilterOptions, pageSize;
var init_useAutocomplete = __esm({
  "node_modules/@mui/base/AutocompleteUnstyled/useAutocomplete.js"() {
    init_extends();
    React = __toESM(require_react());
    init_esm();
    defaultFilterOptions = createFilterOptions();
    pageSize = 5;
  }
});

// node_modules/@mui/base/AutocompleteUnstyled/index.js
var init_AutocompleteUnstyled = __esm({
  "node_modules/@mui/base/AutocompleteUnstyled/index.js"() {
    init_useAutocomplete();
  }
});

// node_modules/@mui/base/composeClasses/composeClasses.js
function composeClasses(slots, getUtilityClass, classes) {
  const output = {};
  Object.keys(slots).forEach(
    // `Objet.keys(slots)` can't be wider than `T` because we infer `T` from `slots`.
    // @ts-expect-error https://github.com/microsoft/TypeScript/pull/12253#issuecomment-263132208
    (slot) => {
      output[slot] = slots[slot].reduce((acc, key) => {
        if (key) {
          if (classes && classes[key]) {
            acc.push(classes[key]);
          }
          acc.push(getUtilityClass(key));
        }
        return acc;
      }, []).join(" ");
    }
  );
  return output;
}
var init_composeClasses = __esm({
  "node_modules/@mui/base/composeClasses/composeClasses.js"() {
  }
});

// node_modules/@mui/base/composeClasses/index.js
var init_composeClasses2 = __esm({
  "node_modules/@mui/base/composeClasses/index.js"() {
    init_composeClasses();
  }
});

// node_modules/@mui/base/generateUtilityClass/ClassNameGenerator.js
var defaultGenerator, createClassNameGenerator, ClassNameGenerator, ClassNameGenerator_default;
var init_ClassNameGenerator = __esm({
  "node_modules/@mui/base/generateUtilityClass/ClassNameGenerator.js"() {
    defaultGenerator = (componentName) => componentName;
    createClassNameGenerator = () => {
      let generate = defaultGenerator;
      return {
        configure(generator) {
          generate = generator;
        },
        generate(componentName) {
          return generate(componentName);
        },
        reset() {
          generate = defaultGenerator;
        }
      };
    };
    ClassNameGenerator = createClassNameGenerator();
    ClassNameGenerator_default = ClassNameGenerator;
  }
});

// node_modules/@mui/base/generateUtilityClass/generateUtilityClass.js
function generateUtilityClass(componentName, slot) {
  const globalStateClass = globalStateClassesMapping[slot];
  return globalStateClass || `${ClassNameGenerator_default.generate(componentName)}-${slot}`;
}
var globalStateClassesMapping;
var init_generateUtilityClass = __esm({
  "node_modules/@mui/base/generateUtilityClass/generateUtilityClass.js"() {
    init_ClassNameGenerator();
    globalStateClassesMapping = {
      active: "Mui-active",
      checked: "Mui-checked",
      completed: "Mui-completed",
      disabled: "Mui-disabled",
      error: "Mui-error",
      expanded: "Mui-expanded",
      focused: "Mui-focused",
      focusVisible: "Mui-focusVisible",
      required: "Mui-required",
      selected: "Mui-selected"
    };
  }
});

// node_modules/@mui/base/generateUtilityClass/index.js
var init_generateUtilityClass2 = __esm({
  "node_modules/@mui/base/generateUtilityClass/index.js"() {
    init_generateUtilityClass();
    init_generateUtilityClass();
    init_ClassNameGenerator();
  }
});

// node_modules/@mui/base/generateUtilityClasses/generateUtilityClasses.js
function generateUtilityClasses(componentName, slots) {
  const result = {};
  slots.forEach((slot) => {
    result[slot] = generateUtilityClass(componentName, slot);
  });
  return result;
}
var init_generateUtilityClasses = __esm({
  "node_modules/@mui/base/generateUtilityClasses/generateUtilityClasses.js"() {
    init_generateUtilityClass2();
  }
});

// node_modules/@mui/base/generateUtilityClasses/index.js
var init_generateUtilityClasses2 = __esm({
  "node_modules/@mui/base/generateUtilityClasses/index.js"() {
    init_generateUtilityClasses();
  }
});

// node_modules/@mui/base/BackdropUnstyled/backdropUnstyledClasses.js
function getBackdropUtilityClass(slot) {
  return generateUtilityClass("MuiBackdrop", slot);
}
var backdropUnstyledClasses, backdropUnstyledClasses_default;
var init_backdropUnstyledClasses = __esm({
  "node_modules/@mui/base/BackdropUnstyled/backdropUnstyledClasses.js"() {
    init_generateUtilityClasses2();
    init_generateUtilityClass2();
    backdropUnstyledClasses = generateUtilityClasses("MuiBackdrop", ["root", "invisible"]);
    backdropUnstyledClasses_default = backdropUnstyledClasses;
  }
});

// node_modules/@mui/base/BackdropUnstyled/BackdropUnstyled.js
var React2, import_prop_types, import_jsx_runtime, _excluded, useUtilityClasses, BackdropUnstyled, BackdropUnstyled_default;
var init_BackdropUnstyled = __esm({
  "node_modules/@mui/base/BackdropUnstyled/BackdropUnstyled.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React2 = __toESM(require_react());
    import_prop_types = __toESM(require_prop_types());
    init_clsx_m();
    init_composeClasses2();
    init_isHostComponent();
    init_backdropUnstyledClasses();
    import_jsx_runtime = __toESM(require_jsx_runtime());
    _excluded = ["classes", "className", "invisible", "component", "components", "componentsProps", "theme"];
    useUtilityClasses = (ownerState) => {
      const {
        classes,
        invisible
      } = ownerState;
      const slots = {
        root: ["root", invisible && "invisible"]
      };
      return composeClasses(slots, getBackdropUtilityClass, classes);
    };
    BackdropUnstyled = React2.forwardRef(function BackdropUnstyled2(props, ref) {
      const {
        classes: classesProp,
        className,
        invisible = false,
        component = "div",
        components = {},
        componentsProps = {},
        /* eslint-disable react/prop-types */
        theme
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded);
      const ownerState = _extends({}, props, {
        classes: classesProp,
        invisible
      });
      const classes = useUtilityClasses(ownerState);
      const Root = components.Root || component;
      const rootProps = componentsProps.root || {};
      return (0, import_jsx_runtime.jsx)(Root, _extends({
        "aria-hidden": true
      }, rootProps, !isHostComponent_default(Root) && {
        as: component,
        ownerState: _extends({}, ownerState, rootProps.ownerState),
        theme
      }, {
        ref
      }, other, {
        className: clsx_m_default(classes.root, rootProps.className, className)
      }));
    });
    true ? BackdropUnstyled.propTypes = {
      // ----------------------------- Warning --------------------------------
      // | These PropTypes are generated from the TypeScript type definitions |
      // |     To update them edit the d.ts file and run "yarn proptypes"     |
      // ----------------------------------------------------------------------
      /**
       * The content of the component.
       */
      children: import_prop_types.default.node,
      /**
       * Override or extend the styles applied to the component.
       */
      classes: import_prop_types.default.object,
      /**
       * @ignore
       */
      className: import_prop_types.default.string,
      /**
       * The component used for the root node.
       * Either a string to use a HTML element or a component.
       */
      component: import_prop_types.default.elementType,
      /**
       * The components used for each slot inside the Backdrop.
       * Either a string to use a HTML element or a component.
       * @default {}
       */
      components: import_prop_types.default.shape({
        Root: import_prop_types.default.elementType
      }),
      /**
       * The props used for each slot inside the Backdrop.
       * @default {}
       */
      componentsProps: import_prop_types.default.object,
      /**
       * If `true`, the backdrop is invisible.
       * It can be used when rendering a popover or a custom select component.
       * @default false
       */
      invisible: import_prop_types.default.bool
    } : void 0;
    BackdropUnstyled_default = BackdropUnstyled;
  }
});

// node_modules/@mui/base/BackdropUnstyled/index.js
var init_BackdropUnstyled2 = __esm({
  "node_modules/@mui/base/BackdropUnstyled/index.js"() {
    init_BackdropUnstyled();
    init_backdropUnstyledClasses();
  }
});

// node_modules/@mui/base/BadgeUnstyled/useBadge.js
function useBadge(props) {
  const {
    anchorOrigin: anchorOriginProp = {
      vertical: "top",
      horizontal: "right"
    },
    badgeContent: badgeContentProp,
    invisible: invisibleProp,
    max: maxProp = 99,
    showZero = false,
    variant: variantProp = "standard"
  } = props;
  const prevProps = usePreviousProps_default({
    anchorOrigin: anchorOriginProp,
    badgeContent: badgeContentProp,
    max: maxProp,
    variant: variantProp
  });
  let invisible = invisibleProp;
  if (invisibleProp == null && (badgeContentProp === 0 && !showZero || badgeContentProp == null && variantProp !== "dot")) {
    invisible = true;
  }
  const {
    anchorOrigin = anchorOriginProp,
    badgeContent,
    max = maxProp,
    variant = variantProp
  } = invisible ? prevProps : props;
  let displayValue = "";
  if (variant !== "dot") {
    displayValue = badgeContent && Number(badgeContent) > max ? `${max}+` : badgeContent;
  }
  return {
    anchorOrigin,
    badgeContent,
    invisible,
    max,
    variant,
    displayValue
  };
}
var init_useBadge = __esm({
  "node_modules/@mui/base/BadgeUnstyled/useBadge.js"() {
    init_esm();
  }
});

// node_modules/@mui/base/BadgeUnstyled/badgeUnstyledClasses.js
function getBadgeUtilityClass(slot) {
  return generateUtilityClass("MuiBadge", slot);
}
var badgeUnstyledClasses, badgeUnstyledClasses_default;
var init_badgeUnstyledClasses = __esm({
  "node_modules/@mui/base/BadgeUnstyled/badgeUnstyledClasses.js"() {
    init_generateUtilityClasses2();
    init_generateUtilityClass2();
    badgeUnstyledClasses = generateUtilityClasses("MuiBadge", ["root", "badge", "dot", "standard", "anchorOriginTopLeft", "anchorOriginTopRight", "anchorOriginBottomLeft", "anchorOriginBottomRight", "invisible"]);
    badgeUnstyledClasses_default = badgeUnstyledClasses;
  }
});

// node_modules/@mui/base/BadgeUnstyled/BadgeUnstyled.js
var React3, import_prop_types2, import_jsx_runtime2, import_jsx_runtime3, _excluded2, useUtilityClasses2, BadgeUnstyled, BadgeUnstyled_default;
var init_BadgeUnstyled = __esm({
  "node_modules/@mui/base/BadgeUnstyled/BadgeUnstyled.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React3 = __toESM(require_react());
    import_prop_types2 = __toESM(require_prop_types());
    init_clsx_m();
    init_esm();
    init_composeClasses2();
    init_appendOwnerState();
    init_useBadge();
    init_badgeUnstyledClasses();
    import_jsx_runtime2 = __toESM(require_jsx_runtime());
    import_jsx_runtime3 = __toESM(require_jsx_runtime());
    _excluded2 = ["anchorOrigin", "classes", "badgeContent", "component", "children", "className", "components", "componentsProps", "invisible", "max", "showZero", "variant"];
    useUtilityClasses2 = (ownerState) => {
      const {
        variant,
        anchorOrigin,
        invisible,
        classes
      } = ownerState;
      const slots = {
        root: ["root"],
        badge: ["badge", variant, `anchorOrigin${capitalize(anchorOrigin.vertical)}${capitalize(anchorOrigin.horizontal)}`, invisible && "invisible"]
      };
      return composeClasses(slots, getBadgeUtilityClass, classes);
    };
    BadgeUnstyled = React3.forwardRef(function BadgeUnstyled2(props, ref) {
      const {
        anchorOrigin: anchorOriginProp = {
          vertical: "top",
          horizontal: "right"
        },
        classes: classesProp,
        component,
        children,
        className,
        components = {},
        componentsProps = {},
        max: maxProp = 99,
        showZero = false,
        variant: variantProp = "standard"
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded2);
      const {
        anchorOrigin,
        badgeContent,
        max,
        variant,
        displayValue,
        invisible
      } = useBadge(_extends({}, props, {
        anchorOrigin: anchorOriginProp,
        max: maxProp,
        variant: variantProp
      }));
      const ownerState = _extends({}, props, {
        anchorOrigin,
        badgeContent,
        classes: classesProp,
        invisible,
        max,
        variant,
        showZero
      });
      const classes = useUtilityClasses2(ownerState);
      const Root = component || components.Root || "span";
      const rootProps = appendOwnerState(Root, _extends({}, other, componentsProps.root), ownerState);
      const Badge = components.Badge || "span";
      const badgeProps = appendOwnerState(Badge, componentsProps.badge, ownerState);
      return (0, import_jsx_runtime3.jsxs)(Root, _extends({}, rootProps, {
        ref
      }, other, {
        className: clsx_m_default(classes.root, rootProps.className, className),
        children: [children, (0, import_jsx_runtime2.jsx)(Badge, _extends({}, badgeProps, {
          className: clsx_m_default(classes.badge, badgeProps.className),
          children: displayValue
        }))]
      }));
    });
    true ? BadgeUnstyled.propTypes = {
      // ----------------------------- Warning --------------------------------
      // | These PropTypes are generated from the TypeScript type definitions |
      // |     To update them edit the d.ts file and run "yarn proptypes"     |
      // ----------------------------------------------------------------------
      /**
       * The anchor of the badge.
       * @default {
       *   vertical: 'top',
       *   horizontal: 'right',
       * }
       */
      anchorOrigin: import_prop_types2.default.shape({
        horizontal: import_prop_types2.default.oneOf(["left", "right"]).isRequired,
        vertical: import_prop_types2.default.oneOf(["bottom", "top"]).isRequired
      }),
      /**
       * The content rendered within the badge.
       */
      badgeContent: import_prop_types2.default.node,
      /**
       * The badge will be added relative to this node.
       */
      children: import_prop_types2.default.node,
      /**
       * Override or extend the styles applied to the component.
       */
      classes: import_prop_types2.default.object,
      /**
       * @ignore
       */
      className: import_prop_types2.default.string,
      /**
       * The component used for the root node.
       * Either a string to use a HTML element or a component.
       */
      component: import_prop_types2.default.elementType,
      /**
       * The components used for each slot inside the Badge.
       * Either a string to use a HTML element or a component.
       * @default {}
       */
      components: import_prop_types2.default.shape({
        Badge: import_prop_types2.default.elementType,
        Root: import_prop_types2.default.elementType
      }),
      /**
       * The props used for each slot inside the Badge.
       * @default {}
       */
      componentsProps: import_prop_types2.default.object,
      /**
       * If `true`, the badge is invisible.
       */
      invisible: import_prop_types2.default.bool,
      /**
       * Max count to show.
       * @default 99
       */
      max: import_prop_types2.default.number,
      /**
       * Controls whether the badge is hidden when `badgeContent` is zero.
       * @default false
       */
      showZero: import_prop_types2.default.bool,
      /**
       * The variant to use.
       * @default 'standard'
       */
      variant: import_prop_types2.default.string
    } : void 0;
    BadgeUnstyled_default = BadgeUnstyled;
  }
});

// node_modules/@mui/base/BadgeUnstyled/index.js
var init_BadgeUnstyled2 = __esm({
  "node_modules/@mui/base/BadgeUnstyled/index.js"() {
    init_BadgeUnstyled();
    init_useBadge();
    init_badgeUnstyledClasses();
  }
});

// node_modules/@mui/base/ButtonUnstyled/buttonUnstyledClasses.js
function getButtonUnstyledUtilityClass(slot) {
  return generateUtilityClass("ButtonUnstyled", slot);
}
var buttonUnstyledClasses, buttonUnstyledClasses_default;
var init_buttonUnstyledClasses = __esm({
  "node_modules/@mui/base/ButtonUnstyled/buttonUnstyledClasses.js"() {
    init_generateUtilityClass2();
    init_generateUtilityClasses2();
    buttonUnstyledClasses = generateUtilityClasses("ButtonUnstyled", ["root", "active", "disabled", "focusVisible"]);
    buttonUnstyledClasses_default = buttonUnstyledClasses;
  }
});

// node_modules/@mui/base/ButtonUnstyled/useButton.js
function useButton(props) {
  var _ref;
  const {
    component,
    components = {},
    disabled = false,
    href,
    ref,
    tabIndex = 0,
    to,
    type
  } = props;
  const buttonRef = React4.useRef();
  const [active, setActive] = React4.useState(false);
  const {
    isFocusVisibleRef,
    onFocus: handleFocusVisible,
    onBlur: handleBlurVisible,
    ref: focusVisibleRef
  } = useIsFocusVisible();
  const [focusVisible, setFocusVisible] = React4.useState(false);
  if (disabled && focusVisible) {
    setFocusVisible(false);
  }
  React4.useEffect(() => {
    isFocusVisibleRef.current = focusVisible;
  }, [focusVisible, isFocusVisibleRef]);
  const createHandleMouseLeave = (otherHandlers) => (event) => {
    var _otherHandlers$onMous;
    if (focusVisible) {
      event.preventDefault();
    }
    (_otherHandlers$onMous = otherHandlers.onMouseLeave) == null ? void 0 : _otherHandlers$onMous.call(otherHandlers, event);
  };
  const createHandleBlur = (otherHandlers) => (event) => {
    var _otherHandlers$onBlur;
    handleBlurVisible(event);
    if (isFocusVisibleRef.current === false) {
      setFocusVisible(false);
    }
    (_otherHandlers$onBlur = otherHandlers.onBlur) == null ? void 0 : _otherHandlers$onBlur.call(otherHandlers, event);
  };
  const createHandleFocus = (otherHandlers) => (event) => {
    var _otherHandlers$onFocu2;
    if (!buttonRef.current) {
      buttonRef.current = event.currentTarget;
    }
    handleFocusVisible(event);
    if (isFocusVisibleRef.current === true) {
      var _otherHandlers$onFocu;
      setFocusVisible(true);
      (_otherHandlers$onFocu = otherHandlers.onFocusVisible) == null ? void 0 : _otherHandlers$onFocu.call(otherHandlers, event);
    }
    (_otherHandlers$onFocu2 = otherHandlers.onFocus) == null ? void 0 : _otherHandlers$onFocu2.call(otherHandlers, event);
  };
  const elementType = (_ref = component != null ? component : components.Root) != null ? _ref : "button";
  const isNonNativeButton = () => {
    const button = buttonRef.current;
    return elementType !== "button" && !((button == null ? void 0 : button.tagName) === "A" && button != null && button.href);
  };
  const createHandleMouseDown = (otherHandlers) => (event) => {
    var _otherHandlers$onMous2;
    if (event.target === event.currentTarget && !disabled) {
      setActive(true);
    }
    (_otherHandlers$onMous2 = otherHandlers.onMouseDown) == null ? void 0 : _otherHandlers$onMous2.call(otherHandlers, event);
  };
  const createHandleMouseUp = (otherHandlers) => (event) => {
    var _otherHandlers$onMous3;
    if (event.target === event.currentTarget) {
      setActive(false);
    }
    (_otherHandlers$onMous3 = otherHandlers.onMouseUp) == null ? void 0 : _otherHandlers$onMous3.call(otherHandlers, event);
  };
  const createHandleKeyDown = (otherHandlers) => (event) => {
    var _otherHandlers$onKeyD;
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === " ") {
      event.preventDefault();
    }
    if (event.target === event.currentTarget && event.key === " " && !disabled) {
      setActive(true);
    }
    (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null ? void 0 : _otherHandlers$onKeyD.call(otherHandlers, event);
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === "Enter" && !disabled) {
      var _otherHandlers$onClic;
      event.preventDefault();
      (_otherHandlers$onClic = otherHandlers.onClick) == null ? void 0 : _otherHandlers$onClic.call(otherHandlers, event);
    }
  };
  const createHandleKeyUp = (otherHandlers) => (event) => {
    var _otherHandlers$onKeyU;
    if (event.target === event.currentTarget) {
      setActive(false);
    }
    (_otherHandlers$onKeyU = otherHandlers.onKeyUp) == null ? void 0 : _otherHandlers$onKeyU.call(otherHandlers, event);
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === " " && !event.defaultPrevented) {
      var _otherHandlers$onClic2;
      (_otherHandlers$onClic2 = otherHandlers.onClick) == null ? void 0 : _otherHandlers$onClic2.call(otherHandlers, event);
    }
  };
  const handleOwnRef = useForkRef(focusVisibleRef, buttonRef);
  const handleRef = useForkRef(ref, handleOwnRef);
  const [hostElementName, setHostElementName] = React4.useState("");
  const updateRef = (instance) => {
    var _instance$tagName;
    setHostElementName((_instance$tagName = instance == null ? void 0 : instance.tagName) != null ? _instance$tagName : "");
    setRef(handleRef, instance);
  };
  const buttonProps = {};
  if (hostElementName === "BUTTON") {
    buttonProps.type = type != null ? type : "button";
    buttonProps.disabled = disabled;
  } else if (hostElementName !== "") {
    if (!href && !to) {
      buttonProps.role = "button";
    }
    if (disabled) {
      buttonProps["aria-disabled"] = disabled;
    }
  }
  const getRootProps = (otherHandlers) => {
    const propsEventHandlers = extractEventHandlers(props);
    const externalEventHandlers = _extends({}, propsEventHandlers, otherHandlers);
    const ownEventHandlers = {
      onBlur: createHandleBlur(externalEventHandlers),
      onFocus: createHandleFocus(externalEventHandlers),
      onKeyDown: createHandleKeyDown(externalEventHandlers),
      onKeyUp: createHandleKeyUp(externalEventHandlers),
      onMouseDown: createHandleMouseDown(externalEventHandlers),
      onMouseLeave: createHandleMouseLeave(externalEventHandlers),
      onMouseUp: createHandleMouseUp(externalEventHandlers)
    };
    const mergedEventHandlers = _extends({}, externalEventHandlers, ownEventHandlers);
    delete mergedEventHandlers.onFocusVisible;
    return _extends({
      tabIndex: disabled ? -1 : tabIndex,
      type,
      ref: updateRef
    }, buttonProps, mergedEventHandlers);
  };
  return {
    getRootProps,
    focusVisible,
    setFocusVisible,
    disabled,
    active
  };
}
var React4;
var init_useButton = __esm({
  "node_modules/@mui/base/ButtonUnstyled/useButton.js"() {
    init_extends();
    React4 = __toESM(require_react());
    init_esm();
    init_extractEventHandlers();
  }
});

// node_modules/@mui/base/ButtonUnstyled/ButtonUnstyled.js
var React5, import_prop_types3, import_jsx_runtime4, _excluded3, useUtilityClasses3, ButtonUnstyled, ButtonUnstyled_default;
var init_ButtonUnstyled = __esm({
  "node_modules/@mui/base/ButtonUnstyled/ButtonUnstyled.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React5 = __toESM(require_react());
    import_prop_types3 = __toESM(require_prop_types());
    init_clsx_m();
    init_esm();
    init_composeClasses2();
    init_buttonUnstyledClasses();
    init_useButton();
    init_appendOwnerState();
    import_jsx_runtime4 = __toESM(require_jsx_runtime());
    _excluded3 = ["className", "component", "components", "componentsProps", "children", "disabled", "action", "onBlur", "onClick", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseLeave"];
    useUtilityClasses3 = (ownerState) => {
      const {
        active,
        disabled,
        focusVisible
      } = ownerState;
      const slots = {
        root: ["root", disabled && "disabled", focusVisible && "focusVisible", active && "active"]
      };
      return composeClasses(slots, getButtonUnstyledUtilityClass, {});
    };
    ButtonUnstyled = React5.forwardRef(function ButtonUnstyled2(props, ref) {
      var _ref;
      const {
        className,
        component,
        components = {},
        componentsProps = {},
        children,
        action
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded3);
      const buttonRef = React5.useRef();
      const handleRef = useForkRef(buttonRef, ref);
      const {
        active,
        focusVisible,
        setFocusVisible,
        getRootProps
      } = useButton(_extends({}, props, {
        ref: handleRef
      }));
      React5.useImperativeHandle(action, () => ({
        focusVisible: () => {
          setFocusVisible(true);
          buttonRef.current.focus();
        }
      }), [setFocusVisible]);
      const ownerState = _extends({}, props, {
        active,
        focusVisible
      });
      const ButtonRoot = (_ref = component != null ? component : components.Root) != null ? _ref : "button";
      const buttonRootProps = appendOwnerState(ButtonRoot, _extends({}, other, componentsProps.root), ownerState);
      const classes = useUtilityClasses3(ownerState);
      return (0, import_jsx_runtime4.jsx)(ButtonRoot, _extends({}, getRootProps(), buttonRootProps, {
        className: clsx_m_default(classes.root, className, buttonRootProps.className),
        children
      }));
    });
    true ? ButtonUnstyled.propTypes = {
      // ----------------------------- Warning --------------------------------
      // | These PropTypes are generated from the TypeScript type definitions |
      // |     To update them edit TypeScript types and run "yarn proptypes"  |
      // ----------------------------------------------------------------------
      /**
       * A ref for imperative actions. It currently only supports `focusVisible()` action.
       */
      action: import_prop_types3.default.oneOfType([import_prop_types3.default.func, import_prop_types3.default.shape({
        current: import_prop_types3.default.shape({
          focusVisible: import_prop_types3.default.func.isRequired
        })
      })]),
      /**
       * @ignore
       */
      children: import_prop_types3.default.node,
      /**
       * @ignore
       */
      className: import_prop_types3.default.string,
      /**
       * The component used for the Root slot.
       * Either a string to use a HTML element or a component.
       * This is equivalent to `components.Root`. If both are provided, the `component` is used.
       * @default 'button'
       */
      component: import_prop_types3.default.elementType,
      /**
       * The components used for each slot inside the Button.
       * Either a string to use a HTML element or a component.
       * @default {}
       */
      components: import_prop_types3.default.shape({
        Root: import_prop_types3.default.elementType
      }),
      /**
       * @ignore
       */
      componentsProps: import_prop_types3.default.object,
      /**
       * If `true`, the component is disabled.
       * @default false
       */
      disabled: import_prop_types3.default.bool,
      /**
       * @ignore
       */
      onClick: import_prop_types3.default.func,
      /**
       * @ignore
       */
      onFocusVisible: import_prop_types3.default.func
    } : void 0;
    ButtonUnstyled_default = ButtonUnstyled;
  }
});

// node_modules/@mui/base/ButtonUnstyled/ButtonUnstyledProps.js
var init_ButtonUnstyledProps = __esm({
  "node_modules/@mui/base/ButtonUnstyled/ButtonUnstyledProps.js"() {
  }
});

// node_modules/@mui/base/ButtonUnstyled/index.js
var init_ButtonUnstyled2 = __esm({
  "node_modules/@mui/base/ButtonUnstyled/index.js"() {
    init_ButtonUnstyled();
    init_buttonUnstyledClasses();
    init_ButtonUnstyledProps();
    init_useButton();
  }
});

// node_modules/@mui/base/FormControlUnstyled/FormControlContext.js
var React6, FormControlUnstyledContext, FormControlContext_default;
var init_FormControlContext = __esm({
  "node_modules/@mui/base/FormControlUnstyled/FormControlContext.js"() {
    React6 = __toESM(require_react());
    FormControlUnstyledContext = React6.createContext(void 0);
    if (true) {
      FormControlUnstyledContext.displayName = "FormControlUnstyledContext";
    }
    FormControlContext_default = FormControlUnstyledContext;
  }
});

// node_modules/@mui/base/FormControlUnstyled/formControlUnstyledClasses.js
function getFormControlUnstyledUtilityClasses(slot) {
  return generateUtilityClass("MuiFormControl", slot);
}
var formControlUnstyledClasses, formControlUnstyledClasses_default;
var init_formControlUnstyledClasses = __esm({
  "node_modules/@mui/base/FormControlUnstyled/formControlUnstyledClasses.js"() {
    init_generateUtilityClass2();
    init_generateUtilityClasses2();
    formControlUnstyledClasses = generateUtilityClasses("MuiFormControl", ["root", "disabled"]);
    formControlUnstyledClasses_default = formControlUnstyledClasses;
  }
});

// node_modules/@mui/base/FormControlUnstyled/FormControlUnstyled.js
function hasValue(value) {
  return value != null && !(Array.isArray(value) && value.length === 0) && value !== "";
}
var React7, import_prop_types4, import_jsx_runtime5, _excluded4, FormControlUnstyled, FormControlUnstyled_default;
var init_FormControlUnstyled = __esm({
  "node_modules/@mui/base/FormControlUnstyled/FormControlUnstyled.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React7 = __toESM(require_react());
    import_prop_types4 = __toESM(require_prop_types());
    init_clsx_m();
    init_esm();
    init_FormControlContext();
    init_appendOwnerState();
    init_formControlUnstyledClasses();
    import_jsx_runtime5 = __toESM(require_jsx_runtime());
    _excluded4 = ["defaultValue", "children", "className", "component", "components", "componentsProps", "disabled", "error", "focused", "onChange", "required", "value"];
    FormControlUnstyled = React7.forwardRef(function FormControlUnstyled2(props, ref) {
      var _ref;
      const {
        defaultValue,
        children,
        className,
        component,
        components = {},
        componentsProps = {},
        disabled = false,
        error = false,
        focused: visuallyFocused,
        onChange,
        required = false,
        value: incomingValue
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded4);
      const [value, setValue] = useControlled({
        controlled: incomingValue,
        default: defaultValue,
        name: "FormControl",
        state: "value"
      });
      const filled = hasValue(value);
      const [focusedState, setFocused] = React7.useState(false);
      if (disabled && focusedState) {
        setFocused(false);
      }
      const focused = visuallyFocused !== void 0 && !disabled ? visuallyFocused : focusedState;
      const ownerState = _extends({}, props, {
        disabled,
        error,
        filled,
        focused,
        required
      });
      let registerEffect = () => {
      };
      if (true) {
        const registeredInput = React7.useRef(false);
        registerEffect = () => {
          if (registeredInput.current) {
            console.error(["MUI: There are multiple `Input` components inside a FormControl.", "This creates visual inconsistencies, only use one `Input`."].join("\n"));
          }
          registeredInput.current = true;
          return () => {
            registeredInput.current = false;
          };
        };
      }
      const handleChange = (event) => {
        setValue(event.target.value);
        onChange == null ? void 0 : onChange(event);
      };
      const childContext = {
        disabled,
        error,
        filled,
        focused,
        onBlur: () => {
          setFocused(false);
        },
        onChange: handleChange,
        onFocus: () => {
          setFocused(true);
        },
        registerEffect,
        required,
        value: value != null ? value : ""
      };
      const Root = (_ref = component != null ? component : components.Root) != null ? _ref : "div";
      const rootProps = appendOwnerState(Root, _extends({}, other, componentsProps.root), ownerState);
      return (0, import_jsx_runtime5.jsx)(FormControlContext_default.Provider, {
        value: childContext,
        children: (0, import_jsx_runtime5.jsx)(Root, _extends({
          ref
        }, rootProps, {
          className: clsx_m_default(formControlUnstyledClasses_default.root, className, rootProps == null ? void 0 : rootProps.className, disabled && formControlUnstyledClasses_default.disabled),
          children
        }))
      });
    });
    true ? FormControlUnstyled.propTypes = {
      // ----------------------------- Warning --------------------------------
      // | These PropTypes are generated from the TypeScript type definitions |
      // |     To update them edit TypeScript types and run "yarn proptypes"  |
      // ----------------------------------------------------------------------
      /**
       * The content of the component.
       */
      children: import_prop_types4.default.node,
      /**
       * Class name applied to the root element.
       */
      className: import_prop_types4.default.string,
      /**
       * The component used for the root node.
       * Either a string to use a HTML element or a component.
       */
      component: import_prop_types4.default.elementType,
      /**
       * The components used for each slot inside the FormControl.
       * Either a string to use a HTML element or a component.
       * @default {}
       */
      components: import_prop_types4.default.shape({
        Root: import_prop_types4.default.elementType
      }),
      /**
       * @ignore
       */
      componentsProps: import_prop_types4.default.object,
      /**
       * @ignore
       */
      defaultValue: import_prop_types4.default.any,
      /**
       * If `true`, the label, input and helper text should be displayed in a disabled state.
       * @default false
       */
      disabled: import_prop_types4.default.bool,
      /**
       * If `true`, the label is displayed in an error state.
       * @default false
       */
      error: import_prop_types4.default.bool,
      /**
       * If `true`, the component is displayed in focused state.
       * @default false
       */
      focused: import_prop_types4.default.bool,
      /**
       * @ignore
       */
      onChange: import_prop_types4.default.func,
      /**
       * If `true`, the label will indicate that the `input` is required.
       * @default false
       */
      required: import_prop_types4.default.bool,
      /**
       * @ignore
       */
      value: import_prop_types4.default.any
    } : void 0;
    FormControlUnstyled_default = FormControlUnstyled;
  }
});

// node_modules/@mui/base/FormControlUnstyled/useFormControl.js
function useFormControlUnstyled() {
  return React8.useContext(FormControlContext_default);
}
var React8;
var init_useFormControl = __esm({
  "node_modules/@mui/base/FormControlUnstyled/useFormControl.js"() {
    React8 = __toESM(require_react());
    init_FormControlContext();
  }
});

// node_modules/@mui/base/FormControlUnstyled/index.js
var init_FormControlUnstyled2 = __esm({
  "node_modules/@mui/base/FormControlUnstyled/index.js"() {
    init_FormControlUnstyled();
    init_FormControlContext();
    init_formControlUnstyledClasses();
    init_formControlUnstyledClasses();
    init_useFormControl();
  }
});

// node_modules/@mui/base/InputUnstyled/inputUnstyledClasses.js
function getInputUnstyledUtilityClass(slot) {
  return generateUtilityClass("MuiInput", slot);
}
var inputBaseClasses, inputUnstyledClasses_default;
var init_inputUnstyledClasses = __esm({
  "node_modules/@mui/base/InputUnstyled/inputUnstyledClasses.js"() {
    init_generateUtilityClass2();
    init_generateUtilityClasses2();
    inputBaseClasses = generateUtilityClasses("MuiInput", ["root", "formControl", "focused", "disabled", "error", "multiline", "input", "inputMultiline", "inputTypeSearch", "adornedStart", "adornedEnd"]);
    inputUnstyledClasses_default = inputBaseClasses;
  }
});

// node_modules/@mui/base/InputUnstyled/useInput.js
function useInput(props, inputRef) {
  const {
    defaultValue,
    disabled: disabledProp = false,
    error: errorProp = false,
    onBlur,
    onChange,
    onFocus,
    required: requiredProp = false,
    value: valueProp
  } = props;
  const formControlContext = useFormControlUnstyled();
  let value;
  let required;
  let disabled;
  let error;
  if (formControlContext) {
    var _formControlContext$d, _formControlContext$r, _formControlContext$e;
    value = formControlContext.value;
    disabled = (_formControlContext$d = formControlContext.disabled) != null ? _formControlContext$d : false;
    required = (_formControlContext$r = formControlContext.required) != null ? _formControlContext$r : false;
    error = (_formControlContext$e = formControlContext.error) != null ? _formControlContext$e : false;
  } else {
    value = valueProp;
    disabled = disabledProp;
    required = requiredProp;
    error = errorProp;
  }
  const {
    current: isControlled
  } = React9.useRef(value != null);
  const handleInputRefWarning = React9.useCallback((instance) => {
    if (true) {
      if (instance && instance.nodeName !== "INPUT" && !instance.focus) {
        console.error(["MUI: You have provided a `components.Input` to the input component", "that does not correctly handle the `ref` prop.", "Make sure the `ref` prop is called with a HTMLInputElement."].join("\n"));
      }
    }
  }, []);
  const internalInputRef = React9.useRef(null);
  const handleIncomingRef = useForkRef(inputRef, handleInputRefWarning);
  const handleInputRef = useForkRef(internalInputRef, handleIncomingRef);
  const [focused, setFocused] = React9.useState(false);
  React9.useEffect(() => {
    if (!formControlContext && disabled && focused) {
      setFocused(false);
      onBlur == null ? void 0 : onBlur();
    }
  }, [formControlContext, disabled, focused, onBlur]);
  const handleFocus = (otherHandlers) => (event) => {
    var _otherHandlers$onFocu;
    if (formControlContext != null && formControlContext.disabled) {
      event.stopPropagation();
      return;
    }
    (_otherHandlers$onFocu = otherHandlers.onFocus) == null ? void 0 : _otherHandlers$onFocu.call(otherHandlers, event);
    if (formControlContext && formControlContext.onFocus) {
      var _formControlContext$o;
      formControlContext == null ? void 0 : (_formControlContext$o = formControlContext.onFocus) == null ? void 0 : _formControlContext$o.call(formControlContext);
    } else {
      setFocused(true);
    }
  };
  const handleBlur = (otherHandlers) => (event) => {
    var _otherHandlers$onBlur;
    (_otherHandlers$onBlur = otherHandlers.onBlur) == null ? void 0 : _otherHandlers$onBlur.call(otherHandlers, event);
    if (formControlContext && formControlContext.onBlur) {
      formControlContext.onBlur();
    } else {
      setFocused(false);
    }
  };
  const handleChange = (otherHandlers) => (event, ...args) => {
    var _formControlContext$o2, _otherHandlers$onChan;
    if (!isControlled) {
      const element = event.target || internalInputRef.current;
      if (element == null) {
        throw new Error(true ? `MUI: Expected valid input target. Did you use a custom \`components.Input\` and forget to forward refs? See https://mui.com/r/input-component-ref-interface for more info.` : formatMuiErrorMessage(17));
      }
    }
    formControlContext == null ? void 0 : (_formControlContext$o2 = formControlContext.onChange) == null ? void 0 : _formControlContext$o2.call(formControlContext, event);
    (_otherHandlers$onChan = otherHandlers.onChange) == null ? void 0 : _otherHandlers$onChan.call(otherHandlers, event, ...args);
  };
  const handleClick = (otherHandlers) => (event) => {
    var _otherHandlers$onClic;
    if (internalInputRef.current && event.currentTarget === event.target) {
      internalInputRef.current.focus();
    }
    (_otherHandlers$onClic = otherHandlers.onClick) == null ? void 0 : _otherHandlers$onClic.call(otherHandlers, event);
  };
  const getRootProps = (externalProps) => {
    const propsEventHandlers = extractEventHandlers(props, ["onBlur", "onChange", "onFocus"]);
    const externalEventHandlers = _extends({}, propsEventHandlers, extractEventHandlers(externalProps));
    return _extends({}, externalProps, externalEventHandlers, {
      onClick: handleClick(externalEventHandlers)
    });
  };
  const getInputProps = (externalProps) => {
    const propsEventHandlers = {
      onBlur,
      onChange,
      onFocus
    };
    const externalEventHandlers = _extends({}, propsEventHandlers, extractEventHandlers(externalProps));
    const mergedEventHandlers = _extends({}, externalProps, externalEventHandlers, {
      onBlur: handleBlur(externalEventHandlers),
      onChange: handleChange(externalEventHandlers),
      onFocus: handleFocus(externalEventHandlers)
    });
    return _extends({}, mergedEventHandlers, {
      "aria-invalid": error || void 0,
      defaultValue,
      ref: handleInputRef,
      value,
      required,
      disabled
    });
  };
  return {
    disabled,
    error,
    focused,
    formControlContext,
    getInputProps,
    getRootProps,
    required,
    value
  };
}
var React9;
var init_useInput = __esm({
  "node_modules/@mui/base/InputUnstyled/useInput.js"() {
    init_extends();
    init_esm();
    React9 = __toESM(require_react());
    init_esm();
    init_useFormControl();
    init_extractEventHandlers();
  }
});

// node_modules/@mui/base/InputUnstyled/InputUnstyled.js
var React10, import_prop_types5, import_jsx_runtime6, import_jsx_runtime7, _excluded5, InputUnstyled, InputUnstyled_default;
var init_InputUnstyled = __esm({
  "node_modules/@mui/base/InputUnstyled/InputUnstyled.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React10 = __toESM(require_react());
    init_clsx_m();
    import_prop_types5 = __toESM(require_prop_types());
    init_appendOwnerState();
    init_isHostComponent();
    init_inputUnstyledClasses();
    init_useInput();
    import_jsx_runtime6 = __toESM(require_jsx_runtime());
    import_jsx_runtime7 = __toESM(require_jsx_runtime());
    _excluded5 = ["aria-describedby", "aria-label", "aria-labelledby", "autoComplete", "autoFocus", "className", "component", "components", "componentsProps", "defaultValue", "disabled", "endAdornment", "error", "id", "maxRows", "minRows", "multiline", "name", "onClick", "onChange", "onKeyDown", "onKeyUp", "onFocus", "onBlur", "placeholder", "readOnly", "required", "rows", "type", "startAdornment", "value"];
    InputUnstyled = React10.forwardRef(function InputUnstyled2(props, ref) {
      var _componentsProps$inpu, _ref, _componentsProps$root, _components$Input, _componentsProps$inpu2;
      const {
        "aria-describedby": ariaDescribedby,
        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabelledby,
        autoComplete,
        autoFocus,
        className,
        component,
        components = {},
        componentsProps = {},
        defaultValue,
        disabled,
        endAdornment,
        error,
        id,
        maxRows,
        minRows,
        multiline = false,
        name,
        onClick,
        onChange,
        onKeyDown,
        onKeyUp,
        onFocus,
        onBlur,
        placeholder,
        readOnly,
        required,
        rows,
        type = "text",
        startAdornment,
        value
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded5);
      const {
        getRootProps,
        getInputProps,
        focused,
        formControlContext,
        error: errorState,
        disabled: disabledState
      } = useInput({
        disabled,
        defaultValue,
        error,
        onBlur,
        onClick,
        onChange,
        onFocus,
        required,
        value
      }, (_componentsProps$inpu = componentsProps.input) == null ? void 0 : _componentsProps$inpu.ref);
      const ownerState = _extends({}, props, {
        disabled: disabledState,
        error: errorState,
        focused,
        formControlContext,
        multiline,
        type
      });
      const rootStateClasses = clsx_m_default(disabledState && inputUnstyledClasses_default.disabled, errorState && inputUnstyledClasses_default.error, focused && inputUnstyledClasses_default.focused, Boolean(formControlContext) && inputUnstyledClasses_default.formControl, multiline && inputUnstyledClasses_default.multiline, Boolean(startAdornment) && inputUnstyledClasses_default.adornedStart, Boolean(endAdornment) && inputUnstyledClasses_default.adornedEnd);
      const inputStateClasses = clsx_m_default(disabledState && inputUnstyledClasses_default.disabled, multiline && inputUnstyledClasses_default.multiline);
      const propsToForward = {
        "aria-describedby": ariaDescribedby,
        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabelledby,
        autoComplete,
        autoFocus,
        id,
        onKeyDown,
        onKeyUp,
        name,
        placeholder,
        readOnly,
        type
      };
      const Root = (_ref = component != null ? component : components.Root) != null ? _ref : "div";
      const rootProps = appendOwnerState(Root, _extends({}, getRootProps(_extends({}, other, componentsProps.root)), {
        className: clsx_m_default(inputUnstyledClasses_default.root, rootStateClasses, className, (_componentsProps$root = componentsProps.root) == null ? void 0 : _componentsProps$root.className)
      }), ownerState);
      let Input = (_components$Input = components.Input) != null ? _components$Input : "input";
      let inputProps = appendOwnerState(Input, _extends({}, getInputProps(_extends({}, componentsProps.input, propsToForward)), {
        className: clsx_m_default(inputUnstyledClasses_default.input, inputStateClasses, (_componentsProps$inpu2 = componentsProps.input) == null ? void 0 : _componentsProps$inpu2.className)
      }), ownerState);
      if (multiline) {
        var _components$Textarea, _components$Textarea2;
        const hasHostTexarea = isHostComponent_default((_components$Textarea = components.Textarea) != null ? _components$Textarea : "textarea");
        if (rows) {
          if (true) {
            if (minRows || maxRows) {
              console.warn("MUI: You can not use the `minRows` or `maxRows` props when the input `rows` prop is set.");
            }
          }
          inputProps = _extends({
            type: void 0,
            minRows: hasHostTexarea ? void 0 : rows,
            maxRows: hasHostTexarea ? void 0 : rows
          }, inputProps);
        } else {
          inputProps = _extends({
            type: void 0,
            maxRows: hasHostTexarea ? void 0 : maxRows,
            minRows: hasHostTexarea ? void 0 : minRows
          }, inputProps);
        }
        Input = (_components$Textarea2 = components.Textarea) != null ? _components$Textarea2 : "textarea";
      }
      return (0, import_jsx_runtime7.jsxs)(Root, _extends({}, rootProps, {
        ref,
        children: [startAdornment, (0, import_jsx_runtime6.jsx)(Input, _extends({}, inputProps)), endAdornment]
      }));
    });
    true ? InputUnstyled.propTypes = {
      // ----------------------------- Warning --------------------------------
      // | These PropTypes are generated from the TypeScript type definitions |
      // |     To update them edit TypeScript types and run "yarn proptypes"  |
      // ----------------------------------------------------------------------
      /**
       * @ignore
       */
      "aria-describedby": import_prop_types5.default.string,
      /**
       * @ignore
       */
      "aria-label": import_prop_types5.default.string,
      /**
       * @ignore
       */
      "aria-labelledby": import_prop_types5.default.string,
      /**
       * This prop helps users to fill forms faster, especially on mobile devices.
       * The name can be confusing, as it's more like an autofill.
       * You can learn more about it [following the specification](https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#autofill).
       */
      autoComplete: import_prop_types5.default.string,
      /**
       * If `true`, the `input` element is focused during the first mount.
       */
      autoFocus: import_prop_types5.default.bool,
      /**
       * @ignore
       */
      children: import_prop_types5.default.node,
      /**
       * Class name applied to the root element.
       */
      className: import_prop_types5.default.string,
      /**
       * The component used for the root node.
       * Either a string to use a HTML element or a component.
       */
      component: import_prop_types5.default.elementType,
      /**
       * The components used for each slot inside the InputBase.
       * Either a string to use a HTML element or a component.
       * @default {}
       */
      components: import_prop_types5.default.shape({
        Input: import_prop_types5.default.elementType,
        Root: import_prop_types5.default.elementType,
        Textarea: import_prop_types5.default.elementType
      }),
      /**
       * The props used for each slot inside the Input.
       * @default {}
       */
      componentsProps: import_prop_types5.default.object,
      /**
       * The default value. Use when the component is not controlled.
       */
      defaultValue: import_prop_types5.default.any,
      /**
       * If `true`, the component is disabled.
       * The prop defaults to the value (`false`) inherited from the parent FormControl component.
       */
      disabled: import_prop_types5.default.bool,
      /**
       * Trailing adornment for this input.
       */
      endAdornment: import_prop_types5.default.node,
      /**
       * If `true`, the `input` will indicate an error.
       * The prop defaults to the value (`false`) inherited from the parent FormControl component.
       */
      error: import_prop_types5.default.bool,
      /**
       * The id of the `input` element.
       */
      id: import_prop_types5.default.string,
      /**
       * Maximum number of rows to display when multiline option is set to true.
       */
      maxRows: import_prop_types5.default.number,
      /**
       * Minimum number of rows to display when multiline option is set to true.
       */
      minRows: import_prop_types5.default.number,
      /**
       * If `true`, a `textarea` element is rendered.
       * @default false
       */
      multiline: import_prop_types5.default.bool,
      /**
       * Name attribute of the `input` element.
       */
      name: import_prop_types5.default.string,
      /**
       * @ignore
       */
      onBlur: import_prop_types5.default.func,
      /**
       * @ignore
       */
      onChange: import_prop_types5.default.func,
      /**
       * @ignore
       */
      onClick: import_prop_types5.default.func,
      /**
       * @ignore
       */
      onFocus: import_prop_types5.default.func,
      /**
       * @ignore
       */
      onKeyDown: import_prop_types5.default.func,
      /**
       * @ignore
       */
      onKeyUp: import_prop_types5.default.func,
      /**
       * The short hint displayed in the `input` before the user enters a value.
       */
      placeholder: import_prop_types5.default.string,
      /**
       * It prevents the user from changing the value of the field
       * (not from interacting with the field).
       */
      readOnly: import_prop_types5.default.bool,
      /**
       * If `true`, the `input` element is required.
       * The prop defaults to the value (`false`) inherited from the parent FormControl component.
       */
      required: import_prop_types5.default.bool,
      /**
       * Number of rows to display when multiline option is set to true.
       */
      rows: import_prop_types5.default.number,
      /**
       * Leading adornment for this input.
       */
      startAdornment: import_prop_types5.default.node,
      /**
       * Type of the `input` element. It should be [a valid HTML5 input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Form_%3Cinput%3E_types).
       * @default 'text'
       */
      type: import_prop_types5.default.string,
      /**
       * The value of the `input` element, required for a controlled component.
       */
      value: import_prop_types5.default.any
    } : void 0;
    InputUnstyled_default = InputUnstyled;
  }
});

// node_modules/@mui/base/InputUnstyled/InputUnstyledProps.js
var init_InputUnstyledProps = __esm({
  "node_modules/@mui/base/InputUnstyled/InputUnstyledProps.js"() {
  }
});

// node_modules/@mui/base/InputUnstyled/index.js
var init_InputUnstyled2 = __esm({
  "node_modules/@mui/base/InputUnstyled/index.js"() {
    init_InputUnstyled();
    init_InputUnstyledProps();
    init_useInput();
    init_inputUnstyledClasses();
    init_inputUnstyledClasses();
  }
});

// node_modules/@mui/base/ModalUnstyled/ModalManager.js
function isOverflowing(container) {
  const doc = ownerDocument(container);
  if (doc.body === container) {
    return ownerWindow(container).innerWidth > doc.documentElement.clientWidth;
  }
  return container.scrollHeight > container.clientHeight;
}
function ariaHidden(element, show) {
  if (show) {
    element.setAttribute("aria-hidden", "true");
  } else {
    element.removeAttribute("aria-hidden");
  }
}
function getPaddingRight(element) {
  return parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) || 0;
}
function ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude = [], show) {
  const blacklist = [mountElement, currentElement, ...elementsToExclude];
  const blacklistTagNames = ["TEMPLATE", "SCRIPT", "STYLE"];
  [].forEach.call(container.children, (element) => {
    if (blacklist.indexOf(element) === -1 && blacklistTagNames.indexOf(element.tagName) === -1) {
      ariaHidden(element, show);
    }
  });
}
function findIndexOf(items, callback) {
  let idx = -1;
  items.some((item, index) => {
    if (callback(item)) {
      idx = index;
      return true;
    }
    return false;
  });
  return idx;
}
function handleContainer(containerInfo, props) {
  const restoreStyle = [];
  const container = containerInfo.container;
  if (!props.disableScrollLock) {
    if (isOverflowing(container)) {
      const scrollbarSize = getScrollbarSize(ownerDocument(container));
      restoreStyle.push({
        value: container.style.paddingRight,
        property: "padding-right",
        el: container
      });
      container.style.paddingRight = `${getPaddingRight(container) + scrollbarSize}px`;
      const fixedElements = ownerDocument(container).querySelectorAll(".mui-fixed");
      [].forEach.call(fixedElements, (element) => {
        restoreStyle.push({
          value: element.style.paddingRight,
          property: "padding-right",
          el: element
        });
        element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;
      });
    }
    const parent = container.parentElement;
    const containerWindow = ownerWindow(container);
    const scrollContainer = (parent == null ? void 0 : parent.nodeName) === "HTML" && containerWindow.getComputedStyle(parent).overflowY === "scroll" ? parent : container;
    restoreStyle.push({
      value: scrollContainer.style.overflow,
      property: "overflow",
      el: scrollContainer
    }, {
      value: scrollContainer.style.overflowX,
      property: "overflow-x",
      el: scrollContainer
    }, {
      value: scrollContainer.style.overflowY,
      property: "overflow-y",
      el: scrollContainer
    });
    scrollContainer.style.overflow = "hidden";
  }
  const restore = () => {
    restoreStyle.forEach(({
      value,
      el,
      property
    }) => {
      if (value) {
        el.style.setProperty(property, value);
      } else {
        el.style.removeProperty(property);
      }
    });
  };
  return restore;
}
function getHiddenSiblings(container) {
  const hiddenSiblings = [];
  [].forEach.call(container.children, (element) => {
    if (element.getAttribute("aria-hidden") === "true") {
      hiddenSiblings.push(element);
    }
  });
  return hiddenSiblings;
}
var ModalManager;
var init_ModalManager = __esm({
  "node_modules/@mui/base/ModalUnstyled/ModalManager.js"() {
    init_esm();
    ModalManager = class {
      constructor() {
        this.containers = void 0;
        this.modals = void 0;
        this.modals = [];
        this.containers = [];
      }
      add(modal, container) {
        let modalIndex = this.modals.indexOf(modal);
        if (modalIndex !== -1) {
          return modalIndex;
        }
        modalIndex = this.modals.length;
        this.modals.push(modal);
        if (modal.modalRef) {
          ariaHidden(modal.modalRef, false);
        }
        const hiddenSiblings = getHiddenSiblings(container);
        ariaHiddenSiblings(container, modal.mount, modal.modalRef, hiddenSiblings, true);
        const containerIndex = findIndexOf(this.containers, (item) => item.container === container);
        if (containerIndex !== -1) {
          this.containers[containerIndex].modals.push(modal);
          return modalIndex;
        }
        this.containers.push({
          modals: [modal],
          container,
          restore: null,
          hiddenSiblings
        });
        return modalIndex;
      }
      mount(modal, props) {
        const containerIndex = findIndexOf(this.containers, (item) => item.modals.indexOf(modal) !== -1);
        const containerInfo = this.containers[containerIndex];
        if (!containerInfo.restore) {
          containerInfo.restore = handleContainer(containerInfo, props);
        }
      }
      remove(modal) {
        const modalIndex = this.modals.indexOf(modal);
        if (modalIndex === -1) {
          return modalIndex;
        }
        const containerIndex = findIndexOf(this.containers, (item) => item.modals.indexOf(modal) !== -1);
        const containerInfo = this.containers[containerIndex];
        containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
        this.modals.splice(modalIndex, 1);
        if (containerInfo.modals.length === 0) {
          if (containerInfo.restore) {
            containerInfo.restore();
          }
          if (modal.modalRef) {
            ariaHidden(modal.modalRef, true);
          }
          ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);
          this.containers.splice(containerIndex, 1);
        } else {
          const nextTop = containerInfo.modals[containerInfo.modals.length - 1];
          if (nextTop.modalRef) {
            ariaHidden(nextTop.modalRef, false);
          }
        }
        return modalIndex;
      }
      isTopModal(modal) {
        return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
      }
    };
  }
});

// node_modules/@mui/base/Unstable_TrapFocus/Unstable_TrapFocus.js
function getTabIndex(node) {
  const tabindexAttr = parseInt(node.getAttribute("tabindex"), 10);
  if (!Number.isNaN(tabindexAttr)) {
    return tabindexAttr;
  }
  if (node.contentEditable === "true" || (node.nodeName === "AUDIO" || node.nodeName === "VIDEO" || node.nodeName === "DETAILS") && node.getAttribute("tabindex") === null) {
    return 0;
  }
  return node.tabIndex;
}
function isNonTabbableRadio(node) {
  if (node.tagName !== "INPUT" || node.type !== "radio") {
    return false;
  }
  if (!node.name) {
    return false;
  }
  const getRadio = (selector) => node.ownerDocument.querySelector(`input[type="radio"]${selector}`);
  let roving = getRadio(`[name="${node.name}"]:checked`);
  if (!roving) {
    roving = getRadio(`[name="${node.name}"]`);
  }
  return roving !== node;
}
function isNodeMatchingSelectorFocusable(node) {
  if (node.disabled || node.tagName === "INPUT" && node.type === "hidden" || isNonTabbableRadio(node)) {
    return false;
  }
  return true;
}
function defaultGetTabbable(root) {
  const regularTabNodes = [];
  const orderedTabNodes = [];
  Array.from(root.querySelectorAll(candidatesSelector)).forEach((node, i) => {
    const nodeTabIndex = getTabIndex(node);
    if (nodeTabIndex === -1 || !isNodeMatchingSelectorFocusable(node)) {
      return;
    }
    if (nodeTabIndex === 0) {
      regularTabNodes.push(node);
    } else {
      orderedTabNodes.push({
        documentOrder: i,
        tabIndex: nodeTabIndex,
        node
      });
    }
  });
  return orderedTabNodes.sort((a, b) => a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex).map((a) => a.node).concat(regularTabNodes);
}
function defaultIsEnabled() {
  return true;
}
function Unstable_TrapFocus(props) {
  const {
    children,
    disableAutoFocus = false,
    disableEnforceFocus = false,
    disableRestoreFocus = false,
    getTabbable = defaultGetTabbable,
    isEnabled = defaultIsEnabled,
    open
  } = props;
  const ignoreNextEnforceFocus = React11.useRef();
  const sentinelStart = React11.useRef(null);
  const sentinelEnd = React11.useRef(null);
  const nodeToRestore = React11.useRef(null);
  const reactFocusEventTarget = React11.useRef(null);
  const activated = React11.useRef(false);
  const rootRef = React11.useRef(null);
  const handleRef = useForkRef(children.ref, rootRef);
  const lastKeydown = React11.useRef(null);
  React11.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    activated.current = !disableAutoFocus;
  }, [disableAutoFocus, open]);
  React11.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    const doc = ownerDocument(rootRef.current);
    if (!rootRef.current.contains(doc.activeElement)) {
      if (!rootRef.current.hasAttribute("tabIndex")) {
        if (true) {
          console.error(["MUI: The modal content node does not accept focus.", 'For the benefit of assistive technologies, the tabIndex of the node is being set to "-1".'].join("\n"));
        }
        rootRef.current.setAttribute("tabIndex", -1);
      }
      if (activated.current) {
        rootRef.current.focus();
      }
    }
    return () => {
      if (!disableRestoreFocus) {
        if (nodeToRestore.current && nodeToRestore.current.focus) {
          ignoreNextEnforceFocus.current = true;
          nodeToRestore.current.focus();
        }
        nodeToRestore.current = null;
      }
    };
  }, [open]);
  React11.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    const doc = ownerDocument(rootRef.current);
    const contain = (nativeEvent) => {
      const {
        current: rootElement
      } = rootRef;
      if (rootElement === null) {
        return;
      }
      if (!doc.hasFocus() || disableEnforceFocus || !isEnabled() || ignoreNextEnforceFocus.current) {
        ignoreNextEnforceFocus.current = false;
        return;
      }
      if (!rootElement.contains(doc.activeElement)) {
        if (nativeEvent && reactFocusEventTarget.current !== nativeEvent.target || doc.activeElement !== reactFocusEventTarget.current) {
          reactFocusEventTarget.current = null;
        } else if (reactFocusEventTarget.current !== null) {
          return;
        }
        if (!activated.current) {
          return;
        }
        let tabbable = [];
        if (doc.activeElement === sentinelStart.current || doc.activeElement === sentinelEnd.current) {
          tabbable = getTabbable(rootRef.current);
        }
        if (tabbable.length > 0) {
          var _lastKeydown$current, _lastKeydown$current2;
          const isShiftTab = Boolean(((_lastKeydown$current = lastKeydown.current) == null ? void 0 : _lastKeydown$current.shiftKey) && ((_lastKeydown$current2 = lastKeydown.current) == null ? void 0 : _lastKeydown$current2.key) === "Tab");
          const focusNext = tabbable[0];
          const focusPrevious = tabbable[tabbable.length - 1];
          if (isShiftTab) {
            focusPrevious.focus();
          } else {
            focusNext.focus();
          }
        } else {
          rootElement.focus();
        }
      }
    };
    const loopFocus = (nativeEvent) => {
      lastKeydown.current = nativeEvent;
      if (disableEnforceFocus || !isEnabled() || nativeEvent.key !== "Tab") {
        return;
      }
      if (doc.activeElement === rootRef.current && nativeEvent.shiftKey) {
        ignoreNextEnforceFocus.current = true;
        sentinelEnd.current.focus();
      }
    };
    doc.addEventListener("focusin", contain);
    doc.addEventListener("keydown", loopFocus, true);
    const interval = setInterval(() => {
      if (doc.activeElement.tagName === "BODY") {
        contain();
      }
    }, 50);
    return () => {
      clearInterval(interval);
      doc.removeEventListener("focusin", contain);
      doc.removeEventListener("keydown", loopFocus, true);
    };
  }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled, open, getTabbable]);
  const onFocus = (event) => {
    if (nodeToRestore.current === null) {
      nodeToRestore.current = event.relatedTarget;
    }
    activated.current = true;
    reactFocusEventTarget.current = event.target;
    const childrenPropsHandler = children.props.onFocus;
    if (childrenPropsHandler) {
      childrenPropsHandler(event);
    }
  };
  const handleFocusSentinel = (event) => {
    if (nodeToRestore.current === null) {
      nodeToRestore.current = event.relatedTarget;
    }
    activated.current = true;
  };
  return (0, import_jsx_runtime9.jsxs)(React11.Fragment, {
    children: [(0, import_jsx_runtime8.jsx)("div", {
      tabIndex: 0,
      onFocus: handleFocusSentinel,
      ref: sentinelStart,
      "data-test": "sentinelStart"
    }), React11.cloneElement(children, {
      ref: handleRef,
      onFocus
    }), (0, import_jsx_runtime8.jsx)("div", {
      tabIndex: 0,
      onFocus: handleFocusSentinel,
      ref: sentinelEnd,
      "data-test": "sentinelEnd"
    })]
  });
}
var React11, import_prop_types6, import_jsx_runtime8, import_jsx_runtime9, candidatesSelector, Unstable_TrapFocus_default;
var init_Unstable_TrapFocus = __esm({
  "node_modules/@mui/base/Unstable_TrapFocus/Unstable_TrapFocus.js"() {
    React11 = __toESM(require_react());
    import_prop_types6 = __toESM(require_prop_types());
    init_esm();
    import_jsx_runtime8 = __toESM(require_jsx_runtime());
    import_jsx_runtime9 = __toESM(require_jsx_runtime());
    candidatesSelector = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
    true ? Unstable_TrapFocus.propTypes = {
      // ----------------------------- Warning --------------------------------
      // | These PropTypes are generated from the TypeScript type definitions |
      // |     To update them edit the d.ts file and run "yarn proptypes"     |
      // ----------------------------------------------------------------------
      /**
       * A single child content element.
       */
      children: elementAcceptingRef_default,
      /**
       * If `true`, the trap focus will not automatically shift focus to itself when it opens, and
       * replace it to the last focused element when it closes.
       * This also works correctly with any trap focus children that have the `disableAutoFocus` prop.
       *
       * Generally this should never be set to `true` as it makes the trap focus less
       * accessible to assistive technologies, like screen readers.
       * @default false
       */
      disableAutoFocus: import_prop_types6.default.bool,
      /**
       * If `true`, the trap focus will not prevent focus from leaving the trap focus while open.
       *
       * Generally this should never be set to `true` as it makes the trap focus less
       * accessible to assistive technologies, like screen readers.
       * @default false
       */
      disableEnforceFocus: import_prop_types6.default.bool,
      /**
       * If `true`, the trap focus will not restore focus to previously focused element once
       * trap focus is hidden.
       * @default false
       */
      disableRestoreFocus: import_prop_types6.default.bool,
      /**
       * Returns an array of ordered tabbable nodes (i.e. in tab order) within the root.
       * For instance, you can provide the "tabbable" npm dependency.
       * @param {HTMLElement} root
       */
      getTabbable: import_prop_types6.default.func,
      /**
       * This prop extends the `open` prop.
       * It allows to toggle the open state without having to wait for a rerender when changing the `open` prop.
       * This prop should be memoized.
       * It can be used to support multiple trap focus mounted at the same time.
       * @default function defaultIsEnabled() {
       *   return true;
       * }
       */
      isEnabled: import_prop_types6.default.func,
      /**
       * If `true`, focus is locked.
       */
      open: import_prop_types6.default.bool.isRequired
    } : void 0;
    if (true) {
      Unstable_TrapFocus["propTypes"] = exactProp(Unstable_TrapFocus.propTypes);
    }
    Unstable_TrapFocus_default = Unstable_TrapFocus;
  }
});

// node_modules/@mui/base/Unstable_TrapFocus/index.js
var init_Unstable_TrapFocus2 = __esm({
  "node_modules/@mui/base/Unstable_TrapFocus/index.js"() {
    init_Unstable_TrapFocus();
  }
});

// node_modules/@mui/base/ModalUnstyled/modalUnstyledClasses.js
function getModalUtilityClass(slot) {
  return generateUtilityClass("MuiModal", slot);
}
var modalUnstyledClasses, modalUnstyledClasses_default;
var init_modalUnstyledClasses = __esm({
  "node_modules/@mui/base/ModalUnstyled/modalUnstyledClasses.js"() {
    init_generateUtilityClasses2();
    init_generateUtilityClass2();
    modalUnstyledClasses = generateUtilityClasses("MuiModal", ["root", "hidden"]);
    modalUnstyledClasses_default = modalUnstyledClasses;
  }
});

// node_modules/@mui/base/ModalUnstyled/ModalUnstyled.js
function getContainer(container) {
  return typeof container === "function" ? container() : container;
}
function getHasTransition(props) {
  return props.children ? props.children.props.hasOwnProperty("in") : false;
}
var React12, import_prop_types7, import_jsx_runtime10, import_jsx_runtime11, _excluded6, useUtilityClasses4, defaultManager, ModalUnstyled, ModalUnstyled_default;
var init_ModalUnstyled = __esm({
  "node_modules/@mui/base/ModalUnstyled/ModalUnstyled.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React12 = __toESM(require_react());
    import_prop_types7 = __toESM(require_prop_types());
    init_clsx_m();
    init_esm();
    init_composeClasses2();
    init_isHostComponent();
    init_Portal();
    init_ModalManager();
    init_Unstable_TrapFocus2();
    init_modalUnstyledClasses();
    import_jsx_runtime10 = __toESM(require_jsx_runtime());
    import_jsx_runtime11 = __toESM(require_jsx_runtime());
    _excluded6 = ["BackdropComponent", "BackdropProps", "children", "classes", "className", "closeAfterTransition", "component", "components", "componentsProps", "container", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "manager", "onBackdropClick", "onClose", "onKeyDown", "open", "theme", "onTransitionEnter", "onTransitionExited"];
    useUtilityClasses4 = (ownerState) => {
      const {
        open,
        exited,
        classes
      } = ownerState;
      const slots = {
        root: ["root", !open && exited && "hidden"]
      };
      return composeClasses(slots, getModalUtilityClass, classes);
    };
    defaultManager = new ModalManager();
    ModalUnstyled = React12.forwardRef(function ModalUnstyled2(props, ref) {
      const {
        BackdropComponent,
        BackdropProps,
        children,
        classes: classesProp,
        className,
        closeAfterTransition = false,
        component = "div",
        components = {},
        componentsProps = {},
        container,
        disableAutoFocus = false,
        disableEnforceFocus = false,
        disableEscapeKeyDown = false,
        disablePortal = false,
        disableRestoreFocus = false,
        disableScrollLock = false,
        hideBackdrop = false,
        keepMounted = false,
        // private
        // eslint-disable-next-line react/prop-types
        manager = defaultManager,
        onBackdropClick,
        onClose,
        onKeyDown,
        open,
        /* eslint-disable react/prop-types */
        theme,
        onTransitionEnter,
        onTransitionExited
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded6);
      const [exited, setExited] = React12.useState(true);
      const modal = React12.useRef({});
      const mountNodeRef = React12.useRef(null);
      const modalRef = React12.useRef(null);
      const handleRef = useForkRef(modalRef, ref);
      const hasTransition = getHasTransition(props);
      const getDoc = () => ownerDocument(mountNodeRef.current);
      const getModal = () => {
        modal.current.modalRef = modalRef.current;
        modal.current.mountNode = mountNodeRef.current;
        return modal.current;
      };
      const handleMounted = () => {
        manager.mount(getModal(), {
          disableScrollLock
        });
        modalRef.current.scrollTop = 0;
      };
      const handleOpen = useEventCallback(() => {
        const resolvedContainer = getContainer(container) || getDoc().body;
        manager.add(getModal(), resolvedContainer);
        if (modalRef.current) {
          handleMounted();
        }
      });
      const isTopModal = React12.useCallback(() => manager.isTopModal(getModal()), [manager]);
      const handlePortalRef = useEventCallback((node) => {
        mountNodeRef.current = node;
        if (!node) {
          return;
        }
        if (open && isTopModal()) {
          handleMounted();
        } else {
          ariaHidden(modalRef.current, true);
        }
      });
      const handleClose = React12.useCallback(() => {
        manager.remove(getModal());
      }, [manager]);
      React12.useEffect(() => {
        return () => {
          handleClose();
        };
      }, [handleClose]);
      React12.useEffect(() => {
        if (open) {
          handleOpen();
        } else if (!hasTransition || !closeAfterTransition) {
          handleClose();
        }
      }, [open, handleClose, hasTransition, closeAfterTransition, handleOpen]);
      const ownerState = _extends({}, props, {
        classes: classesProp,
        closeAfterTransition,
        disableAutoFocus,
        disableEnforceFocus,
        disableEscapeKeyDown,
        disablePortal,
        disableRestoreFocus,
        disableScrollLock,
        exited,
        hideBackdrop,
        keepMounted
      });
      const classes = useUtilityClasses4(ownerState);
      if (!keepMounted && !open && (!hasTransition || exited)) {
        return null;
      }
      const handleEnter = () => {
        setExited(false);
        if (onTransitionEnter) {
          onTransitionEnter();
        }
      };
      const handleExited = () => {
        setExited(true);
        if (onTransitionExited) {
          onTransitionExited();
        }
        if (closeAfterTransition) {
          handleClose();
        }
      };
      const handleBackdropClick = (event) => {
        if (event.target !== event.currentTarget) {
          return;
        }
        if (onBackdropClick) {
          onBackdropClick(event);
        }
        if (onClose) {
          onClose(event, "backdropClick");
        }
      };
      const handleKeyDown = (event) => {
        if (onKeyDown) {
          onKeyDown(event);
        }
        if (event.key !== "Escape" || !isTopModal()) {
          return;
        }
        if (!disableEscapeKeyDown) {
          event.stopPropagation();
          if (onClose) {
            onClose(event, "escapeKeyDown");
          }
        }
      };
      const childProps = {};
      if (children.props.tabIndex === void 0) {
        childProps.tabIndex = "-1";
      }
      if (hasTransition) {
        childProps.onEnter = createChainedFunction(handleEnter, children.props.onEnter);
        childProps.onExited = createChainedFunction(handleExited, children.props.onExited);
      }
      const Root = components.Root || component;
      const rootProps = componentsProps.root || {};
      return (0, import_jsx_runtime10.jsx)(Portal_default, {
        ref: handlePortalRef,
        container,
        disablePortal,
        children: (0, import_jsx_runtime11.jsxs)(Root, _extends({
          role: "presentation"
        }, rootProps, !isHostComponent_default(Root) && {
          as: component,
          ownerState: _extends({}, ownerState, rootProps.ownerState),
          theme
        }, other, {
          ref: handleRef,
          onKeyDown: handleKeyDown,
          className: clsx_m_default(classes.root, rootProps.className, className),
          children: [!hideBackdrop && BackdropComponent ? (0, import_jsx_runtime10.jsx)(BackdropComponent, _extends({
            open,
            onClick: handleBackdropClick
          }, BackdropProps)) : null, (0, import_jsx_runtime10.jsx)(Unstable_TrapFocus_default, {
            disableEnforceFocus,
            disableAutoFocus,
            disableRestoreFocus,
            isEnabled: isTopModal,
            open,
            children: React12.cloneElement(children, childProps)
          })]
        }))
      });
    });
    true ? ModalUnstyled.propTypes = {
      // ----------------------------- Warning --------------------------------
      // | These PropTypes are generated from the TypeScript type definitions |
      // |     To update them edit the d.ts file and run "yarn proptypes"     |
      // ----------------------------------------------------------------------
      /**
       * A backdrop component. This prop enables custom backdrop rendering.
       */
      BackdropComponent: import_prop_types7.default.elementType,
      /**
       * Props applied to the [`BackdropUnstyled`](/api/backdrop-unstyled/) element.
       */
      BackdropProps: import_prop_types7.default.object,
      /**
       * A single child content element.
       */
      children: elementAcceptingRef_default.isRequired,
      /**
       * Override or extend the styles applied to the component.
       */
      classes: import_prop_types7.default.object,
      /**
       * @ignore
       */
      className: import_prop_types7.default.string,
      /**
       * When set to true the Modal waits until a nested Transition is completed before closing.
       * @default false
       */
      closeAfterTransition: import_prop_types7.default.bool,
      /**
       * The component used for the root node.
       * Either a string to use a HTML element or a component.
       */
      component: import_prop_types7.default.elementType,
      /**
       * The components used for each slot inside the Modal.
       * Either a string to use a HTML element or a component.
       * @default {}
       */
      components: import_prop_types7.default.shape({
        Root: import_prop_types7.default.elementType
      }),
      /**
       * The props used for each slot inside the Modal.
       * @default {}
       */
      componentsProps: import_prop_types7.default.object,
      /**
       * An HTML element or function that returns one.
       * The `container` will have the portal children appended to it.
       *
       * By default, it uses the body of the top-level document object,
       * so it's simply `document.body` most of the time.
       */
      container: import_prop_types7.default.oneOfType([HTMLElementType, import_prop_types7.default.func]),
      /**
       * If `true`, the modal will not automatically shift focus to itself when it opens, and
       * replace it to the last focused element when it closes.
       * This also works correctly with any modal children that have the `disableAutoFocus` prop.
       *
       * Generally this should never be set to `true` as it makes the modal less
       * accessible to assistive technologies, like screen readers.
       * @default false
       */
      disableAutoFocus: import_prop_types7.default.bool,
      /**
       * If `true`, the modal will not prevent focus from leaving the modal while open.
       *
       * Generally this should never be set to `true` as it makes the modal less
       * accessible to assistive technologies, like screen readers.
       * @default false
       */
      disableEnforceFocus: import_prop_types7.default.bool,
      /**
       * If `true`, hitting escape will not fire the `onClose` callback.
       * @default false
       */
      disableEscapeKeyDown: import_prop_types7.default.bool,
      /**
       * The `children` will be under the DOM hierarchy of the parent component.
       * @default false
       */
      disablePortal: import_prop_types7.default.bool,
      /**
       * If `true`, the modal will not restore focus to previously focused element once
       * modal is hidden.
       * @default false
       */
      disableRestoreFocus: import_prop_types7.default.bool,
      /**
       * Disable the scroll lock behavior.
       * @default false
       */
      disableScrollLock: import_prop_types7.default.bool,
      /**
       * If `true`, the backdrop is not rendered.
       * @default false
       */
      hideBackdrop: import_prop_types7.default.bool,
      /**
       * Always keep the children in the DOM.
       * This prop can be useful in SEO situation or
       * when you want to maximize the responsiveness of the Modal.
       * @default false
       */
      keepMounted: import_prop_types7.default.bool,
      /**
       * Callback fired when the backdrop is clicked.
       */
      onBackdropClick: import_prop_types7.default.func,
      /**
       * Callback fired when the component requests to be closed.
       * The `reason` parameter can optionally be used to control the response to `onClose`.
       *
       * @param {object} event The event source of the callback.
       * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`.
       */
      onClose: import_prop_types7.default.func,
      /**
       * @ignore
       */
      onKeyDown: import_prop_types7.default.func,
      /**
       * If `true`, the component is shown.
       */
      open: import_prop_types7.default.bool.isRequired
    } : void 0;
    ModalUnstyled_default = ModalUnstyled;
  }
});

// node_modules/@mui/base/ModalUnstyled/index.js
var init_ModalUnstyled2 = __esm({
  "node_modules/@mui/base/ModalUnstyled/index.js"() {
    init_ModalUnstyled();
    init_ModalManager();
    init_modalUnstyledClasses();
  }
});

// node_modules/@mui/base/NoSsr/NoSsr.js
function NoSsr(props) {
  const {
    children,
    defer = false,
    fallback = null
  } = props;
  const [mountedState, setMountedState] = React13.useState(false);
  useEnhancedEffect_default(() => {
    if (!defer) {
      setMountedState(true);
    }
  }, [defer]);
  React13.useEffect(() => {
    if (defer) {
      setMountedState(true);
    }
  }, [defer]);
  return (0, import_jsx_runtime12.jsx)(React13.Fragment, {
    children: mountedState ? children : fallback
  });
}
var React13, import_prop_types8, import_jsx_runtime12, NoSsr_default;
var init_NoSsr = __esm({
  "node_modules/@mui/base/NoSsr/NoSsr.js"() {
    React13 = __toESM(require_react());
    import_prop_types8 = __toESM(require_prop_types());
    init_esm();
    import_jsx_runtime12 = __toESM(require_jsx_runtime());
    true ? NoSsr.propTypes = {
      // ----------------------------- Warning --------------------------------
      // | These PropTypes are generated from the TypeScript type definitions |
      // |     To update them edit the d.ts file and run "yarn proptypes"     |
      // ----------------------------------------------------------------------
      /**
       * You can wrap a node.
       */
      children: import_prop_types8.default.node,
      /**
       * If `true`, the component will not only prevent server-side rendering.
       * It will also defer the rendering of the children into a different screen frame.
       * @default false
       */
      defer: import_prop_types8.default.bool,
      /**
       * The fallback content to display.
       * @default null
       */
      fallback: import_prop_types8.default.node
    } : void 0;
    if (true) {
      NoSsr["propTypes"] = exactProp(NoSsr.propTypes);
    }
    NoSsr_default = NoSsr;
  }
});

// node_modules/@mui/base/NoSsr/index.js
var init_NoSsr2 = __esm({
  "node_modules/@mui/base/NoSsr/index.js"() {
    init_NoSsr();
  }
});

// node_modules/@mui/base/SliderUnstyled/sliderUnstyledClasses.js
function getSliderUtilityClass(slot) {
  return generateUtilityClass("MuiSlider", slot);
}
var sliderUnstyledClasses, sliderUnstyledClasses_default;
var init_sliderUnstyledClasses = __esm({
  "node_modules/@mui/base/SliderUnstyled/sliderUnstyledClasses.js"() {
    init_generateUtilityClasses2();
    init_generateUtilityClass2();
    sliderUnstyledClasses = generateUtilityClasses("MuiSlider", ["root", "active", "focusVisible", "disabled", "dragging", "marked", "vertical", "trackInverted", "trackFalse", "rail", "track", "mark", "markActive", "markLabel", "markLabelActive", "thumb", "valueLabel", "valueLabelOpen", "valueLabelCircle", "valueLabelLabel"]);
    sliderUnstyledClasses_default = sliderUnstyledClasses;
  }
});

// node_modules/@mui/base/SliderUnstyled/SliderValueLabelUnstyled.js
function SliderValueLabelUnstyled(props) {
  const {
    children,
    className,
    value,
    theme
  } = props;
  const classes = useValueLabelClasses(props);
  return React14.cloneElement(children, {
    className: clsx_m_default(children.props.className)
  }, (0, import_jsx_runtime14.jsxs)(React14.Fragment, {
    children: [children.props.children, (0, import_jsx_runtime13.jsx)("span", {
      className: clsx_m_default(classes.offset, className),
      theme,
      "aria-hidden": true,
      children: (0, import_jsx_runtime13.jsx)("span", {
        className: classes.circle,
        children: (0, import_jsx_runtime13.jsx)("span", {
          className: classes.label,
          children: value
        })
      })
    })]
  }));
}
var React14, import_prop_types9, import_jsx_runtime13, import_jsx_runtime14, useValueLabelClasses, SliderValueLabelUnstyled_default;
var init_SliderValueLabelUnstyled = __esm({
  "node_modules/@mui/base/SliderUnstyled/SliderValueLabelUnstyled.js"() {
    React14 = __toESM(require_react());
    import_prop_types9 = __toESM(require_prop_types());
    init_clsx_m();
    init_sliderUnstyledClasses();
    import_jsx_runtime13 = __toESM(require_jsx_runtime());
    import_jsx_runtime14 = __toESM(require_jsx_runtime());
    useValueLabelClasses = (props) => {
      const {
        open
      } = props;
      const utilityClasses = {
        offset: clsx_m_default(open && sliderUnstyledClasses_default.valueLabelOpen),
        circle: sliderUnstyledClasses_default.valueLabelCircle,
        label: sliderUnstyledClasses_default.valueLabelLabel
      };
      return utilityClasses;
    };
    true ? SliderValueLabelUnstyled.propTypes = {
      children: import_prop_types9.default.element.isRequired,
      className: import_prop_types9.default.string,
      theme: import_prop_types9.default.any,
      value: import_prop_types9.default.node
    } : void 0;
    SliderValueLabelUnstyled_default = SliderValueLabelUnstyled;
  }
});

// node_modules/@mui/base/SliderUnstyled/SliderUnstyled.js
function asc(a, b) {
  return a - b;
}
function clamp(value, min, max) {
  if (value == null) {
    return min;
  }
  return Math.min(Math.max(min, value), max);
}
function findClosest(values, currentValue) {
  const {
    index: closestIndex
  } = values.reduce((acc, value, index) => {
    const distance = Math.abs(currentValue - value);
    if (acc === null || distance < acc.distance || distance === acc.distance) {
      return {
        distance,
        index
      };
    }
    return acc;
  }, null);
  return closestIndex;
}
function trackFinger(event, touchId) {
  if (touchId.current !== void 0 && event.changedTouches) {
    for (let i = 0; i < event.changedTouches.length; i += 1) {
      const touch = event.changedTouches[i];
      if (touch.identifier === touchId.current) {
        return {
          x: touch.clientX,
          y: touch.clientY
        };
      }
    }
    return false;
  }
  return {
    x: event.clientX,
    y: event.clientY
  };
}
function valueToPercent(value, min, max) {
  return (value - min) * 100 / (max - min);
}
function percentToValue(percent, min, max) {
  return (max - min) * percent + min;
}
function getDecimalPrecision(num) {
  if (Math.abs(num) < 1) {
    const parts = num.toExponential().split("e-");
    const matissaDecimalPart = parts[0].split(".")[1];
    return (matissaDecimalPart ? matissaDecimalPart.length : 0) + parseInt(parts[1], 10);
  }
  const decimalPart = num.toString().split(".")[1];
  return decimalPart ? decimalPart.length : 0;
}
function roundValueToStep(value, step, min) {
  const nearest = Math.round((value - min) / step) * step + min;
  return Number(nearest.toFixed(getDecimalPrecision(step)));
}
function setValueIndex({
  values,
  newValue,
  index
}) {
  const output = values.slice();
  output[index] = newValue;
  return output.sort(asc);
}
function focusThumb({
  sliderRef,
  activeIndex,
  setActive
}) {
  const doc = ownerDocument(sliderRef.current);
  if (!sliderRef.current.contains(doc.activeElement) || Number(doc.activeElement.getAttribute("data-index")) !== activeIndex) {
    sliderRef.current.querySelector(`[type="range"][data-index="${activeIndex}"]`).focus();
  }
  if (setActive) {
    setActive(activeIndex);
  }
}
function doesSupportTouchActionNone() {
  if (cachedSupportsTouchActionNone === void 0) {
    if (typeof CSS !== "undefined" && typeof CSS.supports === "function") {
      cachedSupportsTouchActionNone = CSS.supports("touch-action", "none");
    } else {
      cachedSupportsTouchActionNone = true;
    }
  }
  return cachedSupportsTouchActionNone;
}
var React15, import_prop_types10, import_jsx_runtime15, import_jsx_runtime16, _excluded7, INTENTIONAL_DRAG_COUNT_THRESHOLD, axisProps, Identity, cachedSupportsTouchActionNone, useUtilityClasses5, Forward, SliderUnstyled, SliderUnstyled_default;
var init_SliderUnstyled = __esm({
  "node_modules/@mui/base/SliderUnstyled/SliderUnstyled.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React15 = __toESM(require_react());
    import_prop_types10 = __toESM(require_prop_types());
    init_clsx_m();
    init_esm();
    init_isHostComponent();
    init_composeClasses2();
    init_sliderUnstyledClasses();
    init_SliderValueLabelUnstyled();
    import_jsx_runtime15 = __toESM(require_jsx_runtime());
    import_jsx_runtime16 = __toESM(require_jsx_runtime());
    _excluded7 = ["aria-label", "aria-labelledby", "aria-valuetext", "className", "component", "classes", "defaultValue", "disableSwap", "disabled", "getAriaLabel", "getAriaValueText", "marks", "max", "min", "name", "onChange", "onChangeCommitted", "onMouseDown", "orientation", "scale", "step", "tabIndex", "track", "value", "valueLabelDisplay", "valueLabelFormat", "isRtl", "components", "componentsProps"];
    INTENTIONAL_DRAG_COUNT_THRESHOLD = 2;
    axisProps = {
      horizontal: {
        offset: (percent) => ({
          left: `${percent}%`
        }),
        leap: (percent) => ({
          width: `${percent}%`
        })
      },
      "horizontal-reverse": {
        offset: (percent) => ({
          right: `${percent}%`
        }),
        leap: (percent) => ({
          width: `${percent}%`
        })
      },
      vertical: {
        offset: (percent) => ({
          bottom: `${percent}%`
        }),
        leap: (percent) => ({
          height: `${percent}%`
        })
      }
    };
    Identity = (x) => x;
    useUtilityClasses5 = (ownerState) => {
      const {
        disabled,
        dragging,
        marked,
        orientation,
        track,
        classes
      } = ownerState;
      const slots = {
        root: ["root", disabled && "disabled", dragging && "dragging", marked && "marked", orientation === "vertical" && "vertical", track === "inverted" && "trackInverted", track === false && "trackFalse"],
        rail: ["rail"],
        track: ["track"],
        mark: ["mark"],
        markActive: ["markActive"],
        markLabel: ["markLabel"],
        markLabelActive: ["markLabelActive"],
        valueLabel: ["valueLabel"],
        thumb: ["thumb", disabled && "disabled"],
        active: ["active"],
        disabled: ["disabled"],
        focusVisible: ["focusVisible"]
      };
      return composeClasses(slots, getSliderUtilityClass, classes);
    };
    Forward = ({
      children
    }) => children;
    SliderUnstyled = React15.forwardRef(function SliderUnstyled2(props, ref) {
      const {
        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabelledby,
        "aria-valuetext": ariaValuetext,
        className,
        component = "span",
        classes: classesProp,
        defaultValue,
        disableSwap = false,
        disabled = false,
        getAriaLabel,
        getAriaValueText,
        marks: marksProp = false,
        max = 100,
        min = 0,
        name,
        onChange,
        onChangeCommitted,
        onMouseDown,
        orientation = "horizontal",
        scale = Identity,
        step = 1,
        tabIndex,
        track = "normal",
        value: valueProp,
        valueLabelDisplay = "off",
        valueLabelFormat = Identity,
        isRtl = false,
        components = {},
        componentsProps = {}
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded7);
      const touchId = React15.useRef();
      const [active, setActive] = React15.useState(-1);
      const [open, setOpen] = React15.useState(-1);
      const [dragging, setDragging] = React15.useState(false);
      const moveCount = React15.useRef(0);
      const [valueDerived, setValueState] = useControlled({
        controlled: valueProp,
        default: defaultValue != null ? defaultValue : min,
        name: "Slider"
      });
      const handleChange = onChange && ((event, value, thumbIndex) => {
        const nativeEvent = event.nativeEvent || event;
        const clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
        Object.defineProperty(clonedEvent, "target", {
          writable: true,
          value: {
            value,
            name
          }
        });
        onChange(clonedEvent, value, thumbIndex);
      });
      const range = Array.isArray(valueDerived);
      let values = range ? valueDerived.slice().sort(asc) : [valueDerived];
      values = values.map((value) => clamp(value, min, max));
      const marks = marksProp === true && step !== null ? [...Array(Math.floor((max - min) / step) + 1)].map((_, index) => ({
        value: min + step * index
      })) : marksProp || [];
      const {
        isFocusVisibleRef,
        onBlur: handleBlurVisible,
        onFocus: handleFocusVisible,
        ref: focusVisibleRef
      } = useIsFocusVisible();
      const [focusVisible, setFocusVisible] = React15.useState(-1);
      const sliderRef = React15.useRef();
      const handleFocusRef = useForkRef(focusVisibleRef, sliderRef);
      const handleRef = useForkRef(ref, handleFocusRef);
      const handleFocus = (event) => {
        const index = Number(event.currentTarget.getAttribute("data-index"));
        handleFocusVisible(event);
        if (isFocusVisibleRef.current === true) {
          setFocusVisible(index);
        }
        setOpen(index);
      };
      const handleBlur = (event) => {
        handleBlurVisible(event);
        if (isFocusVisibleRef.current === false) {
          setFocusVisible(-1);
        }
        setOpen(-1);
      };
      const handleMouseOver = useEventCallback((event) => {
        const index = Number(event.currentTarget.getAttribute("data-index"));
        setOpen(index);
      });
      const handleMouseLeave = useEventCallback(() => {
        setOpen(-1);
      });
      useEnhancedEffect_default(() => {
        if (disabled && sliderRef.current.contains(document.activeElement)) {
          document.activeElement.blur();
        }
      }, [disabled]);
      if (disabled && active !== -1) {
        setActive(-1);
      }
      if (disabled && focusVisible !== -1) {
        setFocusVisible(-1);
      }
      const handleHiddenInputChange = (event) => {
        const index = Number(event.currentTarget.getAttribute("data-index"));
        const value = values[index];
        const marksValues = marks.map((mark) => mark.value);
        const marksIndex = marksValues.indexOf(value);
        let newValue = event.target.valueAsNumber;
        if (marks && step == null) {
          newValue = newValue < value ? marksValues[marksIndex - 1] : marksValues[marksIndex + 1];
        }
        newValue = clamp(newValue, min, max);
        if (marks && step == null) {
          const markValues = marks.map((mark) => mark.value);
          const currentMarkIndex = markValues.indexOf(values[index]);
          newValue = newValue < values[index] ? markValues[currentMarkIndex - 1] : markValues[currentMarkIndex + 1];
        }
        if (range) {
          if (disableSwap) {
            newValue = clamp(newValue, values[index - 1] || -Infinity, values[index + 1] || Infinity);
          }
          const previousValue = newValue;
          newValue = setValueIndex({
            values,
            newValue,
            index
          });
          let activeIndex = index;
          if (!disableSwap) {
            activeIndex = newValue.indexOf(previousValue);
          }
          focusThumb({
            sliderRef,
            activeIndex
          });
        }
        setValueState(newValue);
        setFocusVisible(index);
        if (handleChange) {
          handleChange(event, newValue, index);
        }
        if (onChangeCommitted) {
          onChangeCommitted(event, newValue);
        }
      };
      const previousIndex = React15.useRef();
      let axis = orientation;
      if (isRtl && orientation !== "vertical") {
        axis += "-reverse";
      }
      const getFingerNewValue = ({
        finger,
        move = false,
        values: values2
      }) => {
        const {
          current: slider
        } = sliderRef;
        const {
          width,
          height,
          bottom,
          left
        } = slider.getBoundingClientRect();
        let percent;
        if (axis.indexOf("vertical") === 0) {
          percent = (bottom - finger.y) / height;
        } else {
          percent = (finger.x - left) / width;
        }
        if (axis.indexOf("-reverse") !== -1) {
          percent = 1 - percent;
        }
        let newValue;
        newValue = percentToValue(percent, min, max);
        if (step) {
          newValue = roundValueToStep(newValue, step, min);
        } else {
          const marksValues = marks.map((mark) => mark.value);
          const closestIndex = findClosest(marksValues, newValue);
          newValue = marksValues[closestIndex];
        }
        newValue = clamp(newValue, min, max);
        let activeIndex = 0;
        if (range) {
          if (!move) {
            activeIndex = findClosest(values2, newValue);
          } else {
            activeIndex = previousIndex.current;
          }
          if (disableSwap) {
            newValue = clamp(newValue, values2[activeIndex - 1] || -Infinity, values2[activeIndex + 1] || Infinity);
          }
          const previousValue = newValue;
          newValue = setValueIndex({
            values: values2,
            newValue,
            index: activeIndex
          });
          if (!(disableSwap && move)) {
            activeIndex = newValue.indexOf(previousValue);
            previousIndex.current = activeIndex;
          }
        }
        return {
          newValue,
          activeIndex
        };
      };
      const handleTouchMove = useEventCallback((nativeEvent) => {
        const finger = trackFinger(nativeEvent, touchId);
        if (!finger) {
          return;
        }
        moveCount.current += 1;
        if (nativeEvent.type === "mousemove" && nativeEvent.buttons === 0) {
          handleTouchEnd(nativeEvent);
          return;
        }
        const {
          newValue,
          activeIndex
        } = getFingerNewValue({
          finger,
          move: true,
          values
        });
        focusThumb({
          sliderRef,
          activeIndex,
          setActive
        });
        setValueState(newValue);
        if (!dragging && moveCount.current > INTENTIONAL_DRAG_COUNT_THRESHOLD) {
          setDragging(true);
        }
        if (handleChange) {
          handleChange(nativeEvent, newValue, activeIndex);
        }
      });
      const handleTouchEnd = useEventCallback((nativeEvent) => {
        const finger = trackFinger(nativeEvent, touchId);
        setDragging(false);
        if (!finger) {
          return;
        }
        const {
          newValue
        } = getFingerNewValue({
          finger,
          values
        });
        setActive(-1);
        if (nativeEvent.type === "touchend") {
          setOpen(-1);
        }
        if (onChangeCommitted) {
          onChangeCommitted(nativeEvent, newValue);
        }
        touchId.current = void 0;
        stopListening();
      });
      const handleTouchStart = useEventCallback((nativeEvent) => {
        if (!doesSupportTouchActionNone()) {
          nativeEvent.preventDefault();
        }
        const touch = nativeEvent.changedTouches[0];
        if (touch != null) {
          touchId.current = touch.identifier;
        }
        const finger = trackFinger(nativeEvent, touchId);
        const {
          newValue,
          activeIndex
        } = getFingerNewValue({
          finger,
          values
        });
        focusThumb({
          sliderRef,
          activeIndex,
          setActive
        });
        setValueState(newValue);
        if (handleChange) {
          handleChange(nativeEvent, newValue, activeIndex);
        }
        moveCount.current = 0;
        const doc = ownerDocument(sliderRef.current);
        doc.addEventListener("touchmove", handleTouchMove);
        doc.addEventListener("touchend", handleTouchEnd);
      });
      const stopListening = React15.useCallback(() => {
        const doc = ownerDocument(sliderRef.current);
        doc.removeEventListener("mousemove", handleTouchMove);
        doc.removeEventListener("mouseup", handleTouchEnd);
        doc.removeEventListener("touchmove", handleTouchMove);
        doc.removeEventListener("touchend", handleTouchEnd);
      }, [handleTouchEnd, handleTouchMove]);
      React15.useEffect(() => {
        const {
          current: slider
        } = sliderRef;
        slider.addEventListener("touchstart", handleTouchStart, {
          passive: doesSupportTouchActionNone()
        });
        return () => {
          slider.removeEventListener("touchstart", handleTouchStart, {
            passive: doesSupportTouchActionNone()
          });
          stopListening();
        };
      }, [stopListening, handleTouchStart]);
      React15.useEffect(() => {
        if (disabled) {
          stopListening();
        }
      }, [disabled, stopListening]);
      const handleMouseDown = useEventCallback((event) => {
        if (onMouseDown) {
          onMouseDown(event);
        }
        if (event.button !== 0) {
          return;
        }
        event.preventDefault();
        const finger = trackFinger(event, touchId);
        const {
          newValue,
          activeIndex
        } = getFingerNewValue({
          finger,
          values
        });
        focusThumb({
          sliderRef,
          activeIndex,
          setActive
        });
        setValueState(newValue);
        if (handleChange) {
          handleChange(event, newValue, activeIndex);
        }
        moveCount.current = 0;
        const doc = ownerDocument(sliderRef.current);
        doc.addEventListener("mousemove", handleTouchMove);
        doc.addEventListener("mouseup", handleTouchEnd);
      });
      const trackOffset = valueToPercent(range ? values[0] : min, min, max);
      const trackLeap = valueToPercent(values[values.length - 1], min, max) - trackOffset;
      const trackStyle = _extends({}, axisProps[axis].offset(trackOffset), axisProps[axis].leap(trackLeap));
      const Root = components.Root || component;
      const rootProps = componentsProps.root || {};
      const Rail = components.Rail || "span";
      const railProps = componentsProps.rail || {};
      const Track = components.Track || "span";
      const trackProps = componentsProps.track || {};
      const Thumb = components.Thumb || "span";
      const thumbProps = componentsProps.thumb || {};
      const ValueLabel = components.ValueLabel || SliderValueLabelUnstyled_default;
      const valueLabelProps = componentsProps.valueLabel || {};
      const Mark = components.Mark || "span";
      const markProps = componentsProps.mark || {};
      const MarkLabel = components.MarkLabel || "span";
      const markLabelProps = componentsProps.markLabel || {};
      const ownerState = _extends({}, props, {
        classes: classesProp,
        disabled,
        dragging,
        isRtl,
        marked: marks.length > 0 && marks.some((mark) => mark.label),
        max,
        min,
        orientation,
        scale,
        step,
        track,
        valueLabelDisplay,
        valueLabelFormat
      });
      const classes = useUtilityClasses5(ownerState);
      return (0, import_jsx_runtime16.jsxs)(Root, _extends({
        ref: handleRef,
        onMouseDown: handleMouseDown
      }, rootProps, !isHostComponent_default(Root) && {
        as: component,
        ownerState: _extends({}, ownerState, rootProps.ownerState)
      }, other, {
        className: clsx_m_default(classes.root, rootProps.className, className),
        children: [(0, import_jsx_runtime15.jsx)(Rail, _extends({}, railProps, !isHostComponent_default(Rail) && {
          ownerState: _extends({}, ownerState, railProps.ownerState)
        }, {
          className: clsx_m_default(classes.rail, railProps.className)
        })), (0, import_jsx_runtime15.jsx)(Track, _extends({}, trackProps, !isHostComponent_default(Track) && {
          ownerState: _extends({}, ownerState, trackProps.ownerState)
        }, {
          className: clsx_m_default(classes.track, trackProps.className),
          style: _extends({}, trackStyle, trackProps.style)
        })), marks.map((mark, index) => {
          const percent = valueToPercent(mark.value, min, max);
          const style = axisProps[axis].offset(percent);
          let markActive;
          if (track === false) {
            markActive = values.indexOf(mark.value) !== -1;
          } else {
            markActive = track === "normal" && (range ? mark.value >= values[0] && mark.value <= values[values.length - 1] : mark.value <= values[0]) || track === "inverted" && (range ? mark.value <= values[0] || mark.value >= values[values.length - 1] : mark.value >= values[0]);
          }
          return (0, import_jsx_runtime16.jsxs)(React15.Fragment, {
            children: [(0, import_jsx_runtime15.jsx)(Mark, _extends({
              "data-index": index
            }, markProps, !isHostComponent_default(Mark) && {
              ownerState: _extends({}, ownerState, markProps.ownerState),
              markActive
            }, {
              style: _extends({}, style, markProps.style),
              className: clsx_m_default(classes.mark, markProps.className, markActive && classes.markActive)
            })), mark.label != null ? (0, import_jsx_runtime15.jsx)(MarkLabel, _extends({
              "aria-hidden": true,
              "data-index": index
            }, markLabelProps, !isHostComponent_default(MarkLabel) && {
              ownerState: _extends({}, ownerState, markLabelProps.ownerState)
            }, {
              markLabelActive: markActive,
              style: _extends({}, style, markLabelProps.style),
              className: clsx_m_default(classes.markLabel, markLabelProps.className, markActive && classes.markLabelActive),
              children: mark.label
            })) : null]
          }, mark.value);
        }), values.map((value, index) => {
          const percent = valueToPercent(value, min, max);
          const style = axisProps[axis].offset(percent);
          const ValueLabelComponent = valueLabelDisplay === "off" ? Forward : ValueLabel;
          return (0, import_jsx_runtime15.jsx)(React15.Fragment, {
            children: (0, import_jsx_runtime15.jsx)(ValueLabelComponent, _extends({
              valueLabelFormat,
              valueLabelDisplay,
              value: typeof valueLabelFormat === "function" ? valueLabelFormat(scale(value), index) : valueLabelFormat,
              index,
              open: open === index || active === index || valueLabelDisplay === "on",
              disabled
            }, valueLabelProps, {
              className: clsx_m_default(classes.valueLabel, valueLabelProps.className)
            }, !isHostComponent_default(ValueLabel) && {
              ownerState: _extends({}, ownerState, valueLabelProps.ownerState)
            }, {
              children: (0, import_jsx_runtime15.jsx)(Thumb, _extends({
                "data-index": index,
                onMouseOver: handleMouseOver,
                onMouseLeave: handleMouseLeave
              }, thumbProps, {
                className: clsx_m_default(classes.thumb, thumbProps.className, active === index && classes.active, focusVisible === index && classes.focusVisible)
              }, !isHostComponent_default(Thumb) && {
                ownerState: _extends({}, ownerState, thumbProps.ownerState)
              }, {
                style: _extends({}, style, {
                  pointerEvents: disableSwap && active !== index ? "none" : void 0
                }, thumbProps.style),
                children: (0, import_jsx_runtime15.jsx)("input", {
                  tabIndex,
                  "data-index": index,
                  "aria-label": getAriaLabel ? getAriaLabel(index) : ariaLabel,
                  "aria-labelledby": ariaLabelledby,
                  "aria-orientation": orientation,
                  "aria-valuemax": scale(max),
                  "aria-valuemin": scale(min),
                  "aria-valuenow": scale(value),
                  "aria-valuetext": getAriaValueText ? getAriaValueText(scale(value), index) : ariaValuetext,
                  onFocus: handleFocus,
                  onBlur: handleBlur,
                  name,
                  type: "range",
                  min: props.min,
                  max: props.max,
                  step: props.step,
                  disabled,
                  value: values[index],
                  onChange: handleHiddenInputChange,
                  style: _extends({}, visuallyHidden_default, {
                    direction: isRtl ? "rtl" : "ltr",
                    // So that VoiceOver's focus indicator matches the thumb's dimensions
                    width: "100%",
                    height: "100%"
                  })
                })
              }))
            }))
          }, index);
        })]
      }));
    });
    true ? SliderUnstyled.propTypes = {
      // ----------------------------- Warning --------------------------------
      // | These PropTypes are generated from the TypeScript type definitions |
      // |     To update them edit the d.ts file and run "yarn proptypes"     |
      // ----------------------------------------------------------------------
      /**
       * The label of the slider.
       */
      "aria-label": chainPropTypes(import_prop_types10.default.string, (props) => {
        const range = Array.isArray(props.value || props.defaultValue);
        if (range && props["aria-label"] != null) {
          return new Error("MUI: You need to use the `getAriaLabel` prop instead of `aria-label` when using a range slider.");
        }
        return null;
      }),
      /**
       * The id of the element containing a label for the slider.
       */
      "aria-labelledby": import_prop_types10.default.string,
      /**
       * A string value that provides a user-friendly name for the current value of the slider.
       */
      "aria-valuetext": chainPropTypes(import_prop_types10.default.string, (props) => {
        const range = Array.isArray(props.value || props.defaultValue);
        if (range && props["aria-valuetext"] != null) {
          return new Error("MUI: You need to use the `getAriaValueText` prop instead of `aria-valuetext` when using a range slider.");
        }
        return null;
      }),
      /**
       * @ignore
       */
      children: import_prop_types10.default.node,
      /**
       * Override or extend the styles applied to the component.
       */
      classes: import_prop_types10.default.object,
      /**
       * @ignore
       */
      className: import_prop_types10.default.string,
      /**
       * The component used for the root node.
       * Either a string to use a HTML element or a component.
       */
      component: import_prop_types10.default.elementType,
      /**
       * The components used for each slot inside the Slider.
       * Either a string to use a HTML element or a component.
       * @default {}
       */
      components: import_prop_types10.default.shape({
        Mark: import_prop_types10.default.elementType,
        MarkLabel: import_prop_types10.default.elementType,
        Rail: import_prop_types10.default.elementType,
        Root: import_prop_types10.default.elementType,
        Thumb: import_prop_types10.default.elementType,
        Track: import_prop_types10.default.elementType,
        ValueLabel: import_prop_types10.default.elementType
      }),
      /**
       * The props used for each slot inside the Slider.
       * @default {}
       */
      componentsProps: import_prop_types10.default.object,
      /**
       * The default value. Use when the component is not controlled.
       */
      defaultValue: import_prop_types10.default.oneOfType([import_prop_types10.default.arrayOf(import_prop_types10.default.number), import_prop_types10.default.number]),
      /**
       * If `true`, the component is disabled.
       * @default false
       */
      disabled: import_prop_types10.default.bool,
      /**
       * If `true`, the active thumb doesn't swap when moving pointer over a thumb while dragging another thumb.
       * @default false
       */
      disableSwap: import_prop_types10.default.bool,
      /**
       * Accepts a function which returns a string value that provides a user-friendly name for the thumb labels of the slider.
       * This is important for screen reader users.
       * @param {number} index The thumb label's index to format.
       * @returns {string}
       */
      getAriaLabel: import_prop_types10.default.func,
      /**
       * Accepts a function which returns a string value that provides a user-friendly name for the current value of the slider.
       * This is important for screen reader users.
       * @param {number} value The thumb label's value to format.
       * @param {number} index The thumb label's index to format.
       * @returns {string}
       */
      getAriaValueText: import_prop_types10.default.func,
      /**
       * Indicates whether the theme context has rtl direction. It is set automatically.
       * @default false
       */
      isRtl: import_prop_types10.default.bool,
      /**
       * Marks indicate predetermined values to which the user can move the slider.
       * If `true` the marks are spaced according the value of the `step` prop.
       * If an array, it should contain objects with `value` and an optional `label` keys.
       * @default false
       */
      marks: import_prop_types10.default.oneOfType([import_prop_types10.default.arrayOf(import_prop_types10.default.shape({
        label: import_prop_types10.default.node,
        value: import_prop_types10.default.number.isRequired
      })), import_prop_types10.default.bool]),
      /**
       * The maximum allowed value of the slider.
       * Should not be equal to min.
       * @default 100
       */
      max: import_prop_types10.default.number,
      /**
       * The minimum allowed value of the slider.
       * Should not be equal to max.
       * @default 0
       */
      min: import_prop_types10.default.number,
      /**
       * Name attribute of the hidden `input` element.
       */
      name: import_prop_types10.default.string,
      /**
       * Callback function that is fired when the slider's value changed.
       *
       * @param {Event} event The event source of the callback.
       * You can pull out the new value by accessing `event.target.value` (any).
       * **Warning**: This is a generic event not a change event.
       * @param {number | number[]} value The new value.
       * @param {number} activeThumb Index of the currently moved thumb.
       */
      onChange: import_prop_types10.default.func,
      /**
       * Callback function that is fired when the `mouseup` is triggered.
       *
       * @param {React.SyntheticEvent | Event} event The event source of the callback. **Warning**: This is a generic event not a change event.
       * @param {number | number[]} value The new value.
       */
      onChangeCommitted: import_prop_types10.default.func,
      /**
       * @ignore
       */
      onMouseDown: import_prop_types10.default.func,
      /**
       * The component orientation.
       * @default 'horizontal'
       */
      orientation: import_prop_types10.default.oneOf(["horizontal", "vertical"]),
      /**
       * A transformation function, to change the scale of the slider.
       * @default (x) => x
       */
      scale: import_prop_types10.default.func,
      /**
       * The granularity with which the slider can step through values. (A "discrete" slider.)
       * The `min` prop serves as the origin for the valid values.
       * We recommend (max - min) to be evenly divisible by the step.
       *
       * When step is `null`, the thumb can only be slid onto marks provided with the `marks` prop.
       * @default 1
       */
      step: import_prop_types10.default.number,
      /**
       * Tab index attribute of the hidden `input` element.
       */
      tabIndex: import_prop_types10.default.number,
      /**
       * The track presentation:
       *
       * - `normal` the track will render a bar representing the slider value.
       * - `inverted` the track will render a bar representing the remaining slider value.
       * - `false` the track will render without a bar.
       * @default 'normal'
       */
      track: import_prop_types10.default.oneOf(["inverted", "normal", false]),
      /**
       * The value of the slider.
       * For ranged sliders, provide an array with two values.
       */
      value: import_prop_types10.default.oneOfType([import_prop_types10.default.arrayOf(import_prop_types10.default.number), import_prop_types10.default.number]),
      /**
       * Controls when the value label is displayed:
       *
       * - `auto` the value label will display when the thumb is hovered or focused.
       * - `on` will display persistently.
       * - `off` will never display.
       * @default 'off'
       */
      valueLabelDisplay: import_prop_types10.default.oneOf(["auto", "off", "on"]),
      /**
       * The format function the value label's value.
       *
       * When a function is provided, it should have the following signature:
       *
       * - {number} value The value label's value to format
       * - {number} index The value label's index to format
       * @default (x) => x
       */
      valueLabelFormat: import_prop_types10.default.oneOfType([import_prop_types10.default.func, import_prop_types10.default.string])
    } : void 0;
    SliderUnstyled_default = SliderUnstyled;
  }
});

// node_modules/@mui/base/SliderUnstyled/index.js
var init_SliderUnstyled2 = __esm({
  "node_modules/@mui/base/SliderUnstyled/index.js"() {
    init_SliderUnstyled();
    init_SliderValueLabelUnstyled();
    init_sliderUnstyledClasses();
    init_sliderUnstyledClasses();
  }
});

// node_modules/@mui/base/SwitchUnstyled/useSwitch.js
function useSwitch(props) {
  const {
    checked: checkedProp,
    defaultChecked,
    disabled,
    onBlur,
    onChange,
    onFocus,
    onFocusVisible,
    readOnly,
    required
  } = props;
  const [checked, setCheckedState] = useControlled({
    controlled: checkedProp,
    default: Boolean(defaultChecked),
    name: "Switch",
    state: "checked"
  });
  const handleInputChange = (event, otherHandler) => {
    if (event.nativeEvent.defaultPrevented) {
      return;
    }
    setCheckedState(event.target.checked);
    onChange == null ? void 0 : onChange(event);
    otherHandler == null ? void 0 : otherHandler(event);
  };
  const {
    isFocusVisibleRef,
    onBlur: handleBlurVisible,
    onFocus: handleFocusVisible,
    ref: focusVisibleRef
  } = useIsFocusVisible();
  const [focusVisible, setFocusVisible] = React16.useState(false);
  if (disabled && focusVisible) {
    setFocusVisible(false);
  }
  React16.useEffect(() => {
    isFocusVisibleRef.current = focusVisible;
  }, [focusVisible, isFocusVisibleRef]);
  const inputRef = React16.useRef(null);
  const handleFocus = (event, otherHandler) => {
    if (!inputRef.current) {
      inputRef.current = event.currentTarget;
    }
    handleFocusVisible(event);
    if (isFocusVisibleRef.current === true) {
      setFocusVisible(true);
      onFocusVisible == null ? void 0 : onFocusVisible(event);
    }
    onFocus == null ? void 0 : onFocus(event);
    otherHandler == null ? void 0 : otherHandler(event);
  };
  const handleBlur = (event, otherHandler) => {
    handleBlurVisible(event);
    if (isFocusVisibleRef.current === false) {
      setFocusVisible(false);
    }
    onBlur == null ? void 0 : onBlur(event);
    otherHandler == null ? void 0 : otherHandler(event);
  };
  const handleRefChange = useForkRef(focusVisibleRef, inputRef);
  const getInputProps = (otherProps = {}) => _extends({
    checked: checkedProp,
    defaultChecked,
    disabled,
    readOnly,
    required,
    type: "checkbox"
  }, otherProps, {
    onChange: (event) => handleInputChange(event, otherProps.onChange),
    onFocus: (event) => handleFocus(event, otherProps.onFocus),
    onBlur: (event) => handleBlur(event, otherProps.onBlur),
    ref: handleRefChange
  });
  return {
    checked,
    disabled: Boolean(disabled),
    focusVisible,
    getInputProps,
    readOnly: Boolean(readOnly)
  };
}
var React16;
var init_useSwitch = __esm({
  "node_modules/@mui/base/SwitchUnstyled/useSwitch.js"() {
    init_extends();
    React16 = __toESM(require_react());
    init_esm();
  }
});

// node_modules/@mui/base/SwitchUnstyled/switchUnstyledClasses.js
function getSwitchUnstyledUtilityClass(slot) {
  return generateUtilityClass("MuiSwitch", slot);
}
var switchUnstyledClasses, switchUnstyledClasses_default;
var init_switchUnstyledClasses = __esm({
  "node_modules/@mui/base/SwitchUnstyled/switchUnstyledClasses.js"() {
    init_generateUtilityClass2();
    init_generateUtilityClasses2();
    switchUnstyledClasses = generateUtilityClasses("MuiSwitch", ["root", "input", "track", "thumb", "checked", "disabled", "focusVisible", "readOnly"]);
    switchUnstyledClasses_default = switchUnstyledClasses;
  }
});

// node_modules/@mui/base/SwitchUnstyled/SwitchUnstyled.js
var React17, import_prop_types11, import_jsx_runtime17, import_jsx_runtime18, _excluded8, SwitchUnstyled, SwitchUnstyled_default;
var init_SwitchUnstyled = __esm({
  "node_modules/@mui/base/SwitchUnstyled/SwitchUnstyled.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React17 = __toESM(require_react());
    import_prop_types11 = __toESM(require_prop_types());
    init_clsx_m();
    init_useSwitch();
    init_switchUnstyledClasses();
    init_appendOwnerState();
    import_jsx_runtime17 = __toESM(require_jsx_runtime());
    import_jsx_runtime18 = __toESM(require_jsx_runtime());
    _excluded8 = ["checked", "className", "component", "components", "componentsProps", "defaultChecked", "disabled", "onBlur", "onChange", "onFocus", "onFocusVisible", "readOnly", "required"];
    SwitchUnstyled = React17.forwardRef(function SwitchUnstyled2(props, ref) {
      var _ref, _components$Thumb, _componentsProps$thum, _components$Input, _componentsProps$inpu, _components$Track, _componentsProps$trac;
      const {
        checked: checkedProp,
        className,
        component,
        components = {},
        componentsProps = {},
        defaultChecked,
        disabled: disabledProp,
        onBlur,
        onChange,
        onFocus,
        onFocusVisible,
        readOnly: readOnlyProp
      } = props, otherProps = _objectWithoutPropertiesLoose(props, _excluded8);
      const useSwitchProps = {
        checked: checkedProp,
        defaultChecked,
        disabled: disabledProp,
        onBlur,
        onChange,
        onFocus,
        onFocusVisible,
        readOnly: readOnlyProp
      };
      const {
        getInputProps,
        checked,
        disabled,
        focusVisible,
        readOnly
      } = useSwitch(useSwitchProps);
      const ownerState = _extends({}, props, {
        checked,
        disabled,
        focusVisible,
        readOnly
      });
      const Root = (_ref = component != null ? component : components.Root) != null ? _ref : "span";
      const rootProps = appendOwnerState(Root, _extends({}, otherProps, componentsProps.root), ownerState);
      const Thumb = (_components$Thumb = components.Thumb) != null ? _components$Thumb : "span";
      const thumbProps = appendOwnerState(Thumb, (_componentsProps$thum = componentsProps.thumb) != null ? _componentsProps$thum : {}, ownerState);
      const Input = (_components$Input = components.Input) != null ? _components$Input : "input";
      const inputProps = appendOwnerState(Input, (_componentsProps$inpu = componentsProps.input) != null ? _componentsProps$inpu : {}, ownerState);
      const Track = components.Track === null ? () => null : (_components$Track = components.Track) != null ? _components$Track : "span";
      const trackProps = appendOwnerState(Track, (_componentsProps$trac = componentsProps.track) != null ? _componentsProps$trac : {}, ownerState);
      const stateClasses = clsx_m_default(checked && switchUnstyledClasses_default.checked, disabled && switchUnstyledClasses_default.disabled, focusVisible && switchUnstyledClasses_default.focusVisible, readOnly && switchUnstyledClasses_default.readOnly);
      return (0, import_jsx_runtime18.jsxs)(Root, _extends({
        ref
      }, rootProps, {
        className: clsx_m_default(switchUnstyledClasses_default.root, stateClasses, className, rootProps == null ? void 0 : rootProps.className),
        children: [(0, import_jsx_runtime17.jsx)(Track, _extends({}, trackProps, {
          className: clsx_m_default(switchUnstyledClasses_default.track, trackProps == null ? void 0 : trackProps.className)
        })), (0, import_jsx_runtime17.jsx)(Thumb, _extends({}, thumbProps, {
          className: clsx_m_default(switchUnstyledClasses_default.thumb, thumbProps == null ? void 0 : thumbProps.className)
        })), (0, import_jsx_runtime17.jsx)(Input, _extends({}, getInputProps(inputProps), {
          className: clsx_m_default(switchUnstyledClasses_default.input, inputProps == null ? void 0 : inputProps.className)
        }))]
      }));
    });
    true ? SwitchUnstyled.propTypes = {
      // ----------------------------- Warning --------------------------------
      // | These PropTypes are generated from the TypeScript type definitions |
      // |     To update them edit TypeScript types and run "yarn proptypes"  |
      // ----------------------------------------------------------------------
      /**
       * If `true`, the component is checked.
       */
      checked: import_prop_types11.default.bool,
      /**
       * Class name applied to the root element.
       */
      className: import_prop_types11.default.string,
      /**
       * The component used for the Root slot.
       * Either a string to use a HTML element or a component.
       * This is equivalent to `components.Root`. If both are provided, the `component` is used.
       */
      component: import_prop_types11.default.elementType,
      /**
       * The components used for each slot inside the Switch.
       * Either a string to use a HTML element or a component.
       * @default {}
       */
      components: import_prop_types11.default.shape({
        Input: import_prop_types11.default.elementType,
        Root: import_prop_types11.default.elementType,
        Thumb: import_prop_types11.default.elementType,
        Track: import_prop_types11.default.oneOfType([import_prop_types11.default.elementType, import_prop_types11.default.oneOf([null])])
      }),
      /**
       * The props used for each slot inside the Switch.
       * @default {}
       */
      componentsProps: import_prop_types11.default.object,
      /**
       * The default checked state. Use when the component is not controlled.
       */
      defaultChecked: import_prop_types11.default.bool,
      /**
       * If `true`, the component is disabled.
       */
      disabled: import_prop_types11.default.bool,
      /**
       * @ignore
       */
      onBlur: import_prop_types11.default.func,
      /**
       * Callback fired when the state is changed.
       *
       * @param {React.ChangeEvent<HTMLInputElement>} event The event source of the callback.
       * You can pull out the new value by accessing `event.target.value` (string).
       * You can pull out the new checked state by accessing `event.target.checked` (boolean).
       */
      onChange: import_prop_types11.default.func,
      /**
       * @ignore
       */
      onFocus: import_prop_types11.default.func,
      /**
       * @ignore
       */
      onFocusVisible: import_prop_types11.default.func,
      /**
       * If `true`, the component is read only.
       */
      readOnly: import_prop_types11.default.bool,
      /**
       * If `true`, the `input` element is required.
       */
      required: import_prop_types11.default.bool
    } : void 0;
    SwitchUnstyled_default = SwitchUnstyled;
  }
});

// node_modules/@mui/base/SwitchUnstyled/index.js
var init_SwitchUnstyled2 = __esm({
  "node_modules/@mui/base/SwitchUnstyled/index.js"() {
    init_SwitchUnstyled();
    init_SwitchUnstyled();
    init_useSwitch();
    init_useSwitch();
    init_switchUnstyledClasses();
    init_switchUnstyledClasses();
  }
});

// node_modules/@mui/base/TabPanelUnstyled/tabPanelUnstyledClasses.js
function getTabPanelUnstyledUtilityClass(slot) {
  return generateUtilityClass("TabPanelUnstyled", slot);
}
var tabPanelUnstyledClasses, tabPanelUnstyledClasses_default;
var init_tabPanelUnstyledClasses = __esm({
  "node_modules/@mui/base/TabPanelUnstyled/tabPanelUnstyledClasses.js"() {
    init_generateUtilityClass2();
    init_generateUtilityClasses2();
    tabPanelUnstyledClasses = generateUtilityClasses("TabPanelUnstyled", ["root", "hidden"]);
    tabPanelUnstyledClasses_default = tabPanelUnstyledClasses;
  }
});

// node_modules/@mui/base/TabsUnstyled/tabsUnstyledClasses.js
function getTabsUnstyledUtilityClass(slot) {
  return generateUtilityClass("TabsUnstyled", slot);
}
var tabsUnstyledClasses, tabsUnstyledClasses_default;
var init_tabsUnstyledClasses = __esm({
  "node_modules/@mui/base/TabsUnstyled/tabsUnstyledClasses.js"() {
    init_generateUtilityClass2();
    init_generateUtilityClasses2();
    tabsUnstyledClasses = generateUtilityClasses("TabsUnstyled", ["root", "horizontal", "vertical"]);
    tabsUnstyledClasses_default = tabsUnstyledClasses;
  }
});

// node_modules/@mui/base/TabsUnstyled/useTabs.js
var React18, useTabs, useTabs_default;
var init_useTabs = __esm({
  "node_modules/@mui/base/TabsUnstyled/useTabs.js"() {
    React18 = __toESM(require_react());
    init_esm();
    useTabs = (props) => {
      const {
        value: valueProp,
        defaultValue,
        onChange,
        orientation,
        direction,
        selectionFollowsFocus
      } = props;
      const [value, setValue] = useControlled({
        controlled: valueProp,
        default: defaultValue,
        name: "Tabs",
        state: "value"
      });
      const idPrefix = useId();
      const onSelected = React18.useCallback((e, newValue) => {
        setValue(newValue);
        if (onChange) {
          onChange(e, newValue);
        }
      }, [onChange, setValue]);
      const getRootProps = () => {
        return {};
      };
      const tabsContextValue = React18.useMemo(() => {
        return {
          idPrefix,
          value,
          onSelected,
          orientation,
          direction,
          selectionFollowsFocus
        };
      }, [idPrefix, value, onSelected, orientation, direction, selectionFollowsFocus]);
      return {
        getRootProps,
        tabsContextValue
      };
    };
    useTabs_default = useTabs;
  }
});

// node_modules/@mui/base/TabsUnstyled/TabsContext.js
function useTabContext() {
  return React19.useContext(Context);
}
function getPanelId(context, value) {
  const {
    idPrefix
  } = context;
  if (idPrefix === null) {
    return null;
  }
  return `${context.idPrefix}-P-${value}`;
}
function getTabId(context, value) {
  const {
    idPrefix
  } = context;
  if (idPrefix === null) {
    return null;
  }
  return `${context.idPrefix}-T-${value}`;
}
var React19, Context, TabsContext_default;
var init_TabsContext = __esm({
  "node_modules/@mui/base/TabsUnstyled/TabsContext.js"() {
    React19 = __toESM(require_react());
    Context = React19.createContext(null);
    if (true) {
      Context.displayName = "TabsContext";
    }
    TabsContext_default = Context;
  }
});

// node_modules/@mui/base/TabsUnstyled/TabsUnstyled.js
var React20, import_prop_types12, import_jsx_runtime19, _excluded9, useUtilityClasses6, TabsUnstyled, TabsUnstyled_default;
var init_TabsUnstyled = __esm({
  "node_modules/@mui/base/TabsUnstyled/TabsUnstyled.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React20 = __toESM(require_react());
    import_prop_types12 = __toESM(require_prop_types());
    init_clsx_m();
    init_utils();
    init_composeClasses2();
    init_tabsUnstyledClasses();
    init_useTabs();
    init_TabsContext();
    import_jsx_runtime19 = __toESM(require_jsx_runtime());
    _excluded9 = ["children", "className", "value", "defaultValue", "orientation", "direction", "component", "components", "componentsProps", "onChange", "selectionFollowsFocus"];
    useUtilityClasses6 = (ownerState) => {
      const {
        orientation
      } = ownerState;
      const slots = {
        root: ["root", orientation]
      };
      return composeClasses(slots, getTabsUnstyledUtilityClass, {});
    };
    TabsUnstyled = React20.forwardRef((props, ref) => {
      var _ref, _componentsProps$root;
      const {
        children,
        className,
        orientation = "horizontal",
        direction = "ltr",
        component,
        components = {},
        componentsProps = {}
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded9);
      const {
        tabsContextValue,
        getRootProps
      } = useTabs_default(props);
      const ownerState = _extends({}, props, {
        orientation,
        direction
      });
      const classes = useUtilityClasses6(ownerState);
      const TabsRoot = (_ref = component != null ? component : components.Root) != null ? _ref : "div";
      const tabsRootProps = appendOwnerState(TabsRoot, _extends({}, other, componentsProps.root), ownerState);
      return (0, import_jsx_runtime19.jsx)(TabsRoot, _extends({}, getRootProps(), tabsRootProps, {
        ref,
        className: clsx_m_default(classes.root, (_componentsProps$root = componentsProps.root) == null ? void 0 : _componentsProps$root.className, className),
        children: (0, import_jsx_runtime19.jsx)(TabsContext_default.Provider, {
          value: tabsContextValue,
          children
        })
      }));
    });
    true ? TabsUnstyled.propTypes = {
      // ----------------------------- Warning --------------------------------
      // | These PropTypes are generated from the TypeScript type definitions |
      // |     To update them edit TypeScript types and run "yarn proptypes"  |
      // ----------------------------------------------------------------------
      /**
       * The content of the component.
       */
      children: import_prop_types12.default.node,
      /**
       * @ignore
       */
      className: import_prop_types12.default.string,
      /**
       * The component used for the root node.
       * Either a string to use a HTML element or a component.
       */
      component: import_prop_types12.default.elementType,
      /**
       * The components used for each slot inside the Tabs.
       * Either a string to use a HTML element or a component.
       * @default {}
       */
      components: import_prop_types12.default.shape({
        Root: import_prop_types12.default.elementType
      }),
      /**
       * The props used for each slot inside the Tabs.
       * @default {}
       */
      componentsProps: import_prop_types12.default.object,
      /**
       * The default value. Use when the component is not controlled.
       */
      defaultValue: import_prop_types12.default.oneOfType([import_prop_types12.default.oneOf([false]), import_prop_types12.default.number, import_prop_types12.default.string]),
      /**
       * The direction of the text.
       * @default 'ltr'
       */
      direction: import_prop_types12.default.oneOf(["ltr", "rtl"]),
      /**
       * Callback invoked when new value is being set.
       */
      onChange: import_prop_types12.default.func,
      /**
       * The component orientation (layout flow direction).
       * @default 'horizontal'
       */
      orientation: import_prop_types12.default.oneOf(["horizontal", "vertical"]),
      /**
       * If `true` the selected tab changes on focus. Otherwise it only
       * changes on activation.
       */
      selectionFollowsFocus: import_prop_types12.default.bool,
      /**
       * The value of the currently selected `Tab`.
       * If you don't want any selected `Tab`, you can set this prop to `false`.
       */
      value: import_prop_types12.default.oneOfType([import_prop_types12.default.oneOf([false]), import_prop_types12.default.number, import_prop_types12.default.string])
    } : void 0;
    TabsUnstyled_default = TabsUnstyled;
  }
});

// node_modules/@mui/base/TabsUnstyled/index.js
var init_TabsUnstyled2 = __esm({
  "node_modules/@mui/base/TabsUnstyled/index.js"() {
    init_TabsUnstyled();
    init_TabsContext();
    init_TabsContext();
    init_tabsUnstyledClasses();
    init_tabsUnstyledClasses();
    init_useTabs();
    init_useTabs();
  }
});

// node_modules/@mui/base/TabPanelUnstyled/useTabPanel.js
var useTabPanel, useTabPanel_default;
var init_useTabPanel = __esm({
  "node_modules/@mui/base/TabPanelUnstyled/useTabPanel.js"() {
    init_TabsUnstyled2();
    useTabPanel = (props) => {
      const {
        value
      } = props;
      const context = useTabContext();
      if (context === null) {
        throw new Error("No TabContext provided");
      }
      const hidden = value !== context.value;
      const id = getPanelId(context, value);
      const tabId = getTabId(context, value);
      const getRootProps = () => {
        return {
          "aria-labelledby": tabId,
          hidden,
          id
        };
      };
      return {
        hidden,
        getRootProps
      };
    };
    useTabPanel_default = useTabPanel;
  }
});

// node_modules/@mui/base/TabPanelUnstyled/TabPanelUnstyled.js
var React21, import_prop_types13, import_jsx_runtime20, _excluded10, useUtilityClasses7, TabPanelUnstyled, TabPanelUnstyled_default;
var init_TabPanelUnstyled = __esm({
  "node_modules/@mui/base/TabPanelUnstyled/TabPanelUnstyled.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React21 = __toESM(require_react());
    import_prop_types13 = __toESM(require_prop_types());
    init_clsx_m();
    init_utils();
    init_composeClasses2();
    init_tabPanelUnstyledClasses();
    init_useTabPanel();
    import_jsx_runtime20 = __toESM(require_jsx_runtime());
    _excluded10 = ["children", "className", "value", "components", "componentsProps", "component"];
    useUtilityClasses7 = (ownerState) => {
      const {
        hidden
      } = ownerState;
      const slots = {
        root: ["root", hidden && "hidden"]
      };
      return composeClasses(slots, getTabPanelUnstyledUtilityClass, {});
    };
    TabPanelUnstyled = React21.forwardRef(function TabPanelUnstyled2(props, ref) {
      var _ref, _componentsProps$root;
      const {
        children,
        className,
        components = {},
        componentsProps = {},
        component
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded10);
      const {
        hidden,
        getRootProps
      } = useTabPanel_default(props);
      const ownerState = _extends({}, props, {
        hidden
      });
      const classes = useUtilityClasses7(ownerState);
      const TabPanelRoot = (_ref = component != null ? component : components.Root) != null ? _ref : "div";
      const tabPanelRootProps = appendOwnerState(TabPanelRoot, _extends({}, other, componentsProps.root), ownerState);
      return (0, import_jsx_runtime20.jsx)(TabPanelRoot, _extends({}, getRootProps(), {
        ref,
        role: "tabpanel"
      }, tabPanelRootProps, {
        className: clsx_m_default(classes.root, (_componentsProps$root = componentsProps.root) == null ? void 0 : _componentsProps$root.className, className),
        children: !hidden && children
      }));
    });
    true ? TabPanelUnstyled.propTypes = {
      // ----------------------------- Warning --------------------------------
      // | These PropTypes are generated from the TypeScript type definitions |
      // |     To update them edit TypeScript types and run "yarn proptypes"  |
      // ----------------------------------------------------------------------
      /**
       * The content of the component.
       */
      children: import_prop_types13.default.node,
      /**
       * @ignore
       */
      className: import_prop_types13.default.string,
      /**
       * The component used for the root node.
       * Either a string to use a HTML element or a component.
       */
      component: import_prop_types13.default.elementType,
      /**
       * The components used for each slot inside the TabPanel.
       * Either a string to use a HTML element or a component.
       * @default {}
       */
      components: import_prop_types13.default.shape({
        Root: import_prop_types13.default.elementType
      }),
      /**
       * The props used for each slot inside the TabPanel.
       * @default {}
       */
      componentsProps: import_prop_types13.default.object,
      /**
       * The value of the TabPanel. It will be shown when the Tab with the corresponding value is selected.
       */
      value: import_prop_types13.default.oneOfType([import_prop_types13.default.number, import_prop_types13.default.string]).isRequired
    } : void 0;
    TabPanelUnstyled_default = TabPanelUnstyled;
  }
});

// node_modules/@mui/base/TabPanelUnstyled/index.js
var init_TabPanelUnstyled2 = __esm({
  "node_modules/@mui/base/TabPanelUnstyled/index.js"() {
    init_TabPanelUnstyled();
    init_tabPanelUnstyledClasses();
    init_tabPanelUnstyledClasses();
    init_useTabPanel();
    init_useTabPanel();
  }
});

// node_modules/@mui/base/TabsListUnstyled/tabsListUnstyledClasses.js
function getTabsListUnstyledUtilityClass(slot) {
  return generateUtilityClass("TabsListUnstyled", slot);
}
var tabsListUnstyledClasses, tabsListUnstyledClasses_default;
var init_tabsListUnstyledClasses = __esm({
  "node_modules/@mui/base/TabsListUnstyled/tabsListUnstyledClasses.js"() {
    init_generateUtilityClass2();
    init_generateUtilityClasses2();
    tabsListUnstyledClasses = generateUtilityClasses("TabsListUnstyled", ["root", "horizontal", "vertical"]);
    tabsListUnstyledClasses_default = tabsListUnstyledClasses;
  }
});

// node_modules/@mui/base/TabsListUnstyled/useTabsList.js
var React22, import_react_is, nextItem, previousItem, moveFocus, useTabsList, useTabsList_default;
var init_useTabsList = __esm({
  "node_modules/@mui/base/TabsListUnstyled/useTabsList.js"() {
    init_extends();
    React22 = __toESM(require_react());
    init_esm();
    import_react_is = __toESM(require_react_is());
    init_TabsUnstyled2();
    init_extractEventHandlers();
    nextItem = (list, item) => {
      if (!list) {
        return null;
      }
      if (list === item) {
        return list.firstChild;
      }
      if (item && item.nextElementSibling) {
        return item.nextElementSibling;
      }
      return list.firstChild;
    };
    previousItem = (list, item) => {
      if (!list) {
        return null;
      }
      if (list === item) {
        return list.lastChild;
      }
      if (item && item.previousElementSibling) {
        return item.previousElementSibling;
      }
      return list.lastChild;
    };
    moveFocus = (list, currentFocus, traversalFunction) => {
      let wrappedOnce = false;
      let nextFocus = traversalFunction(list, currentFocus);
      while (list && nextFocus) {
        if (nextFocus === list.firstChild) {
          if (wrappedOnce) {
            return;
          }
          wrappedOnce = true;
        }
        const nextFocusDisabled = nextFocus.disabled || nextFocus.getAttribute("aria-disabled") === "true";
        if (!nextFocus.hasAttribute("tabindex") || nextFocusDisabled) {
          nextFocus = traversalFunction(list, nextFocus);
        } else {
          nextFocus.focus();
          return;
        }
      }
    };
    useTabsList = (props) => {
      const {
        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabelledBy,
        children,
        ref
      } = props;
      const tabsListRef = React22.createRef();
      const handleRef = useForkRef(tabsListRef, ref);
      const context = useTabContext();
      if (context === null) {
        throw new Error("No TabContext provided");
      }
      const {
        value,
        orientation = "horizontal",
        direction = "ltr"
      } = context;
      const isRtl = direction === "rtl";
      const handleKeyDown = (event) => {
        const list = tabsListRef.current;
        const currentFocus = ownerDocument(list).activeElement;
        const role = currentFocus == null ? void 0 : currentFocus.getAttribute("role");
        if (role !== "tab") {
          return;
        }
        let previousItemKey = orientation === "horizontal" ? "ArrowLeft" : "ArrowUp";
        let nextItemKey = orientation === "horizontal" ? "ArrowRight" : "ArrowDown";
        if (orientation === "horizontal" && isRtl) {
          previousItemKey = "ArrowRight";
          nextItemKey = "ArrowLeft";
        }
        switch (event.key) {
          case previousItemKey:
            event.preventDefault();
            moveFocus(list, currentFocus, previousItem);
            break;
          case nextItemKey:
            event.preventDefault();
            moveFocus(list, currentFocus, nextItem);
            break;
          case "Home":
            event.preventDefault();
            moveFocus(list, null, nextItem);
            break;
          case "End":
            event.preventDefault();
            moveFocus(list, null, previousItem);
            break;
          default:
            break;
        }
      };
      const createHandleKeyDown = (otherHandlers) => (event) => {
        var _otherHandlers$onKeyD;
        handleKeyDown(event);
        (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null ? void 0 : _otherHandlers$onKeyD.call(otherHandlers, event);
      };
      const getRootProps = (otherHandlers) => {
        const propsEventHandlers = extractEventHandlers(props);
        const externalEventHandlers = _extends({}, propsEventHandlers, otherHandlers);
        const ownEventHandlers = {
          onKeyDown: createHandleKeyDown(externalEventHandlers)
        };
        const mergedEventHandlers = _extends({}, externalEventHandlers, ownEventHandlers);
        return _extends({
          "aria-label": ariaLabel,
          "aria-labelledby": ariaLabelledBy,
          "aria-orientation": orientation === "vertical" ? "vertical" : null,
          role: "tablist",
          ref: handleRef
        }, mergedEventHandlers);
      };
      const processChildren = React22.useCallback(() => {
        const valueToIndex = /* @__PURE__ */ new Map();
        let childIndex = 0;
        const processedChildren = React22.Children.map(children, (child) => {
          if (!React22.isValidElement(child)) {
            return null;
          }
          if (true) {
            if ((0, import_react_is.isFragment)(child)) {
              console.error(["MUI: The Tabs component doesn't accept a Fragment as a child.", "Consider providing an array instead."].join("\n"));
            }
          }
          const childValue = child.props.value === void 0 ? childIndex : child.props.value;
          valueToIndex.set(childValue, childIndex);
          childIndex += 1;
          return React22.cloneElement(child, _extends({
            value: childValue
          }, childIndex === 1 && value === false && !child.props.tabIndex || value === childValue ? {
            tabIndex: 0
          } : {
            tabIndex: -1
          }));
        });
        return processedChildren;
      }, [children, value]);
      return {
        isRtl,
        orientation,
        value,
        processChildren,
        getRootProps
      };
    };
    useTabsList_default = useTabsList;
  }
});

// node_modules/@mui/base/TabsListUnstyled/TabsListUnstyled.js
var React23, import_prop_types14, import_jsx_runtime21, _excluded11, useUtilityClasses8, TabsListUnstyled, TabsListUnstyled_default;
var init_TabsListUnstyled = __esm({
  "node_modules/@mui/base/TabsListUnstyled/TabsListUnstyled.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React23 = __toESM(require_react());
    import_prop_types14 = __toESM(require_prop_types());
    init_clsx_m();
    init_composeClasses2();
    init_utils();
    init_tabsListUnstyledClasses();
    init_useTabsList();
    import_jsx_runtime21 = __toESM(require_jsx_runtime());
    _excluded11 = ["className", "children", "component", "components", "componentsProps"];
    useUtilityClasses8 = (ownerState) => {
      const {
        orientation
      } = ownerState;
      const slots = {
        root: ["root", orientation]
      };
      return composeClasses(slots, getTabsListUnstyledUtilityClass, {});
    };
    TabsListUnstyled = React23.forwardRef((props, ref) => {
      var _ref, _componentsProps$root;
      const {
        className,
        component,
        components = {},
        componentsProps = {}
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded11);
      const {
        isRtl,
        orientation,
        getRootProps,
        processChildren
      } = useTabsList_default(_extends({}, props, {
        ref
      }));
      const ownerState = _extends({}, props, {
        isRtl,
        orientation
      });
      const classes = useUtilityClasses8(ownerState);
      const TabsListRoot = (_ref = component != null ? component : components.Root) != null ? _ref : "div";
      const tabsListRootProps = appendOwnerState(TabsListRoot, _extends({}, other, componentsProps.root), ownerState);
      const processedChildren = processChildren();
      return (0, import_jsx_runtime21.jsx)(TabsListRoot, _extends({}, getRootProps(), tabsListRootProps, {
        className: clsx_m_default(className, (_componentsProps$root = componentsProps.root) == null ? void 0 : _componentsProps$root.className, classes.root),
        children: processedChildren
      }));
    });
    true ? TabsListUnstyled.propTypes = {
      // ----------------------------- Warning --------------------------------
      // | These PropTypes are generated from the TypeScript type definitions |
      // |     To update them edit TypeScript types and run "yarn proptypes"  |
      // ----------------------------------------------------------------------
      /**
       * The content of the component.
       */
      children: import_prop_types14.default.node,
      /**
       * @ignore
       */
      className: import_prop_types14.default.string,
      /**
       * The component used for the root node.
       * Either a string to use a HTML element or a component.
       */
      component: import_prop_types14.default.elementType,
      /**
       * The components used for each slot inside the TabsList.
       * Either a string to use a HTML element or a component.
       * @default {}
       */
      components: import_prop_types14.default.shape({
        Root: import_prop_types14.default.elementType
      }),
      /**
       * The props used for each slot inside the TabsList.
       * @default {}
       */
      componentsProps: import_prop_types14.default.object
    } : void 0;
    TabsListUnstyled_default = TabsListUnstyled;
  }
});

// node_modules/@mui/base/TabsListUnstyled/index.js
var init_TabsListUnstyled2 = __esm({
  "node_modules/@mui/base/TabsListUnstyled/index.js"() {
    init_TabsListUnstyled();
    init_tabsListUnstyledClasses();
    init_tabsListUnstyledClasses();
    init_useTabsList();
    init_useTabsList();
  }
});

// node_modules/@mui/base/TabUnstyled/tabUnstyledClasses.js
function getTabUnstyledUtilityClass(slot) {
  return generateUtilityClass("TabUnstyled", slot);
}
var tabUnstyledClasses, tabUnstyledClasses_default;
var init_tabUnstyledClasses = __esm({
  "node_modules/@mui/base/TabUnstyled/tabUnstyledClasses.js"() {
    init_generateUtilityClass2();
    init_generateUtilityClasses2();
    tabUnstyledClasses = generateUtilityClasses("TabUnstyled", ["root", "selected", "disabled"]);
    tabUnstyledClasses_default = tabUnstyledClasses;
  }
});

// node_modules/@mui/base/TabUnstyled/useTab.js
var _excluded12, useTab, useTab_default;
var init_useTab = __esm({
  "node_modules/@mui/base/TabUnstyled/useTab.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_TabsUnstyled2();
    init_ButtonUnstyled2();
    _excluded12 = ["getRootProps"];
    useTab = (props) => {
      const {
        value: valueProp,
        onChange,
        onClick,
        onFocus
      } = props;
      const _useButton = useButton(props), {
        getRootProps: getRootPropsButton
      } = _useButton, otherButtonProps = _objectWithoutPropertiesLoose(_useButton, _excluded12);
      const context = useTabContext();
      if (context === null) {
        throw new Error("No TabContext provided");
      }
      const value = valueProp != null ? valueProp : 0;
      const selected = context.value === value;
      const selectionFollowsFocus = context.selectionFollowsFocus;
      const a11yAttributes = {
        role: "tab",
        "aria-controls": getPanelId(context, value),
        id: getTabId(context, value),
        "aria-selected": selected,
        disabled: otherButtonProps.disabled
      };
      const handleFocus = (event) => {
        if (selectionFollowsFocus && !selected) {
          if (onChange) {
            onChange(event, value);
          }
          context.onSelected(event, value);
        }
        if (onFocus) {
          onFocus(event);
        }
      };
      const handleClick = (event) => {
        if (!selected) {
          if (onChange) {
            onChange(event, value);
          }
          context.onSelected(event, value);
        }
        if (onClick) {
          onClick(event);
        }
      };
      const getRootProps = (otherHandlers) => {
        const buttonResolvedProps = getRootPropsButton(_extends({
          onClick: handleClick,
          onFocus: handleFocus
        }, otherHandlers));
        return _extends({}, buttonResolvedProps, a11yAttributes);
      };
      return _extends({
        getRootProps
      }, otherButtonProps, {
        selected
      });
    };
    useTab_default = useTab;
  }
});

// node_modules/@mui/base/TabUnstyled/TabUnstyled.js
var React24, import_prop_types15, import_jsx_runtime22, _excluded13, useUtilityClasses9, TabUnstyled, TabUnstyled_default;
var init_TabUnstyled = __esm({
  "node_modules/@mui/base/TabUnstyled/TabUnstyled.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React24 = __toESM(require_react());
    import_prop_types15 = __toESM(require_prop_types());
    init_clsx_m();
    init_esm();
    init_composeClasses2();
    init_appendOwnerState();
    init_tabUnstyledClasses();
    init_useTab();
    import_jsx_runtime22 = __toESM(require_jsx_runtime());
    _excluded13 = ["action", "children", "value", "className", "disabled", "onChange", "onClick", "onFocus", "component", "components", "componentsProps"];
    useUtilityClasses9 = (ownerState) => {
      const {
        selected,
        disabled
      } = ownerState;
      const slots = {
        root: ["root", selected && "selected", disabled && "disabled"]
      };
      return composeClasses(slots, getTabUnstyledUtilityClass, {});
    };
    TabUnstyled = React24.forwardRef(function TabUnstyled2(props, ref) {
      var _ref, _componentsProps$root;
      const {
        action,
        children,
        className,
        disabled = false,
        component,
        components = {},
        componentsProps = {}
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded13);
      const tabRef = React24.useRef();
      const handleRef = useForkRef(tabRef, ref);
      const {
        active,
        focusVisible,
        setFocusVisible,
        selected,
        getRootProps
      } = useTab_default(_extends({}, props, {
        ref: handleRef
      }));
      React24.useImperativeHandle(action, () => ({
        focusVisible: () => {
          setFocusVisible(true);
          tabRef.current.focus();
        }
      }), [setFocusVisible]);
      const ownerState = _extends({}, props, {
        active,
        focusVisible,
        disabled,
        selected
      });
      const classes = useUtilityClasses9(ownerState);
      const TabRoot = (_ref = component != null ? component : components.Root) != null ? _ref : "button";
      const tabRootProps = appendOwnerState(TabRoot, _extends({}, other, componentsProps.root), ownerState);
      return (0, import_jsx_runtime22.jsx)(TabRoot, _extends({}, getRootProps(), tabRootProps, {
        className: clsx_m_default(classes.root, (_componentsProps$root = componentsProps.root) == null ? void 0 : _componentsProps$root.className, className),
        ref,
        children
      }));
    });
    true ? TabUnstyled.propTypes = {
      // ----------------------------- Warning --------------------------------
      // | These PropTypes are generated from the TypeScript type definitions |
      // |     To update them edit TypeScript types and run "yarn proptypes"  |
      // ----------------------------------------------------------------------
      /**
       * A ref for imperative actions. It currently only supports `focusVisible()` action.
       */
      action: import_prop_types15.default.oneOfType([import_prop_types15.default.func, import_prop_types15.default.shape({
        current: import_prop_types15.default.shape({
          focusVisible: import_prop_types15.default.func.isRequired
        })
      })]),
      /**
       * @ignore
       */
      children: import_prop_types15.default.node,
      /**
       * @ignore
       */
      className: import_prop_types15.default.string,
      /**
       * The component used for the root node.
       * Either a string to use a HTML element or a component.
       */
      component: import_prop_types15.default.elementType,
      /**
       * The components used for each slot inside the Tab.
       * Either a string to use a HTML element or a component.
       * @default {}
       */
      components: import_prop_types15.default.shape({
        Root: import_prop_types15.default.elementType
      }),
      /**
       * The props used for each slot inside the Tab.
       * @default {}
       */
      componentsProps: import_prop_types15.default.object,
      /**
       * If `true`, the component is disabled.
       * @default false
       */
      disabled: import_prop_types15.default.bool,
      /**
       * Callback invoked when new value is being set.
       */
      onChange: import_prop_types15.default.func,
      /**
       * @ignore
       */
      onClick: import_prop_types15.default.func,
      /**
       * @ignore
       */
      onFocus: import_prop_types15.default.func,
      /**
       * You can provide your own value. Otherwise, we fall back to the child position index.
       */
      value: import_prop_types15.default.oneOfType([import_prop_types15.default.number, import_prop_types15.default.string])
    } : void 0;
    TabUnstyled_default = TabUnstyled;
  }
});

// node_modules/@mui/base/TabUnstyled/index.js
var init_TabUnstyled2 = __esm({
  "node_modules/@mui/base/TabUnstyled/index.js"() {
    init_TabUnstyled();
    init_tabUnstyledClasses();
    init_tabUnstyledClasses();
    init_useTab();
    init_useTab();
  }
});

// node_modules/@mui/base/TextareaAutosize/TextareaAutosize.js
function getStyleValue(computedStyle, property) {
  return parseInt(computedStyle[property], 10) || 0;
}
var React25, import_prop_types16, import_jsx_runtime23, import_jsx_runtime24, _excluded14, styles, TextareaAutosize, TextareaAutosize_default;
var init_TextareaAutosize = __esm({
  "node_modules/@mui/base/TextareaAutosize/TextareaAutosize.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    React25 = __toESM(require_react());
    import_prop_types16 = __toESM(require_prop_types());
    init_esm();
    import_jsx_runtime23 = __toESM(require_jsx_runtime());
    import_jsx_runtime24 = __toESM(require_jsx_runtime());
    _excluded14 = ["onChange", "maxRows", "minRows", "style", "value"];
    styles = {
      shadow: {
        // Visibility needed to hide the extra text area on iPads
        visibility: "hidden",
        // Remove from the content flow
        position: "absolute",
        // Ignore the scrollbar width
        overflow: "hidden",
        height: 0,
        top: 0,
        left: 0,
        // Create a new layer, increase the isolation of the computed values
        transform: "translateZ(0)"
      }
    };
    TextareaAutosize = React25.forwardRef(function TextareaAutosize2(props, ref) {
      const {
        onChange,
        maxRows,
        minRows = 1,
        style,
        value
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded14);
      const {
        current: isControlled
      } = React25.useRef(value != null);
      const inputRef = React25.useRef(null);
      const handleRef = useForkRef(ref, inputRef);
      const shadowRef = React25.useRef(null);
      const renders = React25.useRef(0);
      const [state, setState] = React25.useState({});
      const syncHeight = React25.useCallback(() => {
        const input = inputRef.current;
        const containerWindow = ownerWindow(input);
        const computedStyle = containerWindow.getComputedStyle(input);
        if (computedStyle.width === "0px") {
          return;
        }
        const inputShallow = shadowRef.current;
        inputShallow.style.width = computedStyle.width;
        inputShallow.value = input.value || props.placeholder || "x";
        if (inputShallow.value.slice(-1) === "\n") {
          inputShallow.value += " ";
        }
        const boxSizing = computedStyle["box-sizing"];
        const padding = getStyleValue(computedStyle, "padding-bottom") + getStyleValue(computedStyle, "padding-top");
        const border = getStyleValue(computedStyle, "border-bottom-width") + getStyleValue(computedStyle, "border-top-width");
        const innerHeight = inputShallow.scrollHeight;
        inputShallow.value = "x";
        const singleRowHeight = inputShallow.scrollHeight;
        let outerHeight = innerHeight;
        if (minRows) {
          outerHeight = Math.max(Number(minRows) * singleRowHeight, outerHeight);
        }
        if (maxRows) {
          outerHeight = Math.min(Number(maxRows) * singleRowHeight, outerHeight);
        }
        outerHeight = Math.max(outerHeight, singleRowHeight);
        const outerHeightStyle = outerHeight + (boxSizing === "border-box" ? padding + border : 0);
        const overflow = Math.abs(outerHeight - innerHeight) <= 1;
        setState((prevState) => {
          if (renders.current < 20 && (outerHeightStyle > 0 && Math.abs((prevState.outerHeightStyle || 0) - outerHeightStyle) > 1 || prevState.overflow !== overflow)) {
            renders.current += 1;
            return {
              overflow,
              outerHeightStyle
            };
          }
          if (true) {
            if (renders.current === 20) {
              console.error(["MUI: Too many re-renders. The layout is unstable.", "TextareaAutosize limits the number of renders to prevent an infinite loop."].join("\n"));
            }
          }
          return prevState;
        });
      }, [maxRows, minRows, props.placeholder]);
      React25.useEffect(() => {
        const handleResize = debounce(() => {
          renders.current = 0;
          syncHeight();
        });
        const containerWindow = ownerWindow(inputRef.current);
        containerWindow.addEventListener("resize", handleResize);
        let resizeObserver;
        if (typeof ResizeObserver !== "undefined") {
          resizeObserver = new ResizeObserver(handleResize);
          resizeObserver.observe(inputRef.current);
        }
        return () => {
          handleResize.clear();
          containerWindow.removeEventListener("resize", handleResize);
          if (resizeObserver) {
            resizeObserver.disconnect();
          }
        };
      }, [syncHeight]);
      useEnhancedEffect_default(() => {
        syncHeight();
      });
      React25.useEffect(() => {
        renders.current = 0;
      }, [value]);
      const handleChange = (event) => {
        renders.current = 0;
        if (!isControlled) {
          syncHeight();
        }
        if (onChange) {
          onChange(event);
        }
      };
      return (0, import_jsx_runtime24.jsxs)(React25.Fragment, {
        children: [(0, import_jsx_runtime23.jsx)("textarea", _extends({
          value,
          onChange: handleChange,
          ref: handleRef,
          rows: minRows,
          style: _extends({
            height: state.outerHeightStyle,
            // Need a large enough difference to allow scrolling.
            // This prevents infinite rendering loop.
            overflow: state.overflow ? "hidden" : null
          }, style)
        }, other)), (0, import_jsx_runtime23.jsx)("textarea", {
          "aria-hidden": true,
          className: props.className,
          readOnly: true,
          ref: shadowRef,
          tabIndex: -1,
          style: _extends({}, styles.shadow, style, {
            padding: 0
          })
        })]
      });
    });
    true ? TextareaAutosize.propTypes = {
      // ----------------------------- Warning --------------------------------
      // | These PropTypes are generated from the TypeScript type definitions |
      // |     To update them edit the d.ts file and run "yarn proptypes"     |
      // ----------------------------------------------------------------------
      /**
       * @ignore
       */
      className: import_prop_types16.default.string,
      /**
       * Maximum number of rows to display.
       */
      maxRows: import_prop_types16.default.oneOfType([import_prop_types16.default.number, import_prop_types16.default.string]),
      /**
       * Minimum number of rows to display.
       * @default 1
       */
      minRows: import_prop_types16.default.oneOfType([import_prop_types16.default.number, import_prop_types16.default.string]),
      /**
       * @ignore
       */
      onChange: import_prop_types16.default.func,
      /**
       * @ignore
       */
      placeholder: import_prop_types16.default.string,
      /**
       * @ignore
       */
      style: import_prop_types16.default.object,
      /**
       * @ignore
       */
      value: import_prop_types16.default.oneOfType([import_prop_types16.default.arrayOf(import_prop_types16.default.string), import_prop_types16.default.number, import_prop_types16.default.string])
    } : void 0;
    TextareaAutosize_default = TextareaAutosize;
  }
});

// node_modules/@mui/base/TextareaAutosize/index.js
var init_TextareaAutosize2 = __esm({
  "node_modules/@mui/base/TextareaAutosize/index.js"() {
    init_TextareaAutosize();
  }
});

// node_modules/@mui/base/index.js
var init_base = __esm({
  "node_modules/@mui/base/index.js"() {
    init_utils();
    init_AutocompleteUnstyled();
    init_BackdropUnstyled2();
    init_BackdropUnstyled2();
    init_BadgeUnstyled2();
    init_BadgeUnstyled2();
    init_ButtonUnstyled2();
    init_ButtonUnstyled2();
    init_ClickAwayListener();
    init_composeClasses2();
    init_generateUtilityClass2();
    init_generateUtilityClass2();
    init_generateUtilityClasses2();
    init_FormControlUnstyled2();
    init_FormControlUnstyled2();
    init_InputUnstyled2();
    init_InputUnstyled2();
    init_ModalUnstyled2();
    init_ModalUnstyled2();
    init_NoSsr2();
    init_PopperUnstyled();
    init_Portal();
    init_SliderUnstyled2();
    init_SliderUnstyled2();
    init_SwitchUnstyled2();
    init_SwitchUnstyled2();
    init_TabPanelUnstyled2();
    init_TabPanelUnstyled2();
    init_TabsListUnstyled2();
    init_TabsListUnstyled2();
    init_TabsUnstyled2();
    init_TabsUnstyled2();
    init_TabUnstyled2();
    init_TabUnstyled2();
    init_TextareaAutosize2();
    init_Unstable_TrapFocus2();
  }
});

// node_modules/@mui/material/styles/createTransitions.js
function formatMs(milliseconds) {
  return `${Math.round(milliseconds)}ms`;
}
function getAutoHeightDuration(height) {
  if (!height) {
    return 0;
  }
  const constant = height / 36;
  return Math.round((4 + 15 * constant ** 0.25 + constant / 5) * 10);
}
function createTransitions(inputTransitions) {
  const mergedEasing = _extends({}, easing, inputTransitions.easing);
  const mergedDuration = _extends({}, duration, inputTransitions.duration);
  const create = (props = ["all"], options = {}) => {
    const {
      duration: durationOption = mergedDuration.standard,
      easing: easingOption = mergedEasing.easeInOut,
      delay = 0
    } = options, other = _objectWithoutPropertiesLoose(options, _excluded15);
    if (true) {
      const isString = (value) => typeof value === "string";
      const isNumber = (value) => !isNaN(parseFloat(value));
      if (!isString(props) && !Array.isArray(props)) {
        console.error('MUI: Argument "props" must be a string or Array.');
      }
      if (!isNumber(durationOption) && !isString(durationOption)) {
        console.error(`MUI: Argument "duration" must be a number or a string but found ${durationOption}.`);
      }
      if (!isString(easingOption)) {
        console.error('MUI: Argument "easing" must be a string.');
      }
      if (!isNumber(delay) && !isString(delay)) {
        console.error('MUI: Argument "delay" must be a number or a string.');
      }
      if (Object.keys(other).length !== 0) {
        console.error(`MUI: Unrecognized argument(s) [${Object.keys(other).join(",")}].`);
      }
    }
    return (Array.isArray(props) ? props : [props]).map((animatedProp) => `${animatedProp} ${typeof durationOption === "string" ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay === "string" ? delay : formatMs(delay)}`).join(",");
  };
  return _extends({
    getAutoHeightDuration,
    create
  }, inputTransitions, {
    easing: mergedEasing,
    duration: mergedDuration
  });
}
var _excluded15, easing, duration;
var init_createTransitions = __esm({
  "node_modules/@mui/material/styles/createTransitions.js"() {
    init_objectWithoutPropertiesLoose();
    init_extends();
    _excluded15 = ["duration", "easing", "delay"];
    easing = {
      // This is the most common easing curve.
      easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
      // Objects enter the screen at full velocity from off-screen and
      // slowly decelerate to a resting point.
      easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
      // Objects leave the screen at full velocity. They do not decelerate when off-screen.
      easeIn: "cubic-bezier(0.4, 0, 1, 1)",
      // The sharp curve is used by objects that may return to the screen at any time.
      sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
    };
    duration = {
      shortest: 150,
      shorter: 200,
      short: 250,
      // most basic recommended timing
      standard: 300,
      // this is to be used in complex animations
      complex: 375,
      // recommended when something is entering screen
      enteringScreen: 225,
      // recommended when something is leaving screen
      leavingScreen: 195
    };
  }
});

// node_modules/@mui/material/styles/createMixins.js
function createMixins(breakpoints, spacing, mixins) {
  return _extends({
    toolbar: {
      minHeight: 56,
      [`${breakpoints.up("xs")} and (orientation: landscape)`]: {
        minHeight: 48
      },
      [breakpoints.up("sm")]: {
        minHeight: 64
      }
    }
  }, mixins);
}
var init_createMixins = __esm({
  "node_modules/@mui/material/styles/createMixins.js"() {
    init_extends();
  }
});

// node_modules/@mui/material/colors/common.js
var common, common_default;
var init_common = __esm({
  "node_modules/@mui/material/colors/common.js"() {
    common = {
      black: "#000",
      white: "#fff"
    };
    common_default = common;
  }
});

// node_modules/@mui/material/colors/grey.js
var grey, grey_default;
var init_grey = __esm({
  "node_modules/@mui/material/colors/grey.js"() {
    grey = {
      50: "#fafafa",
      100: "#f5f5f5",
      200: "#eeeeee",
      300: "#e0e0e0",
      400: "#bdbdbd",
      500: "#9e9e9e",
      600: "#757575",
      700: "#616161",
      800: "#424242",
      900: "#212121",
      A100: "#f5f5f5",
      A200: "#eeeeee",
      A400: "#bdbdbd",
      A700: "#616161"
    };
    grey_default = grey;
  }
});

// node_modules/@mui/material/colors/purple.js
var purple, purple_default;
var init_purple = __esm({
  "node_modules/@mui/material/colors/purple.js"() {
    purple = {
      50: "#f3e5f5",
      100: "#e1bee7",
      200: "#ce93d8",
      300: "#ba68c8",
      400: "#ab47bc",
      500: "#9c27b0",
      600: "#8e24aa",
      700: "#7b1fa2",
      800: "#6a1b9a",
      900: "#4a148c",
      A100: "#ea80fc",
      A200: "#e040fb",
      A400: "#d500f9",
      A700: "#aa00ff"
    };
    purple_default = purple;
  }
});

// node_modules/@mui/material/colors/red.js
var red, red_default;
var init_red = __esm({
  "node_modules/@mui/material/colors/red.js"() {
    red = {
      50: "#ffebee",
      100: "#ffcdd2",
      200: "#ef9a9a",
      300: "#e57373",
      400: "#ef5350",
      500: "#f44336",
      600: "#e53935",
      700: "#d32f2f",
      800: "#c62828",
      900: "#b71c1c",
      A100: "#ff8a80",
      A200: "#ff5252",
      A400: "#ff1744",
      A700: "#d50000"
    };
    red_default = red;
  }
});

// node_modules/@mui/material/colors/orange.js
var orange, orange_default;
var init_orange = __esm({
  "node_modules/@mui/material/colors/orange.js"() {
    orange = {
      50: "#fff3e0",
      100: "#ffe0b2",
      200: "#ffcc80",
      300: "#ffb74d",
      400: "#ffa726",
      500: "#ff9800",
      600: "#fb8c00",
      700: "#f57c00",
      800: "#ef6c00",
      900: "#e65100",
      A100: "#ffd180",
      A200: "#ffab40",
      A400: "#ff9100",
      A700: "#ff6d00"
    };
    orange_default = orange;
  }
});

// node_modules/@mui/material/colors/blue.js
var blue, blue_default;
var init_blue = __esm({
  "node_modules/@mui/material/colors/blue.js"() {
    blue = {
      50: "#e3f2fd",
      100: "#bbdefb",
      200: "#90caf9",
      300: "#64b5f6",
      400: "#42a5f5",
      500: "#2196f3",
      600: "#1e88e5",
      700: "#1976d2",
      800: "#1565c0",
      900: "#0d47a1",
      A100: "#82b1ff",
      A200: "#448aff",
      A400: "#2979ff",
      A700: "#2962ff"
    };
    blue_default = blue;
  }
});

// node_modules/@mui/material/colors/lightBlue.js
var lightBlue, lightBlue_default;
var init_lightBlue = __esm({
  "node_modules/@mui/material/colors/lightBlue.js"() {
    lightBlue = {
      50: "#e1f5fe",
      100: "#b3e5fc",
      200: "#81d4fa",
      300: "#4fc3f7",
      400: "#29b6f6",
      500: "#03a9f4",
      600: "#039be5",
      700: "#0288d1",
      800: "#0277bd",
      900: "#01579b",
      A100: "#80d8ff",
      A200: "#40c4ff",
      A400: "#00b0ff",
      A700: "#0091ea"
    };
    lightBlue_default = lightBlue;
  }
});

// node_modules/@mui/material/colors/green.js
var green, green_default;
var init_green = __esm({
  "node_modules/@mui/material/colors/green.js"() {
    green = {
      50: "#e8f5e9",
      100: "#c8e6c9",
      200: "#a5d6a7",
      300: "#81c784",
      400: "#66bb6a",
      500: "#4caf50",
      600: "#43a047",
      700: "#388e3c",
      800: "#2e7d32",
      900: "#1b5e20",
      A100: "#b9f6ca",
      A200: "#69f0ae",
      A400: "#00e676",
      A700: "#00c853"
    };
    green_default = green;
  }
});

// node_modules/@mui/material/styles/createPalette.js
function addLightOrDark(intent, direction, shade, tonalOffset) {
  const tonalOffsetLight = tonalOffset.light || tonalOffset;
  const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
  if (!intent[direction]) {
    if (intent.hasOwnProperty(shade)) {
      intent[direction] = intent[shade];
    } else if (direction === "light") {
      intent.light = lighten(intent.main, tonalOffsetLight);
    } else if (direction === "dark") {
      intent.dark = darken(intent.main, tonalOffsetDark);
    }
  }
}
function getDefaultPrimary(mode = "light") {
  if (mode === "dark") {
    return {
      main: blue_default[200],
      light: blue_default[50],
      dark: blue_default[400]
    };
  }
  return {
    main: blue_default[700],
    light: blue_default[400],
    dark: blue_default[800]
  };
}
function getDefaultSecondary(mode = "light") {
  if (mode === "dark") {
    return {
      main: purple_default[200],
      light: purple_default[50],
      dark: purple_default[400]
    };
  }
  return {
    main: purple_default[500],
    light: purple_default[300],
    dark: purple_default[700]
  };
}
function getDefaultError(mode = "light") {
  if (mode === "dark") {
    return {
      main: red_default[500],
      light: red_default[300],
      dark: red_default[700]
    };
  }
  return {
    main: red_default[700],
    light: red_default[400],
    dark: red_default[800]
  };
}
function getDefaultInfo(mode = "light") {
  if (mode === "dark") {
    return {
      main: lightBlue_default[400],
      light: lightBlue_default[300],
      dark: lightBlue_default[700]
    };
  }
  return {
    main: lightBlue_default[700],
    light: lightBlue_default[500],
    dark: lightBlue_default[900]
  };
}
function getDefaultSuccess(mode = "light") {
  if (mode === "dark") {
    return {
      main: green_default[400],
      light: green_default[300],
      dark: green_default[700]
    };
  }
  return {
    main: green_default[800],
    light: green_default[500],
    dark: green_default[900]
  };
}
function getDefaultWarning(mode = "light") {
  if (mode === "dark") {
    return {
      main: orange_default[400],
      light: orange_default[300],
      dark: orange_default[700]
    };
  }
  return {
    main: "#ed6c02",
    // closest to orange[800] that pass 3:1.
    light: orange_default[500],
    dark: orange_default[900]
  };
}
function createPalette(palette) {
  const {
    mode = "light",
    contrastThreshold = 3,
    tonalOffset = 0.2
  } = palette, other = _objectWithoutPropertiesLoose(palette, _excluded16);
  const primary = palette.primary || getDefaultPrimary(mode);
  const secondary = palette.secondary || getDefaultSecondary(mode);
  const error = palette.error || getDefaultError(mode);
  const info = palette.info || getDefaultInfo(mode);
  const success = palette.success || getDefaultSuccess(mode);
  const warning = palette.warning || getDefaultWarning(mode);
  function getContrastText(background) {
    const contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
    if (true) {
      const contrast = getContrastRatio(background, contrastText);
      if (contrast < 3) {
        console.error([`MUI: The contrast ratio of ${contrast}:1 for ${contrastText} on ${background}`, "falls below the WCAG recommended absolute minimum contrast ratio of 3:1.", "https://www.w3.org/TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-contrast"].join("\n"));
      }
    }
    return contrastText;
  }
  const augmentColor = ({
    color,
    name,
    mainShade = 500,
    lightShade = 300,
    darkShade = 700
  }) => {
    color = _extends({}, color);
    if (!color.main && color[mainShade]) {
      color.main = color[mainShade];
    }
    if (!color.hasOwnProperty("main")) {
      throw new Error(true ? `MUI: The color${name ? ` (${name})` : ""} provided to augmentColor(color) is invalid.
The color object needs to have a \`main\` property or a \`${mainShade}\` property.` : formatMuiErrorMessage(11, name ? ` (${name})` : "", mainShade));
    }
    if (typeof color.main !== "string") {
      throw new Error(true ? `MUI: The color${name ? ` (${name})` : ""} provided to augmentColor(color) is invalid.
\`color.main\` should be a string, but \`${JSON.stringify(color.main)}\` was provided instead.

Did you intend to use one of the following approaches?

import { green } from "@mui/material/colors";

const theme1 = createTheme({ palette: {
  primary: green,
} });

const theme2 = createTheme({ palette: {
  primary: { main: green[500] },
} });` : formatMuiErrorMessage(12, name ? ` (${name})` : "", JSON.stringify(color.main)));
    }
    addLightOrDark(color, "light", lightShade, tonalOffset);
    addLightOrDark(color, "dark", darkShade, tonalOffset);
    if (!color.contrastText) {
      color.contrastText = getContrastText(color.main);
    }
    return color;
  };
  const modes = {
    dark,
    light
  };
  if (true) {
    if (!modes[mode]) {
      console.error(`MUI: The palette mode \`${mode}\` is not supported.`);
    }
  }
  const paletteOutput = deepmerge(_extends({
    // A collection of common colors.
    common: common_default,
    // The palette mode, can be light or dark.
    mode,
    // The colors used to represent primary interface elements for a user.
    primary: augmentColor({
      color: primary,
      name: "primary"
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: augmentColor({
      color: secondary,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: augmentColor({
      color: error,
      name: "error"
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: augmentColor({
      color: warning,
      name: "warning"
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: augmentColor({
      color: info,
      name: "info"
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: augmentColor({
      color: success,
      name: "success"
    }),
    // The grey colors.
    grey: grey_default,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText,
    // Generate a rich color object.
    augmentColor,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset
  }, modes[mode]), other);
  return paletteOutput;
}
var _excluded16, light, dark;
var init_createPalette = __esm({
  "node_modules/@mui/material/styles/createPalette.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_esm();
    init_esm();
    init_esm2();
    init_common();
    init_grey();
    init_purple();
    init_red();
    init_orange();
    init_blue();
    init_lightBlue();
    init_green();
    _excluded16 = ["mode", "contrastThreshold", "tonalOffset"];
    light = {
      // The colors used to style the text.
      text: {
        // The most important text.
        primary: "rgba(0, 0, 0, 0.87)",
        // Secondary text.
        secondary: "rgba(0, 0, 0, 0.6)",
        // Disabled text have even lower visual prominence.
        disabled: "rgba(0, 0, 0, 0.38)"
      },
      // The color used to divide different elements.
      divider: "rgba(0, 0, 0, 0.12)",
      // The background colors used to style the surfaces.
      // Consistency between these values is important.
      background: {
        paper: common_default.white,
        default: common_default.white
      },
      // The colors used to style the action elements.
      action: {
        // The color of an active action like an icon button.
        active: "rgba(0, 0, 0, 0.54)",
        // The color of an hovered action.
        hover: "rgba(0, 0, 0, 0.04)",
        hoverOpacity: 0.04,
        // The color of a selected action.
        selected: "rgba(0, 0, 0, 0.08)",
        selectedOpacity: 0.08,
        // The color of a disabled action.
        disabled: "rgba(0, 0, 0, 0.26)",
        // The background color of a disabled action.
        disabledBackground: "rgba(0, 0, 0, 0.12)",
        disabledOpacity: 0.38,
        focus: "rgba(0, 0, 0, 0.12)",
        focusOpacity: 0.12,
        activatedOpacity: 0.12
      }
    };
    dark = {
      text: {
        primary: common_default.white,
        secondary: "rgba(255, 255, 255, 0.7)",
        disabled: "rgba(255, 255, 255, 0.5)",
        icon: "rgba(255, 255, 255, 0.5)"
      },
      divider: "rgba(255, 255, 255, 0.12)",
      background: {
        paper: "#121212",
        default: "#121212"
      },
      action: {
        active: common_default.white,
        hover: "rgba(255, 255, 255, 0.08)",
        hoverOpacity: 0.08,
        selected: "rgba(255, 255, 255, 0.16)",
        selectedOpacity: 0.16,
        disabled: "rgba(255, 255, 255, 0.3)",
        disabledBackground: "rgba(255, 255, 255, 0.12)",
        disabledOpacity: 0.38,
        focus: "rgba(255, 255, 255, 0.12)",
        focusOpacity: 0.12,
        activatedOpacity: 0.24
      }
    };
  }
});

// node_modules/@mui/material/styles/createTypography.js
function round(value) {
  return Math.round(value * 1e5) / 1e5;
}
function createTypography(palette, typography) {
  const _ref = typeof typography === "function" ? typography(palette) : typography, {
    fontFamily = defaultFontFamily,
    // The default font size of the Material Specification.
    fontSize = 14,
    // px
    fontWeightLight = 300,
    fontWeightRegular = 400,
    fontWeightMedium = 500,
    fontWeightBold = 700,
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    htmlFontSize = 16,
    // Apply the CSS properties to all the variants.
    allVariants,
    pxToRem: pxToRem2
  } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded17);
  if (true) {
    if (typeof fontSize !== "number") {
      console.error("MUI: `fontSize` is required to be a number.");
    }
    if (typeof htmlFontSize !== "number") {
      console.error("MUI: `htmlFontSize` is required to be a number.");
    }
  }
  const coef = fontSize / 14;
  const pxToRem = pxToRem2 || ((size) => `${size / htmlFontSize * coef}rem`);
  const buildVariant = (fontWeight, size, lineHeight, letterSpacing, casing) => _extends({
    fontFamily,
    fontWeight,
    fontSize: pxToRem(size),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight
  }, fontFamily === defaultFontFamily ? {
    letterSpacing: `${round(letterSpacing / size)}em`
  } : {}, casing, allVariants);
  const variants = {
    h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
    h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
    h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
    h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
    h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
    h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
    subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
    subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
    body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
    body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
    button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
    caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
    overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps)
  };
  return deepmerge(_extends({
    htmlFontSize,
    pxToRem,
    fontFamily,
    fontSize,
    fontWeightLight,
    fontWeightRegular,
    fontWeightMedium,
    fontWeightBold
  }, variants), other, {
    clone: false
    // No need to clone deep
  });
}
var _excluded17, caseAllCaps, defaultFontFamily;
var init_createTypography = __esm({
  "node_modules/@mui/material/styles/createTypography.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_esm();
    _excluded17 = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];
    caseAllCaps = {
      textTransform: "uppercase"
    };
    defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
  }
});

// node_modules/@mui/material/styles/shadows.js
function createShadow(...px) {
  return [`${px[0]}px ${px[1]}px ${px[2]}px ${px[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${px[4]}px ${px[5]}px ${px[6]}px ${px[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${px[8]}px ${px[9]}px ${px[10]}px ${px[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(",");
}
var shadowKeyUmbraOpacity, shadowKeyPenumbraOpacity, shadowAmbientShadowOpacity, shadows, shadows_default;
var init_shadows = __esm({
  "node_modules/@mui/material/styles/shadows.js"() {
    shadowKeyUmbraOpacity = 0.2;
    shadowKeyPenumbraOpacity = 0.14;
    shadowAmbientShadowOpacity = 0.12;
    shadows = ["none", createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
    shadows_default = shadows;
  }
});

// node_modules/@mui/material/styles/zIndex.js
var zIndex, zIndex_default;
var init_zIndex = __esm({
  "node_modules/@mui/material/styles/zIndex.js"() {
    zIndex = {
      mobileStepper: 1e3,
      speedDial: 1050,
      appBar: 1100,
      drawer: 1200,
      modal: 1300,
      snackbar: 1400,
      tooltip: 1500
    };
    zIndex_default = zIndex;
  }
});

// node_modules/@mui/material/styles/createTheme.js
function createTheme(options = {}, ...args) {
  const {
    mixins: mixinsInput = {},
    palette: paletteInput = {},
    transitions: transitionsInput = {},
    typography: typographyInput = {}
  } = options, other = _objectWithoutPropertiesLoose(options, _excluded18);
  const palette = createPalette(paletteInput);
  const systemTheme = createTheme_default(options);
  let muiTheme = deepmerge(systemTheme, {
    mixins: createMixins(systemTheme.breakpoints, systemTheme.spacing, mixinsInput),
    palette,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: shadows_default.slice(),
    typography: createTypography(palette, typographyInput),
    transitions: createTransitions(transitionsInput),
    zIndex: _extends({}, zIndex_default)
  });
  muiTheme = deepmerge(muiTheme, other);
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  if (true) {
    const stateClasses = ["active", "checked", "completed", "disabled", "error", "expanded", "focused", "focusVisible", "required", "selected"];
    const traverse = (node, component) => {
      let key;
      for (key in node) {
        const child = node[key];
        if (stateClasses.indexOf(key) !== -1 && Object.keys(child).length > 0) {
          if (true) {
            const stateClass = generateUtilityClass("", key);
            console.error([`MUI: The \`${component}\` component increases the CSS specificity of the \`${key}\` internal state.`, "You can not override it like this: ", JSON.stringify(node, null, 2), "", `Instead, you need to use the '&.${stateClass}' syntax:`, JSON.stringify({
              root: {
                [`&.${stateClass}`]: child
              }
            }, null, 2), "", "https://mui.com/r/state-classes-guide"].join("\n"));
          }
          node[key] = {};
        }
      }
    };
    Object.keys(muiTheme.components).forEach((component) => {
      const styleOverrides = muiTheme.components[component].styleOverrides;
      if (styleOverrides && component.indexOf("Mui") === 0) {
        traverse(styleOverrides, component);
      }
    });
  }
  return muiTheme;
}
function createMuiTheme(...args) {
  if (true) {
    if (!warnedOnce) {
      warnedOnce = true;
      console.error(["MUI: the createMuiTheme function was renamed to createTheme.", "", "You should use `import { createTheme } from '@mui/material/styles'`"].join("\n"));
    }
  }
  return createTheme(...args);
}
var _excluded18, warnedOnce, createTheme_default2;
var init_createTheme = __esm({
  "node_modules/@mui/material/styles/createTheme.js"() {
    init_extends();
    init_objectWithoutPropertiesLoose();
    init_esm();
    init_base();
    init_esm2();
    init_createMixins();
    init_createPalette();
    init_createTypography();
    init_shadows();
    init_createTransitions();
    init_zIndex();
    _excluded18 = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];
    warnedOnce = false;
    createTheme_default2 = createTheme;
  }
});

// node_modules/@mui/material/styles/defaultTheme.js
var defaultTheme, defaultTheme_default;
var init_defaultTheme = __esm({
  "node_modules/@mui/material/styles/defaultTheme.js"() {
    init_createTheme();
    defaultTheme = createTheme_default2();
    defaultTheme_default = defaultTheme;
  }
});

export {
  isHostComponent_default,
  appendOwnerState,
  extractEventHandlers,
  createFilterOptions,
  useAutocomplete,
  init_AutocompleteUnstyled,
  composeClasses,
  init_composeClasses2 as init_composeClasses,
  ClassNameGenerator_default,
  generateUtilityClass,
  generateUtilityClasses,
  getBackdropUtilityClass,
  backdropUnstyledClasses_default,
  BackdropUnstyled_default,
  init_BackdropUnstyled2 as init_BackdropUnstyled,
  useBadge,
  getBadgeUtilityClass,
  badgeUnstyledClasses_default,
  BadgeUnstyled_default,
  init_BadgeUnstyled2 as init_BadgeUnstyled,
  getButtonUnstyledUtilityClass,
  buttonUnstyledClasses_default,
  useButton,
  ButtonUnstyled_default,
  FormControlContext_default,
  getFormControlUnstyledUtilityClasses,
  formControlUnstyledClasses_default,
  FormControlUnstyled_default,
  useFormControlUnstyled,
  getInputUnstyledUtilityClass,
  inputUnstyledClasses_default,
  useInput,
  InputUnstyled_default,
  ModalManager,
  Unstable_TrapFocus_default,
  init_Unstable_TrapFocus2 as init_Unstable_TrapFocus,
  getModalUtilityClass,
  modalUnstyledClasses_default,
  ModalUnstyled_default,
  init_ModalUnstyled2 as init_ModalUnstyled,
  NoSsr_default,
  init_NoSsr2 as init_NoSsr,
  getSliderUtilityClass,
  sliderUnstyledClasses_default,
  SliderValueLabelUnstyled_default,
  SliderUnstyled_default,
  init_SliderUnstyled2 as init_SliderUnstyled,
  useSwitch,
  getSwitchUnstyledUtilityClass,
  switchUnstyledClasses_default,
  SwitchUnstyled_default,
  getTabPanelUnstyledUtilityClass,
  tabPanelUnstyledClasses_default,
  getTabsUnstyledUtilityClass,
  tabsUnstyledClasses_default,
  useTabs_default,
  useTabContext,
  getPanelId,
  getTabId,
  TabsContext_default,
  TabsUnstyled_default,
  useTabPanel_default,
  TabPanelUnstyled_default,
  getTabsListUnstyledUtilityClass,
  tabsListUnstyledClasses_default,
  useTabsList_default,
  TabsListUnstyled_default,
  getTabUnstyledUtilityClass,
  tabUnstyledClasses_default,
  useTab_default,
  TabUnstyled_default,
  TextareaAutosize_default,
  init_TextareaAutosize2 as init_TextareaAutosize,
  init_base,
  common_default,
  init_common,
  grey_default,
  init_grey,
  purple_default,
  init_purple,
  red_default,
  init_red,
  orange_default,
  init_orange,
  blue_default,
  init_blue,
  lightBlue_default,
  init_lightBlue,
  green_default,
  init_green,
  easing,
  duration,
  init_createTransitions,
  createMuiTheme,
  createTheme_default2 as createTheme_default,
  init_createTheme,
  defaultTheme_default,
  init_defaultTheme
};
/*! Bundled license information:

@mui/base/index.js:
  (** @license MUI v5.0.0-alpha.62
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=chunk-3U3DCDMU.js.map
