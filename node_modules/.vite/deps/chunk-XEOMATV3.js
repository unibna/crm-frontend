import {
  Action,
  DragDropProvider,
  DragSource,
  DropTarget,
  Getter,
  PlaceholderWithRef,
  Plugin,
  PluginHost,
  Sizer,
  Template,
  TemplateConnector,
  TemplatePlaceholder,
  createStateHelper,
  easeOutCubic,
  getMessagesFormatter,
  memoize,
  shallowEqual,
  slice,
  withComponents
} from "./chunk-GVMU73SV.js";
import {
  require_react_dom
} from "./chunk-NPN4KBMN.js";
import {
  require_react
} from "./chunk-LBQWZZ6Z.js";
import {
  __toESM
} from "./chunk-TFWDKVI3.js";

// node_modules/@devexpress/dx-react-grid/dist/dx-react-grid.es.js
var import_react = __toESM(require_react());

// node_modules/@devexpress/dx-grid-core/dist/dx-grid-core.es.js
var GRID_GROUP_TYPE = Symbol("group");
var GRID_GROUP_CHECK = Symbol(GRID_GROUP_TYPE.toString() + "_check");
var GRID_GROUP_LEVEL_KEY = Symbol(GRID_GROUP_TYPE.toString() + "_levelKey");
var GRID_GROUP_COLLAPSED_ROWS = Symbol(GRID_GROUP_TYPE.toString() + "_collapsedRows");
var warnIfRowIdUndefined = function(getRowId) {
  return function(row) {
    var result = getRowId(row);
    if (!row[GRID_GROUP_CHECK] && result === void 0) {
      console.warn("The row id is undefined. Check the getRowId function. The row is", row);
    }
    return result;
  };
};
var rowIdGetter = function(getRowId, rows) {
  if (!getRowId) {
    var map_1 = new Map(rows.map(function(row, rowIndex) {
      return [row, rowIndex];
    }));
    return function(row) {
      return map_1.get(row);
    };
  }
  return warnIfRowIdUndefined(getRowId);
};
var defaultGetCellValue = function(row, columnName) {
  return row[columnName];
};
var cellValueGetter = function(getCellValue, columns) {
  if (getCellValue === void 0) {
    getCellValue = defaultGetCellValue;
  }
  var useFastAccessor = true;
  var map = columns.reduce(function(acc, column) {
    if (column.getCellValue) {
      useFastAccessor = false;
      acc[column.name] = column.getCellValue;
    }
    return acc;
  }, {});
  if (useFastAccessor) {
    return getCellValue;
  }
  return function(row, columnName) {
    return map[columnName] ? map[columnName](row, columnName) : getCellValue(row, columnName);
  };
};
var changeColumnSorting = function(state, _a) {
  var columnName = _a.columnName, direction = _a.direction, keepOther = _a.keepOther, sortIndex = _a.sortIndex;
  var sorting = state.sorting;
  var nextSorting = [];
  if (keepOther === true) {
    nextSorting = sorting;
  }
  if (Array.isArray(keepOther)) {
    nextSorting = slice(sorting).filter(function(s) {
      return keepOther.indexOf(s.columnName) > -1;
    });
  }
  var columnSortingIndex = sorting.findIndex(function(s) {
    return s.columnName === columnName;
  });
  var columnSorting = sorting[columnSortingIndex];
  var newColumnSorting = {
    columnName,
    direction: direction || (!columnSorting || columnSorting.direction === "desc" ? "asc" : "desc")
  };
  if (columnSortingIndex > -1) {
    nextSorting = slice(nextSorting);
    nextSorting.splice(columnSortingIndex, 1);
  }
  if (direction !== null) {
    var newIndexFallback = columnSortingIndex > -1 ? columnSortingIndex : nextSorting.length;
    var newIndex = sortIndex !== void 0 ? sortIndex : newIndexFallback;
    nextSorting = slice(nextSorting);
    nextSorting.splice(newIndex, 0, newColumnSorting);
  }
  return {
    sorting: nextSorting
  };
};
var __assign = function() {
  __assign = Object.assign || function __assign3(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
var unique = function(arr) {
  return __spread(Array.from(new Set(arr)));
};
var getColumnSortingDirection = function(sorting, columnName) {
  var columnSorting = sorting.filter(function(s) {
    return s.columnName === columnName;
  })[0];
  return columnSorting ? columnSorting.direction : null;
};
var getPersistentSortedColumns = function(sorting, columnExtensions) {
  if (columnExtensions === void 0) {
    columnExtensions = [];
  }
  return columnExtensions.reduce(function(acc, _a) {
    var columnName = _a.columnName, sortingEnabled = _a.sortingEnabled;
    if (sortingEnabled === false) {
      if (sorting.findIndex(function(sortItem) {
        return sortItem.columnName === columnName;
      }) > -1) {
        acc.push(columnName);
      }
    }
    return acc;
  }, []);
};
var calculateKeepOther = function(sorting, keepOther, persistentSortedColumns) {
  if (persistentSortedColumns === void 0) {
    persistentSortedColumns = [];
  }
  if (!persistentSortedColumns.length)
    return keepOther;
  if (!keepOther)
    return persistentSortedColumns;
  return Array.isArray(keepOther) ? unique(__spread(keepOther, persistentSortedColumns)) : unique(__spread(sorting.map(function(item) {
    return item.columnName;
  }), persistentSortedColumns));
};
var merge = function(array, auxiliary, lo, mid, hi, compare) {
  var i = lo;
  var j = mid + 1;
  var k = lo;
  while (true) {
    var cmp = compare(array[i], array[j]);
    if (cmp <= 0) {
      auxiliary[k++] = array[i++];
      if (i > mid) {
        do {
          auxiliary[k++] = array[j++];
        } while (j <= hi);
        break;
      }
    } else {
      auxiliary[k++] = array[j++];
      if (j > hi) {
        do {
          auxiliary[k++] = array[i++];
        } while (i <= mid);
        break;
      }
    }
  }
};
var sortArrayToAuxiliary = function(array, auxiliary, lo, hi, compare) {
  if (hi < lo)
    return;
  if (hi === lo) {
    auxiliary[lo] = array[lo];
    return;
  }
  var mid = Math.floor(lo + (hi - lo) / 2);
  sortAuxiliaryToArray(array, auxiliary, lo, mid, compare);
  sortAuxiliaryToArray(array, auxiliary, mid + 1, hi, compare);
  merge(array, auxiliary, lo, mid, hi, compare);
};
var sortAuxiliaryToArray = function(array, auxiliary, lo, hi, compare) {
  if (hi <= lo)
    return;
  var mid = Math.floor(lo + (hi - lo) / 2);
  sortArrayToAuxiliary(array, auxiliary, lo, mid, compare);
  sortArrayToAuxiliary(array, auxiliary, mid + 1, hi, compare);
  merge(auxiliary, array, lo, mid, hi, compare);
};
var mergeSort = function(array, compare) {
  if (compare === void 0) {
    compare = function(a, b) {
      if (a < b)
        return -1;
      if (a > b)
        return 1;
      return 0;
    };
  }
  var result = slice(array);
  var auxiliary = slice(array);
  sortAuxiliaryToArray(result, auxiliary, 0, result.length - 1, compare);
  return result;
};
var NODE_CHECK = Symbol("node");
var rowsToTree = function(rows, getRowLevelKey) {
  if (!rows.length)
    return rows;
  var levels = [{ children: [] }];
  rows.forEach(function(row) {
    var _a;
    var levelKey = getRowLevelKey(row);
    if (levelKey) {
      var levelIndex = levels.slice(1).findIndex(function(level) {
        return getRowLevelKey(level.root) === levelKey;
      }) + 1;
      if (levelIndex > 0) {
        levels.splice(levelIndex, levels.length - levelIndex);
      }
      var node = (_a = {}, _a[NODE_CHECK] = true, _a.root = row, _a.children = [], _a);
      levels[levels.length - 1].children.push(node);
      levels.push(node);
    } else {
      levels[levels.length - 1].children.push(row);
    }
  });
  return levels[0].children;
};
var treeToRows = function(tree, rows) {
  if (rows === void 0) {
    rows = [];
  }
  if (!tree.length)
    return tree;
  return tree.reduce(function(acc, node) {
    if (node[NODE_CHECK]) {
      acc.push(node.root);
      treeToRows(node.children, rows);
    } else {
      acc.push(node);
    }
    return acc;
  }, rows);
};
var defaultCompare = function(a, b) {
  if (a === b)
    return 0;
  if (a === null) {
    return b === void 0 ? -1 : 1;
  }
  if (a === void 0) {
    return 1;
  }
  if (b === null || b === void 0) {
    return -1;
  }
  return a < b ? -1 : 1;
};
var createCompare = function(sorting, getColumnCompare, getComparableValue) {
  return sorting.reduceRight(function(prevCompare, columnSorting) {
    var columnName = columnSorting.columnName;
    var inverse = columnSorting.direction === "desc";
    var columnCompare = getColumnCompare && getColumnCompare(columnName) || defaultCompare;
    return function(aRow, bRow) {
      var a = getComparableValue(aRow, columnName);
      var b = getComparableValue(bRow, columnName);
      var result = columnCompare(a, b);
      if (result !== 0) {
        return inverse ? -result : result;
      }
      return prevCompare(aRow, bRow);
    };
  }, function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return 0;
  });
};
var sortTree = function(tree, compare) {
  var sortedTree = tree.map(function(node) {
    if (node[NODE_CHECK]) {
      return __assign(__assign({}, node), { children: sortTree(node.children, compare) });
    }
    return node;
  });
  return mergeSort(sortedTree, function(a, b) {
    return compare(a[NODE_CHECK] ? a.root : a, b[NODE_CHECK] ? b.root : b);
  });
};
var sortHierarchicalRows = function(rows, compare, getRowLevelKey) {
  var tree = rowsToTree(rows, getRowLevelKey);
  var sortedTree = sortTree(tree, compare);
  return treeToRows(sortedTree);
};
var sortedRows = function(rows, sorting, getCellValue, getColumnCompare, isGroupRow, getRowLevelKey) {
  if (!sorting.length || !rows.length)
    return rows;
  var compare;
  if (!getRowLevelKey) {
    compare = createCompare(sorting, getColumnCompare, getCellValue);
    return mergeSort(rows.slice(), compare);
  }
  compare = createCompare(sorting, getColumnCompare, function(row, columnName) {
    if (isGroupRow && isGroupRow(row)) {
      if (row.groupedBy === columnName) {
        return row.value;
      }
      return void 0;
    }
    return getCellValue(row, columnName);
  });
  return sortHierarchicalRows(rows, compare, getRowLevelKey);
};
var changeColumnFilter = function(filters, _a) {
  var columnName = _a.columnName, config = _a.config;
  var filterIndex = filters.findIndex(function(f) {
    return f.columnName === columnName;
  });
  var nextState = slice(filters);
  if (config) {
    var filter = __assign({ columnName }, config);
    if (filterIndex > -1) {
      nextState.splice(filterIndex, 1, filter);
    } else {
      nextState.push(filter);
    }
  } else if (filterIndex > -1) {
    nextState.splice(filterIndex, 1);
  }
  return nextState;
};
var getColumnFilterConfig = function(filters, columnName) {
  return filters.length && filters.filter(function(s) {
    return s.columnName === columnName;
  })[0] || null;
};
var filterExpression = function(filters, expression) {
  var selfFilterExpr = { filters, operator: "and" };
  if (!expression) {
    return selfFilterExpr;
  }
  return {
    operator: "and",
    filters: [expression, selfFilterExpr]
  };
};
var operators = {
  or: function(predicates) {
    return function(row) {
      return predicates.reduce(function(acc, predicate) {
        return acc || predicate(row);
      }, false);
    };
  },
  and: function(predicates) {
    return function(row) {
      return predicates.reduce(function(acc, predicate) {
        return acc && predicate(row);
      }, true);
    };
  }
};
var toLowerCase = function(value) {
  return String(value).toLowerCase();
};
var operationPredicates = {
  contains: function(value, filter) {
    return toLowerCase(value).indexOf(toLowerCase(filter.value)) > -1;
  },
  notContains: function(value, filter) {
    return toLowerCase(value).indexOf(toLowerCase(filter.value)) === -1;
  },
  startsWith: function(value, filter) {
    return toLowerCase(value).startsWith(toLowerCase(filter.value));
  },
  endsWith: function(value, filter) {
    return toLowerCase(value).endsWith(toLowerCase(filter.value));
  },
  equal: function(value, filter) {
    return String(value) === String(filter.value);
  },
  notEqual: function(value, filter) {
    return String(value) !== String(filter.value);
  },
  greaterThan: function(value, filter) {
    return value > filter.value;
  },
  greaterThanOrEqual: function(value, filter) {
    return value >= filter.value;
  },
  lessThan: function(value, filter) {
    return value < filter.value;
  },
  lessThanOrEqual: function(value, filter) {
    return value <= filter.value;
  }
};
var defaultFilterPredicate = function(value, filter) {
  var operation = filter.operation || "contains";
  return operationPredicates[operation](value, filter);
};
var filterTree = function(tree, predicate) {
  return tree.reduce(function(acc, node) {
    if (node[NODE_CHECK]) {
      var filteredChildren = filterTree(node.children, predicate);
      if (filteredChildren.length > 0) {
        acc.push(__assign(__assign({}, node), { children: filteredChildren }));
        return acc;
      }
      if (predicate(node.root, true)) {
        acc.push(node.root);
        return acc;
      }
      return acc;
    }
    if (predicate(node)) {
      acc.push(node);
      return acc;
    }
    return acc;
  }, []);
};
var filterHierarchicalRows = function(rows, predicate, getRowLevelKey, getCollapsedRows2) {
  var tree = rowsToTree(rows, getRowLevelKey);
  var collapsedRowsMeta = [];
  var filteredTree = filterTree(tree, function(row, isNode) {
    if (isNode) {
      var collapsedRows = getCollapsedRows2 && getCollapsedRows2(row);
      if (collapsedRows && collapsedRows.length) {
        var filteredCollapsedRows = collapsedRows.filter(predicate);
        collapsedRowsMeta.push([row, filteredCollapsedRows]);
        return !!filteredCollapsedRows.length || predicate(row);
      }
      if (predicate(row)) {
        collapsedRowsMeta.push([row, []]);
        return true;
      }
      return false;
    }
    return predicate(row);
  });
  return { rows: treeToRows(filteredTree), collapsedRowsMeta: new Map(collapsedRowsMeta) };
};
var buildPredicate = function(initialFilterExpression, getCellValue, getColumnPredicate) {
  var getSimplePredicate = function(filter) {
    var columnName = filter.columnName;
    var customPredicate = getColumnPredicate && getColumnPredicate(columnName);
    var predicate = customPredicate || defaultFilterPredicate;
    return function(row) {
      return predicate(getCellValue(row, columnName), filter, row);
    };
  };
  var getOperatorPredicate = function(filterExpression2) {
    var build = operators[toLowerCase(filterExpression2.operator)];
    return build && build(filterExpression2.filters.map(getPredicate));
  };
  var getPredicate = function(filterExpression2) {
    return getOperatorPredicate(filterExpression2) || getSimplePredicate(filterExpression2);
  };
  return getPredicate(initialFilterExpression);
};
var filteredRows = function(rows, filterExpression2, getCellValue, getColumnPredicate, getRowLevelKey, getCollapsedRows2) {
  if (!(filterExpression2 && Object.keys(filterExpression2).length && rows.length)) {
    return { rows };
  }
  var predicate = buildPredicate(filterExpression2, getCellValue, getColumnPredicate);
  return getRowLevelKey ? filterHierarchicalRows(rows, predicate, getRowLevelKey, getCollapsedRows2) : { rows: rows.filter(predicate) };
};
var filteredCollapsedRowsGetter = function(_a) {
  var collapsedRowsMeta = _a.collapsedRowsMeta;
  return function(row) {
    return collapsedRowsMeta && collapsedRowsMeta.get(row);
  };
};
var unwrappedFilteredRows = function(_a) {
  var rows = _a.rows;
  return rows;
};
var GROUP_KEY_SEPARATOR = "|";
var applyColumnGrouping = function(grouping, _a) {
  var columnName = _a.columnName, groupIndex = _a.groupIndex;
  var nextGrouping = grouping;
  var groupingIndex = nextGrouping.findIndex(function(g) {
    return g.columnName === columnName;
  });
  var targetIndex = groupIndex;
  if (groupingIndex > -1) {
    nextGrouping = slice(grouping);
    nextGrouping.splice(groupingIndex, 1);
  } else if (groupIndex === void 0) {
    targetIndex = nextGrouping.length;
  }
  if (targetIndex > -1) {
    nextGrouping = slice(nextGrouping);
    nextGrouping.splice(targetIndex, 0, {
      columnName
    });
  }
  return nextGrouping;
};
var changeColumnGrouping = function(_a, _b) {
  var grouping = _a.grouping, expandedGroups = _a.expandedGroups;
  var columnName = _b.columnName, groupIndex = _b.groupIndex;
  var nextGrouping = applyColumnGrouping(grouping, { columnName, groupIndex });
  var ungroupedColumnIndex = grouping.findIndex(function(group, index) {
    return !nextGrouping[index] || group.columnName !== nextGrouping[index].columnName;
  });
  if (ungroupedColumnIndex === -1) {
    return {
      grouping: nextGrouping
    };
  }
  var filteredExpandedGroups = expandedGroups.filter(function(group) {
    return group.split(GROUP_KEY_SEPARATOR).length <= ungroupedColumnIndex;
  });
  if (filteredExpandedGroups.length === expandedGroups.length) {
    return {
      grouping: nextGrouping
    };
  }
  return {
    grouping: nextGrouping,
    expandedGroups: filteredExpandedGroups
  };
};
var toggleExpandedGroups = function(state, _a) {
  var groupKey = _a.groupKey;
  var expandedGroups = slice(state.expandedGroups);
  var groupKeyIndex = expandedGroups.indexOf(groupKey);
  if (groupKeyIndex > -1) {
    expandedGroups.splice(groupKeyIndex, 1);
  } else {
    expandedGroups.push(groupKey);
  }
  return {
    expandedGroups
  };
};
var draftColumnGrouping = function(_a, _b) {
  var grouping = _a.grouping, draftGrouping = _a.draftGrouping;
  var columnName = _b.columnName, groupIndex = _b.groupIndex;
  return {
    draftGrouping: applyColumnGrouping(draftGrouping || grouping, { columnName, groupIndex })
  };
};
var cancelColumnGroupingDraft = function() {
  return {
    draftGrouping: null
  };
};
var adjustSortIndex = function(groupingIndex, grouping, sorting) {
  return Math.max(grouping.slice(0, groupingIndex).reduce(function(acc, columnGrouping) {
    var columnSortingIndex = sorting.findIndex(function(columnSorting) {
      return columnSorting.columnName === columnGrouping.columnName;
    });
    return columnSortingIndex === -1 ? acc - 1 : acc;
  }, groupingIndex), 0);
};
var defaultColumnCriteria = function(value) {
  return {
    value,
    key: String(value)
  };
};
var getGroupRows = function(rows, grouping, groupsGetter) {
  if (grouping.length === 0) {
    return rows;
  }
  var keyPrefixes = [{ prefix: "", level: 0, rows }];
  var resultRows = [];
  var compoundKeys = {};
  var _loop_1 = function() {
    var _a = keyPrefixes.pop(), keyPrefix = _a.prefix, level = _a.level, currentRows = _a.rows;
    var currentCompoundKey = keyPrefix.slice(0, keyPrefix.length - 1);
    var groupIndex = (_a = compoundKeys[currentCompoundKey]) !== null && _a !== void 0 ? _a : -1;
    var groupRows = grouping[level] && currentRows.length ? groupsGetter(currentRows, grouping[level], keyPrefix).map(function(_a2, rowIndex) {
      var childRows = _a2.childRows, params = __rest(_a2, ["childRows"]);
      var compoundKey = params.compoundKey;
      compoundKeys[compoundKey] = groupIndex + rowIndex + 1;
      keyPrefixes.push({
        prefix: "" + compoundKey + GROUP_KEY_SEPARATOR,
        level: level + 1,
        rows: childRows || []
      });
      return params;
    }) : currentRows;
    if (groupIndex > -1) {
      resultRows.splice.apply(resultRows, __spread([groupIndex + 1, 0], groupRows));
    } else {
      groupRows.forEach(function(row) {
        return resultRows.push(row);
      });
    }
  };
  while (keyPrefixes.length) {
    _loop_1();
  }
  return resultRows;
};
var getIntegratedGroups = function(rows, grouping, keyPrefix, getCellValue, getColumnCriteria) {
  var columnName = grouping.columnName;
  var groupCriteria = getColumnCriteria && getColumnCriteria(columnName) || defaultColumnCriteria;
  var groups = /* @__PURE__ */ new Map();
  rows.forEach(function(row) {
    var rawValue = getCellValue(row, columnName);
    var _a = groupCriteria(rawValue, row), key = _a.key, value = _a.value;
    var sameKeyItems = groups.get(key);
    if (!sameKeyItems) {
      var groupingValue = value === rawValue ? value : value || key;
      groups.set(key, [groupingValue, key, [row]]);
    } else {
      sameKeyItems[2].push(row);
    }
  });
  var groupedBy = columnName;
  return __spread(groups.values()).map(function(_a) {
    var _b;
    var _c = __read(_a, 3), value = _c[0], key = _c[1], childRows = _c[2];
    return _b = {
      groupedBy,
      compoundKey: "" + keyPrefix + key,
      key,
      value
    }, _b[GRID_GROUP_CHECK] = true, _b[GRID_GROUP_LEVEL_KEY] = GRID_GROUP_TYPE.toString() + "_" + groupedBy, _b.childRows = childRows, _b;
  });
};
var groupRowChecker = function(row) {
  return row[GRID_GROUP_CHECK];
};
var groupRowLevelKeyGetter = function(row) {
  return row ? row[GRID_GROUP_LEVEL_KEY] : void 0;
};
var groupedRows = function(rows, grouping, getCellValue, getColumnCriteria) {
  var groupsGetter = function(currentRows, currentGrouping, prefix) {
    return getIntegratedGroups(currentRows, currentGrouping, prefix, getCellValue, getColumnCriteria);
  };
  return getGroupRows(rows, grouping, groupsGetter);
};
var expandedGroupRows = function(rows, grouping, expandedGroups, isExporting) {
  if (!grouping.length)
    return rows;
  var groupingColumnNames = grouping.map(function(columnGrouping) {
    return columnGrouping.columnName;
  });
  var expandedGroupsSet = new Set(expandedGroups);
  var currentGroupExpanded = true;
  var currentGroupLevel = 0;
  return rows.reduce(function(acc, row) {
    var _a;
    if (!row[GRID_GROUP_CHECK]) {
      if (currentGroupExpanded) {
        acc.push(row);
      } else {
        acc[acc.length - 1][GRID_GROUP_COLLAPSED_ROWS].push(row);
      }
      return acc;
    }
    var groupLevel = groupingColumnNames.indexOf(row.groupedBy);
    if (groupLevel > currentGroupLevel && !currentGroupExpanded) {
      return acc;
    }
    currentGroupExpanded = expandedGroupsSet.has(row.compoundKey) || isExporting;
    currentGroupLevel = groupLevel;
    if (currentGroupExpanded) {
      acc.push(row);
    } else {
      acc.push(__assign(__assign({}, row), (_a = {}, _a[GRID_GROUP_COLLAPSED_ROWS] = [], _a)));
    }
    return acc;
  }, []);
};
var groupCollapsedRowsGetter = function(getCollapsedRows2) {
  return function(row) {
    return row[GRID_GROUP_COLLAPSED_ROWS] || getCollapsedRows2 && getCollapsedRows2(row);
  };
};
var getCustomGroups = function(rows, grouping, keyPrefix, getChildGroups, rootRows) {
  var groupedBy = grouping.columnName;
  return getChildGroups(rows, grouping, rootRows).map(function(_a) {
    var _b;
    var key = _a.key, _c = _a.value, value = _c === void 0 ? key : _c, childRows = _a.childRows;
    return _b = {
      groupedBy,
      compoundKey: "" + keyPrefix + key,
      key,
      value
    }, _b[GRID_GROUP_CHECK] = true, _b[GRID_GROUP_LEVEL_KEY] = GRID_GROUP_TYPE.toString() + "_" + groupedBy, _b.childRows = childRows, _b;
  });
};
var customGroupedRows = function(rows, grouping, getChildGroups, rootRows) {
  if (rootRows === void 0) {
    rootRows = rows;
  }
  var groupsGetter = function(currentRows, currentGrouping, prefix) {
    return getCustomGroups(currentRows, currentGrouping, prefix, getChildGroups, rootRows);
  };
  return getGroupRows(rows, grouping, groupsGetter);
};
var customGroupingRowIdGetter = function(getRowId, rows) {
  var firstRow = rows.find(function(row) {
    return !row[GRID_GROUP_CHECK];
  });
  if (!firstRow || getRowId(firstRow) !== void 0) {
    return getRowId;
  }
  var map = new Map(rows.filter(function(row) {
    return !row[GRID_GROUP_CHECK];
  }).map(function(row, rowIndex) {
    return [row, rowIndex];
  }));
  return function(row) {
    return map.get(row);
  };
};
var groupingPanelItems = function(columns, grouping, draftGrouping) {
  var items = draftGrouping.map(function(_a) {
    var columnName = _a.columnName;
    return {
      column: columns.find(function(c) {
        return c.name === columnName;
      }),
      draft: !grouping.some(function(columnGrouping) {
        return columnGrouping.columnName === columnName;
      })
    };
  });
  grouping.forEach(function(_a, index) {
    var columnName = _a.columnName;
    if (draftGrouping.some(function(columnGrouping) {
      return columnGrouping.columnName === columnName;
    }))
      return;
    items.splice(index, 0, {
      column: columns.find(function(c) {
        return c.name === columnName;
      }),
      draft: true
    });
  });
  return items;
};
var setCurrentPage = function(prevPage, page) {
  return page;
};
var setPageSize = function(prevPageSize, size) {
  return size;
};
var clamp = function(value, max) {
  return Math.max(Math.min(value, max), 0);
};
var PAGE_HEADERS_OVERFLOW_ERROR = "Max row level exceeds the page size. Consider increasing the page size.";
var paginatedRows = function(rows, pageSize, page) {
  return pageSize ? rows.slice(pageSize * page, pageSize * (page + 1)) : rows;
};
var rowsWithPageHeaders = function(rows, pageSize, getRowLevelKey) {
  if (!pageSize || !getRowLevelKey)
    return rows;
  var result = rows.slice();
  var headerRows = [];
  var currentIndex = 0;
  var _loop_1 = function() {
    var row = result[currentIndex];
    var levelKey = getRowLevelKey(row);
    if (levelKey) {
      var headerIndex = headerRows.findIndex(function(headerRow) {
        return getRowLevelKey(headerRow) === levelKey;
      });
      if (headerIndex === -1) {
        headerRows = __spread(headerRows, [row]);
      } else {
        headerRows = __spread(headerRows.slice(0, headerIndex), [row]);
      }
      if (headerRows.length >= pageSize) {
        throw new Error(PAGE_HEADERS_OVERFLOW_ERROR);
      }
    }
    var indexInPage = currentIndex % pageSize;
    if (indexInPage < headerRows.length && row !== headerRows[indexInPage]) {
      result = __spread(result.slice(0, currentIndex), [
        headerRows[indexInPage]
      ], result.slice(currentIndex));
    }
    currentIndex += 1;
  };
  while (result.length > currentIndex) {
    _loop_1();
  }
  return result;
};
var rowCount = function(rows) {
  return rows.length;
};
var pageCount = function(count, pageSize) {
  return pageSize ? Math.ceil(count / pageSize) : 1;
};
var currentPage = function(page, totalCount, pageSize, setCurrentPage2) {
  var totalPages = pageCount(totalCount, pageSize);
  var adjustedCurrentPage = clamp(page, totalPages - 1);
  if (page !== adjustedCurrentPage) {
    setTimeout(function() {
      return setCurrentPage2(adjustedCurrentPage);
    });
  }
  return adjustedCurrentPage;
};
var firstRowOnPage = function(currentPage2, pageSize, totalCount) {
  if (totalCount === 0) {
    return 0;
  }
  return pageSize ? currentPage2 * pageSize + 1 : 1;
};
var lastRowOnPage = function(currentPage2, pageSize, totalRowCount) {
  var result = totalRowCount;
  if (pageSize) {
    var index = (currentPage2 + 1) * pageSize;
    result = index > totalRowCount ? totalRowCount : index;
  }
  return result;
};
var calculateStartPage = function(currentPage2, maxButtonCount, totalPageCount) {
  return Math.max(Math.min(currentPage2 - Math.floor(maxButtonCount / 2), totalPageCount - maxButtonCount + 1), 1);
};
var toggle = function(source, items, state) {
  var itemsSet = new Set(items);
  var sourceState = state;
  if (sourceState === void 0) {
    var availableSelection = source.filter(function(item) {
      return itemsSet.has(item);
    });
    sourceState = availableSelection.length !== itemsSet.size;
  }
  if (sourceState) {
    var sourceSet_1 = new Set(source);
    return __spread(source, items.filter(function(item) {
      return !sourceSet_1.has(item);
    }));
  }
  return source.filter(function(item) {
    return !itemsSet.has(item);
  });
};
var toggleSelection = function(selection, _a) {
  var rowIds = _a.rowIds, state = _a.state;
  return toggle(selection, rowIds, state);
};
var rowsWithAvailableToSelect = function(rows, getRowId, isGroupRow) {
  var dataRows = rows;
  if (isGroupRow) {
    dataRows = dataRows.filter(function(row) {
      return !isGroupRow(row);
    });
  }
  return { rows, availableToSelect: dataRows.map(function(row) {
    return getRowId(row);
  }) };
};
var someSelected = function(_a, selection) {
  var availableToSelect = _a.availableToSelect;
  var selectionSet = new Set(selection);
  return availableToSelect.length !== 0 && selectionSet.size !== 0 && availableToSelect.some(function(elem) {
    return selectionSet.has(elem);
  }) && availableToSelect.some(function(elem) {
    return !selectionSet.has(elem);
  });
};
var allSelected = function(_a, selection) {
  var availableToSelect = _a.availableToSelect;
  var selectionSet = new Set(selection);
  return selectionSet.size !== 0 && availableToSelect.length !== 0 && !availableToSelect.some(function(elem) {
    return !selectionSet.has(elem);
  });
};
var unwrapSelectedRows = function(_a) {
  var rows = _a.rows;
  return rows;
};
var startEditRows = function(prevEditingRowIds, _a) {
  var rowIds = _a.rowIds;
  return __spread(prevEditingRowIds, rowIds);
};
var stopEditRows = function(prevEditingRowIds, _a) {
  var rowIds = _a.rowIds;
  var rowIdSet = new Set(rowIds);
  return prevEditingRowIds.filter(function(id) {
    return !rowIdSet.has(id);
  });
};
var startEditCells = function(prevEditingCells, _a) {
  var editingCells = _a.editingCells;
  return __spread(prevEditingCells, editingCells);
};
var stopEditCells = function(prevEditingCells, _a) {
  var editingCells = _a.editingCells;
  return prevEditingCells.filter(function(_a2) {
    var rowId = _a2.rowId, columnName = _a2.columnName;
    return !editingCells.some(function(_a3) {
      var currentRowId = _a3.rowId, currentColumnName = _a3.columnName;
      return currentRowId === rowId && currentColumnName === columnName;
    });
  });
};
var addRow = function(addedRows, _a) {
  var _b = _a === void 0 ? { row: {} } : _a, row = _b.row;
  return __spread(addedRows, [row]);
};
var changeAddedRow = function(addedRows, _a) {
  var rowId = _a.rowId, change = _a.change;
  var result = addedRows.slice();
  result[rowId] = __assign(__assign({}, result[rowId]), change);
  return result;
};
var cancelAddedRows = function(addedRows, _a) {
  var rowIds = _a.rowIds;
  var result = [];
  var indexSet = new Set(rowIds);
  addedRows.forEach(function(row, index) {
    if (!indexSet.has(index)) {
      result.push(row);
    }
  });
  return result;
};
var changeRow = function(prevRowChanges, _a) {
  var _b;
  var rowId = _a.rowId, change = _a.change;
  var prevChange = prevRowChanges[rowId] || {};
  return __assign(__assign({}, prevRowChanges), (_b = {}, _b[rowId] = __assign(__assign({}, prevChange), change), _b));
};
var cancelChanges = function(prevRowChanges, _a) {
  var rowIds = _a.rowIds;
  var result = __assign({}, prevRowChanges);
  rowIds.forEach(function(rowId) {
    delete result[rowId];
  });
  return result;
};
var deleteRows = function(deletedRowIds, _a) {
  var rowIds = _a.rowIds;
  return __spread(deletedRowIds, rowIds);
};
var cancelDeletedRows = function(deletedRowIds, _a) {
  var rowIds = _a.rowIds;
  var rowIdSet = new Set(rowIds);
  return deletedRowIds.filter(function(rowId) {
    return !rowIdSet.has(rowId);
  });
};
var changedRowsByIds = function(changes, rowIds) {
  var result = {};
  rowIds.forEach(function(rowId) {
    result[rowId] = changes[rowId];
  });
  return result;
};
var addedRowsByIds = function(addedRows, rowIds) {
  var rowIdSet = new Set(rowIds);
  var result = [];
  addedRows.forEach(function(row, index) {
    if (rowIdSet.has(index)) {
      result.push(row);
    }
  });
  return result;
};
var defaultCreateRowChange = function(row, value, columnName) {
  var _a;
  return _a = {}, _a[columnName] = value, _a;
};
var createRowChangeGetter = function(createRowChange, columnExtensions) {
  if (createRowChange === void 0) {
    createRowChange = defaultCreateRowChange;
  }
  if (columnExtensions === void 0) {
    columnExtensions = [];
  }
  var map = columnExtensions.reduce(function(acc, columnExtension) {
    if (columnExtension.createRowChange) {
      acc[columnExtension.columnName] = columnExtension.createRowChange;
    }
    return acc;
  }, {});
  return function(row, value, columnName) {
    if (map[columnName]) {
      return map[columnName](row, value, columnName);
    }
    return createRowChange(row, value, columnName);
  };
};
var getRowChange = function(rowChanges, rowId) {
  return rowChanges[rowId] || {};
};
var TABLE_REORDERING_TYPE = Symbol("reordering");
var changeColumnOrder = function(order, _a) {
  var sourceColumnName = _a.sourceColumnName, targetColumnName = _a.targetColumnName;
  var sourceColumnIndex = order.indexOf(sourceColumnName);
  var targetColumnIndex = order.indexOf(targetColumnName);
  var newOrder = slice(order);
  newOrder.splice(sourceColumnIndex, 1);
  newOrder.splice(targetColumnIndex, 0, sourceColumnName);
  return newOrder;
};
var TABLE_DATA_TYPE = Symbol("data");
var TABLE_NODATA_TYPE = Symbol("nodata");
var TABLE_FLEX_TYPE = Symbol("flex");
var orderedColumns = function(tableColumns, order) {
  if (tableColumns === void 0) {
    tableColumns = [];
  }
  return mergeSort(tableColumns, function(a, b) {
    if (a.type !== TABLE_DATA_TYPE || b.type !== TABLE_DATA_TYPE)
      return 0;
    var aPos = order.indexOf(a.column.name);
    var bPos = order.indexOf(b.column.name);
    return aPos - bPos;
  });
};
var tableHeaderRowsWithReordering = function(tableHeaderRows2) {
  return __spread(tableHeaderRows2, [
    {
      key: TABLE_REORDERING_TYPE.toString(),
      type: TABLE_REORDERING_TYPE,
      height: 0
    }
  ]);
};
var draftOrder = function(order, sourceColumnIndex, targetColumnIndex) {
  if (sourceColumnIndex === -1 || targetColumnIndex === -1 || sourceColumnIndex === targetColumnIndex) {
    return order;
  }
  var result = slice(order);
  var sourceColumn = order[sourceColumnIndex];
  result.splice(sourceColumnIndex, 1);
  result.splice(targetColumnIndex, 0, sourceColumn);
  return result;
};
var getColumnWidth = function(columnWidths, name, _a) {
  var columnName = _a.columnName, cachedWidths = _a.cachedWidths, shift = _a.shift, minColumnWidth = _a.minColumnWidth, maxColumnWidth = _a.maxColumnWidth, _b = _a.columnExtensions, columnExtensions = _b === void 0 ? [] : _b;
  var change = name === columnName ? shift : -shift;
  var column = columnWidths.find(function(elem) {
    return elem.columnName === name;
  });
  var extension = columnExtensions.find(function(elem) {
    return elem.columnName === name;
  });
  var width = typeof column.width === "number" ? column.width : cachedWidths[name];
  var minWidth = extension && extension.minWidth >= 0 ? extension.minWidth : minColumnWidth;
  var maxWidth = extension && extension.maxWidth >= 0 ? extension.maxWidth : maxColumnWidth;
  var size = Math.max(minWidth, Math.min(width + change, maxWidth));
  return { width, size };
};
var getColumnSizes = function(columnWidths, payload) {
  var columnName = payload.columnName, nextColumnName2 = payload.nextColumnName, resizingMode = payload.resizingMode, shift = payload.shift;
  var _a = getColumnWidth(columnWidths, columnName, payload), width = _a.width, size = _a.size;
  if (resizingMode === "nextColumn") {
    var _b = getColumnWidth(columnWidths, nextColumnName2, payload), nextWidth = _b.width, nextSize = _b.size;
    if (size + nextSize !== width + nextWidth) {
      var moreThanLimit = size + nextSize > width + nextWidth;
      var columnExpand = shift > 0;
      if (moreThanLimit !== columnExpand) {
        return { size, nextSize: width + nextWidth - size };
      }
      return { size: width + nextWidth - nextSize, nextSize };
    }
    return { size, nextSize };
  }
  return { size };
};
var isValidValue = function(value, validUnits) {
  var numb = parseInt(value, 10);
  var unit = numb ? value.substr(numb.toString().length) : value;
  var sizeIsAuto = isNaN(numb) && unit === "auto";
  var sizeIsValid = numb >= 0 && validUnits.some(function(validUnit) {
    return validUnit === unit;
  });
  return sizeIsAuto || sizeIsValid;
};
var convertWidth = function(value) {
  if (typeof value === "string") {
    var numb = parseInt(value, 10);
    if (value.substr(numb.toString().length).length > 0) {
      return value;
    }
    return numb;
  }
  return value;
};
var VALID_UNITS = ["px", "%", "em", "rem", "vm", "vh", "vmin", "vmax", ""];
var NOT_FOR_WIDGET_UNITS = ["%"];
var COLUMN_RESIZING_ERROR = "The columnWidths property of the TableColumnResizing plugin is given an invalid value.";
var specifyWidths = function(tableColumns, widths, resizingMode, onError) {
  if (resizingMode !== "widget" && resizingMode !== "nextColumn") {
    onError();
  }
  if (!widths.length)
    return tableColumns;
  return tableColumns.reduce(function(acc, tableColumn) {
    if (tableColumn.type === TABLE_DATA_TYPE) {
      var columnName_1 = tableColumn.column.name;
      var column = widths.find(function(el) {
        return el.columnName === columnName_1;
      });
      var width = column && column.width;
      if (typeof width !== "number") {
        if (width === void 0) {
          onError();
        } else if (!isValidValue(width, VALID_UNITS)) {
          onError();
        } else if (resizingMode === "widget" && isValidValue(width, NOT_FOR_WIDGET_UNITS)) {
          onError();
        }
      } else if (width < 0) {
        onError();
      }
      if (width === void 0) {
        acc.push(tableColumn);
      } else {
        acc.push(__assign(__assign({}, tableColumn), { width: convertWidth(width) }));
      }
    } else {
      acc.push(tableColumn);
    }
    return acc;
  }, []);
};
var tableColumnsWithWidths = function(tableColumns, columnWidths, resizingMode) {
  return specifyWidths(tableColumns, columnWidths, resizingMode, throwError);
};
var tableColumnsWithDraftWidths = function(tableColumns, draftColumnWidths, resizingMode) {
  return specifyWidths(tableColumns, draftColumnWidths, resizingMode, function() {
  });
};
var throwError = function() {
  throw new Error(COLUMN_RESIZING_ERROR);
};
var changeTableColumnWidth = function(state, payload) {
  var columnWidths = state.columnWidths;
  var columnName = payload.columnName, nextColumnName2 = payload.nextColumnName, resizingMode = payload.resizingMode;
  var nextColumnWidth = slice(columnWidths);
  var index = nextColumnWidth.findIndex(function(elem) {
    return elem.columnName === columnName;
  });
  var nextIndex = nextColumnWidth.findIndex(function(elem) {
    return elem.columnName === nextColumnName2;
  });
  var _a = getColumnSizes(columnWidths, payload), size = _a.size, nextSize = _a.nextSize;
  nextColumnWidth.splice(index, 1, { columnName, width: size });
  if (resizingMode === "nextColumn") {
    nextColumnWidth.splice(nextIndex, 1, { columnName: nextColumnName2, width: nextSize });
  }
  return {
    columnWidths: nextColumnWidth
  };
};
var draftTableColumnWidth = function(state, payload) {
  var columnWidths = state.columnWidths;
  var columnName = payload.columnName, nextColumnName2 = payload.nextColumnName, resizingMode = payload.resizingMode;
  var _a = getColumnSizes(columnWidths, payload), size = _a.size, nextSize = _a.nextSize;
  if (resizingMode === "nextColumn") {
    return { draftColumnWidths: [
      { columnName, width: size },
      { columnName: nextColumnName2, width: nextSize }
    ] };
  }
  return { draftColumnWidths: [{ columnName, width: size }] };
};
var cancelTableColumnWidthDraft = function() {
  return {
    draftColumnWidths: []
  };
};
var TABLE_EDIT_COMMAND_TYPE = Symbol("editCommand");
var TABLE_ADDED_TYPE = Symbol("added");
var TABLE_EDIT_TYPE = Symbol("edit");
var TABLE_HEADING_TYPE = Symbol("heading");
var isHeadingEditCommandsTableCell = function(tableRow, tableColumn) {
  return tableRow.type === TABLE_HEADING_TYPE && tableColumn.type === TABLE_EDIT_COMMAND_TYPE;
};
var isEditCommandsTableCell = function(tableRow, tableColumn) {
  return (tableRow.type === TABLE_DATA_TYPE || tableRow.type === TABLE_ADDED_TYPE || tableRow.type === TABLE_EDIT_TYPE) && tableColumn.type === TABLE_EDIT_COMMAND_TYPE;
};
var tableColumnsWithEditing = function(tableColumns, width) {
  return __spread([
    {
      width: convertWidth(width),
      key: TABLE_EDIT_COMMAND_TYPE.toString(),
      type: TABLE_EDIT_COMMAND_TYPE
    }
  ], tableColumns);
};
var isEditTableCell = function(tableRow, tableColumn) {
  return (tableRow.type === TABLE_ADDED_TYPE || tableRow.type === TABLE_EDIT_TYPE) && tableColumn.type === TABLE_DATA_TYPE;
};
var isAddedTableRow = function(tableRow) {
  return tableRow.type === TABLE_ADDED_TYPE;
};
var isEditTableRow = function(tableRow) {
  return tableRow.type === TABLE_EDIT_TYPE;
};
var tableRowsWithEditing = function(tableRows, editingRowIds, addedRows, rowHeight) {
  var rowIds = new Set(editingRowIds);
  var editedTableRows = tableRows.map(function(tableRow) {
    return tableRow.type === TABLE_DATA_TYPE && rowIds.has(tableRow.rowId) ? __assign(__assign({}, tableRow), { type: TABLE_EDIT_TYPE, height: rowHeight }) : tableRow;
  });
  var addedTableRows = addedRows.map(function(row, rowIndex) {
    return {
      row,
      key: TABLE_ADDED_TYPE.toString() + "_" + rowIndex,
      type: TABLE_ADDED_TYPE,
      rowId: rowIndex,
      height: rowHeight
    };
  });
  return __spread(slice(addedTableRows).reverse(), editedTableRows);
};
var rowsWithEditingCells = function(tableBodyRows, editingCells) {
  return tableBodyRows.map(function(row) {
    var rowId = row.rowId, type = row.type;
    if (rowId !== void 0 && type === TABLE_DATA_TYPE && editingCells.some(function(elem) {
      return elem.rowId === rowId;
    })) {
      return __assign(__assign({}, row), { hasEditCell: true });
    }
    return row;
  });
};
var columnsWithEditingCells = function(tableColumns, editingCells) {
  return tableColumns.map(function(tableColumn) {
    var columnName = tableColumn.column ? tableColumn.column.name : void 0;
    if (columnName !== void 0 && editingCells.some(function(elem) {
      return elem.columnName === columnName;
    })) {
      return __assign(__assign({}, tableColumn), { hasEditCell: true });
    }
    return tableColumn;
  });
};
var TABLE_FILTER_TYPE = Symbol("filter");
var DEFAULT_FILTER_OPERATIONS = [
  "contains",
  "notContains",
  "startsWith",
  "endsWith",
  "equal",
  "notEqual"
];
var isFilterTableCell = function(tableRow, tableColumn) {
  return tableRow.type === TABLE_FILTER_TYPE && tableColumn.type === TABLE_DATA_TYPE;
};
var isFilterTableRow = function(tableRow) {
  return tableRow.type === TABLE_FILTER_TYPE;
};
var getColumnFilterOperations = function(getAvailableFilterOperations, columnName) {
  return getAvailableFilterOperations && getAvailableFilterOperations(columnName) || DEFAULT_FILTER_OPERATIONS;
};
var isFilterValueEmpty = function(value) {
  return value === void 0 || !String(value).length;
};
var getSelectedFilterOperation = function(filterOperations, columnName, columnFilter, columnFilterOperations) {
  if (columnFilter && columnFilter.operation) {
    return columnFilter.operation;
  }
  if (filterOperations[columnName]) {
    return filterOperations[columnName];
  }
  return columnFilterOperations[0];
};
var tableHeaderRowsWithFilter = function(headerRows, rowHeight) {
  return __spread(headerRows, [
    { key: TABLE_FILTER_TYPE.toString(), type: TABLE_FILTER_TYPE, height: rowHeight }
  ]);
};
var TABLE_GROUP_TYPE = Symbol("group");
var TABLE_STUB_TYPE = Symbol("stub");
var getVisibleBoundaryWithFixed = function(visibleBoundary, items) {
  return items.reduce(function(acc, item, index) {
    if (item.fixed && (index < visibleBoundary[0] || index > visibleBoundary[1])) {
      acc.push([index, index]);
    }
    return acc;
  }, [visibleBoundary]);
};
var getVisibleBoundary = function(items, viewportStart, viewportSize, getItemSize, offset, itemSize) {
  if (offset === void 0) {
    offset = 0;
  }
  if (itemSize === void 0) {
    itemSize = 0;
  }
  var start = null;
  var end = null;
  var index = 0;
  var beforePosition = offset * itemSize;
  var viewportEnd = viewportStart + viewportSize;
  while (end === null && index < items.length) {
    var item = items[index];
    var afterPosition = beforePosition + getItemSize(item);
    var isVisible = beforePosition >= viewportStart && beforePosition < viewportEnd || afterPosition > viewportStart && afterPosition <= viewportEnd || beforePosition < viewportStart && afterPosition > viewportEnd;
    if (isVisible && start === null) {
      start = index;
    }
    if (!isVisible && start !== null) {
      end = index - 1;
      break;
    }
    index += 1;
    beforePosition = afterPosition;
  }
  if (start !== null && end === null) {
    end = index - 1;
  }
  start = start === null ? 0 : start;
  end = end === null ? 0 : end;
  return [start + offset, end + offset];
};
var getRenderBoundary = function(itemsCount, visibleBoundary, overscan) {
  var _a = __read(visibleBoundary, 2), start = _a[0], end = _a[1];
  start = Math.max(0, start - overscan);
  end = Math.min(itemsCount - 1, end + overscan);
  return [start, end];
};
var getColumnBoundaries = function(columns, left, width, getColumnWidth2) {
  return getVisibleBoundaryWithFixed(getColumnsRenderBoundary(columns.length, getVisibleBoundary(columns, left, width, getColumnWidth2, 0)), columns);
};
var getRowsVisibleBoundary = function(rows, top, height, getRowHeight, offset, rowHeight, isDataRemote) {
  var beforePosition = offset * rowHeight;
  var noVisibleRowsLoaded = rowHeight > 0 && beforePosition + rows.length * rowHeight < top || top < beforePosition;
  var boundaries;
  if (isDataRemote && noVisibleRowsLoaded) {
    var topIndex = Math.round(top / rowHeight);
    boundaries = [topIndex, topIndex];
  } else {
    boundaries = getVisibleBoundary(rows, top, height, getRowHeight, offset, rowHeight);
  }
  return boundaries;
};
var getColumnsRenderBoundary = function(columnCount, visibleBoundary) {
  return getRenderBoundary(columnCount, visibleBoundary, 1);
};
var getRowsRenderBoundary = function(rowsCount, visibleBoundary) {
  return getRenderBoundary(rowsCount, visibleBoundary, 3);
};
var getSpanBoundary = function(items, visibleBoundaries, getItemSpan) {
  return visibleBoundaries.map(function(visibleBoundary) {
    var endIndex = Math.min(visibleBoundary[1], items.length - 1);
    var end = endIndex;
    var start = visibleBoundary[0] <= end ? visibleBoundary[0] : 0;
    for (var index = 0; index <= endIndex; index += 1) {
      var span = getItemSpan(items[index]);
      if (index < visibleBoundary[0] && index + span > visibleBoundary[0]) {
        start = index;
      }
      if (index + (span - 1) > visibleBoundary[1]) {
        end = index + (span - 1);
      }
    }
    return [start, end];
  });
};
var collapseBoundaries = function(itemsCount, visibleBoundaries, spanBoundaries) {
  var breakpoints = /* @__PURE__ */ new Set([0, itemsCount]);
  spanBoundaries.forEach(function(rowBoundaries) {
    return rowBoundaries.forEach(function(boundary) {
      breakpoints.add(boundary[0]);
      breakpoints.add(Math.min(boundary[1] + 1, itemsCount));
    });
  });
  visibleBoundaries.filter(function(boundary) {
    return boundary.every(function(bound) {
      return 0 <= bound && bound < itemsCount;
    });
  }).forEach(function(boundary) {
    for (var point = boundary[0]; point <= boundary[1]; point += 1) {
      breakpoints.add(point);
    }
    if (boundary[1] + 1 < itemsCount) {
      breakpoints.add(boundary[1] + 1);
    }
  });
  var bp = __spread(breakpoints).sort(function(a, b) {
    return a - b;
  });
  var bounds = [];
  for (var i = 0; i < bp.length - 1; i += 1) {
    bounds.push([
      bp[i],
      bp[i + 1] - 1
    ]);
  }
  return bounds;
};
var getColumnsSize = function(columns, startIndex, endIndex, getColumnSize) {
  var size = 0;
  for (var i = startIndex; i <= endIndex; i += 1) {
    size += getColumnSize(columns[i], 0) || 0;
  }
  return size;
};
var getCollapsedColumns = function(columns, visibleBoundaries, boundaries, getColumnWidth2) {
  var collapsedColumns = [];
  boundaries.forEach(function(boundary) {
    var isVisible = visibleBoundaries.reduce(function(acc, visibleBoundary) {
      return acc || visibleBoundary[0] <= boundary[0] && boundary[1] <= visibleBoundary[1];
    }, false);
    if (isVisible) {
      var column = columns[boundary[0]];
      collapsedColumns.push(__assign(__assign({}, column), { width: getColumnWidth2(column) }));
    } else {
      collapsedColumns.push({
        key: TABLE_STUB_TYPE.toString() + "_" + boundary[0] + "_" + boundary[1],
        type: TABLE_STUB_TYPE,
        width: getColumnsSize(columns, boundary[0], boundary[1], getColumnWidth2)
      });
    }
  });
  return collapsedColumns;
};
var getCollapsedRows = function(rows, visibleBoundary, boundaries, getRowHeight, getCells, offset) {
  var collapsedRows = [];
  boundaries.forEach(function(boundary) {
    var isVisible = visibleBoundary[0] <= boundary[0] && boundary[1] <= visibleBoundary[1];
    if (isVisible) {
      var row = rows[boundary[0] - offset];
      collapsedRows.push({
        row,
        cells: getCells(row)
      });
    } else {
      var row = {};
      collapsedRows.push({
        row: {
          key: TABLE_STUB_TYPE.toString() + "_" + boundary[0] + "_" + boundary[1],
          type: TABLE_STUB_TYPE,
          height: getColumnsSize(rows, boundary[0], boundary[1], getRowHeight)
        },
        cells: getCells(row)
      });
    }
  });
  return collapsedRows;
};
var getCollapsedCells = function(columns, spanBoundaries, boundaries, getColSpan) {
  var collapsedCells = [];
  var index = 0;
  var _loop_1 = function() {
    var boundary = boundaries[index];
    var isSpan = spanBoundaries.reduce(function(acc, spanBoundary) {
      return acc || spanBoundary[0] <= boundary[0] && boundary[1] <= spanBoundary[1];
    }, false);
    if (isSpan) {
      var column = columns[boundary[0]];
      var realColSpan = getColSpan(column);
      if (realColSpan + index - 1 !== columns.length) {
        var realColSpanEnd_1 = realColSpan + boundary[0] - 1;
        var colSpanEnd = boundaries.findIndex(function(colSpanBoundary) {
          return colSpanBoundary[0] <= realColSpanEnd_1 && realColSpanEnd_1 <= colSpanBoundary[1];
        });
        collapsedCells.push({
          column,
          colSpan: colSpanEnd - index + 1
        });
      } else {
        collapsedCells.push({
          column,
          colSpan: realColSpan
        });
      }
      index += 1;
    } else {
      collapsedCells.push({
        column: {
          key: TABLE_STUB_TYPE.toString() + "_" + boundary[0] + "_" + boundary[1],
          type: TABLE_STUB_TYPE
        },
        colSpan: 1
      });
      index += 1;
    }
  };
  while (index < boundaries.length) {
    _loop_1();
  }
  return collapsedCells;
};
var getCollapsedGrid = function(_a) {
  var rows = _a.rows, columns = _a.columns, rowsVisibleBoundary = _a.rowsVisibleBoundary, columnsVisibleBoundary = _a.columnsVisibleBoundary, getColumnWidth2 = _a.getColumnWidth, getRowHeight = _a.getRowHeight, getColSpan = _a.getColSpan, totalRowCount = _a.totalRowCount, offset = _a.offset;
  if (!columns.length) {
    return {
      columns: [],
      rows: []
    };
  }
  var boundaries = rowsVisibleBoundary || [0, rows.length - 1 || 1];
  var getSpanBoundaryByRow = function(row) {
    return getSpanBoundary(columns, columnsVisibleBoundary, function(column) {
      return getColSpan(row, column);
    });
  };
  var rowSpanBoundaries = rows.slice(boundaries[0], boundaries[1] + 1).map(function(row) {
    return getSpanBoundaryByRow(row);
  });
  var columnBoundaries = collapseBoundaries(columns.length, columnsVisibleBoundary, rowSpanBoundaries);
  var rowBoundaries = collapseBoundaries(totalRowCount, [boundaries], []);
  return {
    columns: getCollapsedColumns(columns, columnsVisibleBoundary, columnBoundaries, getColumnWidth2),
    rows: getCollapsedRows(rows, boundaries, rowBoundaries, getRowHeight, function(row) {
      return getCollapsedCells(columns, getSpanBoundaryByRow(row), columnBoundaries, function(column) {
        return getColSpan(row, column);
      });
    }, offset)
  };
};
var getColumnWidthGetter = function(tableColumns, tableWidth, minColumnWidth) {
  var colsHavingWidth = tableColumns.filter(function(col) {
    return typeof col.width === "number";
  });
  var columnsWidth = colsHavingWidth.reduce(function(acc, col) {
    return acc + col.width;
  }, 0);
  var autoWidth = (tableWidth - columnsWidth) / (tableColumns.length - colsHavingWidth.length);
  var autoColWidth = Math.max(autoWidth, minColumnWidth);
  return function(column) {
    return column.type === TABLE_FLEX_TYPE ? null : typeof column.width === "number" ? column.width : autoColWidth;
  };
};
var getCollapsedGrids = function(_a) {
  var _b = _a.headerRows, headerRows = _b === void 0 ? [] : _b, _c = _a.bodyRows, bodyRows = _c === void 0 ? [] : _c, _d = _a.footerRows, footerRows = _d === void 0 ? [] : _d, columns = _a.columns, loadedRowsStart2 = _a.loadedRowsStart, totalRowCount = _a.totalRowCount, getCellColSpan = _a.getCellColSpan, viewport = _a.viewport, getRowHeight = _a.getRowHeight, getColumnWidth2 = _a.getColumnWidth;
  var getColSpan = function(tableRow, tableColumn) {
    return getCellColSpan({ tableRow, tableColumn, tableColumns: columns });
  };
  var getCollapsedGridBlock = function(rows, rowsVisibleBoundary, rowCount2, offset) {
    if (rowCount2 === void 0) {
      rowCount2 = rows.length;
    }
    if (offset === void 0) {
      offset = 0;
    }
    return getCollapsedGrid({
      rows,
      columns,
      rowsVisibleBoundary,
      columnsVisibleBoundary: viewport.columns,
      getColumnWidth: getColumnWidth2,
      getRowHeight,
      getColSpan,
      totalRowCount: rowCount2,
      offset
    });
  };
  var headerGrid = getCollapsedGridBlock(headerRows, getRowsRenderBoundary(headerRows.length, viewport.headerRows));
  var bodyGrid = getCollapsedGridBlock(bodyRows, adjustedRenderRowBounds(viewport.rows, bodyRows.length, loadedRowsStart2), totalRowCount || 1, loadedRowsStart2);
  var footerGrid = getCollapsedGridBlock(footerRows, getRowsRenderBoundary(footerRows.length, viewport.footerRows));
  return {
    headerGrid,
    bodyGrid,
    footerGrid
  };
};
var adjustedRenderRowBounds = function(visibleBounds, rowCount2, loadedRowsStart2) {
  var renderRowBoundaries = getRowsRenderBoundary(loadedRowsStart2 + rowCount2, visibleBounds);
  var adjustedInterval = intervalUtil.intersect({ start: renderRowBoundaries[0], end: renderRowBoundaries[1] }, { start: loadedRowsStart2, end: loadedRowsStart2 + rowCount2 });
  return [adjustedInterval.start, adjustedInterval.end];
};
var getGroupIndexByColumn = function(grouping, tableColumn) {
  return grouping.findIndex(function(columnGrouping) {
    return !!tableColumn.column && columnGrouping.columnName === tableColumn.column.name;
  });
};
var isIndentCell = function(tableRow, tableColumn, grouping) {
  if (tableColumn.column && tableRow.row.groupedBy === tableColumn.column.name)
    return false;
  var rowGroupIndex = grouping.findIndex(function(columnGrouping) {
    return columnGrouping.columnName === tableRow.row.groupedBy;
  });
  var columnGroupIndex = getGroupIndexByColumn(grouping, tableColumn);
  return columnGroupIndex < rowGroupIndex;
};
var isGroupTableCell = function(tableRow, tableColumn) {
  return !!(tableRow.type === TABLE_GROUP_TYPE && tableColumn.type === TABLE_GROUP_TYPE && tableColumn.column && tableColumn.column.name === tableRow.row.groupedBy);
};
var isGroupIndentTableCell = function(tableRow, tableColumn, grouping) {
  return tableRow.type === TABLE_GROUP_TYPE && tableColumn.type === TABLE_GROUP_TYPE && isIndentCell(tableRow, tableColumn, grouping);
};
var isGroupIndentStubTableCell = function(tableRow, tableColumn, grouping) {
  return tableRow.type === TABLE_GROUP_TYPE && tableColumn.type === TABLE_STUB_TYPE && isIndentCell(tableRow, tableColumn, grouping);
};
var isGroupTableRow = function(tableRow) {
  return tableRow.type === TABLE_GROUP_TYPE;
};
var isGroupRowOrdinaryCell = function(tableRow, tableColumn) {
  return isGroupTableRow(tableRow) && !isGroupTableCell(tableRow, tableColumn);
};
var columnHasGroupRowSummary = function(tableColumn, groupSummaryItems) {
  return !!(groupSummaryItems && groupSummaryItems.some(function(item) {
    return !item.showInGroupFooter && item.alignByColumn && item.columnName === (tableColumn.column && tableColumn.column.name);
  }));
};
var isRowSummaryCell = function(tableRow, tableColumn, grouping, groupSummaryItems) {
  return columnHasGroupRowSummary(tableColumn, groupSummaryItems) && !isGroupIndentTableCell(tableRow, tableColumn, grouping);
};
var isPreviousCellContainSummary = function(tableRow, tableColumn, tableColumns, grouping, groupSummaryItems) {
  var columnIndex = tableColumns.indexOf(tableColumn);
  return columnIndex > 0 && isRowSummaryCell(tableRow, tableColumns[columnIndex - 1], grouping, groupSummaryItems);
};
var calculateGroupCellIndent = function(tableColumn, grouping, indentWidth) {
  return indentWidth * getGroupIndexByColumn(grouping, tableColumn);
};
var sortAndSpliceColumns = function(tableColumns, firstVisibleColumnIndex) {
  var groupColumns = tableColumns.filter(function(col) {
    return col.type === TABLE_GROUP_TYPE;
  });
  var dataColumns = tableColumns.filter(function(col) {
    return col.type === TABLE_DATA_TYPE;
  });
  var otherColumns = tableColumns.filter(function(col) {
    return col.type !== TABLE_DATA_TYPE && col.type !== TABLE_GROUP_TYPE && col.type !== TABLE_FLEX_TYPE;
  });
  if (firstVisibleColumnIndex) {
    var firstGroupIndex = tableColumns.indexOf(groupColumns[0]);
    otherColumns.splice(0, Math.min(firstVisibleColumnIndex, firstGroupIndex));
  }
  return __spread(groupColumns, otherColumns, dataColumns);
};
var tableColumnsWithDraftGrouping = function(tableColumns, grouping, draftGrouping, showColumnWhenGrouped) {
  return tableColumns.reduce(function(acc, tableColumn) {
    if (tableColumn.type !== TABLE_DATA_TYPE) {
      acc.push(tableColumn);
      return acc;
    }
    var columnName = tableColumn.column && tableColumn.column.name || "";
    var columnGroupingExists = grouping.some(function(columnGrouping) {
      return columnGrouping.columnName === columnName;
    });
    var columnDraftGroupingExists = draftGrouping.some(function(columnGrouping) {
      return columnGrouping.columnName === columnName;
    });
    if (!columnGroupingExists && !columnDraftGroupingExists || showColumnWhenGrouped(columnName)) {
      acc.push(tableColumn);
    } else if (!columnGroupingExists && columnDraftGroupingExists || columnGroupingExists && !columnDraftGroupingExists) {
      acc.push(__assign(__assign({}, tableColumn), { draft: true }));
    }
    return acc;
  }, []);
};
var tableColumnsWithGrouping = function(columns, tableColumns, grouping, draftGrouping, indentColumnWidth, showColumnWhenGrouped) {
  return __spread(grouping.map(function(columnGrouping) {
    var groupedColumn = columns.find(function(column) {
      return column.name === columnGrouping.columnName;
    });
    return {
      key: TABLE_GROUP_TYPE.toString() + "_" + groupedColumn.name,
      type: TABLE_GROUP_TYPE,
      column: groupedColumn,
      width: indentColumnWidth
    };
  }), tableColumnsWithDraftGrouping(tableColumns, grouping, draftGrouping, showColumnWhenGrouped));
};
var tableRowsWithGrouping = function(tableRows, isGroupRow) {
  return tableRows.map(function(tableRow) {
    if (tableRow.type !== TABLE_DATA_TYPE || !isGroupRow(tableRow.row)) {
      return tableRow;
    }
    return __assign(__assign({}, tableRow), { key: TABLE_GROUP_TYPE.toString() + "_" + tableRow.row.compoundKey, type: TABLE_GROUP_TYPE });
  });
};
var isRowLevelSummary = function(groupSummaryItems, colName) {
  return groupSummaryItems.some(function(item) {
    return !item.showInGroupFooter && item.alignByColumn && item.columnName === colName;
  });
};
var groupSummaryChains = function(tableRow, tableColumns, groupSummaryItems, firstVisibleColumnIndex) {
  var captionStarted = false;
  return sortAndSpliceColumns(tableColumns, firstVisibleColumnIndex).reduce(function(acc, col) {
    var colName = col.column && col.column.name;
    var colKey = col.key;
    var isStartOfGroupCaption = col.type === TABLE_GROUP_TYPE && tableRow.row.groupedBy === colName;
    var isIndentColumn = col.type === TABLE_GROUP_TYPE && tableRow.row.groupedBy !== colName && !captionStarted;
    if (isStartOfGroupCaption) {
      captionStarted = true;
    }
    if (isStartOfGroupCaption || isIndentColumn) {
      acc.push([colKey]);
    } else if (groupSummaryItems && isRowLevelSummary(groupSummaryItems, colName)) {
      acc.push([colKey]);
      acc.push([]);
    } else {
      acc[acc.length - 1].push(colKey);
    }
    return acc;
  }, [[]]);
};
var tableGroupCellColSpanGetter = function(getTableCellColSpan, groupSummaryItems, firstVisibleColumnIndex) {
  return function(params) {
    var tableRow = params.tableRow, tableColumns = params.tableColumns, tableColumn = params.tableColumn;
    if (tableRow.type === TABLE_GROUP_TYPE) {
      var colKey_1 = tableColumn.key;
      var chains = groupSummaryChains(tableRow, tableColumns, groupSummaryItems, firstVisibleColumnIndex);
      var chain = chains.find(function(ch) {
        return ch[0] === colKey_1;
      });
      if (chain) {
        return chain.length;
      }
    }
    return getTableCellColSpan(params);
  };
};
var isHeadingTableCell = function(tableRow, tableColumn) {
  return tableRow.type === TABLE_HEADING_TYPE && tableColumn.type === TABLE_DATA_TYPE;
};
var isHeadingTableRow = function(tableRow) {
  return tableRow.type === TABLE_HEADING_TYPE;
};
var findChainByColumnIndex = function(chains, columnIndex) {
  return chains.find(function(chain) {
    return chain.start <= columnIndex && columnIndex < chain.start + chain.columns.length;
  });
};
var splitHeaderColumnChains = function(tableColumnChains, tableColumns, shouldSplitChain, extendChainProps) {
  return tableColumnChains.map(function(row, rowIndex) {
    return row.reduce(function(acc, chain) {
      var currentChain = null;
      chain.columns.forEach(function(col) {
        var column = tableColumns.find(function(c) {
          return c.key === col.key;
        });
        var isNewGroup = shouldSplitChain(currentChain, column, rowIndex);
        if (isNewGroup) {
          var start = currentChain ? currentChain.start + currentChain.columns.length : chain.start;
          acc.push(__assign(__assign(__assign({}, chain), extendChainProps(column)), { start, columns: [] }));
          currentChain = acc[acc.length - 1];
        }
        currentChain.columns.push(column);
      });
      return acc;
    }, []);
  });
};
var generateSimpleChains = function(rows, columns) {
  return rows.map(function() {
    return [{
      columns,
      start: 0
    }];
  });
};
var nextColumnName = function(tableColumns, index) {
  var isNextColumnHasName = index < tableColumns.length - 1 && tableColumns[index + 1].column;
  return isNextColumnHasName ? tableColumns[index + 1].column.name : void 0;
};
var getNextColumnName = function(tableColumns, columnName) {
  var index = tableColumns.findIndex(function(elem) {
    return elem.column && elem.column.name === columnName;
  });
  return index >= 0 ? nextColumnName(tableColumns, index) : void 0;
};
var tableRowsWithHeading = function(headerRows) {
  return __spread([
    { key: TABLE_HEADING_TYPE.toString(), type: TABLE_HEADING_TYPE }
  ], headerRows);
};
var TABLE_BAND_TYPE = Symbol("band");
var BAND_GROUP_CELL = "bandGroupCell";
var BAND_HEADER_CELL = "bandHeaderCell";
var BAND_EMPTY_CELL = "bandEmptyCell";
var BAND_DUPLICATE_RENDER = "bandDuplicateRender";
var BAND_FILL_LEVEL_CELL = "bandFillLevelCell";
var isBandedTableRow = function(tableRow) {
  return tableRow.type === TABLE_BAND_TYPE;
};
var isBandedOrHeaderRow = function(tableRow) {
  return isBandedTableRow(tableRow) || tableRow.type === TABLE_HEADING_TYPE;
};
var isNoDataColumn = function(columnType) {
  return columnType !== TABLE_DATA_TYPE;
};
var getColumnMeta = function(columnName, bands, tableRowLevel, key, level, title, result) {
  if (key === void 0) {
    key = "";
  }
  if (level === void 0) {
    level = 0;
  }
  if (title === void 0) {
    title = null;
  }
  if (result === void 0) {
    result = null;
  }
  return bands.reduce(function(acc, band) {
    if (band.columnName === columnName) {
      return __assign(__assign({}, acc), { title, level, key });
    }
    if (band.children !== void 0) {
      var rowLevelPassed = level > tableRowLevel;
      var bandTitle = rowLevelPassed ? title : band.title;
      var bandKey = rowLevelPassed ? key : key + "_" + bandTitle;
      return getColumnMeta(columnName, band.children, tableRowLevel, bandKey, level + 1, bandTitle, acc);
    }
    return acc;
  }, result || { level, title, key: title });
};
var calculateBand = function(visibleBound, headerChain) {
  if (visibleBound) {
    var bandStart = Math.max(visibleBound[0], headerChain.start);
    var bandEnd = Math.min(visibleBound[1] + 1, headerChain.start + headerChain.columns.length);
    return [bandStart, bandEnd];
  }
  return [headerChain.start, headerChain.start + headerChain.columns.length];
};
var getBandComponent = function(_a, tableHeaderRows2, tableColumns, columnBands, tableHeaderColumnChains, columnVisibleIntervals2, bandLevelsVisibility2) {
  var currentTableColumn = _a.tableColumn, tableRow = _a.tableRow, rowSpan = _a.rowSpan;
  if (rowSpan)
    return { type: BAND_DUPLICATE_RENDER, payload: null };
  var maxLevel = tableHeaderRows2.filter(function(column) {
    return column.type === TABLE_BAND_TYPE;
  }).length + 1;
  var level = tableRow.level;
  var currentRowLevel = level === void 0 ? maxLevel - 1 : level;
  var currentColumnMeta = currentTableColumn.type === TABLE_DATA_TYPE ? getColumnMeta(currentTableColumn.column.name, columnBands, currentRowLevel) : { level: 0, title: "" };
  var currentColumnIndex = tableColumns.findIndex(function(column) {
    return column.key === currentTableColumn.key;
  });
  var levelsCount = bandLevelsVisibility2.length;
  var visibleLevelsCount = bandLevelsVisibility2.filter(Boolean).length;
  if (currentColumnMeta.level < currentRowLevel) {
    var shouldFillLevel = currentRowLevel > 0 && visibleLevelsCount < levelsCount && !bandLevelsVisibility2[currentRowLevel] && currentTableColumn.type === TABLE_STUB_TYPE;
    if (shouldFillLevel) {
      return { type: BAND_FILL_LEVEL_CELL, payload: null };
    }
    return { type: BAND_EMPTY_CELL, payload: null };
  }
  var previousTableColumn = tableColumns[currentColumnIndex - 1];
  var beforeBorder = false;
  if (currentColumnIndex > 0 && currentTableColumn.type === TABLE_DATA_TYPE && isNoDataColumn(previousTableColumn.type)) {
    beforeBorder = true;
  }
  var isStubColumn = currentTableColumn.type === TABLE_STUB_TYPE;
  var isColumnVisible = currentColumnIndex >= 0;
  if (currentColumnMeta.level === currentRowLevel) {
    if (isStubColumn) {
      var cellRowSpan = visibleLevelsCount < levelsCount ? visibleLevelsCount || 1 : maxLevel;
      return {
        type: BAND_FILL_LEVEL_CELL,
        payload: {
          rowSpan: cellRowSpan
        }
      };
    }
    if (isColumnVisible) {
      return {
        type: BAND_HEADER_CELL,
        payload: __assign({ tableRow: tableHeaderRows2.find(function(row) {
          return row.type === TABLE_HEADING_TYPE;
        }), rowSpan: maxLevel - currentRowLevel }, beforeBorder && { beforeBorder })
      };
    }
  }
  if (!isColumnVisible)
    return { type: BAND_EMPTY_CELL, payload: null };
  var currentColumnChain = findChainByColumnIndex(tableHeaderColumnChains[currentRowLevel], currentColumnIndex);
  var columnVisibleBoundary = columnVisibleIntervals2.find(function(_a2) {
    var _b2 = __read(_a2, 2), start = _b2[0], end = _b2[1];
    return start <= currentColumnIndex && currentColumnIndex <= end;
  });
  var _b = __read(calculateBand(columnVisibleBoundary, currentColumnChain), 2), bandStart = _b[0], bandEnd = _b[1];
  if (bandStart < currentColumnIndex) {
    return { type: null, payload: null };
  }
  return {
    type: BAND_GROUP_CELL,
    payload: __assign({ colSpan: bandEnd - bandStart, value: currentColumnMeta.title, column: currentColumnMeta }, beforeBorder && { beforeBorder })
  };
};
var emptyVirtualRows = {
  skip: Number.POSITIVE_INFINITY,
  rows: []
};
var pluckSubarray = function(source, sourceStart, left, right) {
  return source.slice(left - sourceStart, right - sourceStart);
};
var mergeRows = function(rowsInterval, cacheInterval, rows, cacheRows, rowsStart, cacheStart) {
  var breakpoints = [
    rowsInterval.start,
    rowsInterval.end,
    cacheInterval.start,
    cacheInterval.end
  ].filter(function(i2) {
    return 0 <= i2 && i2 < Number.POSITIVE_INFINITY;
  }).sort(function(a, b) {
    return a - b;
  });
  var result = [];
  if (breakpoints.length > 1) {
    for (var i = 0; i < breakpoints.length - 1; i += 1) {
      var left = breakpoints[i];
      var right = breakpoints[i + 1];
      var chunk = rowsInterval.start <= left && right <= rowsInterval.end ? pluckSubarray(rows, rowsStart, left, right) : pluckSubarray(cacheRows, cacheStart, left, right);
      result = result.concat(chunk);
    }
  }
  return {
    skip: breakpoints[0],
    rows: result
  };
};
var correctRequestedRange = function(calculatedRange, referenceIndex, pageSize) {
  var start = calculatedRange.start, end = calculatedRange.end;
  if (start - referenceIndex > pageSize / 2) {
    return { start: start - pageSize, end: start };
  }
  return { start, end };
};
var calculateRequestedRange = function(virtualRows, newRange, pageSize, referenceIndex, isInfiniteScroll) {
  var loadedInterval = intervalUtil.getRowsInterval(virtualRows);
  var isAdjacentPage = Math.abs(loadedInterval.start - newRange.start) < 2 * pageSize;
  if (isAdjacentPage) {
    var calculatedRange = intervalUtil.difference(newRange, loadedInterval);
    if (isInfiniteScroll && calculatedRange !== intervalUtil.empty) {
      return correctRequestedRange(calculatedRange, referenceIndex, pageSize);
    }
    return calculatedRange;
  }
  return newRange;
};
var rowToPageIndex = function(rowIndex, pageSize) {
  return Math.floor(rowIndex / pageSize);
};
var recalculateBounds = function(middleIndex, pageSize, totalCount) {
  var currentPageIndex = rowToPageIndex(middleIndex, pageSize);
  var prevPageIndex = currentPageIndex - 1;
  var nextPageIndex = currentPageIndex + 2;
  var start = Math.max(0, prevPageIndex * pageSize);
  var end = Math.min(nextPageIndex * pageSize, totalCount);
  return {
    start,
    end
  };
};
var trimRowsToInterval = function(virtualRows, targetInterval) {
  var rowsInterval = intervalUtil.getRowsInterval(virtualRows);
  var intersection = intervalUtil.intersect(rowsInterval, targetInterval);
  if (intervalUtil.empty === intersection) {
    return emptyVirtualRows;
  }
  var rows = pluckSubarray(virtualRows.rows, virtualRows.skip, intersection.start, intersection.end);
  return {
    rows,
    skip: intersection.start
  };
};
var getAvailableRowCount = function(isInfiniteScroll, newRowCount, lastRowCount, totalRowCount) {
  return isInfiniteScroll ? Math.min(Math.max(newRowCount, lastRowCount), totalRowCount) : totalRowCount;
};
var getForceReloadInterval = function(virtualRows, pageSize, totalRowCount) {
  var _a = intervalUtil.getRowsInterval(virtualRows), start = _a.start, intervalEnd = _a.end;
  var end = Math.min(Math.max(start + pageSize * 2, intervalEnd), Math.max(start + pageSize * 2, totalRowCount));
  return {
    start,
    end
  };
};
var getRequestMeta = function(referenceIndex, virtualRows, pageSize, totalRowCount, forceReload, isInfiniteScroll) {
  var actualBounds = forceReload ? getForceReloadInterval(virtualRows, pageSize, totalRowCount) : recalculateBounds(referenceIndex, pageSize, totalRowCount);
  var requestedRange = forceReload ? actualBounds : calculateRequestedRange(virtualRows, actualBounds, pageSize, referenceIndex, isInfiniteScroll);
  return { requestedRange, actualBounds };
};
var needFetchMorePages = function(virtualRows, referenceIndex, pageSize) {
  var _a = intervalUtil.getRowsInterval(virtualRows), start = _a.start, end = _a.end;
  var loadCount = end - start;
  var topTriggerIndex = start > 0 ? start + pageSize : 0;
  var bottomTriggerIndex = Math.max(topTriggerIndex + pageSize, end - pageSize * 1.5);
  if (loadCount <= 0) {
    return false;
  }
  return referenceIndex < topTriggerIndex || bottomTriggerIndex < referenceIndex;
};
var getReferenceIndex = function(_a) {
  var _b = __read(_a.rows, 2), top = _b[0], bottom = _b[1];
  return (top + bottom) / 2;
};
var shouldSendRequest = function(_a, requestedPageIndex, requestedEndIndex) {
  var start = _a.start, end = _a.end;
  var loadCount = end - start;
  return (start !== requestedPageIndex || end !== requestedEndIndex) && loadCount > 0;
};
var empty = {
  start: Number.POSITIVE_INFINITY,
  end: Number.NEGATIVE_INFINITY
};
var getRowsInterval = function(r) {
  return r === emptyVirtualRows ? empty : {
    start: r.skip,
    end: r.skip + r.rows.length
  };
};
var getLength = function(a) {
  return a.end - a.start;
};
var intersect = function(a, b) {
  if (a.end < b.start || b.end < a.start) {
    return empty;
  }
  return {
    start: Math.max(a.start, b.start),
    end: Math.min(a.end, b.end)
  };
};
var difference = function(a, b) {
  if (empty === intervalUtil.intersect(a, b)) {
    return a;
  }
  if (b.end < a.end) {
    return {
      start: b.end,
      end: a.end
    };
  }
  if (a.start < b.start) {
    return {
      start: a.start,
      end: b.start
    };
  }
  return empty;
};
var intervalUtil = {
  empty,
  getRowsInterval,
  getLength,
  intersect,
  difference
};
var tableRowsWithBands = function(tableHeaderRows2, columnBands, tableColumns) {
  var tableDataColumns = tableColumns.filter(function(column) {
    return column.type === TABLE_DATA_TYPE;
  });
  var getMaxNestedLevel = function(bands, level, result) {
    if (level === void 0) {
      level = 0;
    }
    if (result === void 0) {
      result = null;
    }
    return bands.reduce(function(acc, column) {
      if (column.children !== void 0) {
        return getMaxNestedLevel(column.children, level + 1, acc);
      }
      var isDataColumn = tableDataColumns.findIndex(function(dataColumn) {
        return !!dataColumn.column && dataColumn.column.name === column.columnName;
      }) > -1;
      if (level > acc.level && isDataColumn) {
        return __assign(__assign({}, acc), { level });
      }
      return acc;
    }, result || { level: 0 });
  };
  var tableBandHeaders = Array.from({
    length: getMaxNestedLevel(columnBands, 0).level
  }).map(function(row, index) {
    return {
      key: TABLE_BAND_TYPE.toString() + "_" + index,
      type: TABLE_BAND_TYPE,
      level: index
    };
  });
  return __spread(tableBandHeaders, tableHeaderRows2);
};
var tableHeaderColumnChainsWithBands = function(tableHeaderRows2, tableColumns, bands) {
  var chains = generateSimpleChains(tableHeaderRows2, tableColumns);
  var maxBandRowIndex = tableHeaderRows2.filter(function(row) {
    return row.type === TABLE_BAND_TYPE;
  }).length;
  var rawBandChains = chains.slice(0, maxBandRowIndex);
  var currentBand = null;
  var shouldSplitChain = function(chain, column, rowIndex) {
    if (rowIndex > maxBandRowIndex)
      return false;
    var columnName = column.column && column.column.name || "";
    currentBand = getColumnMeta(columnName, bands, rowIndex);
    return !chain || chain.key !== currentBand.key;
  };
  var extendChainProps = function() {
    return {
      bandTitle: currentBand === null || currentBand === void 0 ? void 0 : currentBand.title,
      key: currentBand === null || currentBand === void 0 ? void 0 : currentBand.key
    };
  };
  var bandChains = splitHeaderColumnChains(rawBandChains, tableColumns, shouldSplitChain, extendChainProps);
  return __spread(bandChains, chains.slice(maxBandRowIndex));
};
var getBandLevels = function(columnsBands, levels, level) {
  if (levels === void 0) {
    levels = {};
  }
  if (level === void 0) {
    level = 0;
  }
  columnsBands.forEach(function(band) {
    if (band.title) {
      levels[band.title] = level;
    }
    if (band.children) {
      getBandLevels(band.children, levels, level + 1);
    }
  });
  return levels;
};
var columnBandLevels = function(columnsBands) {
  return getBandLevels(columnsBands);
};
var bandLevelsVisibility = function(columnIntervals, tableHeaderColumnChains, bandLevels) {
  var rowsWithBands = tableHeaderColumnChains.filter(function(r) {
    return r.filter(function(ch) {
      return !!ch.bandTitle;
    }).length;
  });
  var visibleIntervals = columnIntervals.map(function(_a) {
    var _b = __read(_a, 2), start = _b[0], end = _b[1];
    return { start, end };
  });
  var isBandChainVisible = function(chain) {
    return visibleIntervals.some(function(interval) {
      return intervalUtil.intersect(interval, { start: chain.start, end: chain.start + chain.columns.length - 1 }) !== intervalUtil.empty;
    });
  };
  var getVisibleBandsByLevel = function(level) {
    return (
      // Note: a visible band level always matches with it's row
      rowsWithBands[level] ? rowsWithBands[level].filter(function(chain) {
        return bandLevels[chain.bandTitle] === level && isBandChainVisible(chain);
      }) : []
    );
  };
  return rowsWithBands.reduce(function(acc, _, index) {
    var rowBands = getVisibleBandsByLevel(index);
    return __spread(acc, [!!rowBands.length]);
  }, []);
};
var columnVisibleIntervals = function(viewport, tableColumns) {
  return viewport ? viewport.columns : [[0, tableColumns.length]];
};
var toggleDetailRowExpanded = function(prevExpanded, _a) {
  var rowId = _a.rowId, state = _a.state;
  return toggle(prevExpanded, [rowId], state);
};
var TABLE_DETAIL_TYPE = Symbol("detail");
var isDetailRowExpanded = function(expandedDetailRowIds, rowId) {
  return expandedDetailRowIds.indexOf(rowId) > -1;
};
var isDetailToggleTableCell = function(tableRow, tableColumn) {
  return tableColumn.type === TABLE_DETAIL_TYPE && tableRow.type === TABLE_DATA_TYPE;
};
var isDetailTableRow = function(tableRow) {
  return tableRow.type === TABLE_DETAIL_TYPE;
};
var isDetailTableCell = function(tableColumn, tableColumns) {
  return tableColumns.indexOf(tableColumn) === 0;
};
var tableRowsWithExpandedDetail = function(tableRows, expandedDetailRowIds, rowHeight) {
  var result = tableRows;
  expandedDetailRowIds.forEach(function(expandedRowId) {
    var rowIndex = result.findIndex(function(tableRow) {
      return tableRow.type === TABLE_DATA_TYPE && tableRow.rowId === expandedRowId;
    });
    if (rowIndex === -1)
      return;
    var insertIndex = rowIndex + 1;
    var _a = result[rowIndex], row = _a.row, rowId = _a.rowId;
    result = __spread(result.slice(0, insertIndex), [
      {
        rowId,
        row,
        key: TABLE_DETAIL_TYPE.toString() + "_" + rowId,
        type: TABLE_DETAIL_TYPE,
        height: rowHeight
      }
    ], result.slice(insertIndex));
  });
  return result;
};
var tableColumnsWithDetail = function(tableColumns, toggleColumnWidth) {
  return __spread([
    { key: TABLE_DETAIL_TYPE.toString(), type: TABLE_DETAIL_TYPE, width: toggleColumnWidth }
  ], tableColumns);
};
var tableDetailCellColSpanGetter = function(getTableCellColSpan) {
  return function(params) {
    var tableRow = params.tableRow, tableColumns = params.tableColumns, tableColumn = params.tableColumn;
    if (tableRow.type === TABLE_DETAIL_TYPE && tableColumns.indexOf(tableColumn) === 0) {
      return tableColumns.length;
    }
    return getTableCellColSpan(params);
  };
};
var TABLE_SELECT_TYPE = Symbol("select");
var isSelectTableCell = function(tableRow, tableColumn) {
  return tableColumn.type === TABLE_SELECT_TYPE && tableRow.type === TABLE_DATA_TYPE;
};
var isSelectAllTableCell = function(tableRow, tableColumn) {
  return tableColumn.type === TABLE_SELECT_TYPE && tableRow.type === TABLE_HEADING_TYPE;
};
var isRowHighlighted = function(highlightRow, selection, tableRow, focused) {
  var highlightion = selection ? selection.concat(focused || []) : focused;
  return !!(highlightRow && highlightion && highlightion.includes(tableRow.rowId));
};
var tableColumnsWithSelection = function(tableColumns, selectionColumnWidth, showSelectionColumn) {
  if (showSelectionColumn) {
    return __spread([
      { key: TABLE_SELECT_TYPE.toString(), type: TABLE_SELECT_TYPE, width: selectionColumnWidth }
    ], tableColumns);
  }
  return tableColumns;
};
var VALID_UNITS$1 = ["px", "%", "em", "rem", "vm", "vh", "vmin", "vmax", ""];
var TABLE_ERROR = "The columnExtension property of the Table plugin is given an invalid value.";
var isDataTableCell = function(tableRow, tableColumn) {
  return tableRow.type === TABLE_DATA_TYPE && tableColumn.type === TABLE_DATA_TYPE;
};
var isHeaderStubTableCell = function(tableRow, headerRows) {
  return headerRows.indexOf(tableRow) > -1;
};
var isDataTableRow = function(tableRow) {
  return tableRow.type === TABLE_DATA_TYPE;
};
var isNoDataTableRow = function(tableRow) {
  return tableRow.type === TABLE_NODATA_TYPE;
};
var isNoDataTableCell = function(tableColumn, tableColumns) {
  return tableColumns.indexOf(tableColumn) === 0;
};
var isStubTableCell = function(tableRow) {
  return tableRow.type === TABLE_STUB_TYPE;
};
var checkTableColumnExtensions = function(columnExtensions) {
  if (columnExtensions) {
    columnExtensions.map(function(column) {
      var width = column.width;
      if (typeof width === "string") {
        if (!isValidValue(width, VALID_UNITS$1)) {
          throw new Error(TABLE_ERROR);
        }
      }
    });
  }
};
var getColumnExtension = function(columnExtensions, columnName) {
  if (!columnExtensions) {
    return {};
  }
  var columnExtension = columnExtensions.find(function(extension) {
    return extension.columnName === columnName;
  });
  if (!columnExtension) {
    return {};
  }
  return columnExtension;
};
var getColumnExtensionValueGetter = function(columnExtensions, extensionName, defaultValue) {
  return function(columnName) {
    if (columnExtensions) {
      var columnExtension = getColumnExtension(columnExtensions, columnName);
      var extensionValue = columnExtension[extensionName];
      return extensionValue !== void 0 ? extensionValue : defaultValue;
    }
    return defaultValue;
  };
};
var tableColumnsWithDataRows = function(columns, columnExtensions) {
  return columns.map(function(column) {
    var name = column.name;
    var columnExtension = getColumnExtension(columnExtensions, name);
    var width = convertWidth(columnExtension.width);
    return {
      column,
      key: TABLE_DATA_TYPE.toString() + "_" + name,
      type: TABLE_DATA_TYPE,
      width,
      align: columnExtension.align,
      wordWrapEnabled: columnExtension.wordWrapEnabled
    };
  });
};
var tableRowsWithDataRows = function(rows, getRowId, isRemoteRowsLoading) {
  return !rows.length && !isRemoteRowsLoading ? [{ key: TABLE_NODATA_TYPE.toString(), type: TABLE_NODATA_TYPE }] : rows.map(function(row, dataIndex) {
    var rowId = getRowId(row);
    return {
      row,
      // dataIndex,
      rowId,
      type: TABLE_DATA_TYPE,
      key: TABLE_DATA_TYPE.toString() + "_" + rowId
    };
  });
};
var tableCellColSpanGetter = function(params) {
  var tableRow = params.tableRow, tableColumns = params.tableColumns, tableColumn = params.tableColumn;
  if (tableRow.type === TABLE_NODATA_TYPE && tableColumns.indexOf(tableColumn) === 0) {
    return tableColumns.length;
  }
  return 1;
};
var visibleTableColumns = function(tableColumns, hiddenColumnNames) {
  if (tableColumns === void 0) {
    tableColumns = [];
  }
  return tableColumns.filter(function(tableColumn) {
    return tableColumn.type !== TABLE_DATA_TYPE || hiddenColumnNames.indexOf(tableColumn.column.name) === -1;
  });
};
var tableDataColumnsExist = function(tableColumns) {
  return tableColumns.some(function(column) {
    return column.type === TABLE_DATA_TYPE;
  });
};
var columnChooserItems = function(columns, hiddenColumnNames) {
  return columns.map(function(column) {
    return {
      column,
      hidden: hiddenColumnNames.indexOf(column.name) !== -1
    };
  });
};
var toggleColumn = function(hiddenColumnNames, columnName) {
  return hiddenColumnNames.indexOf(columnName) === -1 ? __spread(hiddenColumnNames, [columnName]) : hiddenColumnNames.filter(function(hiddenColumn) {
    return hiddenColumn !== columnName;
  });
};
var toggleRowExpanded = function(prevExpanded, _a) {
  var rowId = _a.rowId, state = _a.state;
  return toggle(prevExpanded, [rowId], state);
};
var GRID_TREE_NODE_TYPE = Symbol("treeNode");
var customTreeRowsWithMeta = function(rows, getChildRows) {
  var rowsToProcess = [{ row: null, level: -1 }];
  var treeRows = [];
  var _loop_1 = function() {
    var _a = rowsToProcess.shift(), currentRow = _a.row, level = _a.level;
    var rowIndex = treeRows.findIndex(function(_a2) {
      var row = _a2.row;
      return row === currentRow;
    });
    var nestedRows = (_a = getChildRows(currentRow, rows)) === null || _a === void 0 ? void 0 : _a.map(function(childRow) {
      return {
        row: childRow,
        level: level + 1,
        leaf: !getChildRows(childRow, rows)
      };
    });
    if (nestedRows) {
      if (rowIndex > -1) {
        treeRows.splice.apply(treeRows, __spread([rowIndex + 1, 0], nestedRows));
      } else {
        treeRows.push.apply(treeRows, __spread(nestedRows));
      }
      rowsToProcess.push.apply(rowsToProcess, __spread(nestedRows));
    }
  };
  while (rowsToProcess === null || rowsToProcess === void 0 ? void 0 : rowsToProcess.length) {
    _loop_1();
  }
  var result = treeRows.reduce(function(acc, _a) {
    var row = _a.row, level = _a.level, leaf = _a.leaf;
    acc.rows.push(row);
    acc.treeMeta.push([row, { level, leaf }]);
    return acc;
  }, { rows: [], treeMeta: [] });
  return {
    rows: result.rows,
    treeMeta: new Map(result.treeMeta)
  };
};
var customTreeRowIdGetter = function(getRowId, _a) {
  var rows = _a.rows, treeMeta = _a.treeMeta;
  var firstNestedRowIndex = rows.findIndex(function(row) {
    return treeMeta.get(row).level > 0;
  });
  if (firstNestedRowIndex === -1 || getRowId(rows[firstNestedRowIndex]) !== void 0) {
    return getRowId;
  }
  var map = new Map(rows.map(function(row, rowIndex) {
    return [row, rowIndex];
  }));
  return function(row) {
    return map.get(row);
  };
};
var customTreeRowLevelKeyGetter = function(getRowLevelKey, _a) {
  var treeMeta = _a.treeMeta;
  return function(row) {
    var rowMeta = treeMeta.get(row);
    if (rowMeta !== void 0) {
      return GRID_TREE_NODE_TYPE.toString() + "_" + rowMeta.level;
    }
    return getRowLevelKey && getRowLevelKey();
  };
};
var expandedTreeRows = function(_a, getRowId, expandedRowIds) {
  var rows = _a.rows, treeMeta = _a.treeMeta;
  var expandedRowIdsSet = new Set(expandedRowIds);
  var currentExpanded = true;
  var currentLevel = 0;
  var collapsedRowsMeta = /* @__PURE__ */ new Map();
  var resultRows = [];
  rows.forEach(function(row) {
    var rowMeta = treeMeta.get(row);
    var level = rowMeta && rowMeta.level;
    if (level === void 0 && currentExpanded) {
      resultRows.push(row);
    } else if (!currentExpanded && (level === void 0 || level > currentLevel)) {
      var lastRow = resultRows[resultRows.length - 1];
      var collapsedItems = collapsedRowsMeta.get(lastRow);
      if (!collapsedItems) {
        collapsedItems = [];
        collapsedRowsMeta.set(lastRow, collapsedItems);
      }
      collapsedItems.push(row);
    } else {
      currentExpanded = expandedRowIdsSet.has(getRowId(row));
      currentLevel = level;
      resultRows.push(row);
    }
  });
  return {
    treeMeta,
    collapsedRowsMeta,
    rows: resultRows
  };
};
var collapsedTreeRowsGetter = function(getCollapsedRows2, _a) {
  var collapsedRowsMeta = _a.collapsedRowsMeta;
  return function(row) {
    return collapsedRowsMeta.get(row) || getCollapsedRows2 && getCollapsedRows2(row);
  };
};
var isTreeRowLeafGetter = function(_a) {
  var treeMeta = _a.treeMeta;
  return function(row) {
    var rowMeta = treeMeta.get(row);
    return rowMeta && rowMeta.leaf;
  };
};
var getTreeRowLevelGetter = function(_a) {
  var treeMeta = _a.treeMeta;
  return function(row) {
    var rowMeta = treeMeta.get(row);
    return rowMeta && rowMeta.level;
  };
};
var unwrappedCustomTreeRows = function(_a) {
  var rows = _a.rows;
  return rows;
};
var isTreeTableCell = function(tableRow, tableColumn, forColumnName) {
  return tableRow.type === TABLE_DATA_TYPE && tableColumn.type === TABLE_DATA_TYPE && tableColumn.column.name === forColumnName;
};
var changeSearchValue = function(prevSearchValue, searchValue) {
  return searchValue;
};
var searchFilterExpression = function(searchValue, columns, filterExpression2) {
  var filters = columns.map(function(_a) {
    var name = _a.name;
    return { columnName: name, value: searchValue };
  });
  var selfFilterExpression = { filters, operator: "or" };
  if (!filterExpression2) {
    return selfFilterExpression;
  }
  return {
    operator: "and",
    filters: [filterExpression2, selfFilterExpression]
  };
};
var getAvailableFilterOperationsGetter = function(getAvailableFilterOperations, availableFilterOperations, columnNames) {
  return function(columnName) {
    return columnNames.indexOf(columnName) > -1 && availableFilterOperations || typeof getAvailableFilterOperations === "function" && getAvailableFilterOperations(columnName) || void 0;
  };
};
var FIXED_COLUMN_LEFT_SIDE = "left";
var FIXED_COLUMN_RIGHT_SIDE = "right";
var TABLE_FIXED_TYPE = Symbol("fixed");
var getFixedColumnKeys = function(tableColumns, fixedNames) {
  return tableColumns.filter(function(tableColumn) {
    return tableColumn.type === TABLE_DATA_TYPE && fixedNames.indexOf(tableColumn.column.name) !== -1 || fixedNames.indexOf(tableColumn.type) !== -1;
  }).map(function(_a) {
    var key = _a.key;
    return key;
  });
};
var isFixedTableRow = function(tableRow) {
  return tableRow.type === TABLE_FIXED_TYPE;
};
var calculatePosition = function(array, index, tableColumnDimensions) {
  return index === 0 ? 0 : array.slice(0, index).reduce(function(acc, target) {
    return acc + tableColumnDimensions[target] || 0;
  }, 0);
};
var calculateFixedColumnProps = function(_a, _b, tableColumns, tableColumnDimensions, tableHeaderColumnChains) {
  var tableColumn = _a.tableColumn;
  var leftColumns = _b.leftColumns, rightColumns = _b.rightColumns;
  var side2 = tableColumn.fixed;
  var targetArray = side2 === FIXED_COLUMN_LEFT_SIDE ? getFixedColumnKeys(tableColumns, leftColumns) : slice(getFixedColumnKeys(tableColumns, rightColumns)).reverse();
  var index = tableColumns.findIndex(function(_a2) {
    var key = _a2.key;
    return key === tableColumn.key;
  });
  var fixedIndex = targetArray.indexOf(tableColumn.key);
  var columnChain = findChainByColumnIndex(tableHeaderColumnChains[0], index);
  var showLeftDivider = columnChain.start === index && index !== 0;
  var showRightDivider = columnChain.start + columnChain.columns.length - 1 === index && index < tableColumns.length - 1;
  var position = calculatePosition(targetArray, fixedIndex, tableColumnDimensions);
  return {
    showRightDivider,
    showLeftDivider,
    position,
    side: side2
  };
};
var tableColumnsWithFixed = function(tableColumns, leftColumns, rightColumns) {
  return tableColumns.map(function(tableColumn) {
    var fixed;
    if (tableColumn.type === TABLE_DATA_TYPE && leftColumns.indexOf(tableColumn.column.name) !== -1 || leftColumns.indexOf(tableColumn.type) !== -1) {
      fixed = FIXED_COLUMN_LEFT_SIDE;
    }
    if (tableColumn.type === TABLE_DATA_TYPE && rightColumns.indexOf(tableColumn.column.name) !== -1 || rightColumns.indexOf(tableColumn.type) !== -1) {
      fixed = FIXED_COLUMN_RIGHT_SIDE;
    }
    return fixed ? __assign(__assign({}, tableColumn), { fixed }) : tableColumn;
  });
};
var tableHeaderRowsWithFixed = function(tableHeaderRows2) {
  return __spread(tableHeaderRows2, [
    { key: TABLE_FIXED_TYPE.toString(), type: TABLE_FIXED_TYPE, height: 0 }
  ]);
};
var tableHeaderColumnChainsWithFixed = function(tableHeaderColumnChains, tableHeaderRows2, tableColumns) {
  var chains = tableHeaderColumnChains || generateSimpleChains(tableHeaderRows2, tableColumns);
  var shouldSplitChain = function(currentGroup, column) {
    return !currentGroup || currentGroup.fixed !== column.fixed;
  };
  var extendChainProps = function(column) {
    return {
      fixed: column.fixed
    };
  };
  return splitHeaderColumnChains(chains, tableColumns, shouldSplitChain, extendChainProps);
};
var defaultSummaryCalculators = {
  count: function(rows) {
    return rows.length;
  },
  sum: function(rows, getValue) {
    return rows.reduce(function(acc, row) {
      return acc + getValue(row);
    }, 0);
  },
  max: function(rows, getValue) {
    return rows.length ? rows.reduce(function(acc, row) {
      return Math.max(acc, getValue(row));
    }, -Infinity) : null;
  },
  min: function(rows, getValue) {
    return rows.length ? rows.reduce(function(acc, row) {
      return Math.min(acc, getValue(row));
    }, Infinity) : null;
  },
  avg: function(rows, getValue) {
    return rows.length ? rows.reduce(function(acc, row) {
      return acc + getValue(row);
    }, 0) / rows.length : null;
  }
};
var defaultSummaryCalculator = function(type, rows, getValue) {
  var summaryCalculator = defaultSummaryCalculators[type];
  if (!summaryCalculator) {
    throw new Error("The summary type '" + type + "' is not defined");
  }
  return summaryCalculator(rows, getValue);
};
var rowsSummary = function(rows, summaryItems, getCellValue, calculator) {
  return summaryItems.reduce(function(acc, _a) {
    var type = _a.type, columnName = _a.columnName;
    var getValue = function(row) {
      return getCellValue(row, columnName);
    };
    acc.push(calculator(type, rows, getValue));
    return acc;
  }, []);
};
var expandRows = function(rows, getRowLevelKey, getCollapsedRows2, isGroupRow, includeGroupRow) {
  if (includeGroupRow === void 0) {
    includeGroupRow = false;
  }
  var shouldIncludeRow = includeGroupRow || !isGroupRow ? function() {
    return true;
  } : function(row) {
    return !isGroupRow(row);
  };
  return rows.reduce(function(acc, row) {
    if (getRowLevelKey && getRowLevelKey(row)) {
      if (shouldIncludeRow(row)) {
        acc.push(row);
      }
      var collapsedRows = getCollapsedRows2 && getCollapsedRows2(row);
      if (collapsedRows) {
        acc.push.apply(acc, __spread(collapsedRows));
      }
      return acc;
    }
    acc.push(row);
    return acc;
  }, []);
};
var totalSummaryValues = function(rows, summaryItems, getCellValue, getRowLevelKey, isGroupRow, getCollapsedRows2, calculator) {
  if (calculator === void 0) {
    calculator = defaultSummaryCalculator;
  }
  var plainRows2 = expandRows(rows, getRowLevelKey, getCollapsedRows2, isGroupRow);
  return rowsSummary(plainRows2, summaryItems, getCellValue, calculator);
};
var groupSummaryValues = function(rows, summaryItems, getCellValue, getRowLevelKey, isGroupRow, getCollapsedRows2, calculator) {
  if (calculator === void 0) {
    calculator = defaultSummaryCalculator;
  }
  var levels = [];
  var getLevelIndex = function(levelKey) {
    return levels.findIndex(function(level) {
      return level.levelKey === levelKey;
    });
  };
  var summaries = {};
  var anyRowLevelSummaryExist = summaryItems.some(function(item) {
    return !item.showInGroupFooter;
  });
  var expandedRows = anyRowLevelSummaryExist ? expandRows(rows, getRowLevelKey, getCollapsedRows2, isGroupRow, true) : rows;
  expandedRows.forEach(function(row) {
    var levelKey = getRowLevelKey(row);
    var collapsedRows = getCollapsedRows2 && getCollapsedRows2(row);
    var levelIndex = getLevelIndex(levelKey);
    if (levelIndex > -1) {
      levels.forEach(function(level) {
        summaries[level.row.compoundKey] = rowsSummary(level.rows, summaryItems, getCellValue, calculator);
      });
      levels = levels.slice(0, levelIndex);
    }
    if (isGroupRow(row)) {
      levels.push({
        levelKey,
        row,
        rows: []
      });
      levelIndex = getLevelIndex(levelKey);
    }
    var isCollapsedNestedGroupRow = collapsedRows && levelIndex > 0 && !anyRowLevelSummaryExist;
    var rowsToAppend = !levelKey ? [row] : collapsedRows;
    if (!levelKey || isCollapsedNestedGroupRow) {
      levels.forEach(function(level) {
        var _a;
        (_a = level.rows).push.apply(_a, __spread(rowsToAppend));
      });
    }
  }, {});
  levels.forEach(function(level) {
    summaries[level.row.compoundKey] = rowsSummary(level.rows, summaryItems, getCellValue, calculator);
  });
  return summaries;
};
var treeSummaryValues = function(rows, summaryItems, getCellValue, getRowLevelKey, isGroupRow, getRowId, calculator) {
  if (calculator === void 0) {
    calculator = defaultSummaryCalculator;
  }
  var levels = [];
  var summaries = {};
  rows.forEach(function(row) {
    var levelKey = getRowLevelKey(row);
    if (!levelKey) {
      levels[levels.length - 1].rows.push(row);
      return;
    }
    var levelIndex = levels.findIndex(function(level) {
      return level.levelKey === levelKey;
    });
    if (levelIndex > -1) {
      levels.slice(levelIndex).forEach(function(level) {
        if (level.rows.length) {
          summaries[getRowId(level.row)] = rowsSummary(level.rows, summaryItems, getCellValue, calculator);
        }
      });
      levels = levels.slice(0, levelIndex);
    }
    if (!isGroupRow || !isGroupRow(row)) {
      if (levels.length) {
        levels[levels.length - 1].rows.push(row);
      }
      levels.push({
        levelKey,
        row,
        rows: []
      });
    }
  }, {});
  levels.forEach(function(level) {
    if (level.rows.length) {
      summaries[getRowId(level.row)] = rowsSummary(level.rows, summaryItems, getCellValue, calculator);
    }
  });
  return summaries;
};
var TABLE_TOTAL_SUMMARY_TYPE = Symbol("totalSummary");
var TABLE_GROUP_SUMMARY_TYPE = Symbol("groupSummary");
var TABLE_TREE_SUMMARY_TYPE = Symbol("treeSummary");
var defaultFormatlessSummaries = ["count"];
var isTotalSummaryTableCell = function(tableRow, tableColumn) {
  return tableRow.type === TABLE_TOTAL_SUMMARY_TYPE && tableColumn.type === TABLE_DATA_TYPE;
};
var isGroupSummaryTableCell = function(tableRow, tableColumn) {
  return tableRow.type === TABLE_GROUP_SUMMARY_TYPE && tableColumn.type === TABLE_DATA_TYPE;
};
var isTreeSummaryTableCell = function(tableRow, tableColumn) {
  return tableRow.type === TABLE_TREE_SUMMARY_TYPE && tableColumn.type === TABLE_DATA_TYPE;
};
var isTotalSummaryTableRow = function(tableRow) {
  return tableRow.type === TABLE_TOTAL_SUMMARY_TYPE;
};
var isGroupSummaryTableRow = function(tableRow) {
  return tableRow.type === TABLE_GROUP_SUMMARY_TYPE;
};
var isTreeSummaryTableRow = function(tableRow) {
  return tableRow.type === TABLE_TREE_SUMMARY_TYPE;
};
var getColumnSummaries = function(summaryItems, columnName, summaryValues, predicate) {
  if (predicate === void 0) {
    predicate = function() {
      return true;
    };
  }
  return summaryItems.map(function(item, index) {
    return [item, index];
  }).filter(function(_a) {
    var _b = __read(_a, 1), item = _b[0];
    return item.columnName === columnName && predicate(item);
  }).map(function(_a) {
    var _b = __read(_a, 2), item = _b[0], index = _b[1];
    return {
      type: item.type,
      value: summaryValues[index]
    };
  });
};
var isFooterSummary = function(summaryItem) {
  return summaryItem.showInGroupFooter;
};
var isInlineGroupCaptionSummary = function(summaryItem) {
  return !(summaryItem.showInGroupFooter || summaryItem.alignByColumn);
};
var groupFooterSummaryExists = function(groupSummaryItems) {
  return groupSummaryItems === null || groupSummaryItems === void 0 ? void 0 : groupSummaryItems.some(isFooterSummary);
};
var getGroupInlineSummaries = function(summaryItems, columns, summaryValues) {
  if (!summaryItems.some(isInlineGroupCaptionSummary)) {
    return [];
  }
  return columns.reduce(function(acc, column) {
    var colName = column.name;
    var summaries = getColumnSummaries(summaryItems, colName, summaryValues, isInlineGroupCaptionSummary);
    if (summaries.length) {
      acc.push({
        column,
        summaries
      });
    }
    return acc;
  }, []);
};
var tableRowsWithTotalSummaries = function(footerRows) {
  return __spread([
    { key: TABLE_TOTAL_SUMMARY_TYPE.toString(), type: TABLE_TOTAL_SUMMARY_TYPE }
  ], footerRows);
};
var tableRowsWithSummaries = function(tableRows, groupSummaryItems, treeSummaryItems, getRowLevelKey, isGroupRow, getRowId) {
  var hasGroupFooterSummary = groupFooterSummaryExists(groupSummaryItems);
  if (!getRowLevelKey || !(hasGroupFooterSummary || treeSummaryItems.length))
    return tableRows;
  var result = [];
  var closeLevel = function(level) {
    if (!level.opened)
      return;
    if (hasGroupFooterSummary && isGroupRow && isGroupRow(level.row)) {
      var compoundKey = level.row.compoundKey;
      result.push({
        key: TABLE_GROUP_SUMMARY_TYPE.toString() + "_" + compoundKey,
        type: TABLE_GROUP_SUMMARY_TYPE,
        row: level.row
      });
    } else if (treeSummaryItems.length) {
      var rowId = getRowId(level.row);
      result.push({
        key: TABLE_TREE_SUMMARY_TYPE.toString() + "_" + rowId,
        type: TABLE_TREE_SUMMARY_TYPE,
        row: level.row
      });
    }
  };
  var levels = [];
  tableRows.forEach(function(tableRow) {
    var row = tableRow.row;
    var levelKey = getRowLevelKey(row);
    if (levelKey) {
      var levelIndex = levels.findIndex(function(level) {
        return level.levelKey === levelKey;
      });
      if (levelIndex > -1) {
        levels.slice(levelIndex).reverse().forEach(closeLevel);
        levels = levels.slice(0, levelIndex);
      }
      if (!isGroupRow || !isGroupRow(row)) {
        levels = levels.map(function(level) {
          return __assign(__assign({}, level), { opened: true });
        });
      }
      levels.push({
        levelKey,
        row,
        opened: false
      });
    } else {
      levels = levels.map(function(level) {
        return __assign(__assign({}, level), { opened: true });
      });
    }
    result.push(tableRow);
  });
  levels.slice().reverse().forEach(closeLevel);
  return result;
};
var prepareGroupSummaryItems = function(items) {
  return !!items ? items.map(function(item) {
    return __assign(__assign({}, item), { showInGroupFooter: item.showInGroupFooter === void 0 && !item.alignByColumn ? true : item.showInGroupFooter });
  }) : items;
};
var HEADING_TYPE = TABLE_HEADING_TYPE.toString();
var FILTER_TYPE = TABLE_FILTER_TYPE.toString();
var DATA_TYPE = TABLE_DATA_TYPE.toString();
var BAND_TYPE = TABLE_BAND_TYPE.toString();
var TOTAL_SUMMARY_TYPE = TABLE_TOTAL_SUMMARY_TYPE.toString();
var STUB_TYPE = TABLE_STUB_TYPE.toString();
var GROUP_TYPE = TABLE_GROUP_TYPE.toString();
var tableParts = [HEADING_TYPE, FILTER_TYPE, DATA_TYPE, TOTAL_SUMMARY_TYPE];
var getIndex = function(arr, key) {
  return arr.findIndex(function(el) {
    return el.key === key;
  });
};
var isSpanInput = function(innerElements) {
  return innerElements[0].tagName === "SPAN" || innerElements[0].tagName === "INPUT" && innerElements[0].type === "text";
};
var isDefined = function(value) {
  return value !== void 0;
};
var hasInsideElements = function(innerElements, focusedElementIndex) {
  if (innerElements.length && focusedElementIndex === void 0 || isDefined(focusedElementIndex) && focusedElementIndex < innerElements.length - 1) {
    if (innerElements.length === 1 && focusedElementIndex === void 0) {
      return !isSpanInput(innerElements);
    }
    return true;
  }
  return false;
};
var getIndexInnerElement = function(elements, rowKey, columnKey, direction) {
  var innerElements = getInnerElements(elements, rowKey, columnKey);
  var index = direction > 0 ? 0 : innerElements.length - 1;
  return cellEmptyOrHasSpanAndInput(elements, rowKey, columnKey) ? void 0 : index;
};
var getNextPrevClosestColumnKey = function(tableColumns, columnIndex, rowKey, elements, direction) {
  var columnKey;
  if (direction > 0) {
    for (var i = columnIndex; i <= tableColumns.length - 1; i += 1) {
      if (elements[rowKey][tableColumns[i].key]) {
        columnKey = tableColumns[i].key;
        break;
      }
    }
  } else {
    for (var i = columnIndex; i >= 0; i -= 1) {
      if (elements[rowKey][tableColumns[i].key]) {
        columnKey = tableColumns[i].key;
        break;
      }
    }
  }
  return columnKey;
};
var shouldBeScrolled = function(elements, key1, key2, scrollToColumn) {
  if (scrollToColumn && !elements[key1][key2]) {
    return Object.keys(elements[key1]).some(function(column) {
      return column.includes(STUB_TYPE);
    });
  }
  return false;
};
var convertPart = function(part, elements, tableBodyRows) {
  if (part === DATA_TYPE && elements[tableBodyRows[0].key]) {
    return DATA_TYPE;
  }
  if (elements[part]) {
    return part;
  }
  return;
};
var getLastPart = function(elements, tableBodyRows, partIndex) {
  var index = partIndex || tableParts.length;
  var part;
  do {
    index = index - 1;
    part = convertPart(tableParts[index], elements, tableBodyRows);
  } while (index > 0 && !part);
  return part;
};
var getRowKey = function(part, key, headerRowKey) {
  if (headerRowKey && part === HEADING_TYPE) {
    return headerRowKey;
  }
  return part === DATA_TYPE ? key : part;
};
var getPrevPart = function(focusedElement, elements, tableBodyRows) {
  var index = tableParts.findIndex(function(p) {
    return p === focusedElement.part;
  });
  if (index === 0) {
    return;
  }
  return getLastPart(elements, tableBodyRows, index);
};
var getNextPart = function(focusedElement, elements, tableBodyRows) {
  var index = tableParts.findIndex(function(p) {
    return p === focusedElement.part;
  });
  if (index === tableParts.length - 1) {
    return;
  }
  var part = tableParts.find(function(p, i) {
    if (i > index) {
      return convertPart(p, elements, tableBodyRows);
    }
    return false;
  });
  return part;
};
var getCellNextPart = function(focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn) {
  var part = getNextPart(focusedElement, elements, tableBodyRows);
  if (!part) {
    return {};
  }
  var rowKey = getRowKey(part, tableBodyRows[0].key);
  var columnKey = tableColumns[0].key;
  if (shouldBeScrolled(elements, rowKey, columnKey, scrollToColumn)) {
    return {
      element: {
        rowKey,
        columnKey,
        part
      },
      scrolling: "left"
    };
  }
  return {
    element: {
      rowKey,
      columnKey,
      index: getIndexInnerElement(elements, rowKey, columnKey, 1),
      part
    }
  };
};
var getCellPrevPart = function(focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn) {
  var part = getPrevPart(focusedElement, elements, tableBodyRows);
  if (!part) {
    return {};
  }
  var rowKey = getRowKey(part, tableBodyRows[tableBodyRows.length - 1].key);
  var columnKeyIndex = tableColumns.length - 1;
  var columnKey = tableColumns[columnKeyIndex].key;
  if (shouldBeScrolled(elements, rowKey, columnKey, scrollToColumn)) {
    return {
      element: {
        rowKey,
        columnKey,
        part
      },
      scrolling: "right"
    };
  }
  var nextColumnKey = getNextPrevClosestColumnKey(tableColumns, columnKeyIndex, rowKey, elements, -1);
  return {
    element: nextColumnKey ? {
      rowKey,
      columnKey: nextColumnKey,
      index: getIndexInnerElement(elements, rowKey, nextColumnKey, -1),
      part
    } : void 0
  };
};
var getPrevCellFromBody = function(columnIndex, rowIndex, tableColumns, tableBodyRows, focusedElement, elements, scrollToColumn) {
  var prevRowKey = focusedElement.rowKey;
  var prevColumnKey;
  if (columnIndex === 0 && rowIndex === 0) {
    return getCellPrevPart(focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn);
  }
  if (columnIndex === 0) {
    prevRowKey = tableBodyRows[rowIndex - 1].key;
    if (prevRowKey.includes(GROUP_TYPE)) {
      prevColumnKey = getNextPrevClosestColumnKey(tableColumns, tableColumns.length - 1, prevRowKey, elements, -1);
    } else {
      prevColumnKey = tableColumns[tableColumns.length - 1].key;
    }
    if (prevColumnKey && shouldBeScrolled(elements, prevRowKey, prevColumnKey, scrollToColumn)) {
      return {
        element: {
          rowKey: prevRowKey,
          columnKey: prevColumnKey,
          part: focusedElement.part
        },
        scrolling: "right"
      };
    }
  } else {
    prevColumnKey = getNextPrevClosestColumnKey(tableColumns, columnIndex - 1, prevRowKey, elements, -1);
  }
  return {
    element: prevColumnKey ? {
      rowKey: prevRowKey,
      columnKey: prevColumnKey,
      index: getIndexInnerElement(elements, prevRowKey, prevColumnKey, -1),
      part: focusedElement.part
    } : void 0
  };
};
var getPrevCellFromHeading = function(tableHeaderRows2, tableColumns, columnIndex, _a, elements) {
  var rowKey = _a.rowKey, part = _a.part;
  var prevColumnKey;
  var prevRowKey;
  var headIndex = getIndex(tableHeaderRows2, rowKey);
  prevColumnKey = getNextPrevClosestColumnKey(tableColumns, columnIndex - 1, rowKey, elements, -1);
  if (prevColumnKey) {
    return {
      element: {
        columnKey: prevColumnKey,
        rowKey,
        part,
        index: getIndexInnerElement(elements, rowKey, prevColumnKey, -1)
      }
    };
  }
  if (headIndex > 0) {
    var abort = false;
    for (var i = headIndex - 1; i >= 0 && !abort; i -= 1) {
      for (var j = tableColumns.length - 1; j >= 0; j -= 1) {
        if (elements[tableHeaderRows2[i].key][tableColumns[j].key]) {
          prevColumnKey = tableColumns[j].key;
          prevRowKey = tableHeaderRows2[i].key;
          abort = true;
          break;
        }
      }
    }
    if (prevColumnKey && prevRowKey) {
      return {
        element: {
          columnKey: prevColumnKey,
          rowKey: prevRowKey,
          part,
          index: getIndexInnerElement(elements, prevRowKey, prevColumnKey, -1)
        }
      };
    }
  }
  return {};
};
var getPrevElement = function(focusedElement, tableBodyRows, tableColumns, tableHeaderRows2, elements, scrollToColumn) {
  var columnIndex = getIndex(tableColumns, focusedElement.columnKey);
  var rowIndex = getIndex(tableBodyRows, focusedElement.rowKey);
  if (isDefined(focusedElement.index) && focusedElement.index > 0) {
    return { element: __assign(__assign({}, focusedElement), { index: focusedElement.index - 1 }) };
  }
  if (focusedElement.part === DATA_TYPE) {
    return getPrevCellFromBody(columnIndex, rowIndex, tableColumns, tableBodyRows, focusedElement, elements, scrollToColumn);
  }
  if (focusedElement.part === HEADING_TYPE) {
    var cell = getPrevCellFromHeading(tableHeaderRows2, tableColumns, columnIndex, focusedElement, elements);
    if (cell.element) {
      return {
        element: __assign(__assign({}, cell.element), { index: getIndexInnerElement(elements, cell.element.rowKey, cell.element.columnKey, -1) })
      };
    }
    return { element: cell.element };
  }
  if (columnIndex === 0) {
    return getCellPrevPart(focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn);
  }
  var rowKey = focusedElement.part;
  var columnKey = tableColumns[columnIndex - 1].key;
  return {
    element: {
      rowKey,
      columnKey,
      index: getIndexInnerElement(elements, rowKey, columnKey, -1),
      part: focusedElement.part
    }
  };
};
var getNextCellFromBody = function(columnIndex, rowIndex, tableColumns, tableBodyRows, focusedElement, elements, scrollToColumn) {
  var nextRowKey = focusedElement.rowKey;
  var nextColumnKey;
  if (columnIndex === tableColumns.length - 1 && rowIndex === tableBodyRows.length - 1) {
    return getCellNextPart(focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn);
  }
  if (columnIndex === tableColumns.length - 1) {
    nextRowKey = tableBodyRows[rowIndex + 1].key;
    nextColumnKey = tableColumns[0].key;
    if (shouldBeScrolled(elements, nextRowKey, nextColumnKey, scrollToColumn)) {
      return {
        element: {
          rowKey: nextRowKey,
          columnKey: nextColumnKey,
          part: focusedElement.part
        },
        scrolling: "left"
      };
    }
  } else {
    nextColumnKey = getNextPrevClosestColumnKey(tableColumns, columnIndex + 1, nextRowKey, elements, 1);
    if (!nextColumnKey) {
      if (rowIndex === tableBodyRows.length - 1) {
        return getCellNextPart(focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn);
      }
      nextRowKey = tableBodyRows[rowIndex + 1].key;
      nextColumnKey = tableColumns[0].key;
    }
  }
  return {
    element: {
      rowKey: nextRowKey,
      columnKey: nextColumnKey,
      index: getIndexInnerElement(elements, nextRowKey, nextColumnKey, 1),
      part: focusedElement.part
    }
  };
};
var getNextCellFromHeading = function(tableHeaderRows2, tableBodyRows, tableColumns, columnIndex, focusedElement, elements, scrollToColumn) {
  var headIndex = getIndex(tableHeaderRows2, focusedElement.rowKey);
  var nextRowKey;
  var nextColumnKey = getNextPrevClosestColumnKey(tableColumns, columnIndex + 1, focusedElement.rowKey, elements, 1);
  if (nextColumnKey) {
    return {
      element: {
        columnKey: nextColumnKey,
        rowKey: focusedElement.rowKey,
        part: focusedElement.part,
        index: getIndexInnerElement(elements, focusedElement.rowKey, nextColumnKey, 1)
      }
    };
  }
  if (headIndex !== tableHeaderRows2.length - 1) {
    var abort = false;
    for (var i = headIndex + 1; i <= tableHeaderRows2.length - 1 && !abort; i += 1) {
      for (var j = 0; j <= tableColumns.length - 1; j += 1) {
        if (elements[tableHeaderRows2[i].key][tableColumns[j].key]) {
          nextColumnKey = tableColumns[j].key;
          nextRowKey = tableHeaderRows2[i].key;
          abort = true;
          break;
        }
      }
    }
    if (nextColumnKey && nextRowKey) {
      return {
        element: {
          columnKey: nextColumnKey,
          rowKey: nextRowKey,
          part: focusedElement.part,
          index: getIndexInnerElement(elements, nextRowKey, nextColumnKey, 1)
        }
      };
    }
  }
  return getCellNextPart(focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn);
};
var getNextElement = function(focusedElement, tableBodyRows, tableColumns, tableHeaderRows2, elements, scrollToColumn) {
  var innerElements = getInnerElements(elements, focusedElement.rowKey, focusedElement.columnKey);
  var columnIndex = getIndex(tableColumns, focusedElement.columnKey);
  var rowIndex = getIndex(tableBodyRows, focusedElement.rowKey);
  if (hasInsideElements(innerElements, focusedElement.index)) {
    return {
      element: __assign(__assign({}, focusedElement), { index: !isDefined(focusedElement.index) ? 0 : focusedElement.index + 1 })
    };
  }
  if (focusedElement.part === DATA_TYPE) {
    return getNextCellFromBody(columnIndex, rowIndex, tableColumns, tableBodyRows, focusedElement, elements, scrollToColumn);
  }
  if (focusedElement.part === HEADING_TYPE) {
    return getNextCellFromHeading(tableHeaderRows2, tableBodyRows, tableColumns, columnIndex, focusedElement, elements, scrollToColumn);
  }
  if (columnIndex === tableColumns.length - 1) {
    return getCellNextPart(focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn);
  }
  var rowKey = focusedElement.rowKey;
  var columnKey = tableColumns[columnIndex + 1].key;
  return {
    element: {
      rowKey,
      columnKey,
      part: focusedElement.part,
      index: getIndexInnerElement(elements, rowKey, columnKey, 1)
    }
  };
};
var hasCellInput = function(innerElements) {
  return innerElements.length ? innerElements[0].tagName === "INPUT" : false;
};
var cellEmptyOrHasSpanAndInput = function(elements, key1, key2) {
  var innerElements = getInnerElements(elements, key1, key2);
  if (innerElements.length) {
    return isSpanInput(innerElements);
  }
  return true;
};
var getCellRightLeft = function(direction, focusedElement, tableColumns, elements) {
  if (focusedElement.part !== DATA_TYPE) {
    return;
  }
  var columnIndex = getIndex(tableColumns, focusedElement.columnKey);
  if (tableColumns[columnIndex + direction]) {
    var columnKey = getNextPrevClosestColumnKey(tableColumns, columnIndex + direction, focusedElement.rowKey, elements, direction);
    if (columnKey) {
      return {
        rowKey: focusedElement.rowKey,
        columnKey,
        part: focusedElement.part
      };
    }
  }
  return;
};
var getFirstCell = function(elements, tableBodyRows, tableColumns, tableHeaderRows2, scrollToColumn, withInnerElements) {
  var part = tableParts.find(function(p) {
    return convertPart(p, elements, tableBodyRows);
  });
  if (!part) {
    return {};
  }
  var rowKey = getRowKey(part, tableBodyRows[0].key, tableHeaderRows2[0].key);
  var columnKey = tableColumns[0].key;
  if (shouldBeScrolled(elements, rowKey, columnKey, scrollToColumn)) {
    return {
      element: {
        rowKey,
        columnKey,
        part
      },
      scrolling: "left"
    };
  }
  return {
    element: {
      rowKey,
      columnKey,
      index: withInnerElements ? getIndexInnerElement(elements, rowKey, columnKey, 1) : void 0,
      part
    }
  };
};
var getLastCell = function(elements, tableBodyRows, tableColumns) {
  var part = getLastPart(elements, tableBodyRows);
  if (!part) {
    return {};
  }
  var rowKey = getRowKey(part, tableBodyRows[tableBodyRows.length - 1].key);
  var columnKey = getNextPrevClosestColumnKey(tableColumns, tableColumns.length - 1, rowKey, elements, -1);
  return {
    element: columnKey ? {
      rowKey,
      columnKey,
      index: getIndexInnerElement(elements, rowKey, columnKey, 1),
      part
    } : void 0
  };
};
var getToolbarPagingElements = function(elements) {
  return {
    toolbarElements: elements.toolbar && getInnerElements(elements, "toolbar", "none"),
    pagingElements: elements.paging && getInnerElements(elements, "paging", "none").filter(function(el) {
      return !el.hasAttribute("disabled") && el.getAttribute("tabindex") !== "-1";
    })
  };
};
var getFirstCellInLastPart = function(elements, tableBodyRows, tableColumns, scrollToColumn, withInnerElements) {
  var lastPart = getLastPart(elements, tableBodyRows);
  if (lastPart) {
    var columnKey = tableColumns[0].key;
    var rowKey = getRowKey(lastPart, tableBodyRows[0].key);
    if (shouldBeScrolled(elements, rowKey, columnKey, scrollToColumn)) {
      return {
        element: {
          rowKey,
          columnKey,
          part: lastPart
        },
        scrolling: "left"
      };
    }
    return {
      element: {
        columnKey,
        rowKey,
        index: withInnerElements ? getIndexInnerElement(elements, rowKey, columnKey, 1) : void 0,
        part: lastPart
      }
    };
  }
  return {};
};
var applyEnterAction = function(elements, _a, tableColumns, tableBodyRows, focusedElement) {
  var commitChangedRows = _a.commitChangedRows, stopEditCells2 = _a.stopEditCells, startEditCells2 = _a.startEditCells;
  if (!focusedElement) {
    return;
  }
  var innerElements = getInnerElements(elements, focusedElement.rowKey, focusedElement.columnKey);
  var columnIndex = getIndex(tableColumns, focusedElement.columnKey);
  var rowIndex = getIndex(tableBodyRows, focusedElement.rowKey);
  if (focusedElement.part === DATA_TYPE && commitChangedRows) {
    if (focusedElement.index === 0) {
      commitChangedRows({ rowIds: [tableBodyRows[rowIndex].rowId] });
      stopEditCells2({
        editingCells: [{
          rowId: tableBodyRows[rowIndex].rowId,
          columnName: tableColumns[columnIndex].column.name
        }]
      });
      return {
        part: focusedElement.part,
        columnKey: focusedElement.columnKey,
        rowKey: focusedElement.rowKey
      };
    }
    startEditCells2({
      editingCells: [{
        rowId: tableBodyRows[rowIndex].rowId,
        columnName: tableColumns[columnIndex].column.name
      }]
    });
    return {
      part: focusedElement.part,
      columnKey: focusedElement.columnKey,
      rowKey: focusedElement.rowKey,
      index: 0
    };
  }
  if (!isDefined(focusedElement.index) && innerElements.length && isSpanInput(innerElements)) {
    if (innerElements[0].tagName === "SPAN") {
      innerElements[0].click();
    }
    return {
      part: focusedElement.part,
      columnKey: focusedElement.columnKey,
      rowKey: focusedElement.rowKey,
      index: 0
    };
  }
  if (focusedElement.index === 0 && hasCellInput(innerElements)) {
    return {
      part: focusedElement.part,
      columnKey: focusedElement.columnKey,
      rowKey: focusedElement.rowKey
    };
  }
  return;
};
var applyEscapeAction = function(elements, _a, tableColumns, tableBodyRows, focusedElement) {
  var cancelChangedRows = _a.cancelChangedRows, stopEditCells2 = _a.stopEditCells;
  if (!focusedElement) {
    return;
  }
  var innerElements = getInnerElements(elements, focusedElement.rowKey, focusedElement.columnKey);
  var columnIndex = getIndex(tableColumns, focusedElement.columnKey);
  var rowIndex = getIndex(tableBodyRows, focusedElement.rowKey);
  if (focusedElement.index === 0 && hasCellInput(innerElements)) {
    if (focusedElement.part === DATA_TYPE && cancelChangedRows) {
      cancelChangedRows({
        rowIds: [tableBodyRows[rowIndex].rowId]
      });
      stopEditCells2({
        editingCells: [{
          rowId: tableBodyRows[rowIndex].rowId,
          columnName: tableColumns[columnIndex].column.name
        }]
      });
    }
    return {
      part: focusedElement.part,
      columnKey: focusedElement.columnKey,
      rowKey: focusedElement.rowKey
    };
  }
  return;
};
var actionOnCheckbox = function(elements, focusedElement) {
  if (!focusedElement || isDefined(focusedElement.index)) {
    return;
  }
  var el = getInnerElements(elements, focusedElement.rowKey, focusedElement.columnKey, "input").filter(function(element) {
    return element.type === "checkbox";
  });
  if (el[0]) {
    el[0].click();
  }
};
var actionOnTreeMode = function(elements, expandedRowIds, direction, focusedElement) {
  if (!focusedElement || isDefined(focusedElement.index) || !expandedRowIds) {
    return;
  }
  var el = getInnerElements(elements, focusedElement.rowKey, focusedElement.columnKey, "button, i");
  var index = getIndexFromKey(focusedElement.rowKey);
  if (direction > 0 && expandedRowIds.indexOf(index) === -1 || direction < 0 && expandedRowIds.indexOf(index) > -1) {
    if (el[0]) {
      el[0].click();
    }
  }
};
var getInnerElements = function(elements, key1, key2, query) {
  if (query === void 0) {
    query = "[tabIndex], input, button, a";
  }
  return Array.from(elements[key1][key2][0].current.querySelectorAll(query)).filter(function(el) {
    return !el.hasAttribute("disabled") && el.getAttribute("tabindex") !== "-1";
  });
};
var getCellTopBottom = function(direction, focusedElement, tableBodyRows, tableColumns, elements) {
  if (focusedElement.part !== DATA_TYPE) {
    return;
  }
  var columnIndex = getIndex(tableColumns, focusedElement.columnKey);
  var rowIndex = getIndex(tableBodyRows, focusedElement.rowKey);
  if (tableBodyRows[rowIndex + direction]) {
    var columnKey = getNextPrevClosestColumnKey(tableColumns, columnIndex, tableBodyRows[rowIndex + direction].key, elements, -1);
    if (columnKey) {
      return {
        rowKey: tableBodyRows[rowIndex + direction].key,
        columnKey,
        part: focusedElement.part
      };
    }
  }
  return;
};
var isCtrlMetaKey = function(event) {
  return event.ctrlKey || event.metaKey;
};
var getIndexFromKey = function(key) {
  var array = key.split("_");
  return Number(array[array.length - 1]);
};
var getCellNextPrevPart = function(focusedElement, elements, tableBodyRows, tableColumns, direction, scrollToColumn) {
  var part = direction > 0 ? getNextPart(focusedElement, elements, tableBodyRows) : getPrevPart(focusedElement, elements, tableBodyRows);
  if (part) {
    var rowKey = getRowKey(part, tableBodyRows[0].key);
    var columnKey = tableColumns[0].key;
    return {
      element: {
        part,
        rowKey,
        columnKey
      },
      scrolling: shouldBeScrolled(elements, rowKey, columnKey, scrollToColumn) ? "left" : void 0
    };
  }
  return {};
};
var applyFocusOnToolbarPaging = function(elements, direction) {
  if (direction > 0 && elements.paging) {
    getInnerElements(elements, "paging", "none")[0].focus();
  }
  if (direction < 0 && elements.toolbar) {
    getInnerElements(elements, "toolbar", "none")[0].focus();
  }
};
var getClosestCellByRow = function(tableBodyRows, focusedElement, elements) {
  var currentIndex = getIndexFromKey(focusedElement.rowKey);
  var bodyRow = tableBodyRows.find(function(row) {
    return getIndexFromKey(row.key) > currentIndex;
  });
  var rowKey = bodyRow ? bodyRow.key : tableBodyRows[tableBodyRows.length - 1].key;
  var columnKey = focusedElement.columnKey;
  return {
    rowKey,
    columnKey,
    part: focusedElement.part,
    index: getIndexInnerElement(elements, rowKey, columnKey, 1)
  };
};
var getNextFocusedCell = function(tableColumns, tableBodyRows, tableHeaderRows2, expandedRowIds, elements, event, inlineEditing, focusedElement, scrollToColumn) {
  if (!focusedElement) {
    var _a = getToolbarPagingElements(elements), toolbarElements = _a.toolbarElements, pagingElements = _a.pagingElements;
    var hasFocus = function(innerElements) {
      return innerElements.some(function(el) {
        return event.target === el;
      });
    };
    if (isCtrlMetaKey(event)) {
      if (event.key === "ArrowDown" && (toolbarElements && hasFocus(toolbarElements) || !toolbarElements)) {
        return getFirstCell(elements, tableBodyRows, tableColumns, tableHeaderRows2, scrollToColumn);
      }
      if (event.key === "ArrowUp" && (pagingElements && hasFocus(pagingElements) || !pagingElements)) {
        return getFirstCellInLastPart(elements, tableBodyRows, tableColumns, scrollToColumn);
      }
    } else if (event.key === "Tab") {
      if (toolbarElements && event.target === toolbarElements[toolbarElements.length - 1] && !event.shiftKey) {
        return getFirstCell(elements, tableBodyRows, tableColumns, tableHeaderRows2, scrollToColumn, true);
      }
      if (pagingElements && event.target === pagingElements[0] && event.shiftKey) {
        if (scrollToColumn) {
          return getFirstCellInLastPart(elements, tableBodyRows, tableColumns, scrollToColumn, true);
        }
        return getLastCell(elements, tableBodyRows, tableColumns);
      }
      var element = (!event.shiftKey ? getFirstCell(elements, tableBodyRows, tableColumns, tableHeaderRows2, void 0, true) : getLastCell(elements, tableBodyRows, tableColumns)).element;
      if (element && event.target === elements[element.rowKey][element.columnKey][0].current) {
        return { element };
      }
    }
    return {};
  }
  var cell;
  switch (event.key) {
    case "Enter":
      cell = {
        element: applyEnterAction(elements, inlineEditing, tableColumns, tableBodyRows, focusedElement)
      };
      break;
    case "Escape":
      cell = {
        element: applyEscapeAction(elements, inlineEditing, tableColumns, tableBodyRows, focusedElement)
      };
      break;
    case " ":
      actionOnCheckbox(elements, focusedElement);
      break;
    case "Tab":
      if (event.shiftKey) {
        cell = getPrevElement(focusedElement, tableBodyRows, tableColumns, tableHeaderRows2, elements, scrollToColumn);
      } else {
        cell = getNextElement(focusedElement, tableBodyRows, tableColumns, tableHeaderRows2, elements, scrollToColumn);
      }
      break;
    case "ArrowUp":
      if (isCtrlMetaKey(event)) {
        cell = getCellNextPrevPart(focusedElement, elements, tableBodyRows, tableColumns, -1, scrollToColumn);
        if (!cell.element) {
          applyFocusOnToolbarPaging(elements, -1);
        }
      } else {
        cell = {
          element: getCellTopBottom(-1, focusedElement, tableBodyRows, tableColumns, elements)
        };
      }
      break;
    case "ArrowDown":
      if (isCtrlMetaKey(event)) {
        cell = getCellNextPrevPart(focusedElement, elements, tableBodyRows, tableColumns, 1, scrollToColumn);
        if (!cell.element) {
          applyFocusOnToolbarPaging(elements, 1);
        }
      } else {
        cell = {
          element: getCellTopBottom(1, focusedElement, tableBodyRows, tableColumns, elements)
        };
      }
      break;
    case "ArrowLeft":
      if (isCtrlMetaKey(event)) {
        actionOnTreeMode(elements, expandedRowIds, -1, focusedElement);
      } else {
        cell = { element: getCellRightLeft(-1, focusedElement, tableColumns, elements) };
      }
      break;
    case "ArrowRight":
      if (isCtrlMetaKey(event)) {
        actionOnTreeMode(elements, expandedRowIds, 1, focusedElement);
      } else {
        cell = { element: getCellRightLeft(1, focusedElement, tableColumns, elements) };
      }
      break;
  }
  return cell || {};
};
var getPart = function(key) {
  if (tableParts.find(function(t) {
    return t === key;
  })) {
    return key;
  }
  if (key.includes(BAND_TYPE)) {
    return HEADING_TYPE;
  }
  return DATA_TYPE;
};
var getIndexToFocus = function(key1, key2, elements, event, _a, part) {
  var startEditCells2 = _a.startEditCells;
  if (startEditCells2 && part === DATA_TYPE) {
    return 0;
  }
  var innerElements = getInnerElements(elements, key1, key2);
  var index = innerElements.findIndex(function(el) {
    return event.target === el;
  });
  return index !== -1 ? index : void 0;
};
var filterHeaderRows = function(tableHeaderRows2) {
  return tableHeaderRows2.filter(function(row) {
    return row.key.includes(BAND_TYPE) || row.key.includes(HEADING_TYPE);
  });
};
var isRowFocused = function(tableRow, focusedRowKey) {
  if (focusedRowKey) {
    return tableRow.key === focusedRowKey;
  }
  return false;
};
var isCellExist = function(elements, focusedElement) {
  return !!(elements[focusedElement.rowKey] && elements[focusedElement.rowKey][focusedElement.columnKey]);
};
var isTabArrowUpDown = function(event) {
  return event.key === "Tab" || isCtrlMetaKey(event) && (event.key === "ArrowDown" || event.key === "ArrowUp");
};
var focus = function(elements, focusedElement, prevFocusedElement, onFocusedCellChange) {
  if (!focusedElement || !elements[focusedElement.rowKey] || !elements[focusedElement.rowKey][focusedElement.columnKey]) {
    return;
  }
  var el = focusedElement.index === void 0 ? elements[focusedElement.rowKey][focusedElement.columnKey][0] : getInnerElements(elements, focusedElement.rowKey, focusedElement.columnKey)[focusedElement.index];
  if (el) {
    el.focus ? el.focus() : el.current.focus();
    if (onFocusedCellChange && ((prevFocusedElement === null || prevFocusedElement === void 0 ? void 0 : prevFocusedElement.rowKey) !== focusedElement.rowKey || (prevFocusedElement === null || prevFocusedElement === void 0 ? void 0 : prevFocusedElement.columnKey) !== focusedElement.columnKey)) {
      onFocusedCellChange({
        rowKey: focusedElement.rowKey,
        columnKey: focusedElement.columnKey
      });
    }
  }
};
var isCellFocused = function(row, column, focusedElement) {
  if (!focusedElement || isDefined(focusedElement.index)) {
    return false;
  }
  return focusedElement.rowKey === row.key && focusedElement.columnKey === column.key;
};
var getFocusing = function(tableBodyRows, focusedElement) {
  if (!focusedElement) {
    return [];
  }
  var focusedRow = tableBodyRows.find(function(row) {
    return row.key === focusedElement.rowKey;
  });
  return focusedRow ? [focusedRow.rowId] : [];
};
var getTargetColumnGeometries = function(columnGeometries, sourceIndex) {
  var sourceWidth = columnGeometries[sourceIndex].right - columnGeometries[sourceIndex].left;
  var getWidthDifference = function(index) {
    return columnGeometries[index].right - columnGeometries[index].left - sourceWidth;
  };
  return columnGeometries.map(function(_a, targetIndex) {
    var top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left;
    var leftBorder = left;
    if (targetIndex > 0 && targetIndex <= sourceIndex) {
      leftBorder = Math.min(leftBorder, leftBorder - getWidthDifference(targetIndex - 1));
    }
    if (targetIndex > sourceIndex) {
      leftBorder = Math.max(leftBorder, leftBorder + getWidthDifference(targetIndex));
    }
    var rightBorder = right;
    if (targetIndex < columnGeometries.length - 1 && targetIndex >= sourceIndex) {
      rightBorder = Math.max(rightBorder, rightBorder + getWidthDifference(targetIndex + 1));
    }
    if (targetIndex < sourceIndex) {
      rightBorder = Math.min(rightBorder, rightBorder - getWidthDifference(targetIndex));
    }
    return {
      top,
      bottom,
      right: rightBorder,
      left: leftBorder
    };
  });
};
var getCellGeometries = function(node) {
  var _a, _b;
  var _c = node.getBoundingClientRect(), left = _c.left, right = _c.right, width = _c.width;
  var styleLeft = parseInt((_a = node.style.left) === null || _a === void 0 ? void 0 : _a.toString().replace("px", ""), 10);
  var styleRight = parseInt((_b = node.style.right) === null || _b === void 0 ? void 0 : _b.toString().replace("px", ""), 10);
  if (!isNaN(styleLeft)) {
    var calculatedLeft = Math.max(styleLeft, left);
    return {
      left: calculatedLeft,
      right: calculatedLeft + width,
      isFixed: true
    };
  }
  if (!isNaN(styleRight)) {
    var tableContainer = node;
    while (tableContainer && tableContainer.nodeName !== "DIV") {
      tableContainer = tableContainer.parentNode;
    }
    tableContainer = tableContainer === null || tableContainer === void 0 ? void 0 : tableContainer.parentNode;
    if (tableContainer) {
      var tableWidth = tableContainer.getBoundingClientRect().width;
      var calculatedRight = Math.min(tableWidth - styleRight, right);
      return {
        left: calculatedRight - width,
        right: calculatedRight,
        isFixed: true
      };
    }
  }
  return { left, right };
};
var getTableColumnGeometries = function(columns, tableWidth) {
  var columnWidths = columns.map(function(column) {
    return column.width;
  });
  var freeSpace = tableWidth;
  var restrictedSpace = columnWidths.reduce(function(accum, width) {
    return accum + (typeof width === "number" ? width : 0);
  }, 0);
  var freeSpacePortions = columnWidths.reduce(function(accum, width) {
    return accum + (typeof width !== "number" ? 1 : 0);
  }, 0);
  var freeSpacePortion = (freeSpace - restrictedSpace) / freeSpacePortions;
  var lastRightPosition = 0;
  return columnWidths.map(function(width) {
    return typeof width !== "number" ? freeSpacePortion : width;
  }).map(function(width) {
    lastRightPosition += width;
    return {
      left: lastRightPosition - width,
      right: lastRightPosition
    };
  });
};
var getTableTargetColumnIndex = function(columnGeometries, offset) {
  var indexes = columnGeometries.reduce(function(acc, _a, index) {
    var left = _a.left, right = _a.right;
    if (offset >= left && offset < right) {
      acc.push(index);
    }
    return acc;
  }, []);
  if (columnGeometries.some(function(_a) {
    var left = _a.left, right = _a.right;
    return left <= 0 && right <= 0;
  })) {
    if (indexes.some(function(index) {
      return columnGeometries[index].isFixed || columnGeometries[index].left <= 0 && columnGeometries[index].right <= 0;
    })) {
      return -1;
    }
  }
  if (indexes.length === 2) {
    return indexes.find(function(index) {
      return columnGeometries[index].isFixed;
    });
  }
  if (indexes.length === 1) {
    return indexes[0];
  }
  return -1;
};
var ANIMATION_DURATION = 200;
var getAnimationProgress = function(animation) {
  return (new Date().getTime() - animation.startTime) / ANIMATION_DURATION;
};
var getAnimations = function(prevColumns, nextColumns, tableWidth, prevAnimations) {
  var resizing = prevColumns.map(function(column) {
    return column.key;
  }).join() === nextColumns.map(function(column) {
    return column.key;
  }).join();
  var prevColumnGeometries = new Map(getTableColumnGeometries(prevColumns, tableWidth).map(function(geometry, index) {
    return [prevColumns[index].key, geometry];
  }).map(function(_a) {
    var _b = __read(_a, 2), key = _b[0], geometry = _b[1];
    var animation = prevAnimations.get(key);
    if (!animation)
      return [key, geometry];
    var progress = easeOutCubic(getAnimationProgress(animation));
    var _c = animation.left, to = _c.to, from = _c.from;
    var left = (to - from) * progress + from;
    return [key, {
      left,
      right: geometry.right - (geometry.left - left)
    }];
  }));
  var nextColumnGeometries = new Map(getTableColumnGeometries(nextColumns, tableWidth).map(function(geometry, index) {
    return [nextColumns[index].key, geometry];
  }));
  return new Map(__spread(nextColumnGeometries.keys()).map(function(key) {
    var prev = prevColumnGeometries.get(key);
    var next = nextColumnGeometries.get(key);
    var result = { startTime: new Date().getTime(), style: {} };
    var takePrevColumnIntoAccount = !!prevAnimations.get(key) || prev && !resizing;
    if (Math.abs((takePrevColumnIntoAccount ? prev.left : next.left) - next.left) > 1) {
      result.left = { from: prev.left, to: next.left };
    }
    return [key, result];
  }).filter(function(animation) {
    return animation[1].left;
  }));
};
var filterActiveAnimations = function(animations) {
  return new Map(__spread(animations.entries()).filter(function(_a) {
    var _b = __read(_a, 2), animation = _b[1];
    return getAnimationProgress(animation) < 1;
  }));
};
var evalAnimations = function(animations) {
  return new Map(__spread(animations.entries()).map(function(_a) {
    var _b = __read(_a, 2), key = _b[0], animation = _b[1];
    var progress = easeOutCubic(getAnimationProgress(animation));
    var result = __assign({}, animation.style);
    if (animation.left) {
      var offset = (animation.left.to - animation.left.from) * (progress - 1);
      result.transform = "translateX(" + offset + "px)";
    }
    return [key, result];
  }));
};
var isOnTheSameLine = function(geometry, y) {
  return y >= geometry.top && y <= geometry.bottom;
};
var rectToObject = function(_a) {
  var top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left;
  return {
    top,
    right,
    bottom,
    left
  };
};
var collapseGapsBetweenItems = function(geometries) {
  return geometries.map(function(geometry, index) {
    if (index !== geometries.length - 1 && geometry.top === geometries[index + 1].top) {
      return __assign(__assign({}, geometry), { right: geometries[index + 1].left });
    }
    return geometry;
  });
};
var getGroupCellTargetIndex = function(geometries, sourceIndex, _a) {
  var x = _a.x, y = _a.y;
  if (geometries.length === 0)
    return 0;
  var targetGeometries = sourceIndex !== -1 ? getTargetColumnGeometries(geometries, sourceIndex) : geometries.map(rectToObject);
  var targetIndex = collapseGapsBetweenItems(targetGeometries).findIndex(function(geometry, index) {
    var inVerticalBounds = isOnTheSameLine(geometry, y);
    var inHorizontalBounds = x >= geometry.left && x <= geometry.right;
    var shouldGoFirst = index === 0 && x < geometry.left;
    var shouldGoOnLineBreak = !inVerticalBounds && !!geometries[index - 1] && isOnTheSameLine(geometries[index - 1], y);
    return inVerticalBounds && inHorizontalBounds || shouldGoFirst || shouldGoOnLineBreak;
  });
  return targetIndex === -1 ? geometries.length : targetIndex;
};
var arraysEqual = function(arrA, arrB, comparator) {
  if (comparator === void 0) {
    comparator = function(a, b) {
      return a === b;
    };
  }
  if (arrA.length !== arrB.length) {
    return false;
  }
  for (var i = 0; i < arrA.length; i += 1) {
    if (!comparator(arrA[i], arrB[i])) {
      return false;
    }
  }
  return true;
};
var TOP_POSITION = Symbol("top");
var BOTTOM_POSITION = Symbol("bottom");
var LEFT_POSITION = Symbol("left");
var RIGHT_POSITION = Symbol("right");
var VALID_UNITS$2 = ["px", ""];
var VIRTUAL_TABLE_ERROR = "The columnExtension property of the VirtualTable plugin is given an invalid value.";
var getViewport = function(state, getters, estimatedRowHeight, getRowHeight, getColumnWidth2) {
  var viewportTop = state.viewportTop, viewportLeft = state.viewportLeft, containerWidth = state.containerWidth, containerHeight = state.containerHeight;
  var loadedRowsStart2 = getters.loadedRowsStart, tableBodyRows = getters.bodyRows, tableColumns = getters.columns, _a = getters.headerRows, tableHeaderRows2 = _a === void 0 ? [] : _a, _b = getters.footerRows, tableFooterRows2 = _b === void 0 ? [] : _b, isDataRemote = getters.isDataRemote, viewport = getters.viewport;
  var rows = getRowsVisibleBoundary(tableBodyRows, viewportTop, containerHeight, getRowHeight, loadedRowsStart2, estimatedRowHeight, isDataRemote);
  var headerRows = getRowsVisibleBoundary(tableHeaderRows2, 0, 0, getRowHeight, 0, estimatedRowHeight, false);
  var footerRows = getRowsVisibleBoundary(tableFooterRows2, 0, 0, getRowHeight, 0, estimatedRowHeight, false);
  var columns = getColumnBoundaries(tableColumns, viewportLeft, containerWidth, getColumnWidth2);
  var result = viewport;
  if (viewportTop !== viewport.top) {
    result = __assign(__assign({}, result), { top: viewportTop });
  }
  if (viewportLeft !== viewport.left) {
    result = __assign(__assign({}, result), { left: viewportLeft });
  }
  if (containerWidth !== viewport.width) {
    result = __assign(__assign({}, result), { width: containerWidth });
  }
  if (containerHeight !== viewport.height) {
    result = __assign(__assign({}, result), { height: containerHeight });
  }
  if (!arraysEqual(rows, viewport.rows)) {
    result = __assign(__assign({}, result), { rows });
  }
  if (!arraysEqual(headerRows, viewport.headerRows)) {
    result = __assign(__assign({}, result), { headerRows });
  }
  if (!arraysEqual(footerRows, viewport.footerRows)) {
    result = __assign(__assign({}, result), { footerRows });
  }
  if (!arraysEqual(columns, viewport.columns, arraysEqual)) {
    result = __assign(__assign({}, result), { columns });
  }
  return result;
};
var checkColumnWidths = function(tableColumns) {
  return tableColumns.reduce(function(acc, tableColumn) {
    var width = tableColumn.width;
    if (typeof width === "string") {
      var numb = parseInt(width, 10);
      var unit_1 = numb ? width.substr(numb.toString().length) : width;
      var isValidUnit = VALID_UNITS$2.some(function(validUnit) {
        return validUnit === unit_1;
      });
      if (!isValidUnit) {
        throw new Error(VIRTUAL_TABLE_ERROR);
      }
      acc.push(__assign(__assign({}, tableColumn), { width: numb }));
    } else {
      acc.push(tableColumn);
    }
    return acc;
  }, []);
};
var calculateScrollHeight = function(rowHeight, index) {
  return index > -1 ? rowHeight * index : void 0;
};
var getScrollTop = function(rows, rowsCount, rowId, rowHeight, isDataRemote) {
  if (rowId === TOP_POSITION) {
    return 0;
  }
  if (rowId === BOTTOM_POSITION) {
    return rowsCount * rowHeight;
  }
  var searchIndexRequired = !isDataRemote && rowId !== void 0;
  var indexById = searchIndexRequired ? rows.findIndex(function(row) {
    return row.rowId === rowId;
  }) : void 0;
  return calculateScrollHeight(rowHeight, indexById);
};
var getScrollLeft = function(columnCount, columnWidth, columnId) {
  if (!columnId) {
    return;
  }
  if (columnId === LEFT_POSITION) {
    return 0;
  }
  return columnCount * columnWidth;
};
var getTopRowId = function(viewport, tableBodyRows, isDataRemote) {
  var hasViewportRows = viewport && viewport.rows;
  var hasBodyRows = tableBodyRows && tableBodyRows.length;
  if (hasViewportRows && hasBodyRows && !isDataRemote) {
    var index = viewport.rows[0];
    return index < tableBodyRows.length ? tableBodyRows[index].rowId : void 0;
  }
  return void 0;
};
var virtualRowsWithCache = function(skip, rows, cache) {
  var rowsInterval = intervalUtil.getRowsInterval({ skip, rows });
  var cacheInterval = intervalUtil.getRowsInterval(cache);
  return mergeRows(rowsInterval, cacheInterval, rows, cache.rows, skip, cache.skip);
};
var plainRows = function(virtualRows, availableRowCount) {
  return virtualRows.rows.length > availableRowCount ? virtualRows.rows.slice(0, availableRowCount) : virtualRows.rows;
};
var loadedRowsStart = function(virtualRows) {
  return virtualRows.skip;
};

// node_modules/@devexpress/dx-react-grid/dist/dx-react-grid.es.js
var import_react_dom = __toESM(require_react_dom());
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign2 = function() {
  __assign2 = Object.assign || function __assign3(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
function __rest2(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __read2(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spread2() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read2(arguments[i]));
  return ar;
}
var showColumnWhenGroupedGetter = function(showColumnsWhenGrouped, columnExtensions) {
  if (columnExtensions === void 0) {
    columnExtensions = [];
  }
  var map = columnExtensions.reduce(function(acc, columnExtension) {
    acc[columnExtension.columnName] = columnExtension.showWhenGrouped;
    return acc;
  }, {});
  return function(columnName) {
    return map[columnName] || showColumnsWhenGrouped;
  };
};
var TableColumnsWithGrouping = (0, import_react.memo)(function(_a) {
  var indentColumnWidth = _a.indentColumnWidth, showColumnsWhenGrouped = _a.showColumnsWhenGrouped, columnExtensions = _a.columnExtensions;
  var tableColumnsComputed2 = function(_a2) {
    var columns = _a2.columns, tableColumns = _a2.tableColumns, grouping = _a2.grouping, draftGrouping = _a2.draftGrouping;
    return tableColumnsWithGrouping(columns, tableColumns, grouping, draftGrouping, indentColumnWidth, showColumnWhenGroupedGetter(showColumnsWhenGrouped, columnExtensions));
  };
  return (0, import_react.createElement)(
    Plugin,
    null,
    (0, import_react.createElement)(Getter, { name: "tableColumns", computed: tableColumnsComputed2 })
  );
});
TableColumnsWithGrouping.defaultProps = {
  indentColumnWidth: 0
};
var GridCoreGetters = (0, import_react.memo)(function(_a) {
  var rows = _a.rows, columns = _a.columns, getRowId = _a.getRowId, getCellValue = _a.getCellValue;
  return (0, import_react.createElement)(
    Plugin,
    null,
    (0, import_react.createElement)(Getter, { name: "rows", value: rows }),
    (0, import_react.createElement)(Getter, { name: "getRowId", value: rowIdGetter(getRowId, rows) }),
    (0, import_react.createElement)(Getter, { name: "columns", value: columns }),
    (0, import_react.createElement)(Getter, { name: "getCellValue", value: cellValueGetter(getCellValue, columns) })
  );
});
var TableColumnsWithDataRowsGetter = (0, import_react.memo)(function(_a) {
  var columnExtensions = _a.columnExtensions;
  var tableColumnsComputed2 = (0, import_react.useCallback)(function(_a2) {
    var columns = _a2.columns;
    return tableColumnsWithDataRows(columns, columnExtensions);
  }, [columnExtensions]);
  checkTableColumnExtensions(columnExtensions);
  return (0, import_react.createElement)(
    Plugin,
    null,
    (0, import_react.createElement)(Getter, { name: "tableColumns", computed: tableColumnsComputed2 })
  );
});
var visibleTableColumnsComputed = function(_a) {
  var tableColumns = _a.tableColumns, hiddenColumnNames = _a.hiddenColumnNames;
  return visibleTableColumns(tableColumns, hiddenColumnNames);
};
var VisibleTableColumns = (0, import_react.memo)(function(_a) {
  var hiddenColumnNames = _a.hiddenColumnNames;
  return (0, import_react.createElement)(
    Plugin,
    null,
    (0, import_react.createElement)(Getter, { name: "hiddenColumnNames", value: hiddenColumnNames }),
    (0, import_react.createElement)(Getter, { name: "tableColumns", computed: visibleTableColumnsComputed })
  );
});
VisibleTableColumns.defaultProps = {
  hiddenColumnNames: []
};
var OrderedTableColumns = function(_a) {
  var order = _a.order;
  var columnsComputed = function(_a2) {
    var tableColumns = _a2.tableColumns;
    return orderedColumns(tableColumns, order);
  };
  return (0, import_react.createElement)(
    Plugin,
    null,
    (0, import_react.createElement)(Getter, { name: "tableColumns", computed: columnsComputed })
  );
};
OrderedTableColumns.defaultProps = {
  order: []
};
var GridCore = function(_super) {
  __extends(GridCore2, _super);
  function GridCore2(props) {
    var _this = _super.call(this, props) || this;
    _this.state = {
      ref: {}
    };
    _this.rootRef = (0, import_react.createRef)();
    return _this;
  }
  GridCore2.prototype.componentDidMount = function() {
    this.setState({
      ref: this.rootRef
    });
  };
  GridCore2.prototype.render = function() {
    var _a = this.props, Root = _a.rootComponent, restProps = __rest2(_a, ["rootComponent"]);
    var ref = this.state.ref;
    return (0, import_react.createElement)(
      Plugin,
      null,
      (0, import_react.createElement)(Getter, { name: "skip", value: 0 }),
      (0, import_react.createElement)(Getter, { name: "loadedRowsStart", value: 0 }),
      (0, import_react.createElement)(Getter, { name: "rootRef", value: ref }),
      (0, import_react.createElement)(GridCoreGetters, __assign2({}, restProps)),
      (0, import_react.createElement)(
        Template,
        { name: "root" },
        (0, import_react.createElement)(
          Root,
          { rootRef: this.rootRef },
          (0, import_react.createElement)(TemplatePlaceholder, { name: "header" }),
          (0, import_react.createElement)(TemplatePlaceholder, { name: "body" }),
          (0, import_react.createElement)(TemplatePlaceholder, { name: "footer" })
        )
      )
    );
  };
  return GridCore2;
}(import_react.PureComponent);
var GridBase = function(_a) {
  var rows = _a.rows, columns = _a.columns, getRowId = _a.getRowId, getCellValue = _a.getCellValue, rootComponent = _a.rootComponent, children = _a.children;
  return (0, import_react.createElement)(
    PluginHost,
    null,
    (0, import_react.createElement)(GridCore, { rows, columns, getRowId, getCellValue, rootComponent }),
    children
  );
};
var Grid = GridBase;
var pluginDependencies = [
  { name: "TableColumnVisibility" },
  { name: "Toolbar" }
];
var ColumnChooserBase = function(_super) {
  __extends(ColumnChooserBase2, _super);
  function ColumnChooserBase2(props) {
    var _this = _super.call(this, props) || this;
    _this.state = {
      visible: false
    };
    _this.handleToggle = _this.handleToggle.bind(_this);
    _this.handleHide = _this.handleHide.bind(_this);
    _this.setButtonRef = _this.setButtonRef.bind(_this);
    return _this;
  }
  ColumnChooserBase2.prototype.setButtonRef = function(button) {
    this.button = button;
  };
  ColumnChooserBase2.prototype.handleToggle = function() {
    var visible = this.state.visible;
    this.setState({ visible: !visible });
  };
  ColumnChooserBase2.prototype.handleHide = function() {
    this.setState({ visible: false });
  };
  ColumnChooserBase2.prototype.render = function() {
    var _this = this;
    var _a = this.props, Overlay = _a.overlayComponent, Container = _a.containerComponent, Item = _a.itemComponent, ToggleButton = _a.toggleButtonComponent, messages = _a.messages;
    var getMessage = getMessagesFormatter(messages);
    var visible = this.state.visible;
    return (0, import_react.createElement)(
      Plugin,
      { name: "ColumnChooser", dependencies: pluginDependencies },
      (0, import_react.createElement)(
        Template,
        { name: "toolbarContent" },
        (0, import_react.createElement)(TemplatePlaceholder, null),
        (0, import_react.createElement)(TemplateConnector, null, function(_a2, _b) {
          var columns = _a2.columns, hiddenColumnNames = _a2.hiddenColumnNames, isColumnTogglingEnabled = _a2.isColumnTogglingEnabled;
          var toggleColumnVisibility = _b.toggleColumnVisibility;
          return (0, import_react.createElement)(
            import_react.Fragment,
            null,
            (0, import_react.createElement)(ToggleButton, { buttonRef: _this.setButtonRef, onToggle: _this.handleToggle, getMessage, active: visible }),
            (0, import_react.createElement)(
              Overlay,
              { visible, target: _this.button, onHide: _this.handleHide },
              (0, import_react.createElement)(Container, null, columnChooserItems(columns, hiddenColumnNames).map(function(item) {
                var columnName = item.column.name;
                var togglingEnabled = isColumnTogglingEnabled(columnName);
                return (0, import_react.createElement)(Item, { key: columnName, item, disabled: !togglingEnabled, onToggle: function() {
                  return toggleColumnVisibility(columnName);
                } });
              }))
            )
          );
        })
      )
    );
  };
  ColumnChooserBase2.defaultProps = {
    messages: {}
  };
  ColumnChooserBase2.components = {
    overlayComponent: "Overlay",
    containerComponent: "Container",
    itemComponent: "Item",
    toggleButtonComponent: "ToggleButton"
  };
  return ColumnChooserBase2;
}(import_react.PureComponent);
var ColumnChooser = ColumnChooserBase;
var columnExtensionValueGetter = function(columnExtensions, defaultValue) {
  return getColumnExtensionValueGetter(columnExtensions, "filteringEnabled", defaultValue);
};
var filterExpressionComputed = function(_a) {
  var filters = _a.filters, filterExpressionValue = _a.filterExpression;
  return filterExpression(filters, filterExpressionValue);
};
var FilteringStateBase = function(_super) {
  __extends(FilteringStateBase2, _super);
  function FilteringStateBase2(props) {
    var _this = _super.call(this, props) || this;
    _this.state = {
      filters: props.filters || props.defaultFilters
    };
    var stateHelper = createStateHelper(_this, {
      filters: function() {
        var onFiltersChange = _this.props.onFiltersChange;
        return onFiltersChange;
      }
    });
    _this.changeColumnFilter = stateHelper.applyFieldReducer.bind(stateHelper, "filters", changeColumnFilter);
    return _this;
  }
  FilteringStateBase2.getDerivedStateFromProps = function(nextProps, prevState) {
    var _a = nextProps.filters, filters = _a === void 0 ? prevState.filters : _a;
    return {
      filters
    };
  };
  FilteringStateBase2.prototype.render = function() {
    var filters = this.state.filters;
    var _a = this.props, columnExtensions = _a.columnExtensions, columnFilteringEnabled = _a.columnFilteringEnabled;
    return (0, import_react.createElement)(
      Plugin,
      { name: "FilteringState" },
      (0, import_react.createElement)(Getter, { name: "filters", value: filters }),
      (0, import_react.createElement)(Getter, { name: "filterExpression", computed: filterExpressionComputed }),
      (0, import_react.createElement)(Getter, { name: "isColumnFilteringEnabled", value: columnExtensionValueGetter(columnExtensions, columnFilteringEnabled) }),
      (0, import_react.createElement)(Action, { name: "changeColumnFilter", action: this.changeColumnFilter })
    );
  };
  FilteringStateBase2.defaultProps = {
    defaultFilters: [],
    columnFilteringEnabled: true
  };
  return FilteringStateBase2;
}(import_react.PureComponent);
var FilteringState = FilteringStateBase;
var pluginDependencies$1 = [
  { name: "FilteringState", optional: true },
  { name: "SearchState", optional: true }
];
var getCollapsedRowsComputed = function(_a) {
  var rows = _a.rows;
  return filteredCollapsedRowsGetter(rows);
};
var unwrappedRowsComputed = function(_a) {
  var rows = _a.rows;
  return unwrappedFilteredRows(rows);
};
var IntegratedFilteringBase = function(_super) {
  __extends(IntegratedFilteringBase2, _super);
  function IntegratedFilteringBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  IntegratedFilteringBase2.prototype.render = function() {
    var columnExtensions = this.props.columnExtensions;
    var getColumnPredicate = function(columnName) {
      return getColumnExtension(columnExtensions, columnName).predicate;
    };
    var rowsComputed2 = function(_a) {
      var rows = _a.rows, filterExpression2 = _a.filterExpression, getCellValue = _a.getCellValue, getRowLevelKey = _a.getRowLevelKey, getCollapsedRows2 = _a.getCollapsedRows;
      return filteredRows(rows, filterExpression2, getCellValue, getColumnPredicate, getRowLevelKey, getCollapsedRows2);
    };
    return (0, import_react.createElement)(
      Plugin,
      { name: "IntegratedFiltering", dependencies: pluginDependencies$1 },
      (0, import_react.createElement)(Getter, { name: "rows", computed: rowsComputed2 }),
      (0, import_react.createElement)(Getter, { name: "getCollapsedRows", computed: getCollapsedRowsComputed }),
      (0, import_react.createElement)(Getter, { name: "rows", computed: unwrappedRowsComputed })
    );
  };
  return IntegratedFilteringBase2;
}(import_react.PureComponent);
IntegratedFilteringBase.defaultPredicate = defaultFilterPredicate;
var IntegratedFiltering = IntegratedFilteringBase;
var columnExtensionValueGetter$1 = function(columnExtensions, defaultValue) {
  return getColumnExtensionValueGetter(columnExtensions, "editingEnabled", defaultValue);
};
var EditingStateBase = function(_super) {
  __extends(EditingStateBase2, _super);
  function EditingStateBase2(props) {
    var _this = _super.call(this, props) || this;
    var rowChanges = props.rowChanges || props.defaultRowChanges;
    var addedRows = props.addedRows || props.defaultAddedRows;
    var getRowChanges = function() {
      var stateRowChanges = _this.state.rowChanges;
      return stateRowChanges;
    };
    var getAddedRows = function() {
      var stateAddedRows = _this.state.addedRows;
      return stateAddedRows;
    };
    _this.state = {
      addedRows,
      rowChanges,
      editingRowIds: props.editingRowIds || props.defaultEditingRowIds,
      deletedRowIds: props.deletedRowIds || props.defaultDeletedRowIds,
      editingCells: props.editingCells || props.defaultEditingCells
    };
    var stateHelper = createStateHelper(_this, {
      editingRowIds: function() {
        var onEditingRowIdsChange = _this.props.onEditingRowIdsChange;
        return onEditingRowIdsChange;
      },
      editingCells: function() {
        var onEditingCellsChange = _this.props.onEditingCellsChange;
        return onEditingCellsChange;
      },
      addedRows: function() {
        var onAddedRowsChange = _this.props.onAddedRowsChange;
        return onAddedRowsChange;
      },
      rowChanges: function() {
        var onRowChangesChange = _this.props.onRowChangesChange;
        return onRowChangesChange;
      },
      deletedRowIds: function() {
        var onDeletedRowIdsChange = _this.props.onDeletedRowIdsChange;
        return onDeletedRowIdsChange;
      }
    });
    _this.startEditRows = stateHelper.applyFieldReducer.bind(stateHelper, "editingRowIds", startEditRows);
    _this.stopEditRows = stateHelper.applyFieldReducer.bind(stateHelper, "editingRowIds", stopEditRows);
    _this.startEditCells = stateHelper.applyFieldReducer.bind(stateHelper, "editingCells", startEditCells);
    _this.stopEditCells = stateHelper.applyFieldReducer.bind(stateHelper, "editingCells", stopEditCells);
    _this.changeRow = stateHelper.applyFieldReducer.bind(stateHelper, "rowChanges", changeRow);
    _this.cancelChangedRows = stateHelper.applyFieldReducer.bind(stateHelper, "rowChanges", cancelChanges);
    _this.commitChangedRows = function(_a) {
      var rowIds = _a.rowIds;
      var onCommitChanges = _this.props.onCommitChanges;
      onCommitChanges({
        changed: changedRowsByIds(getRowChanges(), rowIds)
      });
      _this.cancelChangedRows({ rowIds });
    };
    _this.addRow = stateHelper.applyFieldReducer.bind(stateHelper, "addedRows", addRow);
    _this.changeAddedRow = stateHelper.applyFieldReducer.bind(stateHelper, "addedRows", changeAddedRow);
    _this.cancelAddedRows = stateHelper.applyFieldReducer.bind(stateHelper, "addedRows", cancelAddedRows);
    _this.commitAddedRows = function(_a) {
      var rowIds = _a.rowIds;
      var onCommitChanges = _this.props.onCommitChanges;
      onCommitChanges({
        added: addedRowsByIds(getAddedRows(), rowIds)
      });
      _this.cancelAddedRows({ rowIds });
    };
    _this.deleteRows = stateHelper.applyFieldReducer.bind(stateHelper, "deletedRowIds", deleteRows);
    _this.cancelDeletedRows = stateHelper.applyFieldReducer.bind(stateHelper, "deletedRowIds", cancelDeletedRows);
    _this.commitDeletedRows = function(_a) {
      var rowIds = _a.rowIds;
      var onCommitChanges = _this.props.onCommitChanges;
      onCommitChanges({ deleted: rowIds });
      _this.cancelDeletedRows({ rowIds });
    };
    return _this;
  }
  EditingStateBase2.getDerivedStateFromProps = function(nextProps, prevState) {
    var _a = nextProps.editingRowIds, editingRowIds = _a === void 0 ? prevState.editingRowIds : _a, _b = nextProps.editingCells, editingCells = _b === void 0 ? prevState.editingCells : _b, _c = nextProps.rowChanges, rowChanges = _c === void 0 ? prevState.rowChanges : _c, _d = nextProps.addedRows, addedRows = _d === void 0 ? prevState.addedRows : _d, _e = nextProps.deletedRowIds, deletedRowIds = _e === void 0 ? prevState.deletedRowIds : _e;
    return {
      editingRowIds,
      editingCells,
      rowChanges,
      addedRows,
      deletedRowIds
    };
  };
  EditingStateBase2.prototype.render = function() {
    var _a = this.props, createRowChange = _a.createRowChange, columnExtensions = _a.columnExtensions, columnEditingEnabled = _a.columnEditingEnabled;
    var _b = this.state, editingRowIds = _b.editingRowIds, editingCells = _b.editingCells, rowChanges = _b.rowChanges, addedRows = _b.addedRows, deletedRowIds = _b.deletedRowIds;
    return (0, import_react.createElement)(
      Plugin,
      { name: "EditingState" },
      (0, import_react.createElement)(Getter, { name: "createRowChange", value: createRowChangeGetter(createRowChange, columnExtensions) }),
      (0, import_react.createElement)(Getter, { name: "editingRowIds", value: editingRowIds }),
      (0, import_react.createElement)(Action, { name: "startEditRows", action: this.startEditRows }),
      (0, import_react.createElement)(Action, { name: "stopEditRows", action: this.stopEditRows }),
      (0, import_react.createElement)(Getter, { name: "editingCells", value: editingCells }),
      (0, import_react.createElement)(Action, { name: "startEditCells", action: this.startEditCells }),
      (0, import_react.createElement)(Action, { name: "stopEditCells", action: this.stopEditCells }),
      (0, import_react.createElement)(Getter, { name: "rowChanges", value: rowChanges }),
      (0, import_react.createElement)(Action, { name: "changeRow", action: this.changeRow }),
      (0, import_react.createElement)(Action, { name: "cancelChangedRows", action: this.cancelChangedRows }),
      (0, import_react.createElement)(Action, { name: "commitChangedRows", action: this.commitChangedRows }),
      (0, import_react.createElement)(Getter, { name: "addedRows", value: addedRows }),
      (0, import_react.createElement)(Action, { name: "addRow", action: this.addRow }),
      (0, import_react.createElement)(Action, { name: "changeAddedRow", action: this.changeAddedRow }),
      (0, import_react.createElement)(Action, { name: "cancelAddedRows", action: this.cancelAddedRows }),
      (0, import_react.createElement)(Action, { name: "commitAddedRows", action: this.commitAddedRows }),
      (0, import_react.createElement)(Getter, { name: "deletedRowIds", value: deletedRowIds }),
      (0, import_react.createElement)(Action, { name: "deleteRows", action: this.deleteRows }),
      (0, import_react.createElement)(Action, { name: "cancelDeletedRows", action: this.cancelDeletedRows }),
      (0, import_react.createElement)(Action, { name: "commitDeletedRows", action: this.commitDeletedRows }),
      (0, import_react.createElement)(Getter, { name: "isColumnEditingEnabled", value: columnExtensionValueGetter$1(columnExtensions, columnEditingEnabled) })
    );
  };
  EditingStateBase2.defaultProps = {
    columnEditingEnabled: true,
    defaultEditingRowIds: [],
    defaultEditingCells: [],
    defaultRowChanges: {},
    defaultAddedRows: [],
    defaultDeletedRowIds: []
  };
  return EditingStateBase2;
}(import_react.PureComponent);
var EditingState = EditingStateBase;
var PagingStateBase = function(_super) {
  __extends(PagingStateBase2, _super);
  function PagingStateBase2(props) {
    var _this = _super.call(this, props) || this;
    _this.state = {
      currentPage: props.currentPage || props.defaultCurrentPage,
      pageSize: props.pageSize !== void 0 ? props.pageSize : props.defaultPageSize
    };
    var stateHelper = createStateHelper(_this, {
      currentPage: function() {
        var onCurrentPageChange = _this.props.onCurrentPageChange;
        return onCurrentPageChange;
      },
      pageSize: function() {
        var onPageSizeChange = _this.props.onPageSizeChange;
        return onPageSizeChange;
      }
    });
    _this.setCurrentPage = stateHelper.applyFieldReducer.bind(stateHelper, "currentPage", setCurrentPage);
    _this.setPageSize = stateHelper.applyFieldReducer.bind(stateHelper, "pageSize", setPageSize);
    return _this;
  }
  PagingStateBase2.getDerivedStateFromProps = function(nextProps, prevState) {
    var _a = nextProps.currentPage, currentPage2 = _a === void 0 ? prevState.currentPage : _a, _b = nextProps.pageSize, pageSize = _b === void 0 ? prevState.pageSize : _b;
    return {
      currentPage: currentPage2,
      pageSize
    };
  };
  PagingStateBase2.prototype.render = function() {
    var _a = this.state, pageSize = _a.pageSize, currentPage2 = _a.currentPage;
    return (0, import_react.createElement)(
      Plugin,
      { name: "PagingState" },
      (0, import_react.createElement)(Getter, { name: "currentPage", value: currentPage2 }),
      (0, import_react.createElement)(Getter, { name: "pageSize", value: pageSize }),
      (0, import_react.createElement)(Action, { name: "setCurrentPage", action: this.setCurrentPage }),
      (0, import_react.createElement)(Action, { name: "setPageSize", action: this.setPageSize })
    );
  };
  PagingStateBase2.defaultProps = {
    defaultPageSize: 10,
    defaultCurrentPage: 0
  };
  return PagingStateBase2;
}(import_react.PureComponent);
var PagingState = PagingStateBase;
var pluginDependencies$2 = [
  { name: "PagingState" }
];
var rowsWithHeadersComputed = function(_a) {
  var rows = _a.rows, pageSize = _a.pageSize, getRowLevelKey = _a.getRowLevelKey;
  return rowsWithPageHeaders(rows, pageSize, getRowLevelKey);
};
var totalCountComputed = function(_a) {
  var rows = _a.rows;
  return rowCount(rows);
};
var paginatedRowsComputed = function(_a) {
  var rows = _a.rows, pageSize = _a.pageSize, page = _a.currentPage;
  return paginatedRows(rows, pageSize, page);
};
var currentPageComputed = function(_a, _b) {
  var page = _a.currentPage, totalCount = _a.totalCount, pageSize = _a.pageSize;
  var setCurrentPage2 = _b.setCurrentPage;
  return currentPage(page, totalCount, pageSize, setCurrentPage2);
};
var IntegratedPagingBase = function(_super) {
  __extends(IntegratedPagingBase2, _super);
  function IntegratedPagingBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  IntegratedPagingBase2.prototype.render = function() {
    return (0, import_react.createElement)(
      Plugin,
      { name: "IntegratedPaging", dependencies: pluginDependencies$2 },
      (0, import_react.createElement)(Getter, { name: "rows", computed: rowsWithHeadersComputed }),
      (0, import_react.createElement)(Getter, { name: "totalCount", computed: totalCountComputed }),
      (0, import_react.createElement)(Getter, { name: "currentPage", computed: currentPageComputed }),
      (0, import_react.createElement)(Getter, { name: "rows", computed: paginatedRowsComputed })
    );
  };
  return IntegratedPagingBase2;
}(import_react.PureComponent);
var IntegratedPaging = IntegratedPagingBase;
var pluginDependencies$3 = [
  { name: "PagingState" }
];
var CustomPagingBase = function(_super) {
  __extends(CustomPagingBase2, _super);
  function CustomPagingBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  CustomPagingBase2.prototype.render = function() {
    var totalCount = this.props.totalCount;
    return (0, import_react.createElement)(
      Plugin,
      { name: "CustomPaging", dependencies: pluginDependencies$3 },
      (0, import_react.createElement)(Getter, { name: "totalCount", value: totalCount })
    );
  };
  CustomPagingBase2.defaultProps = {
    totalCount: 0
  };
  return CustomPagingBase2;
}(import_react.PureComponent);
var CustomPaging = CustomPagingBase;
var dependencies = [
  { name: "SortingState", optional: true }
];
var columnExtensionValueGetter$2 = function(columnExtensions, defaultValue) {
  return getColumnExtensionValueGetter(columnExtensions, "groupingEnabled", defaultValue);
};
var GroupingStateBase = function(_super) {
  __extends(GroupingStateBase2, _super);
  function GroupingStateBase2(props) {
    var _this = _super.call(this, props) || this;
    _this.state = {
      grouping: props.grouping || props.defaultGrouping,
      draftGrouping: null,
      expandedGroups: props.expandedGroups || props.defaultExpandedGroups
    };
    _this.stateHelper = createStateHelper(_this, {
      grouping: function() {
        var onGroupingChange = _this.props.onGroupingChange;
        return onGroupingChange;
      },
      expandedGroups: function() {
        var onExpandedGroupsChange = _this.props.onExpandedGroupsChange;
        return onExpandedGroupsChange;
      }
    });
    _this.changeColumnGrouping = _this.changeColumnGrouping.bind(_this);
    _this.toggleGroupExpanded = _this.stateHelper.applyReducer.bind(_this.stateHelper, toggleExpandedGroups);
    _this.draftColumnGrouping = _this.stateHelper.applyReducer.bind(_this.stateHelper, draftColumnGrouping);
    _this.cancelColumnGroupingDraft = _this.stateHelper.applyReducer.bind(_this.stateHelper, cancelColumnGroupingDraft);
    _this.changeColumnSorting = _this.changeColumnSorting.bind(_this);
    return _this;
  }
  GroupingStateBase2.getDerivedStateFromProps = function(nextProps, prevState) {
    var _a = nextProps.grouping, grouping = _a === void 0 ? prevState.grouping : _a, _b = nextProps.expandedGroups, expandedGroups = _b === void 0 ? prevState.expandedGroups : _b;
    return {
      grouping,
      expandedGroups
    };
  };
  GroupingStateBase2.prototype.changeColumnSorting = function(_a, _b, _c) {
    var sorting = _b.sorting;
    var changeColumnSorting2 = _c.changeColumnSorting;
    var columnName = _a.columnName, keepOther = _a.keepOther, restParams = __rest2(_a, ["columnName", "keepOther"]);
    var grouping = this.state.grouping;
    var groupingIndex = grouping.findIndex(function(columnGrouping) {
      return columnGrouping.columnName === columnName;
    });
    if (groupingIndex === -1) {
      changeColumnSorting2(__assign2({ columnName, keepOther: keepOther || grouping.map(function(columnGrouping) {
        return columnGrouping.columnName;
      }) }, restParams));
      return false;
    }
    var sortIndex = adjustSortIndex(groupingIndex, grouping, sorting);
    changeColumnSorting2(__assign2({
      columnName,
      sortIndex,
      keepOther: true
    }, restParams));
    return false;
  };
  GroupingStateBase2.prototype.changeColumnGrouping = function(_a, getters, actions) {
    var columnName = _a.columnName, groupIndex = _a.groupIndex;
    this.stateHelper.applyReducer(changeColumnGrouping, { columnName, groupIndex }, function(nextState, state) {
      var grouping = nextState.grouping;
      var prevGrouping = state.grouping;
      var sorting = getters.sorting;
      var changeColumnSorting2 = actions.changeColumnSorting;
      if (!sorting)
        return;
      var columnSortingIndex = sorting.findIndex(function(columnSorting) {
        return columnSorting.columnName === columnName;
      });
      var prevGroupingIndex = prevGrouping.findIndex(function(columnGrouping) {
        return columnGrouping.columnName === columnName;
      });
      var groupingIndex = grouping.findIndex(function(columnGrouping) {
        return columnGrouping.columnName === columnName;
      });
      if (columnSortingIndex === -1 || prevGroupingIndex === prevGrouping.length - 1 && groupingIndex === -1)
        return;
      var sortIndex = adjustSortIndex(groupingIndex === -1 ? grouping.length : groupingIndex, grouping, sorting);
      if (columnSortingIndex === sortIndex)
        return;
      changeColumnSorting2(__assign2({ sortIndex, keepOther: true }, sorting[columnSortingIndex]));
    });
  };
  GroupingStateBase2.prototype.render = function() {
    var _a = this.state, grouping = _a.grouping, draftGrouping = _a.draftGrouping, expandedGroups = _a.expandedGroups;
    var _b = this.props, columnExtensions = _b.columnExtensions, columnGroupingEnabled = _b.columnGroupingEnabled;
    return (0, import_react.createElement)(
      Plugin,
      { name: "GroupingState", dependencies },
      (0, import_react.createElement)(Getter, { name: "grouping", value: grouping }),
      (0, import_react.createElement)(Getter, { name: "draftGrouping", value: draftGrouping || grouping }),
      (0, import_react.createElement)(Getter, { name: "isColumnGroupingEnabled", value: columnExtensionValueGetter$2(columnExtensions, columnGroupingEnabled) }),
      (0, import_react.createElement)(Action, { name: "changeColumnGrouping", action: this.changeColumnGrouping }),
      (0, import_react.createElement)(Action, { name: "draftColumnGrouping", action: this.draftColumnGrouping }),
      (0, import_react.createElement)(Action, { name: "cancelColumnGroupingDraft", action: this.cancelColumnGroupingDraft }),
      (0, import_react.createElement)(Getter, { name: "expandedGroups", value: expandedGroups }),
      (0, import_react.createElement)(Action, { name: "toggleGroupExpanded", action: this.toggleGroupExpanded }),
      (0, import_react.createElement)(Action, { name: "changeColumnSorting", action: this.changeColumnSorting })
    );
  };
  GroupingStateBase2.defaultProps = {
    defaultGrouping: [],
    defaultExpandedGroups: [],
    columnGroupingEnabled: true
  };
  return GroupingStateBase2;
}(import_react.PureComponent);
var GroupingState = GroupingStateBase;
var pluginDependencies$4 = [
  { name: "GroupingState" }
];
var getCollapsedRowsComputed$1 = function(_a) {
  var getCollapsedRows2 = _a.getCollapsedRows;
  return groupCollapsedRowsGetter(getCollapsedRows2);
};
var expandedGroupedRowsComputed = function(_a) {
  var rows = _a.rows, grouping = _a.grouping, expandedGroups = _a.expandedGroups, isExporting = _a.isExporting;
  return expandedGroupRows(rows, grouping, expandedGroups, isExporting);
};
var IntegratedGroupingBase = function(_super) {
  __extends(IntegratedGroupingBase2, _super);
  function IntegratedGroupingBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  IntegratedGroupingBase2.prototype.render = function() {
    var columnExtensions = this.props.columnExtensions;
    var getColumnCriteria = function(columnName) {
      return getColumnExtension(columnExtensions, columnName).criteria;
    };
    var groupedRowsComputed = function(_a) {
      var rows = _a.rows, grouping = _a.grouping, getCellValue = _a.getCellValue;
      return groupedRows(rows, grouping, getCellValue, getColumnCriteria);
    };
    return (0, import_react.createElement)(
      Plugin,
      { name: "IntegratedGrouping", dependencies: pluginDependencies$4 },
      (0, import_react.createElement)(Getter, { name: "isGroupRow", value: groupRowChecker }),
      (0, import_react.createElement)(Getter, { name: "getRowLevelKey", value: groupRowLevelKeyGetter }),
      (0, import_react.createElement)(Getter, { name: "getCollapsedRows", computed: getCollapsedRowsComputed$1 }),
      (0, import_react.createElement)(Getter, { name: "rows", computed: groupedRowsComputed }),
      (0, import_react.createElement)(Getter, { name: "rows", computed: expandedGroupedRowsComputed })
    );
  };
  return IntegratedGroupingBase2;
}(import_react.PureComponent);
var IntegratedGrouping = IntegratedGroupingBase;
var pluginDependencies$5 = [
  { name: "GroupingState" }
];
var getCollapsedRowsComputed$2 = function(_a) {
  var getCollapsedRows2 = _a.getCollapsedRows;
  return groupCollapsedRowsGetter(getCollapsedRows2);
};
var expandedGroupedRowsComputed$1 = function(_a) {
  var rows = _a.rows, grouping = _a.grouping, expandedGroups = _a.expandedGroups, isExporting = _a.isExporting;
  return expandedGroupRows(rows, grouping, expandedGroups, isExporting);
};
var getRowIdComputed = function(_a) {
  var getRowId = _a.getRowId, rows = _a.rows;
  return customGroupingRowIdGetter(getRowId, rows);
};
var CustomGroupingBase = function(_super) {
  __extends(CustomGroupingBase2, _super);
  function CustomGroupingBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  CustomGroupingBase2.prototype.render = function() {
    var _a = this.props, getChildGroups = _a.getChildGroups, appliedGrouping = _a.grouping, appliedExpandedGroups = _a.expandedGroups;
    var groupedRowsComputed = function(_a2) {
      var rows = _a2.rows, grouping = _a2.grouping;
      return customGroupedRows(rows, grouping, getChildGroups);
    };
    return (0, import_react.createElement)(
      Plugin,
      { name: "CustomGrouping", dependencies: pluginDependencies$5 },
      appliedGrouping && (0, import_react.createElement)(Getter, { name: "grouping", value: appliedGrouping }),
      appliedExpandedGroups && (0, import_react.createElement)(Getter, { name: "expandedGroups", value: appliedExpandedGroups }),
      (0, import_react.createElement)(Getter, { name: "isGroupRow", value: groupRowChecker }),
      (0, import_react.createElement)(Getter, { name: "getRowLevelKey", value: groupRowLevelKeyGetter }),
      (0, import_react.createElement)(Getter, { name: "getCollapsedRows", computed: getCollapsedRowsComputed$2 }),
      (0, import_react.createElement)(Getter, { name: "rows", computed: groupedRowsComputed }),
      (0, import_react.createElement)(Getter, { name: "getRowId", computed: getRowIdComputed }),
      (0, import_react.createElement)(Getter, { name: "rows", computed: expandedGroupedRowsComputed$1 })
    );
  };
  return CustomGroupingBase2;
}(import_react.PureComponent);
var CustomGrouping = CustomGroupingBase;
var SelectionStateBase = function(_super) {
  __extends(SelectionStateBase2, _super);
  function SelectionStateBase2(props) {
    var _this = _super.call(this, props) || this;
    _this.state = {
      selection: props.selection || props.defaultSelection
    };
    var stateHelper = createStateHelper(_this, {
      selection: function() {
        var onSelectionChange = _this.props.onSelectionChange;
        return onSelectionChange;
      }
    });
    _this.toggleSelection = stateHelper.applyFieldReducer.bind(stateHelper, "selection", toggleSelection);
    return _this;
  }
  SelectionStateBase2.getDerivedStateFromProps = function(nextProps, prevState) {
    var _a = nextProps.selection, selection = _a === void 0 ? prevState.selection : _a;
    return {
      selection
    };
  };
  SelectionStateBase2.prototype.render = function() {
    var selection = this.state.selection;
    return (0, import_react.createElement)(
      Plugin,
      { name: "SelectionState" },
      (0, import_react.createElement)(Getter, { name: "selection", value: selection }),
      (0, import_react.createElement)(Action, { name: "toggleSelection", action: this.toggleSelection })
    );
  };
  SelectionStateBase2.defaultProps = {
    defaultSelection: []
  };
  return SelectionStateBase2;
}(import_react.PureComponent);
var SelectionState = SelectionStateBase;
var rowsWithAvailableToSelectComputed = function(_a) {
  var rows = _a.rows, getRowId = _a.getRowId, isGroupRow = _a.isGroupRow;
  return rowsWithAvailableToSelect(rows, getRowId, isGroupRow);
};
var allSelectedComputed = function(_a) {
  var rows = _a.rows, selection = _a.selection;
  return allSelected(rows, selection);
};
var someSelectedComputed = function(_a) {
  var rows = _a.rows, selection = _a.selection;
  return someSelected(rows, selection);
};
var selectAllAvailableComputed = function(_a) {
  var availableToSelect = _a.rows.availableToSelect;
  return !!availableToSelect.length;
};
var toggleSelectAll = function(state, _a, _b) {
  var availableToSelect = _a.rows.availableToSelect;
  var toggleSelection2 = _b.toggleSelection;
  toggleSelection2({ state, rowIds: availableToSelect });
};
var unwrapRowsComputed = function(_a) {
  var rows = _a.rows;
  return unwrapSelectedRows(rows);
};
var pluginDependencies$6 = [
  { name: "SelectionState" }
];
var IntegratedSelectionBase = function(_super) {
  __extends(IntegratedSelectionBase2, _super);
  function IntegratedSelectionBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  IntegratedSelectionBase2.prototype.render = function() {
    return (0, import_react.createElement)(
      Plugin,
      { name: "IntegratedSelection", dependencies: pluginDependencies$6 },
      (0, import_react.createElement)(Getter, { name: "rows", computed: rowsWithAvailableToSelectComputed }),
      (0, import_react.createElement)(Getter, { name: "allSelected", computed: allSelectedComputed }),
      (0, import_react.createElement)(Getter, { name: "someSelected", computed: someSelectedComputed }),
      (0, import_react.createElement)(Getter, { name: "selectAllAvailable", computed: selectAllAvailableComputed }),
      (0, import_react.createElement)(Action, { name: "toggleSelectAll", action: toggleSelectAll }),
      (0, import_react.createElement)(Getter, { name: "rows", computed: unwrapRowsComputed })
    );
  };
  return IntegratedSelectionBase2;
}(import_react.PureComponent);
var IntegratedSelection = IntegratedSelectionBase;
var columnExtensionValueGetter$3 = function(columnExtensions, defaultValue) {
  return getColumnExtensionValueGetter(columnExtensions, "sortingEnabled", defaultValue);
};
var SortingStateBase = function(_super) {
  __extends(SortingStateBase2, _super);
  function SortingStateBase2(props) {
    var _this = _super.call(this, props) || this;
    _this.state = {
      sorting: props.sorting || props.defaultSorting
    };
    var stateHelper = createStateHelper(_this, {
      sorting: function() {
        var onSortingChange = _this.props.onSortingChange;
        return onSortingChange;
      }
    });
    _this.changeColumnSorting = stateHelper.applyReducer.bind(stateHelper, function(prevState, payload) {
      var _a = _this.props.sorting, sorting = _a === void 0 ? prevState.sorting : _a;
      var persistentSortedColumns = getPersistentSortedColumns(sorting, props.columnExtensions);
      var keepOther = calculateKeepOther(prevState.sorting, payload.keepOther, persistentSortedColumns);
      return changeColumnSorting(prevState, __assign2(__assign2({}, payload), { keepOther }));
    });
    return _this;
  }
  SortingStateBase2.getDerivedStateFromProps = function(nextProps, prevState) {
    var _a = nextProps.sorting, sorting = _a === void 0 ? prevState.sorting : _a;
    return {
      sorting
    };
  };
  SortingStateBase2.prototype.render = function() {
    var sorting = this.state.sorting;
    var _a = this.props, columnExtensions = _a.columnExtensions, columnSortingEnabled = _a.columnSortingEnabled;
    return (0, import_react.createElement)(
      Plugin,
      { name: "SortingState" },
      (0, import_react.createElement)(Getter, { name: "sorting", value: sorting }),
      (0, import_react.createElement)(Getter, { name: "isColumnSortingEnabled", value: columnExtensionValueGetter$3(columnExtensions, columnSortingEnabled) }),
      (0, import_react.createElement)(Action, { name: "changeColumnSorting", action: this.changeColumnSorting })
    );
  };
  SortingStateBase2.defaultProps = {
    defaultSorting: [],
    columnSortingEnabled: true
  };
  return SortingStateBase2;
}(import_react.PureComponent);
var SortingState = SortingStateBase;
var pluginDependencies$7 = [
  { name: "SortingState" }
];
var IntegratedSortingBase = function(_super) {
  __extends(IntegratedSortingBase2, _super);
  function IntegratedSortingBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  IntegratedSortingBase2.prototype.render = function() {
    var columnExtensions = this.props.columnExtensions;
    var getColumnCompare = function(columnName) {
      return getColumnExtension(columnExtensions, columnName).compare;
    };
    var rowsComputed2 = function(_a) {
      var rows = _a.rows, sorting = _a.sorting, getCellValue = _a.getCellValue, isGroupRow = _a.isGroupRow, getRowLevelKey = _a.getRowLevelKey;
      return sortedRows(rows, sorting, getCellValue, getColumnCompare, isGroupRow, getRowLevelKey);
    };
    return (0, import_react.createElement)(
      Plugin,
      { name: "IntegratedSorting", dependencies: pluginDependencies$7 },
      (0, import_react.createElement)(Getter, { name: "rows", computed: rowsComputed2 })
    );
  };
  return IntegratedSortingBase2;
}(import_react.PureComponent);
var IntegratedSorting = IntegratedSortingBase;
var getTargetColumns = function(payload, columns) {
  return payload.filter(function(item) {
    return item.type === "column";
  }).map(function(item) {
    return columns.find(function(column) {
      return column.name === item.columnName;
    });
  });
};
var DragDropProviderBase = function(_super) {
  __extends(DragDropProviderBase2, _super);
  function DragDropProviderBase2(props) {
    var _this = _super.call(this, props) || this;
    _this.state = {
      payload: null,
      clientOffset: null
    };
    _this.change = function(_a) {
      var payload = _a.payload, clientOffset = _a.clientOffset;
      return _this.setState({ payload, clientOffset });
    };
    return _this;
  }
  DragDropProviderBase2.prototype.componentDidMount = function() {
    this.bodyRef = document.body;
  };
  DragDropProviderBase2.prototype.render = function() {
    var _this = this;
    var _a = this.props, Container = _a.containerComponent, Column = _a.columnComponent;
    var _b = this.state, payload = _b.payload, clientOffset = _b.clientOffset;
    return (0, import_react.createElement)(
      Plugin,
      { name: "DragDropProvider" },
      (0, import_react.createElement)(Getter, { name: "draggingEnabled", value: true }),
      (0, import_react.createElement)(
        Template,
        { name: "root" },
        (0, import_react.createElement)(
          DragDropProvider,
          { onChange: this.change },
          (0, import_react.createElement)(TemplatePlaceholder, null)
        ),
        payload && (0, import_react.createElement)(TemplateConnector, null, function(_a2) {
          var columns = _a2.columns;
          return (0, import_react_dom.createPortal)((0, import_react.createElement)(Container, { clientOffset }, getTargetColumns(payload, columns).map(function(column) {
            return (0, import_react.createElement)(Column, { key: column.name, column });
          })), _this.bodyRef);
        })
      )
    );
  };
  DragDropProviderBase2.components = {
    containerComponent: "Container",
    columnComponent: "Column"
  };
  return DragDropProviderBase2;
}(import_react.PureComponent);
var DragDropProvider2 = DragDropProviderBase;
var pluginDependencies$8 = [
  { name: "Table" },
  { name: "DragDropProvider", optional: true }
];
var tableHeaderRowsComputed = function(_a) {
  var tableHeaderRows2 = _a.tableHeaderRows;
  return tableHeaderRowsWithReordering(tableHeaderRows2);
};
var TableColumnReorderingRaw = function(_super) {
  __extends(TableColumnReorderingRaw2, _super);
  function TableColumnReorderingRaw2(props) {
    var _this = _super.call(this, props) || this;
    _this.cellDimensionGetters = {};
    _this.cellDimensions = [];
    _this.state = {
      order: props.defaultOrder,
      sourceColumnIndex: -1,
      targetColumnIndex: -1
    };
    _this.onOver = _this.handleOver.bind(_this);
    _this.onLeave = _this.handleLeave.bind(_this);
    _this.onDrop = _this.handleDrop.bind(_this);
    return _this;
  }
  TableColumnReorderingRaw2.prototype.getState = function() {
    var orderState = this.state.order;
    var _a = this.props.order, order = _a === void 0 ? orderState : _a;
    return __assign2(__assign2({}, this.state), { order });
  };
  TableColumnReorderingRaw2.prototype.getDraftOrder = function() {
    var _a = this.getState(), order = _a.order, sourceColumnIndex = _a.sourceColumnIndex, targetColumnIndex = _a.targetColumnIndex;
    return draftOrder(order, sourceColumnIndex, targetColumnIndex);
  };
  TableColumnReorderingRaw2.prototype.getAvailableColumns = function() {
    var _this = this;
    return this.getDraftOrder().filter(function(columnName) {
      return !!_this.cellDimensionGetters[columnName];
    });
  };
  TableColumnReorderingRaw2.prototype.cacheCellDimensions = function() {
    var _this = this;
    this.cellDimensions = this.cellDimensions && this.cellDimensions.length ? this.cellDimensions : this.getAvailableColumns().map(function(columnName) {
      return _this.cellDimensionGetters[columnName]();
    });
  };
  TableColumnReorderingRaw2.prototype.resetCellDimensions = function() {
    this.cellDimensions = [];
  };
  TableColumnReorderingRaw2.prototype.ensureCellDimensionGetters = function(tableColumns) {
    var _this = this;
    Object.keys(this.cellDimensionGetters).forEach(function(columnName) {
      var columnIndex = tableColumns.findIndex(function(_a) {
        var type = _a.type, column = _a.column;
        return type === TABLE_DATA_TYPE && column.name === columnName;
      });
      if (columnIndex === -1) {
        delete _this.cellDimensionGetters[columnName];
      }
    });
  };
  TableColumnReorderingRaw2.prototype.storeCellDimensionsGetter = function(tableColumn, getter, tableColumns) {
    if (tableColumn.type === TABLE_DATA_TYPE) {
      this.cellDimensionGetters[tableColumn.column.name] = getter;
    }
    this.ensureCellDimensionGetters(tableColumns);
  };
  TableColumnReorderingRaw2.prototype.handleOver = function(_a) {
    var payload = _a.payload, x = _a.clientOffset.x;
    var sourceColumnName = payload[0].columnName;
    var availableColumns = this.getAvailableColumns();
    var relativeSourceColumnIndex = availableColumns.indexOf(sourceColumnName);
    if (relativeSourceColumnIndex === -1)
      return;
    this.cacheCellDimensions();
    var cellDimensions = this.cellDimensions;
    var relativeTargetIndex = getTableTargetColumnIndex(cellDimensions, x);
    if (relativeTargetIndex === -1)
      return;
    var _b = this.getState(), prevSourceColumnIndex = _b.sourceColumnIndex, prevTargetColumnIndex = _b.targetColumnIndex;
    var draftOrder2 = this.getDraftOrder();
    var targetColumnIndex = draftOrder2.indexOf(availableColumns[relativeTargetIndex]);
    if (targetColumnIndex === prevTargetColumnIndex)
      return;
    var sourceColumnIndex = prevSourceColumnIndex === -1 ? draftOrder2.indexOf(sourceColumnName) : prevSourceColumnIndex;
    this.setState({
      sourceColumnIndex,
      targetColumnIndex
    });
  };
  TableColumnReorderingRaw2.prototype.handleLeave = function() {
    this.setState({
      sourceColumnIndex: -1,
      targetColumnIndex: -1
    });
    this.resetCellDimensions();
  };
  TableColumnReorderingRaw2.prototype.handleDrop = function() {
    var _a = this.getState(), sourceColumnIndex = _a.sourceColumnIndex, targetColumnIndex = _a.targetColumnIndex, order = _a.order;
    var onOrderChange = this.props.onOrderChange;
    if (sourceColumnIndex === -1 && targetColumnIndex === -1)
      return;
    var nextOrder = changeColumnOrder(order, {
      sourceColumnName: order[sourceColumnIndex],
      targetColumnName: order[targetColumnIndex]
    });
    this.setState({
      order: nextOrder,
      sourceColumnIndex: -1,
      targetColumnIndex: -1
    });
    if (onOrderChange) {
      onOrderChange(nextOrder);
    }
    this.resetCellDimensions();
  };
  TableColumnReorderingRaw2.prototype.render = function() {
    var _this = this;
    var _a = this.props, Container = _a.tableContainerComponent, Row = _a.rowComponent, Cell = _a.cellComponent;
    this.cellDimensionGetters = {};
    return (0, import_react.createElement)(
      Plugin,
      { name: "TableColumnReordering", dependencies: pluginDependencies$8 },
      (0, import_react.createElement)(OrderedTableColumns, { order: this.getDraftOrder() }),
      (0, import_react.createElement)(Getter, { name: "tableHeaderRows", computed: tableHeaderRowsComputed }),
      (0, import_react.createElement)(Template, { name: "table" }, function(params) {
        return (0, import_react.createElement)(TemplateConnector, null, function(_a2) {
          var draggingEnabled = _a2.draggingEnabled;
          return (0, import_react.createElement)(
            Container,
            __assign2({}, params, { onOver: _this.onOver, onLeave: _this.onLeave, onDrop: _this.onDrop, draggingEnabled }),
            (0, import_react.createElement)(PlaceholderWithRef, null)
          );
        });
      }),
      (0, import_react.createElement)(Template, { name: "tableRow", predicate: function(_a2) {
        var tableRow = _a2.tableRow;
        return tableRow.type === TABLE_REORDERING_TYPE;
      } }, function(params) {
        return (0, import_react.createElement)(Row, __assign2({}, params));
      }),
      (0, import_react.createElement)(Template, { name: "tableCell", predicate: function(_a2) {
        var tableRow = _a2.tableRow;
        return tableRow.type === TABLE_REORDERING_TYPE;
      } }, function(params) {
        return (0, import_react.createElement)(TemplateConnector, null, function(_a2) {
          var tableColumns = _a2.tableColumns;
          return (0, import_react.createElement)(Cell, __assign2({}, params, { getCellDimensions: function(getter) {
            return _this.storeCellDimensionsGetter(params.tableColumn, getter, tableColumns);
          } }));
        });
      })
    );
  };
  TableColumnReorderingRaw2.defaultProps = {
    defaultOrder: []
  };
  TableColumnReorderingRaw2.components = {
    tableContainerComponent: "TableContainer",
    rowComponent: "Row",
    cellComponent: "Cell"
  };
  return TableColumnReorderingRaw2;
}(import_react.PureComponent);
var TableContainer = function(_a) {
  var onOver = _a.onOver, onLeave = _a.onLeave, onDrop = _a.onDrop, children = _a.children, draggingEnabled = _a.draggingEnabled;
  return draggingEnabled ? (0, import_react.createElement)(DropTarget, { onOver, onLeave, onDrop }, children) : children;
};
var TableColumnReordering = withComponents({ TableContainer })(TableColumnReorderingRaw);
var RowPlaceholder = (0, import_react.forwardRef)(function(props, ref) {
  return (0, import_react.createElement)(TemplatePlaceholder, { name: "tableRow", params: __assign2(__assign2({}, props), { ref }) });
});
var CellPlaceholder = function(props) {
  return (0, import_react.createElement)(TemplatePlaceholder, { name: "tableCell", params: props });
};
var tableHeaderRows = [];
var tableBodyRowsComputed = function(_a) {
  var rows = _a.rows, getRowId = _a.getRowId, isDataLoading = _a.isDataLoading;
  return tableRowsWithDataRows(rows, getRowId, isDataLoading);
};
var tableFooterRows = [];
var defaultMessages = {
  noData: "No data"
};
var TableBase = function(_super) {
  __extends(TableBase2, _super);
  function TableBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  TableBase2.prototype.render = function() {
    var _a = this.props, Layout = _a.layoutComponent, Cell = _a.cellComponent, Row = _a.rowComponent, NoDataRow = _a.noDataRowComponent, NoDataCell = _a.noDataCellComponent, StubRow = _a.stubRowComponent, StubCell = _a.stubCellComponent, StubHeaderCell = _a.stubHeaderCellComponent, columnExtensions = _a.columnExtensions, messages = _a.messages, containerComponent = _a.containerComponent, tableComponent = _a.tableComponent, headComponent = _a.headComponent, bodyComponent = _a.bodyComponent, footerComponent = _a.footerComponent;
    var getMessage = getMessagesFormatter(__assign2(__assign2({}, defaultMessages), messages));
    return (0, import_react.createElement)(
      Plugin,
      { name: "Table" },
      (0, import_react.createElement)(Getter, { name: "tableHeaderRows", value: tableHeaderRows }),
      (0, import_react.createElement)(Getter, { name: "tableBodyRows", computed: tableBodyRowsComputed }),
      (0, import_react.createElement)(Getter, { name: "tableFooterRows", value: tableFooterRows }),
      (0, import_react.createElement)(TableColumnsWithDataRowsGetter, { columnExtensions }),
      (0, import_react.createElement)(Getter, { name: "getTableCellColSpan", value: tableCellColSpanGetter }),
      (0, import_react.createElement)(
        Template,
        { name: "body" },
        (0, import_react.createElement)(TemplatePlaceholder, { name: "table" })
      ),
      (0, import_react.createElement)(Template, { name: "table" }, function(params) {
        return (0, import_react.createElement)(TemplateConnector, null, function(_a2) {
          var headerRows = _a2.tableHeaderRows, bodyRows = _a2.tableBodyRows, footerRows = _a2.tableFooterRows, columns = _a2.tableColumns, getTableCellColSpan = _a2.getTableCellColSpan;
          return (0, import_react.createElement)(TemplatePlaceholder, { name: "tableLayout", params: __assign2(__assign2({}, params), {
            tableComponent,
            headComponent,
            bodyComponent,
            footerComponent,
            containerComponent,
            headerRows,
            bodyRows,
            footerRows,
            columns,
            rowComponent: RowPlaceholder,
            cellComponent: CellPlaceholder,
            getCellColSpan: getTableCellColSpan
          }) });
        });
      }),
      (0, import_react.createElement)(Template, { name: "tableLayout" }, function(params) {
        return (0, import_react.createElement)(Layout, __assign2({}, params));
      }),
      (0, import_react.createElement)(Template, { name: "tableCell" }, function(params) {
        return (0, import_react.createElement)(TemplateConnector, null, function(_a2) {
          var headerRows = _a2.tableHeaderRows;
          return isHeaderStubTableCell(params.tableRow, headerRows) ? (0, import_react.createElement)(StubHeaderCell, __assign2({}, params)) : (0, import_react.createElement)(StubCell, __assign2({}, params));
        });
      }),
      (0, import_react.createElement)(Template, { name: "tableCell", predicate: function(_a2) {
        var tableRow = _a2.tableRow, tableColumn = _a2.tableColumn;
        return isDataTableCell(tableRow, tableColumn);
      } }, function(params) {
        return (0, import_react.createElement)(TemplateConnector, null, function(_a2) {
          var getCellValue = _a2.getCellValue;
          var columnName = params.tableColumn.column.name;
          var value = getCellValue(params.tableRow.row, columnName);
          return (0, import_react.createElement)(TemplatePlaceholder, { name: "valueFormatter", params: {
            value,
            row: params.tableRow.row,
            column: params.tableColumn.column
          } }, function(content) {
            return (0, import_react.createElement)(Cell, __assign2({}, params, { row: params.tableRow.row, column: params.tableColumn.column, value }), content);
          });
        });
      }),
      (0, import_react.createElement)(Template, { name: "tableCell", predicate: function(_a2) {
        var tableRow = _a2.tableRow;
        return !!isNoDataTableRow(tableRow);
      } }, function(params) {
        return (0, import_react.createElement)(TemplateConnector, null, function(_a2) {
          var tableColumns = _a2.tableColumns;
          if (isNoDataTableCell(params.tableColumn, tableColumns)) {
            return (0, import_react.createElement)(NoDataCell, __assign2({}, params, { getMessage }));
          }
          return null;
        });
      }),
      (0, import_react.createElement)(Template, { name: "tableRow" }, function(params) {
        return (0, import_react.createElement)(StubRow, __assign2({}, params));
      }),
      (0, import_react.createElement)(Template, { name: "tableRow", predicate: function(_a2) {
        var tableRow = _a2.tableRow;
        return !!isDataTableRow(tableRow);
      } }, function(params) {
        return (0, import_react.createElement)(Row, __assign2({}, params, { row: params.tableRow.row }));
      }),
      (0, import_react.createElement)(Template, { name: "tableRow", predicate: function(_a2) {
        var tableRow = _a2.tableRow;
        return !!isNoDataTableRow(tableRow);
      } }, function(params) {
        return (0, import_react.createElement)(NoDataRow, __assign2({}, params));
      })
    );
  };
  TableBase2.COLUMN_TYPE = TABLE_DATA_TYPE;
  TableBase2.ROW_TYPE = TABLE_DATA_TYPE;
  TableBase2.NODATA_ROW_TYPE = TABLE_NODATA_TYPE;
  TableBase2.defaultProps = {
    messages: {}
  };
  TableBase2.components = {
    tableComponent: "Table",
    headComponent: "TableHead",
    bodyComponent: "TableBody",
    footerComponent: "TableFooter",
    containerComponent: "Container",
    layoutComponent: "Layout",
    rowComponent: "Row",
    cellComponent: "Cell",
    noDataRowComponent: "NoDataRow",
    noDataCellComponent: "NoDataCell",
    stubRowComponent: "StubRow",
    stubCellComponent: "StubCell",
    stubHeaderCellComponent: "StubHeaderCell"
  };
  return TableBase2;
}(import_react.PureComponent);
var Table = TableBase;
var TableSelectionBase = function(_super) {
  __extends(TableSelectionBase2, _super);
  function TableSelectionBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  TableSelectionBase2.prototype.render = function() {
    var _a = this.props, highlightRow = _a.highlightRow, selectByRowClick = _a.selectByRowClick, showSelectionColumn = _a.showSelectionColumn, showSelectAll = _a.showSelectAll, HeaderCell = _a.headerCellComponent, Cell = _a.cellComponent, Row = _a.rowComponent, selectionColumnWidth = _a.selectionColumnWidth;
    var tableColumnsComputed2 = function(_a2) {
      var tableColumns = _a2.tableColumns;
      return tableColumnsWithSelection(tableColumns, selectionColumnWidth, showSelectionColumn);
    };
    return (0, import_react.createElement)(
      Plugin,
      { name: "TableSelection", dependencies: [
        { name: "Table" },
        { name: "SelectionState" },
        { name: "IntegratedSelection", optional: !showSelectAll }
      ] },
      (0, import_react.createElement)(Getter, { name: "tableColumns", computed: tableColumnsComputed2 }),
      highlightRow && (0, import_react.createElement)(Getter, { name: "highlightSelectedRow", value: true }),
      showSelectionColumn && showSelectAll && (0, import_react.createElement)(Template, { name: "tableCell", predicate: function(_a2) {
        var tableRow = _a2.tableRow, tableColumn = _a2.tableColumn;
        return isSelectAllTableCell(tableRow, tableColumn);
      } }, function(params) {
        return (0, import_react.createElement)(TemplateConnector, null, function(_a2, _b) {
          var selectAllAvailable = _a2.selectAllAvailable, allSelected2 = _a2.allSelected, someSelected2 = _a2.someSelected;
          var toggleSelectAll2 = _b.toggleSelectAll;
          return (0, import_react.createElement)(HeaderCell, __assign2({}, params, { disabled: !selectAllAvailable, allSelected: allSelected2, someSelected: someSelected2, onToggle: function(select) {
            return toggleSelectAll2(select);
          } }));
        });
      }),
      showSelectionColumn && (0, import_react.createElement)(Template, { name: "tableCell", predicate: function(_a2) {
        var tableRow = _a2.tableRow, tableColumn = _a2.tableColumn;
        return isSelectTableCell(tableRow, tableColumn);
      } }, function(params) {
        return (0, import_react.createElement)(TemplateConnector, null, function(_a2, _b) {
          var selection = _a2.selection;
          var toggleSelection2 = _b.toggleSelection;
          return (0, import_react.createElement)(Cell, __assign2({}, params, { row: params.tableRow.row, selected: selection.indexOf(params.tableRow.rowId) !== -1, onToggle: function() {
            return toggleSelection2({ rowIds: [params.tableRow.rowId] });
          } }));
        });
      }),
      (highlightRow || selectByRowClick) && (0, import_react.createElement)(Template, { name: "tableRow", predicate: function(_a2) {
        var tableRow = _a2.tableRow;
        return !!isDataTableRow(tableRow);
      } }, function(params) {
        return (0, import_react.createElement)(TemplateConnector, null, function(_a2, _b) {
          var selection = _a2.selection;
          var toggleSelection2 = _b.toggleSelection;
          return (0, import_react.createElement)(Row, __assign2({}, params, { selectByRowClick, highlighted: isRowHighlighted(highlightRow, selection, params.tableRow), onToggle: function() {
            return toggleSelection2({ rowIds: [params.tableRow.rowId] });
          } }));
        });
      })
    );
  };
  TableSelectionBase2.defaultProps = {
    highlightRow: false,
    selectByRowClick: false,
    showSelectAll: false,
    showSelectionColumn: true
  };
  TableSelectionBase2.components = {
    rowComponent: "Row",
    cellComponent: "Cell",
    headerCellComponent: "HeaderCell"
  };
  TableSelectionBase2.COLUMN_TYPE = TABLE_SELECT_TYPE;
  return TableSelectionBase2;
}(import_react.PureComponent);
var TableSelection = TableSelectionBase;
var RowDetailStateBase = function(_super) {
  __extends(RowDetailStateBase2, _super);
  function RowDetailStateBase2(props) {
    var _this = _super.call(this, props) || this;
    _this.state = {
      expandedRowIds: props.expandedRowIds || props.defaultExpandedRowIds
    };
    var stateHelper = createStateHelper(_this, {
      expandedRowIds: function() {
        var onExpandedRowIdsChange = _this.props.onExpandedRowIdsChange;
        return onExpandedRowIdsChange;
      }
    });
    _this.toggleDetailRowExpanded = stateHelper.applyFieldReducer.bind(stateHelper, "expandedRowIds", toggleDetailRowExpanded);
    return _this;
  }
  RowDetailStateBase2.getDerivedStateFromProps = function(nextProps, prevState) {
    var _a = nextProps.expandedRowIds, expandedRowIds = _a === void 0 ? prevState.expandedRowIds : _a;
    return {
      expandedRowIds
    };
  };
  RowDetailStateBase2.prototype.render = function() {
    var expandedRowIds = this.state.expandedRowIds;
    return (0, import_react.createElement)(
      Plugin,
      { name: "RowDetailState" },
      (0, import_react.createElement)(Getter, { name: "expandedDetailRowIds", value: expandedRowIds }),
      (0, import_react.createElement)(Action, { name: "toggleDetailRowExpanded", action: this.toggleDetailRowExpanded })
    );
  };
  RowDetailStateBase2.defaultProps = {
    defaultExpandedRowIds: []
  };
  return RowDetailStateBase2;
}(import_react.PureComponent);
var RowDetailState = RowDetailStateBase;
var getCellColSpanComputed = function(_a) {
  var getTableCellColSpan = _a.getTableCellColSpan;
  return tableDetailCellColSpanGetter(getTableCellColSpan);
};
var pluginDependencies$9 = [
  { name: "RowDetailState" },
  { name: "Table" }
];
var TableRowDetailBase = function(_super) {
  __extends(TableRowDetailBase2, _super);
  function TableRowDetailBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  TableRowDetailBase2.prototype.render = function() {
    var _a = this.props, rowHeight = _a.rowHeight, Content = _a.contentComponent, ToggleCell = _a.toggleCellComponent, Cell = _a.cellComponent, Row = _a.rowComponent, toggleColumnWidth = _a.toggleColumnWidth;
    var tableColumnsComputed2 = function(_a2) {
      var tableColumns = _a2.tableColumns;
      return tableColumnsWithDetail(tableColumns, toggleColumnWidth);
    };
    var tableBodyRowsComputed2 = function(_a2) {
      var tableBodyRows = _a2.tableBodyRows, expandedDetailRowIds = _a2.expandedDetailRowIds;
      return tableRowsWithExpandedDetail(tableBodyRows, expandedDetailRowIds, rowHeight);
    };
    return (0, import_react.createElement)(
      Plugin,
      { name: "TableRowDetail", dependencies: pluginDependencies$9 },
      (0, import_react.createElement)(Getter, { name: "tableColumns", computed: tableColumnsComputed2 }),
      (0, import_react.createElement)(Getter, { name: "tableBodyRows", computed: tableBodyRowsComputed2 }),
      (0, import_react.createElement)(Getter, { name: "getTableCellColSpan", computed: getCellColSpanComputed }),
      (0, import_react.createElement)(Template, { name: "tableCell", predicate: function(_a2) {
        var tableRow = _a2.tableRow, tableColumn = _a2.tableColumn;
        return isDetailToggleTableCell(tableRow, tableColumn);
      } }, function(params) {
        return (0, import_react.createElement)(TemplateConnector, null, function(_a2, _b) {
          var expandedDetailRowIds = _a2.expandedDetailRowIds;
          var toggleDetailRowExpanded2 = _b.toggleDetailRowExpanded;
          return (0, import_react.createElement)(ToggleCell, __assign2({}, params, { row: params.tableRow.row, expanded: isDetailRowExpanded(expandedDetailRowIds, params.tableRow.rowId), onToggle: function() {
            return toggleDetailRowExpanded2({ rowId: params.tableRow.rowId });
          } }));
        });
      }),
      (0, import_react.createElement)(Template, { name: "tableCell", predicate: function(_a2) {
        var tableRow = _a2.tableRow;
        return !!isDetailTableRow(tableRow);
      } }, function(params) {
        return (0, import_react.createElement)(TemplateConnector, null, function(_a2) {
          var tableColumns = _a2.tableColumns;
          if (isDetailTableCell(params.tableColumn, tableColumns)) {
            return (0, import_react.createElement)(Cell, __assign2({}, params, { row: params.tableRow.row }), Content && (0, import_react.createElement)(Content, { row: params.tableRow.row }));
          }
          return null;
        });
      }),
      (0, import_react.createElement)(Template, { name: "tableRow", predicate: function(_a2) {
        var tableRow = _a2.tableRow;
        return !!isDetailTableRow(tableRow);
      } }, function(params) {
        return (0, import_react.createElement)(Row, __assign2({}, params, { row: params.tableRow.row }));
      })
    );
  };
  TableRowDetailBase2.ROW_TYPE = TABLE_DETAIL_TYPE;
  TableRowDetailBase2.COLUMN_TYPE = TABLE_DETAIL_TYPE;
  TableRowDetailBase2.defaultProps = {
    contentComponent: function() {
      return null;
    }
  };
  TableRowDetailBase2.components = {
    rowComponent: "Row",
    cellComponent: "Cell",
    toggleCellComponent: "ToggleCell"
  };
  return TableRowDetailBase2;
}(import_react.PureComponent);
var TableRowDetail = TableRowDetailBase;
var defaultSummaryMessages = {
  sum: "Sum",
  min: "Min",
  max: "Max",
  avg: "Avg",
  count: "Count"
};
var TableSummaryContent = function(_a) {
  var column = _a.column, columnSummaries = _a.columnSummaries, formatlessSummaryTypes = _a.formatlessSummaryTypes, Item = _a.itemComponent, messages = _a.messages;
  var getMessage = getMessagesFormatter(__assign2(__assign2({}, defaultSummaryMessages), messages));
  var SummaryItem = function(_a2) {
    var summary = _a2.summary, children = _a2.children;
    return (0, import_react.createElement)(Item, { getMessage, type: summary.type, value: summary.value }, children || String(summary.value));
  };
  var isFormatlessSummary = function(summary) {
    return summary.value === null || formatlessSummaryTypes.includes(summary.type) || defaultFormatlessSummaries.includes(summary.type);
  };
  return (0, import_react.createElement)(import_react.Fragment, null, columnSummaries.map(function(summary) {
    if (isFormatlessSummary(summary)) {
      return (0, import_react.createElement)(SummaryItem, { key: summary.type, summary });
    }
    return (0, import_react.createElement)(TemplatePlaceholder, { key: summary.type, name: "valueFormatter", params: {
      column,
      value: summary.value
    } }, function(content) {
      return (0, import_react.createElement)(SummaryItem, { summary }, content);
    });
  }));
};
var getInlineSummaryComponent = function(column, summary, formatlessSummaries) {
  return function() {
    return summary.value === null || formatlessSummaries.includes(summary.type) ? (0, import_react.createElement)(import_react.Fragment, null, summary.value) : (0, import_react.createElement)(TemplatePlaceholder, { key: summary.type, name: "valueFormatter", params: {
      column,
      value: summary.value
    } }, function(content) {
      return content || summary.value;
    });
  };
};
var flattenGroupInlineSummaries = function(columns, tableRow, groupSummaryItems, groupSummaryValues2, formatlessSummaries) {
  return getGroupInlineSummaries(groupSummaryItems, columns, groupSummaryValues2[tableRow.row.compoundKey]).map(function(colSummaries) {
    return __spread2(colSummaries.summaries.map(function(summary) {
      return __assign2(__assign2({}, summary), { columnTitle: colSummaries.column.title, messageKey: summary.type + "Of", component: getInlineSummaryComponent(colSummaries.column, summary, formatlessSummaries) });
    }));
  }).reduce(function(acc, summaries) {
    return acc.concat(summaries);
  }, []);
};
var pluginDependencies$a = [
  { name: "GroupingState" },
  { name: "Table" },
  { name: "DataTypeProvider", optional: true },
  { name: "SummaryState", optional: true },
  { name: "CustomSummary", optional: true },
  { name: "IntegratedSummary", optional: true },
  { name: "Table" },
  { name: "DataTypeProvider", optional: true },
  { name: "TableSelection", optional: true }
];
var side = "left";
var defaultMessages$1 = {
  countOf: "Count: ",
  sumOf: "Sum of {columnTitle} is ",
  maxOf: "Max of {columnTitle} is ",
  minOf: "Min of {columnTitle} is ",
  avgOf: "Avg of {columnTitle} is "
};
var tableBodyRowsComputed$1 = function(_a) {
  var tableBodyRows = _a.tableBodyRows, isGroupRow = _a.isGroupRow;
  return tableRowsWithGrouping(tableBodyRows, isGroupRow);
};
var getCellColSpanComputed$1 = function(_a) {
  var getTableCellColSpan = _a.getTableCellColSpan, groupSummaryItems = _a.groupSummaryItems, viewport = _a.viewport;
  var firstVisibleColumnIndex = viewport === null || viewport === void 0 ? void 0 : viewport.columns[0][0];
  return tableGroupCellColSpanGetter(getTableCellColSpan, groupSummaryItems, firstVisibleColumnIndex);
};
var TableGroupRowBase = function(_super) {
  __extends(TableGroupRowBase2, _super);
  function TableGroupRowBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  TableGroupRowBase2.prototype.render = function() {
    var _a = this.props, GroupCell = _a.cellComponent, Content = _a.contentComponent, Icon = _a.iconComponent, GroupRow = _a.rowComponent, Container = _a.containerComponent, GroupIndentCell = _a.indentCellComponent, InlineSummary = _a.inlineSummaryComponent, InlineSummaryItem2 = _a.inlineSummaryItemComponent, SummaryCell = _a.summaryCellComponent, SummaryItem = _a.summaryItemComponent, StubCell = _a.stubCellComponent, indentColumnWidth = _a.indentColumnWidth, contentCellPadding = _a.contentCellPadding, showColumnsWhenGrouped = _a.showColumnsWhenGrouped, columnExtensions = _a.columnExtensions, messages = _a.messages, formatlessSummaryTypes = _a.formatlessSummaryTypes;
    var getMessage = getMessagesFormatter(__assign2(__assign2({}, defaultMessages$1), messages));
    return (0, import_react.createElement)(
      Plugin,
      { name: "TableGroupRow", dependencies: pluginDependencies$a },
      (0, import_react.createElement)(TableColumnsWithGrouping, { columnExtensions, showColumnsWhenGrouped, indentColumnWidth }),
      (0, import_react.createElement)(Getter, { name: "tableBodyRows", computed: tableBodyRowsComputed$1 }),
      (0, import_react.createElement)(Getter, { name: "getTableCellColSpan", computed: getCellColSpanComputed$1 }),
      (0, import_react.createElement)(Template, { name: "tableCell", predicate: function(_a2) {
        var tableRow = _a2.tableRow;
        return isGroupTableRow(tableRow);
      } }, function(params) {
        return (0, import_react.createElement)(TemplateConnector, null, function(_a2, _b) {
          var grouping = _a2.grouping, expandedGroups = _a2.expandedGroups, groupSummaryItems = _a2.groupSummaryItems, groupSummaryValues2 = _a2.groupSummaryValues, columns = _a2.columns;
          var toggleGroupExpanded = _b.toggleGroupExpanded;
          if (isGroupTableCell(params.tableRow, params.tableColumn)) {
            var formatlessSummaries = defaultFormatlessSummaries.concat(formatlessSummaryTypes);
            var inlineSummaries_1 = groupSummaryItems ? flattenGroupInlineSummaries(columns, params.tableRow, groupSummaryItems, groupSummaryValues2, formatlessSummaries) : [];
            var cellIndent = calculateGroupCellIndent(params.tableColumn, grouping, indentColumnWidth);
            var contentIndent_1 = "calc(" + cellIndent + "px + " + contentCellPadding + ")";
            return (0, import_react.createElement)(TemplatePlaceholder, { name: "valueFormatter", params: {
              column: params.tableColumn.column,
              value: params.tableRow.row.value
            } }, function(content) {
              return (0, import_react.createElement)(GroupCell, __assign2({}, params, { contentComponent: Content, iconComponent: Icon, containerComponent: Container, row: params.tableRow.row, column: params.tableColumn.column, expanded: expandedGroups.indexOf(params.tableRow.row.compoundKey) !== -1, onToggle: function() {
                return toggleGroupExpanded({ groupKey: params.tableRow.row.compoundKey });
              }, inlineSummaries: inlineSummaries_1, inlineSummaryComponent: InlineSummary, inlineSummaryItemComponent: InlineSummaryItem2, getMessage, position: contentIndent_1, side }), content);
            });
          }
          if (isGroupIndentTableCell(params.tableRow, params.tableColumn, grouping)) {
            var fixedProps = {
              side,
              position: calculateGroupCellIndent(params.tableColumn, grouping, indentColumnWidth)
            };
            if (GroupIndentCell) {
              return (0, import_react.createElement)(GroupIndentCell, __assign2({}, params, fixedProps, { row: params.tableRow.row, column: params.tableColumn.column }));
            }
            return (0, import_react.createElement)(TemplatePlaceholder, { params: fixedProps });
          }
          if (isGroupIndentStubTableCell(params.tableRow, params.tableColumn, grouping)) {
            return (0, import_react.createElement)(TemplatePlaceholder, { params });
          }
          return null;
        });
      }),
      (0, import_react.createElement)(Template, { name: "tableCell", predicate: function(_a2) {
        var tableRow = _a2.tableRow, tableColumn = _a2.tableColumn;
        return isGroupRowOrdinaryCell(tableRow, tableColumn);
      } }, function(params) {
        return (0, import_react.createElement)(TemplateConnector, null, function(_a2, _b) {
          var groupSummaryItems = _a2.groupSummaryItems, groupSummaryValues2 = _a2.groupSummaryValues, grouping = _a2.grouping, tableColumns = _a2.tableColumns;
          var toggleGroupExpanded = _b.toggleGroupExpanded;
          var tableColumn = params.tableColumn, tableRow = params.tableRow;
          var onToggle = function() {
            return toggleGroupExpanded({ groupKey: tableRow.row.compoundKey });
          };
          if (isRowSummaryCell(tableRow, tableColumn, grouping, groupSummaryItems)) {
            var columnSummaries = getColumnSummaries(groupSummaryItems, tableColumn.column.name, groupSummaryValues2[tableRow.row.compoundKey], function(summaryItem) {
              return !summaryItem.showInGroupFooter && summaryItem.alignByColumn;
            });
            return (0, import_react.createElement)(
              SummaryCell,
              __assign2({}, params, { row: params.tableRow.row, column: params.tableColumn.column, onToggle }),
              (0, import_react.createElement)(TableSummaryContent, { column: tableColumn.column, columnSummaries, formatlessSummaryTypes, itemComponent: SummaryItem, messages })
            );
          }
          if (isPreviousCellContainSummary(tableRow, tableColumn, tableColumns, grouping, groupSummaryItems) || TABLE_FLEX_TYPE === tableColumn.type) {
            return (0, import_react.createElement)(StubCell, __assign2({}, params, { onToggle }));
          }
          return (0, import_react.createElement)(TemplatePlaceholder, null);
        });
      }),
      (0, import_react.createElement)(Template, { name: "tableRow", predicate: function(_a2) {
        var tableRow = _a2.tableRow;
        return isGroupTableRow(tableRow);
      } }, function(params) {
        return (0, import_react.createElement)(GroupRow, __assign2({}, params, { row: params.tableRow.row }));
      })
    );
  };
  TableGroupRowBase2.ROW_TYPE = TABLE_GROUP_TYPE;
  TableGroupRowBase2.COLUMN_TYPE = TABLE_GROUP_TYPE;
  TableGroupRowBase2.defaultProps = {
    showColumnsWhenGrouped: false,
    formatlessSummaryTypes: []
  };
  TableGroupRowBase2.components = {
    rowComponent: "Row",
    cellComponent: "Cell",
    contentComponent: "Content",
    iconComponent: "Icon",
    containerComponent: "Container",
    indentCellComponent: "IndentCell",
    inlineSummaryComponent: "InlineSummary",
    inlineSummaryItemComponent: "InlineSummaryItem",
    summaryCellComponent: "SummaryCell",
    summaryItemComponent: "SummaryItem",
    stubCellComponent: "StubCell"
  };
  return TableGroupRowBase2;
}(import_react.PureComponent);
var TableGroupRow = TableGroupRowBase;
var tableHeaderRowsComputed$1 = function(_a) {
  var tableHeaderRows2 = _a.tableHeaderRows;
  return tableRowsWithHeading(tableHeaderRows2 || []);
};
var TableHeaderRowBase = function(_super) {
  __extends(TableHeaderRowBase2, _super);
  function TableHeaderRowBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  TableHeaderRowBase2.prototype.render = function() {
    var _a = this.props, showSortingControls = _a.showSortingControls, showGroupingControls = _a.showGroupingControls, HeaderCell = _a.cellComponent, HeaderRow = _a.rowComponent, Content = _a.contentComponent, SortLabel = _a.sortLabelComponent, GroupButton = _a.groupButtonComponent, Title = _a.titleComponent, messages = _a.messages;
    var getMessage = getMessagesFormatter(messages);
    return (0, import_react.createElement)(
      Plugin,
      { name: "TableHeaderRow", dependencies: [
        { name: "Table" },
        { name: "SortingState", optional: !showSortingControls },
        { name: "GroupingState", optional: !showGroupingControls },
        { name: "DragDropProvider", optional: true },
        { name: "TableColumnResizing", optional: true }
      ] },
      (0, import_react.createElement)(Getter, { name: "tableHeaderRows", computed: tableHeaderRowsComputed$1 }),
      (0, import_react.createElement)(Template, { name: "tableCell", predicate: function(_a2) {
        var tableRow = _a2.tableRow, tableColumn = _a2.tableColumn;
        return isHeadingTableCell(tableRow, tableColumn);
      } }, function(params) {
        return (0, import_react.createElement)(TemplateConnector, null, function(_a2, _b) {
          var sorting = _a2.sorting, tableColumns = _a2.tableColumns, draggingEnabled = _a2.draggingEnabled, tableColumnResizingEnabled = _a2.tableColumnResizingEnabled, isColumnSortingEnabled = _a2.isColumnSortingEnabled, isColumnGroupingEnabled = _a2.isColumnGroupingEnabled, columnResizingMode = _a2.columnResizingMode;
          var changeColumnSorting2 = _b.changeColumnSorting, changeColumnGrouping2 = _b.changeColumnGrouping, changeTableColumnWidth2 = _b.changeTableColumnWidth, draftTableColumnWidth2 = _b.draftTableColumnWidth, cancelTableColumnWidthDraft2 = _b.cancelTableColumnWidthDraft, _c = _b.storeWidthGetters, storeWidthGetters = _c === void 0 ? function() {
          } : _c;
          var _d = params.tableColumn.column, columnName = _d.name, columnTitle = _d.title;
          var atLeastOneDataColumn = tableColumns.filter(function(_a3) {
            var type = _a3.type;
            return type === TABLE_DATA_TYPE;
          }).length > 1;
          var sortingEnabled = isColumnSortingEnabled && isColumnSortingEnabled(columnName);
          var groupingEnabled = isColumnGroupingEnabled && isColumnGroupingEnabled(columnName) && atLeastOneDataColumn;
          var nextColumnName2 = getNextColumnName(tableColumns, columnName);
          return (0, import_react.createElement)(
            HeaderCell,
            __assign2({}, params, { column: params.tableColumn.column, draggingEnabled: draggingEnabled && atLeastOneDataColumn, resizingEnabled: tableColumnResizingEnabled && (!!nextColumnName2 || columnResizingMode === "widget"), onWidthChange: function(_a3) {
              var shift = _a3.shift;
              return changeTableColumnWidth2({
                columnName,
                nextColumnName: nextColumnName2,
                shift
              });
            }, onWidthDraft: function(_a3) {
              var shift = _a3.shift;
              return draftTableColumnWidth2({
                columnName,
                nextColumnName: nextColumnName2,
                shift
              });
            }, onWidthDraftCancel: function() {
              return cancelTableColumnWidthDraft2();
            }, getCellWidth: function(getter) {
              return storeWidthGetters({
                tableColumn: params.tableColumn,
                getter,
                tableColumns
              });
            } }),
            (0, import_react.createElement)(TemplatePlaceholder, { name: "tableHeaderCellBefore", params: {
              column: params.tableColumn.column
            } }),
            (0, import_react.createElement)(Content, { column: params.tableColumn.column, align: params.tableColumn.align }, showSortingControls ? (0, import_react.createElement)(
              SortLabel,
              { column: params.tableColumn.column, align: params.tableColumn.align, direction: getColumnSortingDirection(sorting, columnName) || null, disabled: !sortingEnabled, onSort: function(_a3) {
                var direction = _a3.direction, keepOther = _a3.keepOther;
                changeColumnSorting2({ columnName, direction, keepOther });
              }, getMessage },
              (0, import_react.createElement)(Title, null, columnTitle || columnName)
            ) : (0, import_react.createElement)(Title, null, columnTitle || columnName)),
            showGroupingControls ? (0, import_react.createElement)(GroupButton, { disabled: !groupingEnabled, onGroup: function() {
              return changeColumnGrouping2({ columnName });
            } }) : null
          );
        });
      }),
      (0, import_react.createElement)(Template, { name: "tableRow", predicate: function(_a2) {
        var tableRow = _a2.tableRow;
        return !!isHeadingTableRow(tableRow);
      } }, function(params) {
        return (0, import_react.createElement)(HeaderRow, __assign2({}, params));
      })
    );
  };
  TableHeaderRowBase2.ROW_TYPE = TABLE_HEADING_TYPE;
  TableHeaderRowBase2.defaultProps = {
    showSortingControls: false,
    showGroupingControls: false,
    messages: {}
  };
  TableHeaderRowBase2.components = {
    cellComponent: "Cell",
    rowComponent: "Row",
    contentComponent: "Content",
    sortLabelComponent: "SortLabel",
    titleComponent: "Title",
    groupButtonComponent: "GroupButton"
  };
  return TableHeaderRowBase2;
}(import_react.PureComponent);
TableHeaderRowBase.components = {
  cellComponent: "Cell",
  rowComponent: "Row",
  contentComponent: "Content",
  sortLabelComponent: "SortLabel",
  titleComponent: "Title",
  groupButtonComponent: "GroupButton"
};
var TableHeaderRow = TableHeaderRowBase;
var CellPlaceholder$1 = function(props) {
  return (0, import_react.createElement)(TemplatePlaceholder, { params: props });
};
var bandLevelsVisibilityComputed = function(_a) {
  var columnIntervals = _a.columnVisibleIntervals, tableHeaderColumnChains = _a.tableHeaderColumnChains, bandLevels = _a.bandLevels;
  return bandLevelsVisibility(columnIntervals, tableHeaderColumnChains, bandLevels);
};
var columnVisibleIntervalsComputed = function(_a) {
  var viewport = _a.viewport, tableColumns = _a.tableColumns;
  return columnVisibleIntervals(viewport, tableColumns);
};
var TableBandHeaderBase = function(_super) {
  __extends(TableBandHeaderBase2, _super);
  function TableBandHeaderBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  TableBandHeaderBase2.prototype.render = function() {
    var _a = this.props, Cell = _a.cellComponent, Row = _a.rowComponent, HeaderCell = _a.bandedHeaderCellComponent, InvisibleCell = _a.invisibleCellComponent, columnBands = _a.columnBands;
    var tableHeaderRowsComputed2 = function(_a2) {
      var tableHeaderRows2 = _a2.tableHeaderRows, tableColumns = _a2.tableColumns;
      return tableRowsWithBands(tableHeaderRows2, columnBands, tableColumns);
    };
    var tableHeaderColumnChainsComputed2 = function(_a2) {
      var tableHeaderRows2 = _a2.tableHeaderRows, tableColumns = _a2.tableColumns;
      return tableHeaderColumnChainsWithBands(tableHeaderRows2, tableColumns, columnBands);
    };
    var bandLevels = columnBandLevels(columnBands);
    return (0, import_react.createElement)(
      Plugin,
      { name: "TableBandHeader", dependencies: [
        { name: "Table" },
        { name: "TableHeaderRow" },
        { name: "TableSelection", optional: true },
        { name: "TableEditColumn", optional: true },
        { name: "TableColumnVisibility", optional: true }
      ] },
      (0, import_react.createElement)(Getter, { name: "tableHeaderRows", computed: tableHeaderRowsComputed2 }),
      (0, import_react.createElement)(Getter, { name: "columnVisibleIntervals", computed: columnVisibleIntervalsComputed }),
      (0, import_react.createElement)(Getter, { name: "tableHeaderColumnChains", computed: tableHeaderColumnChainsComputed2 }),
      (0, import_react.createElement)(Getter, { name: "bandLevels", value: bandLevels }),
      (0, import_react.createElement)(Getter, { name: "bandLevelsVisibility", computed: bandLevelsVisibilityComputed }),
      (0, import_react.createElement)(Template, { name: "tableCell", predicate: function(_a2) {
        var tableRow = _a2.tableRow;
        return !!isBandedOrHeaderRow(tableRow);
      } }, function(params) {
        return (0, import_react.createElement)(TemplateConnector, null, function(_a2) {
          var tableColumns = _a2.tableColumns, tableHeaderRows2 = _a2.tableHeaderRows, tableHeaderColumnChains = _a2.tableHeaderColumnChains, columnIntervals = _a2.columnVisibleIntervals, levelsVisibility = _a2.bandLevelsVisibility;
          var bandComponent = getBandComponent(params, tableHeaderRows2, tableColumns, columnBands, tableHeaderColumnChains, columnIntervals, levelsVisibility);
          switch (bandComponent.type) {
            case BAND_DUPLICATE_RENDER:
              return (0, import_react.createElement)(TemplatePlaceholder, { params: __assign2({}, params) });
            case BAND_EMPTY_CELL:
              return (0, import_react.createElement)(InvisibleCell, null);
            case BAND_GROUP_CELL: {
              var _b = bandComponent.payload, value = _b.value, payload = __rest2(_b, ["value"]);
              return (0, import_react.createElement)(Cell, __assign2({}, params, payload), value);
            }
            case BAND_HEADER_CELL:
              return (0, import_react.createElement)(TemplatePlaceholder, { name: "tableCell", params: __assign2(__assign2({}, params), bandComponent.payload) });
            case BAND_FILL_LEVEL_CELL:
              return (0, import_react.createElement)(Cell, __assign2({}, params, bandComponent.payload, { style: { whiteSpace: "pre" } }), " ");
            default:
              return null;
          }
        });
      }),
      (0, import_react.createElement)(Template, { name: "tableCell", predicate: function(_a2) {
        var tableRow = _a2.tableRow, tableColumn = _a2.tableColumn;
        return isHeadingTableCell(tableRow, tableColumn);
      } }, function(params) {
        return (0, import_react.createElement)(HeaderCell, __assign2({ component: CellPlaceholder$1 }, params));
      }),
      (0, import_react.createElement)(Template, { name: "tableRow", predicate: function(_a2) {
        var tableRow = _a2.tableRow;
        return !!isBandedTableRow(tableRow);
      } }, function(params) {
        return (0, import_react.createElement)(Row, __assign2({}, params));
      })
    );
  };
  TableBandHeaderBase2.ROW_TYPE = TABLE_BAND_TYPE;
  TableBandHeaderBase2.components = {
    cellComponent: "Cell",
    rowComponent: "Row",
    bandedHeaderCellComponent: "BandedHeaderCell",
    invisibleCellComponent: "InvisibleCell"
  };
  return TableBandHeaderBase2;
}(import_react.PureComponent);
TableBandHeaderBase.components = {
  cellComponent: "Cell",
  rowComponent: "Row",
  bandedHeaderCellComponent: "BandedHeaderCell",
  invisibleCellComponent: "InvisibleCell"
};
var TableBandHeader = TableBandHeaderBase;
var pluginDependencies$b = [
  { name: "FilteringState" },
  { name: "Table" },
  { name: "DataTypeProvider", optional: true }
];
var defaultMessages$2 = {
  filterPlaceholder: "Filter...",
  contains: "Contains",
  notContains: "Does not contain",
  startsWith: "Starts with",
  endsWith: "Ends with",
  equal: "Equals",
  notEqual: "Does not equal",
  greaterThan: "Greater than",
  greaterThanOrEqual: "Greater than or equal to",
  lessThan: "Less than",
  lessThanOrEqual: "Less than or equal to"
};
var TableFilterRowBase = function(_super) {
  __extends(TableFilterRowBase2, _super);
  function TableFilterRowBase2(props) {
    var _this = _super.call(this, props) || this;
    _this.state = {
      filterOperations: {}
    };
    return _this;
  }
  TableFilterRowBase2.prototype.render = function() {
    var _this = this;
    var _a = this.props, rowHeight = _a.rowHeight, showFilterSelector = _a.showFilterSelector, FilterCell = _a.cellComponent, FilterRow = _a.rowComponent, FilterSelector = _a.filterSelectorComponent, iconComponent = _a.iconComponent, toggleButtonComponent = _a.toggleButtonComponent, EditorComponent = _a.editorComponent, messages = _a.messages;
    var getMessage = getMessagesFormatter(__assign2(__assign2({}, defaultMessages$2), messages));
    var tableHeaderRowsComputed2 = function(_a2) {
      var tableHeaderRows2 = _a2.tableHeaderRows;
      return tableHeaderRowsWithFilter(tableHeaderRows2, rowHeight);
    };
    return (0, import_react.createElement)(
      Plugin,
      { name: "TableFilterRow", dependencies: pluginDependencies$b },
      (0, import_react.createElement)(Getter, { name: "tableHeaderRows", computed: tableHeaderRowsComputed2 }),
      (0, import_react.createElement)(Template, { name: "tableCell", predicate: function(_a2) {
        var tableRow = _a2.tableRow, tableColumn = _a2.tableColumn;
        return isFilterTableCell(tableRow, tableColumn);
      } }, function(params) {
        return (0, import_react.createElement)(TemplateConnector, null, function(_a2, _b) {
          var filters = _a2.filters, isColumnFilteringEnabled = _a2.isColumnFilteringEnabled, getAvailableFilterOperations = _a2.getAvailableFilterOperations, isDataRemote = _a2.isDataRemote;
          var changeColumnFilter2 = _b.changeColumnFilter, scrollToRow = _b.scrollToRow;
          var filterOperations = _this.state.filterOperations;
          var columnName = params.tableColumn.column.name;
          var filter = getColumnFilterConfig(filters, columnName);
          var onFilter = function(config) {
            if (isDataRemote) {
              scrollToRow(TOP_POSITION);
            }
            changeColumnFilter2({ columnName, config });
          };
          var columnFilterOperations = getColumnFilterOperations(getAvailableFilterOperations, columnName);
          var selectedFilterOperation = getSelectedFilterOperation(filterOperations, columnName, filter, columnFilterOperations);
          var handleFilterOperationChange = function(value) {
            var _a3;
            _this.setState({
              filterOperations: __assign2(__assign2({}, filterOperations), (_a3 = {}, _a3[columnName] = value, _a3))
            });
            if (filter && !isFilterValueEmpty(filter.value)) {
              onFilter({ value: filter.value, operation: value });
            }
          };
          var handleFilterValueChange = function(value) {
            return onFilter(!isFilterValueEmpty(value) ? { value, operation: selectedFilterOperation } : null);
          };
          var filteringEnabled = isColumnFilteringEnabled(columnName);
          return (0, import_react.createElement)(TemplatePlaceholder, { name: "valueEditor", params: {
            column: params.tableColumn.column,
            value: filter ? filter.value : void 0,
            onValueChange: handleFilterValueChange,
            disabled: !filteringEnabled
          } }, function(content) {
            return (0, import_react.createElement)(
              FilterCell,
              __assign2({}, params, { getMessage, column: params.tableColumn.column, filter, filteringEnabled, onFilter }),
              showFilterSelector ? (0, import_react.createElement)(FilterSelector, { toggleButtonComponent, iconComponent, value: selectedFilterOperation, availableValues: columnFilterOperations, onChange: handleFilterOperationChange, disabled: !filteringEnabled, getMessage }) : null,
              content || (0, import_react.createElement)(EditorComponent, { value: filter ? filter.value : void 0, disabled: !filteringEnabled, getMessage, onChange: handleFilterValueChange })
            );
          });
        });
      }),
      (0, import_react.createElement)(Template, { name: "tableRow", predicate: function(_a2) {
        var tableRow = _a2.tableRow;
        return !!isFilterTableRow(tableRow);
      } }, function(params) {
        return (0, import_react.createElement)(FilterRow, __assign2({}, params));
      })
    );
  };
  TableFilterRowBase2.ROW_TYPE = TABLE_FILTER_TYPE;
  TableFilterRowBase2.defaultProps = {
    showFilterSelector: false,
    messages: {}
  };
  TableFilterRowBase2.components = {
    rowComponent: "Row",
    cellComponent: "Cell",
    filterSelectorComponent: "FilterSelector",
    iconComponent: "Icon",
    editorComponent: "Editor",
    toggleButtonComponent: "ToggleButton"
  };
  return TableFilterRowBase2;
}(import_react.PureComponent);
var TableFilterRow = TableFilterRowBase;
var pluginDependencies$c = [
  { name: "EditingState" },
  { name: "Table" },
  { name: "DataTypeProvider", optional: true }
];
var TableEditRowBase = function(_super) {
  __extends(TableEditRowBase2, _super);
  function TableEditRowBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  TableEditRowBase2.prototype.render = function() {
    var _a = this.props, EditCell = _a.cellComponent, EditRow = _a.rowComponent, rowHeight = _a.rowHeight;
    var tableBodyRowsComputed2 = function(_a2) {
      var tableBodyRows = _a2.tableBodyRows, editingRowIds = _a2.editingRowIds, addedRows = _a2.addedRows;
      return tableRowsWithEditing(tableBodyRows, editingRowIds, addedRows, rowHeight);
    };
    return (0, import_react.createElement)(
      Plugin,
      { name: "TableEditRow", dependencies: pluginDependencies$c },
      (0, import_react.createElement)(Getter, { name: "tableBodyRows", computed: tableBodyRowsComputed2 }),
      (0, import_react.createElement)(Template, { name: "tableCell", predicate: function(_a2) {
        var tableRow = _a2.tableRow, tableColumn = _a2.tableColumn;
        return isEditTableCell(tableRow, tableColumn);
      } }, function(params) {
        return (0, import_react.createElement)(TemplateConnector, null, function(_a2, _b) {
          var getCellValue = _a2.getCellValue, createRowChange = _a2.createRowChange, rowChanges = _a2.rowChanges, isColumnEditingEnabled = _a2.isColumnEditingEnabled;
          var changeAddedRow2 = _b.changeAddedRow, changeRow2 = _b.changeRow;
          var _c = params.tableRow, rowId = _c.rowId, row = _c.row;
          var column = params.tableColumn.column;
          var columnName = column.name;
          var isNew = isAddedTableRow(params.tableRow);
          var changedRow = isNew ? row : __assign2(__assign2({}, row), getRowChange(rowChanges, rowId));
          var value = getCellValue(changedRow, columnName);
          var onValueChange = function(newValue) {
            var changeArgs = {
              rowId,
              change: createRowChange(changedRow, newValue, columnName)
            };
            if (isNew) {
              changeAddedRow2(changeArgs);
            } else {
              changeRow2(changeArgs);
            }
          };
          var editingEnabled = isColumnEditingEnabled(columnName);
          return (0, import_react.createElement)(TemplatePlaceholder, { name: "valueEditor", params: {
            column,
            row,
            value,
            onValueChange,
            disabled: !editingEnabled
          } }, function(content) {
            return (0, import_react.createElement)(EditCell, __assign2({}, params, { row, column, value, editingEnabled, onValueChange }), content);
          });
        });
      }),
      (0, import_react.createElement)(Template, { name: "tableRow", predicate: function(_a2) {
        var tableRow = _a2.tableRow;
        return !!(isEditTableRow(tableRow) || isAddedTableRow(tableRow));
      } }, function(params) {
        return (0, import_react.createElement)(EditRow, __assign2({}, params, { row: params.tableRow.row }));
      })
    );
  };
  TableEditRowBase2.ADDED_ROW_TYPE = TABLE_ADDED_TYPE;
  TableEditRowBase2.EDIT_ROW_TYPE = TABLE_EDIT_TYPE;
  TableEditRowBase2.components = {
    rowComponent: "Row",
    cellComponent: "Cell"
  };
  return TableEditRowBase2;
}(import_react.PureComponent);
var TableEditRow = TableEditRowBase;
var pluginDependencies$d = [
  { name: "EditingState" },
  { name: "Table" }
];
var defaultMessages$3 = {
  addCommand: "New",
  editCommand: "Edit",
  deleteCommand: "Delete",
  commitCommand: "Save",
  cancelCommand: "Cancel"
};
var TableEditColumnBase = function(_super) {
  __extends(TableEditColumnBase2, _super);
  function TableEditColumnBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  TableEditColumnBase2.prototype.render = function() {
    var _a = this.props, Cell = _a.cellComponent, HeaderCell = _a.headerCellComponent, Command = _a.commandComponent, showAddCommand = _a.showAddCommand, showEditCommand = _a.showEditCommand, showDeleteCommand = _a.showDeleteCommand, width = _a.width, messages = _a.messages;
    var getMessage = getMessagesFormatter(__assign2(__assign2({}, defaultMessages$3), messages));
    var tableColumnsComputed2 = function(_a2) {
      var tableColumns = _a2.tableColumns;
      return tableColumnsWithEditing(tableColumns, width);
    };
    return (0, import_react.createElement)(
      Plugin,
      { name: "TableEditColumn", dependencies: pluginDependencies$d },
      (0, import_react.createElement)(Getter, { name: "tableColumns", computed: tableColumnsComputed2 }),
      (0, import_react.createElement)(Template, { name: "tableCell", predicate: function(_a2) {
        var tableRow = _a2.tableRow, tableColumn = _a2.tableColumn;
        return isHeadingEditCommandsTableCell(tableRow, tableColumn);
      } }, function(params) {
        return (0, import_react.createElement)(TemplateConnector, null, function(getters, actions) {
          return (0, import_react.createElement)(HeaderCell, __assign2({}, params), showAddCommand && (0, import_react.createElement)(Command, { id: "add", text: getMessage("addCommand"), onExecute: function() {
            return actions.addRow();
          } }));
        });
      }),
      (0, import_react.createElement)(Template, { name: "tableCell", predicate: function(_a2) {
        var tableRow = _a2.tableRow, tableColumn = _a2.tableColumn;
        return isEditCommandsTableCell(tableRow, tableColumn);
      } }, function(params) {
        return (0, import_react.createElement)(TemplateConnector, null, function(getters, actions) {
          var isEdit = isEditTableRow(params.tableRow);
          var isNew = isAddedTableRow(params.tableRow);
          var isEditing = isEdit || isNew;
          var rowIds = [params.tableRow.rowId];
          return (0, import_react.createElement)(
            Cell,
            __assign2({}, params, { row: params.tableRow.row }),
            showEditCommand && !isEditing && (0, import_react.createElement)(Command, { id: "edit", text: getMessage("editCommand"), onExecute: function() {
              return actions.startEditRows({ rowIds });
            } }),
            showDeleteCommand && !isEditing && (0, import_react.createElement)(Command, { id: "delete", text: getMessage("deleteCommand"), onExecute: function() {
              actions.deleteRows({ rowIds });
              actions.commitDeletedRows({ rowIds });
            } }),
            isEditing && (0, import_react.createElement)(Command, { id: "commit", text: getMessage("commitCommand"), onExecute: function() {
              if (isNew) {
                actions.commitAddedRows({ rowIds });
              } else {
                actions.stopEditRows({ rowIds });
                actions.commitChangedRows({ rowIds });
              }
            } }),
            isEditing && (0, import_react.createElement)(Command, { id: "cancel", text: getMessage("cancelCommand"), onExecute: function() {
              if (isNew) {
                actions.cancelAddedRows({ rowIds });
              } else {
                actions.stopEditRows({ rowIds });
                actions.cancelChangedRows({ rowIds });
              }
            } })
          );
        });
      })
    );
  };
  TableEditColumnBase2.COLUMN_TYPE = TABLE_EDIT_COMMAND_TYPE;
  TableEditColumnBase2.defaultProps = {
    showAddCommand: false,
    showEditCommand: false,
    showDeleteCommand: false,
    width: 140,
    messages: {}
  };
  TableEditColumnBase2.components = {
    cellComponent: "Cell",
    headerCellComponent: "HeaderCell",
    commandComponent: "Command"
  };
  return TableEditColumnBase2;
}(import_react.PureComponent);
var TableEditColumn = TableEditColumnBase;
var pluginDependencies$e = [
  { name: "Table" }
];
var TableColumnResizingBase = function(_super) {
  __extends(TableColumnResizingBase2, _super);
  function TableColumnResizingBase2(props) {
    var _this = _super.call(this, props) || this;
    _this.widthGetters = {};
    _this.cachedWidths = {};
    _this.state = {
      columnWidths: props.columnWidths || props.defaultColumnWidths,
      draftColumnWidths: []
    };
    var stateHelper = createStateHelper(_this, {
      columnWidths: function() {
        var onColumnWidthsChange = _this.props.onColumnWidthsChange;
        return onColumnWidthsChange;
      }
    });
    _this.tableColumnsComputed = memoize(function(columnWidths) {
      return function(_a) {
        var tableColumns = _a.tableColumns;
        return tableColumnsWithWidths(tableColumns, columnWidths, _this.props.resizingMode);
      };
    });
    _this.tableColumnsDraftComputed = memoize(function(draftColumnWidths) {
      return function(_a) {
        var tableColumns = _a.tableColumns;
        return tableColumnsWithDraftWidths(tableColumns, draftColumnWidths, _this.props.resizingMode);
      };
    });
    _this.changeTableColumnWidth = stateHelper.applyReducer.bind(stateHelper, function(prevState, payload) {
      var cachedWidths = __assign2({}, _this.cachedWidths);
      var _a = _this.props, minColumnWidth = _a.minColumnWidth, maxColumnWidth = _a.maxColumnWidth, columnExtensions = _a.columnExtensions, resizingMode = _a.resizingMode;
      return changeTableColumnWidth(prevState, __assign2(__assign2({}, payload), {
        cachedWidths,
        resizingMode,
        minColumnWidth,
        maxColumnWidth,
        columnExtensions
      }));
    });
    _this.draftTableColumnWidth = stateHelper.applyReducer.bind(stateHelper, function(prevState, payload) {
      _this.storeCache(payload);
      var cachedWidths = _this.cachedWidths;
      var _a = _this.props, minColumnWidth = _a.minColumnWidth, maxColumnWidth = _a.maxColumnWidth, columnExtensions = _a.columnExtensions, resizingMode = _a.resizingMode;
      return draftTableColumnWidth(prevState, __assign2(__assign2({}, payload), {
        cachedWidths,
        resizingMode,
        minColumnWidth,
        maxColumnWidth,
        columnExtensions
      }));
    });
    _this.cancelTableColumnWidthDraft = stateHelper.applyReducer.bind(stateHelper, cancelTableColumnWidthDraft);
    _this.storeCache = function(_a) {
      var columnName = _a.columnName, nextColumnName2 = _a.nextColumnName;
      if (Object.keys(_this.cachedWidths).length === 0) {
        _this.cachedWidths[columnName] = _this.widthGetters[columnName]();
        if (nextColumnName2) {
          _this.cachedWidths[nextColumnName2] = _this.widthGetters[nextColumnName2]();
        }
      }
    };
    _this.clearCache = function() {
      Object.keys(_this.cachedWidths).forEach(function(columnName) {
        return delete _this.cachedWidths[columnName];
      });
    };
    _this.storeWidthGetters = memoize(function(_a) {
      var tableColumn = _a.tableColumn, getter = _a.getter, tableColumns = _a.tableColumns;
      if (tableColumn.type === TABLE_DATA_TYPE) {
        _this.widthGetters[tableColumn.column.name] = getter;
      }
      Object.keys(_this.widthGetters).forEach(function(columnName) {
        var columnIndex = tableColumns.findIndex(function(_a2) {
          var type = _a2.type, column = _a2.column;
          return type === TABLE_DATA_TYPE && column.name === columnName;
        });
        if (columnIndex === -1) {
          delete _this.widthGetters[columnName];
        }
      });
    });
    return _this;
  }
  TableColumnResizingBase2.getDerivedStateFromProps = function(nextProps, prevState) {
    var _a = nextProps.columnWidths, columnWidths = _a === void 0 ? prevState.columnWidths : _a;
    return {
      columnWidths
    };
  };
  TableColumnResizingBase2.prototype.componentDidUpdate = function(_, prevState) {
    var currentWidths = this.state.columnWidths;
    var prevWidths = prevState.columnWidths;
    if (currentWidths !== prevWidths) {
      this.clearCache();
    }
  };
  TableColumnResizingBase2.prototype.render = function() {
    var _a = this.state, columnWidths = _a.columnWidths, draftColumnWidths = _a.draftColumnWidths;
    var resizingMode = this.props.resizingMode;
    var tableColumnsComputed2 = this.tableColumnsComputed(columnWidths);
    var tableColumnsDraftComputed = this.tableColumnsDraftComputed(draftColumnWidths);
    return (0, import_react.createElement)(
      Plugin,
      { name: "TableColumnResizing", dependencies: pluginDependencies$e },
      (0, import_react.createElement)(Getter, { name: "tableColumnResizingEnabled", value: true }),
      (0, import_react.createElement)(Getter, { name: "tableColumns", computed: tableColumnsComputed2 }),
      (0, import_react.createElement)(Getter, { name: "tableColumns", computed: tableColumnsDraftComputed }),
      (0, import_react.createElement)(Getter, { name: "columnResizingMode", value: resizingMode }),
      (0, import_react.createElement)(Action, { name: "changeTableColumnWidth", action: this.changeTableColumnWidth }),
      (0, import_react.createElement)(Action, { name: "draftTableColumnWidth", action: this.draftTableColumnWidth }),
      (0, import_react.createElement)(Action, { name: "cancelTableColumnWidthDraft", action: this.cancelTableColumnWidthDraft }),
      (0, import_react.createElement)(Action, { name: "storeWidthGetters", action: this.storeWidthGetters })
    );
  };
  TableColumnResizingBase2.defaultProps = {
    defaultColumnWidths: [],
    resizingMode: "widget"
  };
  return TableColumnResizingBase2;
}(import_react.PureComponent);
var TableColumnResizing = TableColumnResizingBase;
var pluginDependencies$f = [
  { name: "PagingState" }
];
var defaultMessages$4 = {
  showAll: "All",
  info: function(_a) {
    var from = _a.from, to = _a.to, count = _a.count;
    return "" + from + (from < to ? "-" + to : "") + " of " + count;
  }
};
var PagingPanelBase = function(_super) {
  __extends(PagingPanelBase2, _super);
  function PagingPanelBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PagingPanelBase2.prototype.render = function() {
    var _a = this.props, Pager = _a.containerComponent, pageSizes = _a.pageSizes, messages = _a.messages;
    var getMessage = getMessagesFormatter(__assign2(__assign2({}, defaultMessages$4), messages));
    return (0, import_react.createElement)(
      Plugin,
      { name: "PagingPanel", dependencies: pluginDependencies$f },
      (0, import_react.createElement)(Template, { name: "footer" }, function(params) {
        return (0, import_react.createElement)(
          import_react.Fragment,
          null,
          (0, import_react.createElement)(TemplatePlaceholder, null),
          (0, import_react.createElement)(TemplateConnector, null, function(_a2, _b) {
            var currentPage2 = _a2.currentPage, pageSize = _a2.pageSize, totalCount = _a2.totalCount;
            var setCurrentPage2 = _b.setCurrentPage, setPageSize2 = _b.setPageSize;
            return (0, import_react.createElement)(Pager, __assign2({}, params, { currentPage: currentPage2, pageSize, totalCount, totalPages: pageCount(totalCount, pageSize), pageSizes, getMessage, onCurrentPageChange: setCurrentPage2, onPageSizeChange: setPageSize2 }));
          })
        );
      })
    );
  };
  PagingPanelBase2.defaultProps = {
    pageSizes: [],
    messages: {}
  };
  PagingPanelBase2.components = {
    containerComponent: "Container"
  };
  return PagingPanelBase2;
}(import_react.PureComponent);
var PagingPanel = PagingPanelBase;
var defaultProps = {
  draggingEnabled: false,
  onDragStart: function() {
  },
  onDragEnd: function() {
  }
};
var ItemLayout = function(_super) {
  __extends(ItemLayout2, _super);
  function ItemLayout2(props) {
    var _this = _super.call(this, props) || this;
    _this.state = {
      dragging: false
    };
    return _this;
  }
  ItemLayout2.prototype.render = function() {
    var _this = this;
    var _a = this.props, item = _a.item, Item = _a.itemComponent, itemRef = _a.itemRef, draggingEnabled = _a.draggingEnabled, onDragStart = _a.onDragStart, onDragEnd = _a.onDragEnd;
    var dragging = this.state.dragging;
    var itemElement = (0, import_react.createElement)(Item, { item: __assign2(__assign2({}, item), { draft: dragging || item.draft }) });
    return draggingEnabled ? (0, import_react.createElement)(DragSource, { payload: [{ type: "column", columnName: item.column.name }], onStart: function() {
      _this.setState({ dragging: true });
      onDragStart();
    }, onEnd: function() {
      _this.setState({ dragging: false });
      onDragEnd();
    }, ref: itemRef }, itemElement) : itemElement;
  };
  ItemLayout2.defaultProps = defaultProps;
  return ItemLayout2;
}(import_react.PureComponent);
var defaultProps$1 = {
  onGroup: function() {
  },
  draggingEnabled: false,
  isColumnGroupingEnabled: function() {
    return false;
  },
  onGroupDraft: function() {
  },
  onGroupDraftCancel: function() {
  }
};
var GroupPanelLayoutBase = function(_super) {
  __extends(GroupPanelLayoutBase2, _super);
  function GroupPanelLayoutBase2(props) {
    var _this = _super.call(this, props) || this;
    _this.itemRefs = [];
    _this.draggingColumnName = null;
    _this.state = {
      sourceColumnName: null,
      targetItemIndex: -1
    };
    _this.handleDragEvent = function(eventHandler, _a) {
      var payload = _a.payload, restArgs = __rest2(_a, ["payload"]);
      var isColumnGroupingEnabled = _this.props.isColumnGroupingEnabled;
      var columnName = payload[0].columnName;
      if (isColumnGroupingEnabled(columnName)) {
        eventHandler(__assign2({ payload }, restArgs));
      }
    };
    _this.onEnter = function(_a) {
      var payload = _a.payload;
      _this.setState({
        sourceColumnName: payload[0].columnName
      });
    };
    _this.onOver = function(_a) {
      var clientOffset = _a.clientOffset;
      var _b = _this.props, onGroupDraft = _b.onGroupDraft, items = _b.items;
      var _c = _this.state, sourceColumnName = _c.sourceColumnName, prevTargetItemIndex = _c.targetItemIndex;
      var itemGeometries = _this.itemRefs.map(function(ref) {
        return ref.getBoundingClientRect();
      });
      var sourceItemIndex = items.findIndex(function(_a2) {
        var column = _a2.column;
        return column.name === sourceColumnName;
      });
      var targetItemIndex = getGroupCellTargetIndex(itemGeometries, sourceItemIndex, clientOffset);
      if (prevTargetItemIndex === targetItemIndex)
        return;
      onGroupDraft({
        columnName: sourceColumnName,
        groupIndex: targetItemIndex
      });
      _this.setState({ targetItemIndex });
    };
    _this.onLeave = function() {
      var onGroupDraft = _this.props.onGroupDraft;
      var sourceColumnName = _this.state.sourceColumnName;
      if (!_this.draggingColumnName) {
        _this.resetState();
        return;
      }
      onGroupDraft({
        columnName: sourceColumnName,
        groupIndex: -1
      });
      _this.setState({
        targetItemIndex: -1
      });
    };
    _this.onDrop = function() {
      var onGroup = _this.props.onGroup;
      var _a = _this.state, sourceColumnName = _a.sourceColumnName, targetItemIndex = _a.targetItemIndex;
      _this.resetState();
      onGroup({
        columnName: sourceColumnName,
        groupIndex: targetItemIndex
      });
    };
    _this.onDragStart = function(columnName) {
      _this.draggingColumnName = columnName;
    };
    _this.onDragEnd = function() {
      _this.draggingColumnName = null;
      var _a = _this.state, sourceColumnName = _a.sourceColumnName, targetItemIndex = _a.targetItemIndex;
      var onGroup = _this.props.onGroup;
      if (sourceColumnName && targetItemIndex === -1) {
        onGroup({
          columnName: sourceColumnName
        });
      }
      _this.resetState();
    };
    return _this;
  }
  GroupPanelLayoutBase2.prototype.resetState = function() {
    var onGroupDraftCancel = this.props.onGroupDraftCancel;
    onGroupDraftCancel();
    this.setState({
      sourceColumnName: null,
      targetItemIndex: -1
    });
  };
  GroupPanelLayoutBase2.prototype.render = function() {
    var _this = this;
    var _a = this.props, items = _a.items, EmptyMessage = _a.emptyMessageComponent, Container = _a.containerComponent, Item = _a.itemComponent, draggingEnabled = _a.draggingEnabled, isColumnGroupingEnabled = _a.isColumnGroupingEnabled;
    this.itemRefs = [];
    var groupPanel = items.length ? (0, import_react.createElement)(Container, null, items.map(function(item) {
      var columnName = item.column.name;
      return (0, import_react.createElement)(ItemLayout, { key: columnName, item, itemComponent: Item, itemRef: function(element) {
        return element && _this.itemRefs.push(element);
      }, draggingEnabled: draggingEnabled && isColumnGroupingEnabled(columnName), onDragStart: function() {
        return _this.onDragStart(columnName);
      }, onDragEnd: _this.onDragEnd });
    })) : (0, import_react.createElement)(EmptyMessage, null);
    return draggingEnabled ? (0, import_react.createElement)(DropTarget, { onEnter: function(args) {
      return _this.handleDragEvent(_this.onEnter, args);
    }, onOver: function(args) {
      return _this.handleDragEvent(_this.onOver, args);
    }, onLeave: function(args) {
      return _this.handleDragEvent(_this.onLeave, args);
    }, onDrop: function(args) {
      return _this.handleDragEvent(_this.onDrop, args);
    } }, groupPanel) : groupPanel;
  };
  GroupPanelLayoutBase2.defaultProps = defaultProps$1;
  return GroupPanelLayoutBase2;
}(import_react.PureComponent);
var GroupPanelLayout = GroupPanelLayoutBase;
var defaultMessages$5 = {
  groupByColumn: "Drag a column header here to group by that column"
};
var defaultProps$2 = {
  showSortingControls: false,
  showGroupingControls: false,
  messages: {}
};
var GroupingPanelRaw = function(_super) {
  __extends(GroupingPanelRaw2, _super);
  function GroupingPanelRaw2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  GroupingPanelRaw2.prototype.render = function() {
    var _a = this.props, LayoutComponent = _a.layoutComponent, Container = _a.containerComponent, Item = _a.itemComponent, EmptyMessage = _a.emptyMessageComponent, showSortingControls = _a.showSortingControls, showGroupingControls = _a.showGroupingControls, messages = _a.messages;
    var getMessage = getMessagesFormatter(__assign2(__assign2({}, defaultMessages$5), messages));
    var EmptyMessagePlaceholder = function(_a2) {
      var forwardedRef = _a2.forwardedRef;
      return (0, import_react.createElement)(EmptyMessage, { getMessage, forwardedRef });
    };
    var ItemPlaceholder = function(_a2) {
      var item = _a2.item, forwardedRef = _a2.forwardedRef;
      var columnName = item.column.name;
      return (0, import_react.createElement)(TemplateConnector, null, function(_a3, _b) {
        var sorting = _a3.sorting, isColumnSortingEnabled = _a3.isColumnSortingEnabled, isColumnGroupingEnabled = _a3.isColumnGroupingEnabled;
        var changeColumnGrouping2 = _b.changeColumnGrouping, changeColumnSorting2 = _b.changeColumnSorting;
        var sortingEnabled = isColumnSortingEnabled && isColumnSortingEnabled(columnName);
        var groupingEnabled = isColumnGroupingEnabled && isColumnGroupingEnabled(columnName);
        return (0, import_react.createElement)(Item, { forwardedRef, item, sortingEnabled, groupingEnabled, showSortingControls, sortingDirection: showSortingControls ? getColumnSortingDirection(sorting, columnName) : void 0, showGroupingControls, onGroup: function() {
          return changeColumnGrouping2({ columnName });
        }, onSort: function(_a4) {
          var direction = _a4.direction, keepOther = _a4.keepOther;
          return changeColumnSorting2({ columnName, direction, keepOther });
        } });
      });
    };
    return (0, import_react.createElement)(
      Plugin,
      { name: "GroupingPanel", dependencies: [
        { name: "GroupingState" },
        { name: "Toolbar" },
        { name: "SortingState", optional: !showSortingControls }
      ] },
      (0, import_react.createElement)(
        Template,
        { name: "toolbarContent" },
        (0, import_react.createElement)(TemplateConnector, null, function(_a2, _b) {
          var columns = _a2.columns, grouping = _a2.grouping, draftGrouping = _a2.draftGrouping, draggingEnabled = _a2.draggingEnabled, isColumnGroupingEnabled = _a2.isColumnGroupingEnabled, isDataRemote = _a2.isDataRemote;
          var changeColumnGrouping2 = _b.changeColumnGrouping, draftColumnGrouping2 = _b.draftColumnGrouping, cancelColumnGroupingDraft2 = _b.cancelColumnGroupingDraft, scrollToRow = _b.scrollToRow;
          var onGroup = function(config) {
            if (isDataRemote) {
              scrollToRow(TOP_POSITION);
            }
            changeColumnGrouping2(config);
          };
          return (0, import_react.createElement)(LayoutComponent, { items: groupingPanelItems(columns, grouping, draftGrouping), isColumnGroupingEnabled, draggingEnabled, onGroup, onGroupDraft: draftColumnGrouping2, onGroupDraftCancel: cancelColumnGroupingDraft2, itemComponent: ItemPlaceholder, emptyMessageComponent: EmptyMessagePlaceholder, containerComponent: Container });
        }),
        (0, import_react.createElement)(TemplatePlaceholder, null)
      )
    );
  };
  GroupingPanelRaw2.defaultProps = defaultProps$2;
  GroupingPanelRaw2.components = {
    layoutComponent: "Layout",
    containerComponent: "Container",
    itemComponent: "Item",
    emptyMessageComponent: "EmptyMessage"
  };
  return GroupingPanelRaw2;
}(import_react.PureComponent);
var GroupingPanel = withComponents({ Layout: GroupPanelLayout })(GroupingPanelRaw);
var DataTypeProviderBase = function(_super) {
  __extends(DataTypeProviderBase2, _super);
  function DataTypeProviderBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  DataTypeProviderBase2.prototype.render = function() {
    var _a = this.props, columnNames = _a.for, Formatter = _a.formatterComponent, Editor = _a.editorComponent, availableFilterOperations = _a.availableFilterOperations;
    var getAvailableFilterOperationsComputed = function(_a2) {
      var getAvailableFilterOperations = _a2.getAvailableFilterOperations;
      return getAvailableFilterOperationsGetter(getAvailableFilterOperations, availableFilterOperations, columnNames);
    };
    return (0, import_react.createElement)(
      Plugin,
      { name: "DataTypeProvider", key: columnNames.join("_") },
      (0, import_react.createElement)(Getter, { name: "getAvailableFilterOperations", computed: getAvailableFilterOperationsComputed }),
      Formatter ? (0, import_react.createElement)(Template, { name: "valueFormatter", predicate: function(_a2) {
        var column = _a2.column;
        return columnNames.includes(column.name);
      } }, function(params) {
        return (0, import_react.createElement)(Formatter, __assign2({}, params));
      }) : null,
      Editor ? (0, import_react.createElement)(Template, { name: "valueEditor", predicate: function(_a2) {
        var column = _a2.column;
        return columnNames.includes(column.name);
      } }, function(params) {
        return (0, import_react.createElement)(Editor, __assign2({}, params));
      }) : null
    );
  };
  return DataTypeProviderBase2;
}(import_react.PureComponent);
var DataTypeProvider = DataTypeProviderBase;
var pluginDependencies$g = [
  { name: "Table" }
];
var defaultMessages$6 = {
  noColumns: "Nothing to show"
};
var columnExtensionValueGetter$4 = function(columnExtensions, defaultValue) {
  return getColumnExtensionValueGetter(columnExtensions, "togglingEnabled", defaultValue);
};
var TableColumnVisibilityBase = function(_super) {
  __extends(TableColumnVisibilityBase2, _super);
  function TableColumnVisibilityBase2(props) {
    var _this = _super.call(this, props) || this;
    _this.state = {
      hiddenColumnNames: props.hiddenColumnNames || props.defaultHiddenColumnNames
    };
    var stateHelper = createStateHelper(_this, {
      hiddenColumnNames: function() {
        var onHiddenColumnNamesChange = _this.props.onHiddenColumnNamesChange;
        return onHiddenColumnNamesChange;
      }
    });
    _this.toggleColumnVisibility = stateHelper.applyFieldReducer.bind(stateHelper, "hiddenColumnNames", toggleColumn);
    return _this;
  }
  TableColumnVisibilityBase2.getDerivedStateFromProps = function(nextProps, prevState) {
    var _a = nextProps.hiddenColumnNames, hiddenColumnNames = _a === void 0 ? prevState.hiddenColumnNames : _a;
    return {
      hiddenColumnNames
    };
  };
  TableColumnVisibilityBase2.prototype.render = function() {
    var _a = this.props, EmptyMessage = _a.emptyMessageComponent, messages = _a.messages;
    var getMessage = getMessagesFormatter(__assign2(__assign2({}, defaultMessages$6), messages));
    var hiddenColumnNames = this.state.hiddenColumnNames;
    var _b = this.props, columnExtensions = _b.columnExtensions, columnTogglingEnabled = _b.columnTogglingEnabled;
    return (0, import_react.createElement)(
      Plugin,
      { name: "TableColumnVisibility", dependencies: pluginDependencies$g },
      (0, import_react.createElement)(VisibleTableColumns, { hiddenColumnNames }),
      (0, import_react.createElement)(Getter, { name: "isColumnTogglingEnabled", value: columnExtensionValueGetter$4(columnExtensions, columnTogglingEnabled) }),
      (0, import_react.createElement)(Action, { name: "toggleColumnVisibility", action: this.toggleColumnVisibility }),
      (0, import_react.createElement)(Template, { name: "table" }, function(params) {
        return (0, import_react.createElement)(TemplateConnector, null, function(_a2) {
          var tableColumns = _a2.tableColumns;
          return tableDataColumnsExist(tableColumns) ? (0, import_react.createElement)(TemplatePlaceholder, null) : (0, import_react.createElement)(EmptyMessage, __assign2({ getMessage }, params));
        });
      })
    );
  };
  TableColumnVisibilityBase2.defaultProps = {
    defaultHiddenColumnNames: [],
    messages: {},
    columnTogglingEnabled: true
  };
  TableColumnVisibilityBase2.components = {
    emptyMessageComponent: "EmptyMessage"
  };
  return TableColumnVisibilityBase2;
}(import_react.PureComponent);
TableColumnVisibilityBase.components = {
  emptyMessageComponent: "EmptyMessage"
};
var TableColumnVisibility = TableColumnVisibilityBase;
var ToolbarBase = function(_super) {
  __extends(ToolbarBase2, _super);
  function ToolbarBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ToolbarBase2.prototype.render = function() {
    var _a = this.props, Root = _a.rootComponent, FlexibleSpaceComponent = _a.flexibleSpaceComponent;
    return (0, import_react.createElement)(
      Plugin,
      { name: "Toolbar" },
      (0, import_react.createElement)(Template, { name: "header" }, function(params) {
        return (0, import_react.createElement)(
          import_react.Fragment,
          null,
          (0, import_react.createElement)(
            Root,
            __assign2({}, params),
            (0, import_react.createElement)(TemplatePlaceholder, { name: "toolbarContent" })
          ),
          (0, import_react.createElement)(TemplatePlaceholder, null)
        );
      }),
      (0, import_react.createElement)(
        Template,
        { name: "toolbarContent" },
        (0, import_react.createElement)(FlexibleSpaceComponent, null)
      )
    );
  };
  ToolbarBase2.components = {
    rootComponent: "Root",
    flexibleSpaceComponent: "FlexibleSpace"
  };
  return ToolbarBase2;
}(import_react.PureComponent);
var Toolbar = ToolbarBase;
var TreeDataStateBase = function(_super) {
  __extends(TreeDataStateBase2, _super);
  function TreeDataStateBase2(props) {
    var _this = _super.call(this, props) || this;
    _this.state = {
      expandedRowIds: props.expandedRowIds || props.defaultExpandedRowIds
    };
    var stateHelper = createStateHelper(_this, {
      expandedRowIds: function() {
        var onExpandedRowIdsChange = _this.props.onExpandedRowIdsChange;
        return onExpandedRowIdsChange;
      }
    });
    _this.toggleRowExpanded = stateHelper.applyFieldReducer.bind(stateHelper, "expandedRowIds", toggleRowExpanded);
    return _this;
  }
  TreeDataStateBase2.getDerivedStateFromProps = function(nextProps, prevState) {
    var _a = nextProps.expandedRowIds, expandedRowIds = _a === void 0 ? prevState.expandedRowIds : _a;
    return {
      expandedRowIds
    };
  };
  TreeDataStateBase2.prototype.render = function() {
    var expandedRowIds = this.state.expandedRowIds;
    return (0, import_react.createElement)(
      Plugin,
      { name: "TreeDataState" },
      (0, import_react.createElement)(Getter, { name: "expandedRowIds", value: expandedRowIds }),
      " ",
      (0, import_react.createElement)(Action, { name: "toggleRowExpanded", action: this.toggleRowExpanded })
    );
  };
  TreeDataStateBase2.defaultProps = {
    defaultExpandedRowIds: []
  };
  return TreeDataStateBase2;
}(import_react.PureComponent);
var TreeDataState = TreeDataStateBase;
var pluginDependencies$h = [
  { name: "TreeDataState" }
];
var expandedTreeRowsComputed = function(_a) {
  var rows = _a.rows, getRowId = _a.getRowId, expandedRowIds = _a.expandedRowIds;
  return expandedTreeRows(rows, getRowId, expandedRowIds);
};
var getRowIdComputed$1 = function(_a) {
  var getRowId = _a.getRowId, rows = _a.rows;
  return customTreeRowIdGetter(getRowId, rows);
};
var getRowLevelKeyComputed = function(_a) {
  var getRowLevelKey = _a.getRowLevelKey, rows = _a.rows;
  return customTreeRowLevelKeyGetter(getRowLevelKey, rows);
};
var isTreeRowLeafComputed = function(_a) {
  var rows = _a.rows;
  return isTreeRowLeafGetter(rows);
};
var getTreeRowLevelComputed = function(_a) {
  var rows = _a.rows;
  return getTreeRowLevelGetter(rows);
};
var collapsedTreeRowsGetterComputed = function(_a) {
  var rows = _a.rows, getCollapsedRows2 = _a.getCollapsedRows;
  return collapsedTreeRowsGetter(getCollapsedRows2, rows);
};
var unwrappedTreeRowsComputed = function(_a) {
  var rows = _a.rows;
  return unwrappedCustomTreeRows(rows);
};
var CustomTreeDataBase = function(_super) {
  __extends(CustomTreeDataBase2, _super);
  function CustomTreeDataBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  CustomTreeDataBase2.prototype.render = function() {
    var getChildRows = this.props.getChildRows;
    var treeRowsComputed = function(_a) {
      var rows = _a.rows;
      return customTreeRowsWithMeta(rows, getChildRows);
    };
    return (0, import_react.createElement)(
      Plugin,
      { name: "CustomTreeData", dependencies: pluginDependencies$h },
      (0, import_react.createElement)(Getter, { name: "rows", computed: treeRowsComputed }),
      (0, import_react.createElement)(Getter, { name: "getRowId", computed: getRowIdComputed$1 }),
      (0, import_react.createElement)(Getter, { name: "getRowLevelKey", computed: getRowLevelKeyComputed }),
      (0, import_react.createElement)(Getter, { name: "isTreeRowLeaf", computed: isTreeRowLeafComputed }),
      (0, import_react.createElement)(Getter, { name: "getTreeRowLevel", computed: getTreeRowLevelComputed }),
      (0, import_react.createElement)(Getter, { name: "rows", computed: expandedTreeRowsComputed }),
      (0, import_react.createElement)(Getter, { name: "getCollapsedRows", computed: collapsedTreeRowsGetterComputed }),
      (0, import_react.createElement)(Getter, { name: "rows", computed: unwrappedTreeRowsComputed })
    );
  };
  return CustomTreeDataBase2;
}(import_react.PureComponent);
var CustomTreeData = CustomTreeDataBase;
var TableTreeColumnBase = function(_super) {
  __extends(TableTreeColumnBase2, _super);
  function TableTreeColumnBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  TableTreeColumnBase2.prototype.render = function() {
    var _a = this.props, forColumnName = _a.for, showSelectionControls = _a.showSelectionControls, showSelectAll = _a.showSelectAll, Indent = _a.indentComponent, ExpandButton = _a.expandButtonComponent, Checkbox = _a.checkboxComponent, Content = _a.contentComponent, Cell = _a.cellComponent;
    return (0, import_react.createElement)(
      Plugin,
      { name: "TableTreeColumn", dependencies: [
        { name: "DataTypeProvider", optional: true },
        { name: "TreeDataState" },
        { name: "SelectionState", optional: !showSelectionControls },
        { name: "IntegratedSelection", optional: !showSelectAll },
        { name: "Table" },
        { name: "TableHeaderRow", optional: true }
      ], key: forColumnName },
      (0, import_react.createElement)(Getter, { name: "tableTreeColumnName", value: forColumnName }),
      (0, import_react.createElement)(
        Template,
        { name: "tableHeaderCellBefore", predicate: function(_a2) {
          var column = _a2.column;
          return column.name === forColumnName;
        } },
        (0, import_react.createElement)(ExpandButton, { visible: false, expanded: false, onToggle: function() {
        } }),
        showSelectionControls && showSelectAll && (0, import_react.createElement)(TemplateConnector, null, function(_a2, _b) {
          var selectAllAvailable = _a2.selectAllAvailable, allSelected2 = _a2.allSelected, someSelected2 = _a2.someSelected;
          var toggleSelectAll2 = _b.toggleSelectAll;
          return (0, import_react.createElement)(Checkbox, { disabled: !selectAllAvailable, checked: allSelected2, indeterminate: someSelected2, onChange: toggleSelectAll2 });
        })
      ),
      (0, import_react.createElement)(Template, { name: "tableCell", predicate: function(_a2) {
        var tableRow = _a2.tableRow, tableColumn = _a2.tableColumn;
        return isTreeTableCell(tableRow, tableColumn, forColumnName);
      } }, function(params) {
        return (0, import_react.createElement)(TemplateConnector, null, function(_a2, _b) {
          var getCollapsedRows2 = _a2.getCollapsedRows, expandedRowIds = _a2.expandedRowIds, selection = _a2.selection, isTreeRowLeaf = _a2.isTreeRowLeaf, getTreeRowLevel = _a2.getTreeRowLevel, getCellValue = _a2.getCellValue;
          var toggleRowExpanded2 = _b.toggleRowExpanded, toggleSelection2 = _b.toggleSelection;
          var _c = params.tableRow, row = _c.row, rowId = _c.rowId;
          var columnName = params.tableColumn.column.name;
          var value = getCellValue(row, columnName);
          var collapsedRows = getCollapsedRows2(row);
          return (0, import_react.createElement)(TemplatePlaceholder, { name: "valueFormatter", params: {
            value,
            row,
            column: params.tableColumn.column
          } }, function(content) {
            return (0, import_react.createElement)(
              Cell,
              __assign2({}, params, { row, column: params.tableColumn.column, value }),
              (0, import_react.createElement)(Indent, { level: getTreeRowLevel(row) }),
              (0, import_react.createElement)(ExpandButton, { visible: collapsedRows ? !!collapsedRows.length : !isTreeRowLeaf(row), expanded: expandedRowIds.indexOf(rowId) > -1, onToggle: function() {
                return toggleRowExpanded2({ rowId });
              } }),
              showSelectionControls && (0, import_react.createElement)(Checkbox, { disabled: false, checked: selection.indexOf(rowId) > -1, indeterminate: false, onChange: function() {
                return toggleSelection2({ rowIds: [rowId] });
              } }),
              (0, import_react.createElement)(Content, null, content || value)
            );
          });
        });
      })
    );
  };
  TableTreeColumnBase2.defaultProps = {
    showSelectionControls: false,
    showSelectAll: false
  };
  TableTreeColumnBase2.components = {
    cellComponent: "Cell",
    contentComponent: "Content",
    indentComponent: "Indent",
    expandButtonComponent: "ExpandButton",
    checkboxComponent: "Checkbox"
  };
  return TableTreeColumnBase2;
}(import_react.PureComponent);
var TableTreeColumn = TableTreeColumnBase;
var SearchStateBase = function(_super) {
  __extends(SearchStateBase2, _super);
  function SearchStateBase2(props) {
    var _this = _super.call(this, props) || this;
    _this.state = {
      value: props.value || props.defaultValue
    };
    var stateHelper = createStateHelper(_this, {
      value: function() {
        var onValueChange = _this.props.onValueChange;
        return onValueChange;
      }
    });
    _this.changeValue = stateHelper.applyFieldReducer.bind(stateHelper, "value", changeSearchValue);
    return _this;
  }
  SearchStateBase2.getDerivedStateFromProps = function(nextProps, prevState) {
    var _a = nextProps.value, value = _a === void 0 ? prevState.value : _a;
    return {
      value
    };
  };
  SearchStateBase2.prototype.render = function() {
    var value = this.state.value;
    var filterExpressionComputed2 = function(_a) {
      var filterExpression2 = _a.filterExpression, columns = _a.columns;
      return searchFilterExpression(value, columns, filterExpression2);
    };
    return (0, import_react.createElement)(
      Plugin,
      { name: "SearchState" },
      (0, import_react.createElement)(Getter, { name: "filterExpression", computed: filterExpressionComputed2 }),
      (0, import_react.createElement)(Getter, { name: "searchValue", value }),
      (0, import_react.createElement)(Action, { name: "changeSearchValue", action: this.changeValue })
    );
  };
  SearchStateBase2.defaultProps = {
    defaultValue: ""
  };
  return SearchStateBase2;
}(import_react.PureComponent);
var SearchState = SearchStateBase;
var pluginDependencies$i = [
  { name: "Toolbar" },
  { name: "SearchState" }
];
var defaultMessages$7 = {
  searchPlaceholder: "Search..."
};
var SearchPanelBase = function(_super) {
  __extends(SearchPanelBase2, _super);
  function SearchPanelBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.ref = (0, import_react.createRef)();
    return _this;
  }
  SearchPanelBase2.prototype.render = function() {
    var _this = this;
    var _a = this.props, Input = _a.inputComponent, messages = _a.messages;
    var getMessage = getMessagesFormatter(__assign2(__assign2({}, defaultMessages$7), messages));
    return (0, import_react.createElement)(
      Plugin,
      { name: "SearchPanel", dependencies: pluginDependencies$i },
      (0, import_react.createElement)(
        Template,
        { name: "toolbarContent" },
        (0, import_react.createElement)(TemplatePlaceholder, null),
        (0, import_react.createElement)(TemplateConnector, null, function(_a2, _b) {
          var searchValue = _a2.searchValue, isDataRemote = _a2.isDataRemote;
          var changeSearchValue2 = _b.changeSearchValue, scrollToRow = _b.scrollToRow, setSearchPanelRef = _b.setSearchPanelRef;
          var onValueChange = function(value) {
            if (isDataRemote) {
              scrollToRow(TOP_POSITION);
            }
            changeSearchValue2(value);
          };
          if (setSearchPanelRef) {
            setSearchPanelRef(_this.ref);
          }
          return (0, import_react.createElement)(Input, { value: searchValue, inputRef: _this.ref, onValueChange, getMessage });
        })
      )
    );
  };
  SearchPanelBase2.defaultProps = {
    messages: {}
  };
  SearchPanelBase2.components = {
    inputComponent: "Input"
  };
  return SearchPanelBase2;
}(import_react.PureComponent);
var SearchPanel = SearchPanelBase;
var tableHeaderRowsComputed$2 = function(_a) {
  var tableHeaderRows2 = _a.tableHeaderRows;
  return tableHeaderRowsWithFixed(tableHeaderRows2);
};
var tableHeaderColumnChainsComputed = function(_a) {
  var tableColumns = _a.tableColumns, tableHeaderRows2 = _a.tableHeaderRows, tableHeaderColumnChains = _a.tableHeaderColumnChains;
  return tableHeaderColumnChainsWithFixed(tableHeaderColumnChains, tableHeaderRows2, tableColumns);
};
var CellPlaceholder$2 = function(props) {
  return (0, import_react.createElement)(TemplatePlaceholder, { params: props });
};
var pluginDependencies$j = [
  { name: "Table" },
  { name: "TableBandHeader", optional: true },
  { name: "TableColumnReordering", optional: true },
  { name: "TableEditColumn", optional: true },
  { name: "TableEditRow", optional: true },
  { name: "TableFilterRow", optional: true },
  { name: "TableGroupRow", optional: true },
  { name: "TableHeaderRow", optional: true },
  { name: "TableRowDetail", optional: true },
  { name: "TableSelection", optional: true },
  { name: "TableSummaryRow", optional: true },
  { name: "TableTreeColumn", optional: true }
];
var TableFixedColumnsBase = function(_super) {
  __extends(TableFixedColumnsBase2, _super);
  function TableFixedColumnsBase2(props) {
    var _this = _super.call(this, props) || this;
    _this.state = {
      tableColumnDimensions: {}
    };
    return _this;
  }
  TableFixedColumnsBase2.prototype.handleListenerSizeChange = function(key, width) {
    var tableColumnDimensions = this.state.tableColumnDimensions;
    if (tableColumnDimensions[key] !== width) {
      this.setState(function(state) {
        var _a;
        return {
          tableColumnDimensions: __assign2(__assign2({}, state.tableColumnDimensions), (_a = {}, _a[key] = width, _a))
        };
      });
    }
  };
  TableFixedColumnsBase2.prototype.render = function() {
    var _this = this;
    var _a = this.props, Cell = _a.cellComponent, ListenerRow = _a.listenerRowComponent, ListenerCell = _a.listenerCellComponent;
    var leftColumns = this.props.leftColumns;
    var rightColumns = this.props.rightColumns;
    var tableColumnsComputed2 = function(_a2) {
      var tableColumns = _a2.tableColumns;
      return tableColumnsWithFixed(tableColumns, leftColumns, rightColumns);
    };
    return (0, import_react.createElement)(
      Plugin,
      { name: "TableFixedColumns", dependencies: pluginDependencies$j },
      (0, import_react.createElement)(Getter, { name: "tableHeaderRows", computed: tableHeaderRowsComputed$2 }),
      (0, import_react.createElement)(Getter, { name: "tableColumns", computed: tableColumnsComputed2 }),
      (0, import_react.createElement)(Getter, { name: "tableHeaderColumnChains", computed: tableHeaderColumnChainsComputed }),
      (0, import_react.createElement)(Template, { name: "tableCell", predicate: function(_a2) {
        var tableColumn = _a2.tableColumn;
        return !!tableColumn.fixed;
      } }, function(params) {
        return (0, import_react.createElement)(TemplateConnector, null, function(_a2) {
          var tableColumns = _a2.tableColumns, tableHeaderColumnChains = _a2.tableHeaderColumnChains, selection = _a2.selection, focused = _a2.focused, highlightSelectedRow = _a2.highlightSelectedRow;
          var selected = isRowHighlighted(highlightSelectedRow, selection, params.tableRow, focused);
          var tableColumnDimensions = _this.state.tableColumnDimensions;
          var fixedColumnProps = calculateFixedColumnProps(params, { leftColumns, rightColumns }, tableColumns, tableColumnDimensions, tableHeaderColumnChains);
          return (0, import_react.createElement)(Cell, __assign2({}, params, fixedColumnProps, { component: CellPlaceholder$2, selected }));
        });
      }),
      (0, import_react.createElement)(Template, { name: "tableRow", predicate: function(_a2) {
        var tableRow = _a2.tableRow;
        return !!isFixedTableRow(tableRow);
      } }, function(params) {
        return (0, import_react.createElement)(ListenerRow, __assign2({}, params));
      }),
      (0, import_react.createElement)(Template, { name: "tableCell", predicate: function(_a2) {
        var tableRow = _a2.tableRow;
        return !!isFixedTableRow(tableRow);
      } }, function(params) {
        return (0, import_react.createElement)(ListenerCell, __assign2({}, params, { listen: !!params.tableColumn.fixed, onSizeChange: function(_a2) {
          var width = _a2.width;
          return _this.handleListenerSizeChange(params.tableColumn.key, width);
        } }));
      })
    );
  };
  TableFixedColumnsBase2.components = {
    cellComponent: "Cell",
    listenerRowComponent: "ListenerRow",
    listenerCellComponent: "ListenerCell"
  };
  TableFixedColumnsBase2.defaultProps = {
    leftColumns: [],
    rightColumns: []
  };
  return TableFixedColumnsBase2;
}(import_react.PureComponent);
var TableFixedColumns = TableFixedColumnsBase;
var groupSummaryItemsComputed = function(_a) {
  var groupSummaryItems = _a.groupSummaryItems;
  return prepareGroupSummaryItems(groupSummaryItems);
};
var SummaryStateBase = function(_super) {
  __extends(SummaryStateBase2, _super);
  function SummaryStateBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  SummaryStateBase2.prototype.render = function() {
    var _a = this.props, totalItems = _a.totalItems, groupItems = _a.groupItems, treeItems = _a.treeItems;
    return (0, import_react.createElement)(
      Plugin,
      { name: "SummaryState" },
      (0, import_react.createElement)(Getter, { name: "totalSummaryItems", value: totalItems }),
      (0, import_react.createElement)(Getter, { name: "groupSummaryItems", value: groupItems }),
      (0, import_react.createElement)(Getter, { name: "groupSummaryItems", computed: groupSummaryItemsComputed }),
      (0, import_react.createElement)(Getter, { name: "treeSummaryItems", value: treeItems })
    );
  };
  SummaryStateBase2.defaultProps = {
    totalItems: [],
    groupItems: [],
    treeItems: []
  };
  return SummaryStateBase2;
}(import_react.PureComponent);
var SummaryState = SummaryStateBase;
var pluginDependencies$k = [
  { name: "SummaryState" },
  { name: "IntegratedGrouping", optional: true }
];
var IntegratedSummaryBase = function(_super) {
  __extends(IntegratedSummaryBase2, _super);
  function IntegratedSummaryBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  IntegratedSummaryBase2.prototype.render = function() {
    var calculator = this.props.calculator;
    var totalSummaryValuesComputed = function(_a) {
      var rows = _a.rows, totalSummaryItems = _a.totalSummaryItems, getCellValue = _a.getCellValue, getRowLevelKey = _a.getRowLevelKey, isGroupRow = _a.isGroupRow, getCollapsedRows2 = _a.getCollapsedRows;
      return totalSummaryValues(rows, totalSummaryItems, getCellValue, getRowLevelKey, isGroupRow, getCollapsedRows2, calculator);
    };
    var groupSummaryValuesComputed = function(_a) {
      var rows = _a.rows, groupSummaryItems = _a.groupSummaryItems, getCellValue = _a.getCellValue, getRowLevelKey = _a.getRowLevelKey, isGroupRow = _a.isGroupRow, getCollapsedRows2 = _a.getCollapsedRows;
      return groupSummaryValues(rows, groupSummaryItems, getCellValue, getRowLevelKey, isGroupRow, getCollapsedRows2, calculator);
    };
    var treeSummaryValuesComputed = function(_a) {
      var rows = _a.rows, treeSummaryItems = _a.treeSummaryItems, getCellValue = _a.getCellValue, getRowLevelKey = _a.getRowLevelKey, isGroupRow = _a.isGroupRow, getRowId = _a.getRowId;
      return treeSummaryValues(rows, treeSummaryItems, getCellValue, getRowLevelKey, isGroupRow, getRowId, calculator);
    };
    return (0, import_react.createElement)(
      Plugin,
      { name: "IntegratedSummary", dependencies: pluginDependencies$k },
      (0, import_react.createElement)(Getter, { name: "totalSummaryValues", computed: totalSummaryValuesComputed }),
      (0, import_react.createElement)(Getter, { name: "groupSummaryValues", computed: groupSummaryValuesComputed }),
      (0, import_react.createElement)(Getter, { name: "treeSummaryValues", computed: treeSummaryValuesComputed })
    );
  };
  IntegratedSummaryBase2.defaultCalculator = defaultSummaryCalculator;
  return IntegratedSummaryBase2;
}(import_react.PureComponent);
var IntegratedSummary = IntegratedSummaryBase;
var pluginDependencies$l = [
  { name: "SummaryState" }
];
var CustomSummaryBase = function(_super) {
  __extends(CustomSummaryBase2, _super);
  function CustomSummaryBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  CustomSummaryBase2.prototype.render = function() {
    var _a = this.props, totalValues = _a.totalValues, groupValues = _a.groupValues, treeValues = _a.treeValues;
    return (0, import_react.createElement)(
      Plugin,
      { name: "CustomSummary", dependencies: pluginDependencies$l },
      (0, import_react.createElement)(Getter, { name: "totalSummaryValues", value: totalValues }),
      (0, import_react.createElement)(Getter, { name: "groupSummaryValues", value: groupValues }),
      (0, import_react.createElement)(Getter, { name: "treeSummaryValues", value: treeValues })
    );
  };
  return CustomSummaryBase2;
}(import_react.PureComponent);
var CustomSummary = CustomSummaryBase;
var dependencies$1 = [
  { name: "DataTypeProvider", optional: true },
  { name: "SummaryState" },
  { name: "CustomSummary", optional: true },
  { name: "IntegratedSummary", optional: true },
  { name: "Table" },
  { name: "TableTreeColumn", optional: true }
];
var tableBodyRowsComputed$2 = function(_a) {
  var tableBodyRows = _a.tableBodyRows, getRowLevelKey = _a.getRowLevelKey, isGroupRow = _a.isGroupRow, getRowId = _a.getRowId, groupSummaryItems = _a.groupSummaryItems, treeSummaryItems = _a.treeSummaryItems;
  return tableRowsWithSummaries(tableBodyRows, groupSummaryItems, treeSummaryItems, getRowLevelKey, isGroupRow, getRowId);
};
var tableFooterRowsComputed = function(_a) {
  var tableFooterRows2 = _a.tableFooterRows, totalSummaryItems = _a.totalSummaryItems;
  return totalSummaryItems.length ? tableRowsWithTotalSummaries(tableFooterRows2) : tableFooterRows2;
};
var TableSummaryRowBase = function(_super) {
  __extends(TableSummaryRowBase2, _super);
  function TableSummaryRowBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  TableSummaryRowBase2.prototype.renderContent = function(column, columnSummaries) {
    var _a = this.props, formatlessSummaryTypes = _a.formatlessSummaryTypes, Item = _a.itemComponent, messages = _a.messages;
    return (0, import_react.createElement)(TableSummaryContent, { column, columnSummaries, formatlessSummaryTypes, itemComponent: Item, messages });
  };
  TableSummaryRowBase2.prototype.render = function() {
    var _this = this;
    var _a = this.props, TotalRow = _a.totalRowComponent, GroupRow = _a.groupRowComponent, TreeRow = _a.treeRowComponent, TotalCell = _a.totalCellComponent, GroupCell = _a.groupCellComponent, TreeCell = _a.treeCellComponent, TreeColumnCell = _a.treeColumnCellComponent, TreeColumnContent = _a.treeColumnContentComponent, TreeColumnIndent = _a.treeColumnIndentComponent;
    return (0, import_react.createElement)(
      Plugin,
      { name: "TableSummaryRow", dependencies: dependencies$1 },
      (0, import_react.createElement)(Getter, { name: "tableBodyRows", computed: tableBodyRowsComputed$2 }),
      (0, import_react.createElement)(Getter, { name: "tableFooterRows", computed: tableFooterRowsComputed }),
      (0, import_react.createElement)(Template, { name: "tableCell", predicate: function(_a2) {
        var tableRow = _a2.tableRow, tableColumn = _a2.tableColumn;
        return isTotalSummaryTableCell(tableRow, tableColumn);
      } }, function(params) {
        return (0, import_react.createElement)(TemplateConnector, null, function(_a2) {
          var totalSummaryItems = _a2.totalSummaryItems, totalSummaryValues2 = _a2.totalSummaryValues;
          var columnSummaries = getColumnSummaries(totalSummaryItems, params.tableColumn.column.name, totalSummaryValues2);
          return (0, import_react.createElement)(TotalCell, __assign2({}, params, { column: params.tableColumn.column }), _this.renderContent(params.tableColumn.column, columnSummaries));
        });
      }),
      (0, import_react.createElement)(Template, { name: "tableCell", predicate: function(_a2) {
        var tableRow = _a2.tableRow, tableColumn = _a2.tableColumn;
        return isGroupSummaryTableCell(tableRow, tableColumn);
      } }, function(params) {
        return (0, import_react.createElement)(TemplateConnector, null, function(_a2) {
          var groupSummaryItems = _a2.groupSummaryItems, groupSummaryValues2 = _a2.groupSummaryValues;
          var columnSummaries = getColumnSummaries(groupSummaryItems, params.tableColumn.column.name, groupSummaryValues2[params.tableRow.row.compoundKey], function(summaryItem) {
            return isFooterSummary(summaryItem);
          });
          return (0, import_react.createElement)(GroupCell, __assign2({}, params, { column: params.tableColumn.column }), _this.renderContent(params.tableColumn.column, columnSummaries));
        });
      }),
      (0, import_react.createElement)(Template, { name: "tableCell", predicate: function(_a2) {
        var tableRow = _a2.tableRow, tableColumn = _a2.tableColumn;
        return isTreeSummaryTableCell(tableRow, tableColumn);
      } }, function(params) {
        return (0, import_react.createElement)(TemplateConnector, null, function(_a2) {
          var treeSummaryItems = _a2.treeSummaryItems, treeSummaryValues2 = _a2.treeSummaryValues, tableTreeColumnName = _a2.tableTreeColumnName, getRowId = _a2.getRowId, getTreeRowLevel = _a2.getTreeRowLevel;
          var columnSummaries = getColumnSummaries(treeSummaryItems, params.tableColumn.column.name, treeSummaryValues2[getRowId(params.tableRow.row)]);
          if (tableTreeColumnName === params.tableColumn.column.name) {
            return (0, import_react.createElement)(
              TreeColumnCell,
              __assign2({}, params, { column: params.tableColumn.column }),
              (0, import_react.createElement)(TreeColumnIndent, { level: getTreeRowLevel(params.tableRow.row) }),
              (0, import_react.createElement)(TreeColumnContent, null, _this.renderContent(params.tableColumn.column, columnSummaries))
            );
          }
          return (0, import_react.createElement)(TreeCell, __assign2({}, params, { column: params.tableColumn.column }), _this.renderContent(params.tableColumn.column, columnSummaries));
        });
      }),
      (0, import_react.createElement)(Template, { name: "tableRow", predicate: function(_a2) {
        var tableRow = _a2.tableRow;
        return !!isTotalSummaryTableRow(tableRow);
      } }, function(params) {
        return (0, import_react.createElement)(TotalRow, __assign2({}, params));
      }),
      (0, import_react.createElement)(Template, { name: "tableRow", predicate: function(_a2) {
        var tableRow = _a2.tableRow;
        return !!isGroupSummaryTableRow(tableRow);
      } }, function(params) {
        return (0, import_react.createElement)(GroupRow, __assign2({}, params));
      }),
      (0, import_react.createElement)(Template, { name: "tableRow", predicate: function(_a2) {
        var tableRow = _a2.tableRow;
        return !!isTreeSummaryTableRow(tableRow);
      } }, function(params) {
        return (0, import_react.createElement)(TreeRow, __assign2({}, params));
      })
    );
  };
  TableSummaryRowBase2.TREE_ROW_TYPE = TABLE_TREE_SUMMARY_TYPE;
  TableSummaryRowBase2.GROUP_ROW_TYPE = TABLE_GROUP_SUMMARY_TYPE;
  TableSummaryRowBase2.TOTAL_ROW_TYPE = TABLE_TOTAL_SUMMARY_TYPE;
  TableSummaryRowBase2.defaultProps = {
    formatlessSummaryTypes: [],
    messages: {}
  };
  TableSummaryRowBase2.components = {
    totalRowComponent: "TotalRow",
    groupRowComponent: "GroupRow",
    treeRowComponent: "TreeRow",
    totalCellComponent: "TotalCell",
    groupCellComponent: "GroupCell",
    treeCellComponent: "TreeCell",
    treeColumnCellComponent: "TableTreeCell",
    treeColumnContentComponent: "TableTreeContent",
    treeColumnIndentComponent: "TableTreeIndent",
    itemComponent: "Item"
  };
  return TableSummaryRowBase2;
}(import_react.PureComponent);
var TableSummaryRow = TableSummaryRowBase;
var virtualRowsComputed = function(_a) {
  var skip = _a.skip, rows = _a.rows, virtualRowsCache = _a.virtualRowsCache;
  return virtualRowsWithCache(skip, rows, virtualRowsCache);
};
var rowsComputed = function(_a) {
  var virtualRows = _a.virtualRows, availableRowCount = _a.availableRowCount;
  return plainRows(virtualRows, availableRowCount);
};
var loadedRowsStartComputed = function(_a) {
  var virtualRows = _a.virtualRows;
  return loadedRowsStart(virtualRows);
};
var VirtualTableStateBase = function(_super) {
  __extends(VirtualTableStateBase2, _super);
  function VirtualTableStateBase2(props) {
    var _this = _super.call(this, props) || this;
    _this.requestTimer = 0;
    _this.setViewport = function(viewport, _a, _b) {
      var virtualRows = _a.virtualRows;
      var requestNextPage = _b.requestNextPage;
      var pageSize = _this.props.pageSize;
      var referenceIndex = getReferenceIndex(viewport);
      if (needFetchMorePages(virtualRows, referenceIndex, pageSize)) {
        requestNextPage({ referenceIndex });
      }
    };
    _this.requestNextPageAction = function(_a, _b) {
      var referenceIndex = _a.referenceIndex, forceReload = _a.forceReload;
      var virtualRows = _b.virtualRows;
      var _c = _this.props, pageSize = _c.pageSize, totalRowCount = _c.totalRowCount, infiniteScrolling = _c.infiniteScrolling;
      var _d = _this.state, requestedStartIndex = _d.requestedStartIndex, requestedEndIndex = _d.requestedEndIndex;
      var actualVirtualRows = forceReload ? emptyVirtualRows : virtualRows;
      var _e = getRequestMeta(referenceIndex, virtualRows, pageSize, totalRowCount, forceReload, infiniteScrolling), requestedRange = _e.requestedRange, actualBounds = _e.actualBounds;
      if (forceReload || shouldSendRequest(requestedRange, requestedStartIndex, requestedEndIndex)) {
        _this.requestNextPage(requestedRange, actualVirtualRows, actualBounds);
      }
    };
    _this.clearRowsCacheAction = function(_, __, _a) {
      var requestNextPage = _a.requestNextPage;
      _this.setState({
        virtualRowsCache: emptyVirtualRows
      });
      requestNextPage({ forceReload: true });
    };
    _this.resetVirtualTablePosition = function() {
      return _this.requestFirstPage();
    };
    _this.state = {
      virtualRowsCache: emptyVirtualRows,
      requestedStartIndex: 0,
      availableRowCount: props.totalRowCount || 0,
      requestedEndIndex: 2 * props.pageSize
    };
    return _this;
  }
  VirtualTableStateBase2.prototype.requestNextPage = function(requestedRange, virtualRows, actualBounds) {
    var _this = this;
    var _a = this.props, getRows = _a.getRows, infiniteScrolling = _a.infiniteScrolling, totalRowCount = _a.totalRowCount;
    var stateAvailableCount = this.state.availableRowCount;
    if (this.requestTimer !== 0) {
      clearTimeout(this.requestTimer);
    }
    this.requestTimer = window.setTimeout(function() {
      var requestedStartIndex = requestedRange.start, end = requestedRange.end;
      var loadCount = end - requestedStartIndex;
      var virtualRowsCache = trimRowsToInterval(virtualRows, actualBounds);
      var availableRowCount = getAvailableRowCount(infiniteScrolling, actualBounds.end, stateAvailableCount, totalRowCount);
      getRows(requestedStartIndex, loadCount);
      _this.setState({
        virtualRowsCache,
        availableRowCount,
        requestedStartIndex,
        requestedEndIndex: end
      });
    }, 50);
  };
  VirtualTableStateBase2.prototype.requestFirstPage = function() {
    var _this = this;
    var _a = this.props, getRows = _a.getRows, pageSize = _a.pageSize;
    var startIndex = 0;
    var endIndex = 2 * pageSize;
    if (this.requestTimer !== 0) {
      clearTimeout(this.requestTimer);
    }
    this.requestTimer = window.setTimeout(function() {
      getRows(startIndex, endIndex);
      _this.setState({
        virtualRowsCache: emptyVirtualRows,
        requestedStartIndex: startIndex,
        requestedEndIndex: endIndex
      });
    }, 50);
  };
  VirtualTableStateBase2.getDerivedStateFromProps = function(nextProps, prevState) {
    var _a = nextProps.availableRowCount, prevAvailableRowCount = _a === void 0 ? prevState.availableRowCount : _a, totalRowCount = nextProps.totalRowCount, pageSize = nextProps.pageSize, infiniteScrolling = nextProps.infiniteScrolling;
    var prevRequestedStartIndex = prevState.requestedStartIndex, prevVirtualRowCache = prevState.virtualRowsCache;
    var availableRowCount = getAvailableRowCount(infiniteScrolling, pageSize * 2, prevAvailableRowCount, totalRowCount);
    var requestedStartIndex = Math.max(Math.min(prevRequestedStartIndex, availableRowCount - pageSize), 0);
    var virtualRowsCache = prevRequestedStartIndex === requestedStartIndex ? prevVirtualRowCache : emptyVirtualRows;
    return {
      availableRowCount,
      requestedStartIndex,
      virtualRowsCache
    };
  };
  VirtualTableStateBase2.prototype.componentDidMount = function() {
    var _a = this.props, getRows = _a.getRows, pageSize = _a.pageSize, infiniteScrolling = _a.infiniteScrolling, totalRowCount = _a.totalRowCount;
    getRows(0, 2 * pageSize);
    var newRowCount = infiniteScrolling ? 2 * pageSize : totalRowCount;
    this.setState({
      availableRowCount: newRowCount
    });
  };
  VirtualTableStateBase2.prototype.componentWillUnmount = function() {
    if (this.requestTimer !== 0) {
      window.clearTimeout(this.requestTimer);
    }
  };
  VirtualTableStateBase2.prototype.render = function() {
    var _a = this.state, virtualRowsCache = _a.virtualRowsCache, availableRowCount = _a.availableRowCount;
    var _b = this.props, skip = _b.skip, pageSize = _b.pageSize, loading = _b.loading, infiniteScrolling = _b.infiniteScrolling;
    return (0, import_react.createElement)(
      Plugin,
      { name: "VirtualTableState" },
      (0, import_react.createElement)(Getter, { name: "isDataRemote", value: true }),
      (0, import_react.createElement)(Getter, { name: "isDataLoading", value: loading }),
      (0, import_react.createElement)(Getter, { name: "isScrollingInfinite", value: infiniteScrolling }),
      (0, import_react.createElement)(Getter, { name: "skip", value: skip }),
      (0, import_react.createElement)(Getter, { name: "virtualRowsCache", value: virtualRowsCache }),
      (0, import_react.createElement)(Getter, { name: "pageSize", value: pageSize }),
      (0, import_react.createElement)(Getter, { name: "availableRowCount", value: availableRowCount }),
      (0, import_react.createElement)(Getter, { name: "virtualRows", computed: virtualRowsComputed }),
      (0, import_react.createElement)(Getter, { name: "rows", computed: rowsComputed }),
      (0, import_react.createElement)(Getter, { name: "loadedRowsStart", computed: loadedRowsStartComputed }),
      (0, import_react.createElement)(Action, { name: "requestNextPage", action: this.requestNextPageAction }),
      (0, import_react.createElement)(Action, { name: "setViewport", action: this.setViewport }),
      (0, import_react.createElement)(Action, { name: "clearRowCache", action: this.clearRowsCacheAction }),
      (0, import_react.createElement)(Action, { name: "changeColumnSorting", action: this.clearRowsCacheAction }),
      (0, import_react.createElement)(Action, { name: "changeColumnFilter", action: this.resetVirtualTablePosition }),
      (0, import_react.createElement)(Action, { name: "changeSearchValue", action: this.resetVirtualTablePosition }),
      (0, import_react.createElement)(Action, { name: "changeColumnGrouping", action: this.resetVirtualTablePosition })
    );
  };
  VirtualTableStateBase2.defaultProps = {
    pageSize: 100
  };
  return VirtualTableStateBase2;
}(import_react.PureComponent);
var VirtualTableState = VirtualTableStateBase;
var pluginDependencies$m = [
  { name: "EditingState" },
  { name: "Table" },
  { name: "DataTypeProvider", optional: true }
];
var rowsWithEditingCellsComputed = function(_a) {
  var tableBodyRows = _a.tableBodyRows, editingCells = _a.editingCells;
  return rowsWithEditingCells(tableBodyRows, editingCells);
};
var columnsWithEditingCellsComputed = function(_a) {
  var tableColumns = _a.tableColumns, editingCells = _a.editingCells;
  return columnsWithEditingCells(tableColumns, editingCells);
};
var INLINE_CELL_EDITING_ERROR = "The startEditAction property of the InlineCellEditing plugin is given an invalid value.";
var TableInlineCellEditingBase = function(props) {
  var EditCell = props.cellComponent, startEditAction = props.startEditAction, selectTextOnEditStart = props.selectTextOnEditStart;
  return (0, import_react.createElement)(
    Plugin,
    { name: "TableInlineCellEditing", dependencies: pluginDependencies$m },
    (0, import_react.createElement)(Getter, { name: "tableBodyRows", computed: rowsWithEditingCellsComputed }),
    (0, import_react.createElement)(Getter, { name: "tableColumns", computed: columnsWithEditingCellsComputed }),
    (0, import_react.createElement)(Template, { name: "tableCell", predicate: function(_a) {
      var tableRow = _a.tableRow, tableColumn = _a.tableColumn;
      return tableRow.type === TABLE_DATA_TYPE && tableColumn.type === TABLE_DATA_TYPE;
    } }, function(params) {
      return (0, import_react.createElement)(TemplateConnector, null, function(_a, _b) {
        var _c;
        var startEditCells2 = _b.startEditCells;
        var rowId = params.tableRow.rowId, column = params.tableColumn.column;
        var columnName = column.name;
        if (startEditAction !== "click" && startEditAction !== "doubleClick") {
          throw new Error(INLINE_CELL_EDITING_ERROR);
        }
        var startEditCellCallback = function() {
          return startEditCells2({
            editingCells: [{ rowId, columnName }]
          });
        };
        var eventName = startEditAction === "click" ? "onClick" : "onDoubleClick";
        var newParams = __assign2(__assign2({}, params), (_c = {}, _c[eventName] = startEditCellCallback, _c));
        return (0, import_react.createElement)(TemplatePlaceholder, { params: newParams });
      });
    }),
    (0, import_react.createElement)(Template, { name: "tableCell", predicate: function(_a) {
      var tableRow = _a.tableRow, tableColumn = _a.tableColumn;
      return tableRow.hasEditCell && tableColumn.hasEditCell;
    } }, function(params) {
      return (0, import_react.createElement)(TemplateConnector, null, function(_a, _b) {
        var getCellValue = _a.getCellValue, createRowChange = _a.createRowChange, rowChanges = _a.rowChanges, isColumnEditingEnabled = _a.isColumnEditingEnabled;
        var changeRow2 = _b.changeRow, stopEditCells2 = _b.stopEditCells, commitChangedRows = _b.commitChangedRows, cancelChangedRows = _b.cancelChangedRows;
        var _c = params.tableRow, rowId = _c.rowId, row = _c.row, column = params.tableColumn.column;
        var columnName = column.name;
        var changedRow = __assign2(__assign2({}, row), getRowChange(rowChanges, rowId));
        var value = getCellValue(changedRow, columnName);
        var onValueChange = function(newValue) {
          var changeArgs = {
            rowId,
            change: createRowChange(changedRow, newValue, columnName)
          };
          changeRow2(changeArgs);
        };
        var onKeyDown = function(_a2) {
          var key = _a2.key;
          if (key === "Enter") {
            commitChangedRows({ rowIds: [rowId] });
            stopEditCells2({ editingCells: [{ rowId, columnName }] });
          } else if (key === "Escape") {
            cancelChangedRows({ rowIds: [rowId] });
            stopEditCells2({ editingCells: [{ rowId, columnName }] });
          }
        };
        var onBlur = function() {
          commitChangedRows({ rowIds: [rowId] });
          stopEditCells2({ editingCells: [{ rowId, columnName }] });
        };
        var onFocus = selectTextOnEditStart ? function(e) {
          return e.target.select();
        } : function() {
        };
        var editingEnabled = isColumnEditingEnabled(columnName);
        return (0, import_react.createElement)(TemplatePlaceholder, { name: "valueEditor", params: {
          column,
          row,
          value,
          onValueChange,
          disabled: !editingEnabled
        } }, function(content) {
          return (0, import_react.createElement)(EditCell, __assign2({}, params, { row, column, value, editingEnabled, onValueChange, autoFocus: true, onKeyDown, onBlur, onFocus }), content);
        });
      });
    })
  );
};
TableInlineCellEditingBase.components = {
  cellComponent: "Cell"
};
TableInlineCellEditingBase.defaultProps = {
  startEditAction: "click",
  selectTextOnEditStart: false
};
var TableInlineCellEditing = TableInlineCellEditingBase;
var defaultMessages$8 = {
  showExportMenu: "Export",
  exportAll: "Export all data",
  exportSelected: "Export selected rows"
};
var ExportPanelBase = function(_super) {
  __extends(ExportPanelBase2, _super);
  function ExportPanelBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.state = { visible: false };
    _this.setButtonRef = function(button) {
      return _this.button = button;
    };
    _this.handleToggle = function() {
      var visible = _this.state.visible;
      _this.setState({ visible: !visible });
    };
    _this.handleHide = function() {
      return _this.setState({ visible: false });
    };
    return _this;
  }
  ExportPanelBase2.prototype.render = function() {
    var _this = this;
    var _a = this.props, ToggleButton = _a.toggleButtonComponent, Menu = _a.menuComponent, MenuItem = _a.menuItemComponent, messages = _a.messages, startExport = _a.startExport;
    var visible = this.state.visible;
    var getMessage = getMessagesFormatter(__assign2(__assign2({}, defaultMessages$8), messages));
    return (0, import_react.createElement)(
      Plugin,
      { name: "ExportPanel", dependencies: [
        { name: "SelectionState", optional: true },
        { name: "Toolbar" }
      ] },
      (0, import_react.createElement)(
        Template,
        { name: "toolbarContent" },
        (0, import_react.createElement)(TemplatePlaceholder, null),
        (0, import_react.createElement)(TemplateConnector, null, function(_a2) {
          var selection = _a2.selection;
          return (0, import_react.createElement)(
            import_react.Fragment,
            null,
            (0, import_react.createElement)(ToggleButton, { buttonRef: _this.setButtonRef, onToggle: _this.handleToggle, getMessage }),
            (0, import_react.createElement)(
              Menu,
              { visible, onHide: _this.handleHide, target: _this.button },
              (0, import_react.createElement)(MenuItem, { key: "exportAll", text: getMessage("exportAll"), onClick: function() {
                _this.handleHide();
                startExport();
              } }),
              (selection === null || selection === void 0 ? void 0 : selection.length) ? (0, import_react.createElement)(MenuItem, { key: "exportSelected", text: getMessage("exportSelected"), onClick: function() {
                _this.handleHide();
                startExport({ selectedOnly: true });
              } }) : null
            )
          );
        })
      )
    );
  };
  ExportPanelBase2.components = {
    toggleButtonComponent: "ToggleButton",
    menuComponent: "Menu",
    menuItemComponent: "MenuItem"
  };
  return ExportPanelBase2;
}(import_react.PureComponent);
var ExportPanel = ExportPanelBase;
var CellPlaceholder$3 = function(props) {
  return (0, import_react.createElement)(TemplatePlaceholder, { params: props });
};
var RowPlaceholder$1 = function(props) {
  return (0, import_react.createElement)(TemplatePlaceholder, { params: props });
};
var TableKeyboardNavigationCore = function(_super) {
  __extends(TableKeyboardNavigationCore2, _super);
  function TableKeyboardNavigationCore2(props) {
    var _this = _super.call(this, props) || this;
    _this.elements = {};
    var focusedCell = props.focusedCell || props.defaultFocusedCell;
    _this.state = {
      focusedElement: focusedCell ? __assign2({ part: TABLE_DATA_TYPE.toString() }, focusedCell) : focusedCell
    };
    _this.handleKeyDownOnWidget = _this.handleKeyDownOnWidget.bind(_this);
    _this.updateRef = _this.updateRef.bind(_this);
    _this.setFocusedElement = _this.setFocusedElement.bind(_this);
    _this.setSearchPanelRef = _this.setSearchPanelRef.bind(_this);
    return _this;
  }
  TableKeyboardNavigationCore2.getDerivedStateFromProps = function(props, state) {
    var focusedCell = props.focusedCell !== void 0 ? props.focusedCell : state.focusedElement;
    return {
      focusedElement: focusedCell ? __assign2({ part: TABLE_DATA_TYPE.toString() }, focusedCell) : void 0
    };
  };
  TableKeyboardNavigationCore2.prototype.componentDidMount = function() {
    this.props.rootRef.current.addEventListener("keydown", this.handleKeyDownOnWidget);
  };
  TableKeyboardNavigationCore2.prototype.componentWillUnmount = function() {
    this.props.rootRef.current.removeEventListener("keydown", this.handleKeyDownOnWidget);
  };
  TableKeyboardNavigationCore2.prototype.pushRef = function(ref, key1, key2) {
    var focusedElement = this.state.focusedElement;
    var tableColumns = this.props.tableColumns;
    if (!this.elements[key1]) {
      this.elements[key1] = [];
    }
    if (!this.elements[key1][key2]) {
      this.elements[key1][key2] = [];
    }
    this.elements[key1][key2].push(ref);
    if ((focusedElement === null || focusedElement === void 0 ? void 0 : focusedElement.rowKey) === key1 && (focusedElement === null || focusedElement === void 0 ? void 0 : focusedElement.columnKey) === key2) {
      focus(this.elements, focusedElement, void 0, this.props.onFocusedCellChange);
    }
    if (key1.toString().includes(TABLE_ADDED_TYPE.toString()) && key2 === tableColumns[0].key) {
      this.changeFocusedElement({
        part: TABLE_DATA_TYPE.toString(),
        columnKey: key2,
        rowKey: key1
      }, focusedElement);
    }
  };
  TableKeyboardNavigationCore2.prototype.setSearchPanelRef = function(ref) {
    this.searchPanelRef = ref;
  };
  TableKeyboardNavigationCore2.prototype.removeRef = function(key1, key2) {
    delete this.elements[key1][key2];
    if (Object.keys(this.elements[key1]).length === 0) {
      delete this.elements[key1];
    }
  };
  TableKeyboardNavigationCore2.prototype.updateRef = function(_a) {
    var ref = _a.ref, key1 = _a.key1, key2 = _a.key2, action = _a.action;
    if (action === "add") {
      this.pushRef(ref, key1, key2);
    } else {
      this.removeRef(key1, key2);
    }
  };
  TableKeyboardNavigationCore2.prototype.changeFocusedElement = function(focusedCell, prevFocusedCell) {
    var onFocusedCellChange = this.props.onFocusedCellChange;
    this.setState({
      focusedElement: focusedCell
    });
    focus(this.elements, focusedCell, prevFocusedCell, onFocusedCellChange);
  };
  TableKeyboardNavigationCore2.prototype.handleKeyDownOnWidget = function(event) {
    var _a;
    var focusedElement = this.state.focusedElement;
    var _b = this.props, tableColumns = _b.tableColumns, tableBodyRows = _b.tableBodyRows, tableHeaderRows2 = _b.tableHeaderRows, expandedRowIds = _b.expandedRowIds, scrollToColumn = _b.scrollToColumn, inlineEditing = _b.inlineEditing;
    if (event.key === "f" && (event.ctrlKey || event.metaKey)) {
      if (this.searchPanelRef) {
        event.preventDefault();
        (_a = this.searchPanelRef.current) === null || _a === void 0 ? void 0 : _a.click();
      }
      if (focusedElement) {
        this.changeFocusedElement(void 0, focusedElement);
      }
      return;
    }
    if (focusedElement && !isCellExist(this.elements, focusedElement) && event.key === "Tab") {
      var focusedCell = getClosestCellByRow(tableBodyRows, focusedElement, this.elements);
      event.preventDefault();
      this.changeFocusedElement(focusedCell, focusedElement);
      return;
    }
    if (focusedElement || isTabArrowUpDown(event)) {
      var _c = getNextFocusedCell(tableColumns, tableBodyRows, tableHeaderRows2, expandedRowIds, this.elements, event, inlineEditing, focusedElement, scrollToColumn), element = _c.element, scrolling = _c.scrolling;
      if (element) {
        if (scrolling) {
          scrollToColumn(scrolling === "left" ? LEFT_POSITION : RIGHT_POSITION);
        }
        event.preventDefault();
        this.changeFocusedElement(element, focusedElement);
      } else if (isTabArrowUpDown(event) && focusedElement) {
        this.changeFocusedElement(void 0, focusedElement);
      }
    }
  };
  TableKeyboardNavigationCore2.prototype.setFocusedElement = function(_a) {
    var key1 = _a.key1, key2 = _a.key2, event = _a.event;
    var focusedElement = this.state.focusedElement;
    var inlineEditing = this.props.inlineEditing;
    if (key1 === "paging" || key1 === "toolbar") {
      this.changeFocusedElement(void 0, focusedElement);
    } else if (key2.includes(TABLE_FLEX_TYPE.toString())) {
      var columnKey = this.props.tableColumns[0].key;
      this.changeFocusedElement({
        rowKey: key1,
        columnKey,
        index: -1,
        part: getPart(key1)
      }, focusedElement);
    } else {
      var part = getPart(key1);
      this.changeFocusedElement({
        rowKey: key1,
        columnKey: key2,
        index: getIndexToFocus(key1, key2, this.elements, event, inlineEditing, part),
        part
      }, focusedElement);
    }
  };
  TableKeyboardNavigationCore2.prototype.render = function() {
    var _this = this;
    var _a = this.props, Cell = _a.cellComponent, Row = _a.rowComponent, focusedRowEnabled = _a.focusedRowEnabled, tableBodyRows = _a.tableBodyRows;
    var focusedElement = this.state.focusedElement;
    var getFocusedGetter = function() {
      return getFocusing(tableBodyRows, focusedElement);
    };
    return (0, import_react.createElement)(
      Plugin,
      { name: "TableKeyboardNavigationCore" },
      (0, import_react.createElement)(Action, { name: "setSearchPanelRef", action: this.setSearchPanelRef }),
      focusedRowEnabled && (0, import_react.createElement)(Getter, { name: "highlightSelectedRow", value: true }),
      focusedRowEnabled && (0, import_react.createElement)(Getter, { name: "focused", computed: getFocusedGetter }),
      (0, import_react.createElement)(Template, { name: "tableCell" }, function(params) {
        return (0, import_react.createElement)(Cell, __assign2({}, params, { component: CellPlaceholder$3, tabIndex: 0, updateRefForKeyboardNavigation: _this.updateRef, setFocusedElement: _this.setFocusedElement, focused: isCellFocused(params.tableRow, params.tableColumn, focusedElement) }));
      }),
      (0, import_react.createElement)(
        Template,
        { name: "header" },
        (0, import_react.createElement)(TemplatePlaceholder, { params: {
          updateRefForKeyboardNavigation: this.updateRef,
          setFocusedElement: this.setFocusedElement
        } })
      ),
      (0, import_react.createElement)(
        Template,
        { name: "footer" },
        (0, import_react.createElement)(TemplatePlaceholder, { params: {
          updateRefForKeyboardNavigation: this.updateRef,
          setFocusedElement: this.setFocusedElement
        } })
      ),
      focusedRowEnabled && (0, import_react.createElement)(Template, { name: "tableRow", predicate: function(_a2) {
        var tableRow = _a2.tableRow;
        return !!isDataTableRow(tableRow);
      } }, function(params) {
        return (0, import_react.createElement)(Row, __assign2({}, params, { component: RowPlaceholder$1, focused: isRowFocused(params.tableRow, focusedElement === null || focusedElement === void 0 ? void 0 : focusedElement.rowKey) }));
      })
    );
  };
  return TableKeyboardNavigationCore2;
}(import_react.PureComponent);
var TableKeyboardNavigationBase = function(_super) {
  __extends(TableKeyboardNavigationBase2, _super);
  function TableKeyboardNavigationBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  TableKeyboardNavigationBase2.prototype.render = function() {
    var _this = this;
    return (0, import_react.createElement)(
      Plugin,
      { name: "TableKeyboardNavigation", dependencies: [
        { name: "Table" }
      ] },
      (0, import_react.createElement)(TemplateConnector, null, function(_a, _b) {
        var tableColumns = _a.tableColumns, tableBodyRows = _a.tableBodyRows, rootRef = _a.rootRef, tableHeaderRows2 = _a.tableHeaderRows, expandedRowIds = _a.expandedRowIds;
        var scrollToColumn = _b.scrollToColumn, stopEditCells2 = _b.stopEditCells, commitChangedRows = _b.commitChangedRows, cancelChangedRows = _b.cancelChangedRows, startEditCells2 = _b.startEditCells;
        return rootRef.current ? (0, import_react.createElement)(TableKeyboardNavigationCore, __assign2({ tableColumns, tableBodyRows, rootRef, tableHeaderRows: filterHeaderRows(tableHeaderRows2), expandedRowIds, scrollToColumn, inlineEditing: {
          stopEditCells: stopEditCells2,
          commitChangedRows,
          cancelChangedRows,
          startEditCells: startEditCells2
        } }, _this.props)) : null;
      })
    );
  };
  TableKeyboardNavigationBase2.components = {
    cellComponent: "Cell",
    rowComponent: "Row"
  };
  return TableKeyboardNavigationBase2;
}(import_react.PureComponent);
var TableKeyboardNavigation = TableKeyboardNavigationBase;
var getRowStyle = function(_a) {
  var row = _a.row;
  return row.height !== void 0 ? { height: row.height + "px" } : void 0;
};
var isNumber = function(value) {
  return typeof value === "number" || !Number.isNaN(Number(value));
};
var TableLayoutBase = function(_super) {
  __extends(TableLayoutBase2, _super);
  function TableLayoutBase2(props) {
    var _this = _super.call(this, props) || this;
    _this.savedOffsetWidth = -1;
    _this.raf = -1;
    _this.state = {
      animationState: /* @__PURE__ */ new Map()
    };
    _this.animations = /* @__PURE__ */ new Map();
    _this.savedScrollWidth = {};
    _this.tableRef = (0, import_react.createRef)();
    return _this;
  }
  TableLayoutBase2.prototype.componentDidMount = function() {
    if (this.tableRef.current) {
      var forwardedRef = this.props.forwardedRef;
      if (typeof forwardedRef === "function") {
        forwardedRef(this.tableRef.current);
      } else if (forwardedRef) {
        forwardedRef.current = this.tableRef.current;
      }
    }
  };
  TableLayoutBase2.prototype.componentDidUpdate = function(prevProps) {
    var columns = this.props.columns;
    var prevColumns = prevProps.columns;
    var animationState = this.state.animationState;
    var activeAnimationExists = !shallowEqual(columns, prevColumns) || !!animationState.size || !!this.animations.size;
    if (activeAnimationExists) {
      this.processAnimation(prevColumns);
    }
  };
  TableLayoutBase2.prototype.processAnimation = function(prevColumns) {
    var columns = this.props.columns;
    var tableWidth = this.getTableWidth(prevColumns, columns);
    this.animations = getAnimations(prevColumns, columns, tableWidth, this.animations);
    cancelAnimationFrame(this.raf);
    this.raf = requestAnimationFrame(this.processAnimationFrame.bind(this));
  };
  TableLayoutBase2.prototype.getTableWidth = function(prevColumns, columns) {
    var _a = this.tableRef.current, offsetWidth = _a.offsetWidth, scrollWidth = _a.scrollWidth;
    var animationState = this.state.animationState;
    var widthChanged = this.savedOffsetWidth !== offsetWidth || !this.savedScrollWidth[columns.length];
    var columnCountChanged = columns.length !== prevColumns.length;
    if (columnCountChanged || widthChanged && !animationState.size) {
      this.savedScrollWidth = {};
      this.savedScrollWidth[columns.length] = scrollWidth;
      this.savedOffsetWidth = offsetWidth;
    }
    return this.savedScrollWidth[columns.length];
  };
  TableLayoutBase2.prototype.getColumns = function() {
    var columns = this.props.columns;
    var animationState = this.state.animationState;
    var result = columns;
    var isFixedWidth = columns.filter(function(column) {
      return column.width === void 0 || column.width === "auto";
    }).length === 0;
    if (isFixedWidth) {
      result = __spread2(result, [{ key: TABLE_FLEX_TYPE.toString(), type: TABLE_FLEX_TYPE }]);
    }
    if (animationState.size) {
      result = result.map(function(column) {
        return animationState.has(column.key) ? __assign2(__assign2({}, column), { animationState: animationState.get(column.key) }) : column;
      });
    }
    return result;
  };
  TableLayoutBase2.prototype.processAnimationFrame = function() {
    var animationComponentState = this.state.animationState;
    this.animations = filterActiveAnimations(this.animations);
    if (!this.animations.size) {
      if (animationComponentState.size) {
        this.setState({ animationState: /* @__PURE__ */ new Map() });
      }
      return;
    }
    var animationState = evalAnimations(this.animations);
    this.setState({ animationState });
  };
  TableLayoutBase2.prototype.render = function() {
    var _a = this.props, Layout = _a.layoutComponent, minColumnWidth = _a.minColumnWidth, forwardedRef = _a.forwardedRef, restProps = __rest2(_a, ["layoutComponent", "minColumnWidth", "forwardedRef"]);
    var columns = this.getColumns();
    var minWidth = columns.map(function(column) {
      return column.width || (column.type === TABLE_FLEX_TYPE ? 0 : minColumnWidth);
    }).filter(function(value) {
      return value !== "auto" && value !== 0;
    }).map(function(value) {
      return isNumber(value) ? value + "px" : value;
    }).join(" + ");
    return (0, import_react.createElement)(Layout, __assign2({}, restProps, { tableRef: this.tableRef, columns, minWidth, minColumnWidth }));
  };
  return TableLayoutBase2;
}(import_react.PureComponent);
var TableLayout = TableLayoutBase;
var shouldUpdateRow = function(prevProps, nextProps) {
  var prevCells = prevProps.cells, prevRow = prevProps.row;
  var nextCells = nextProps.cells, nextRow = nextProps.row;
  if (prevRow !== nextRow || prevCells.length !== nextCells.length) {
    return false;
  }
  return !nextCells.some(function(nextCell, i) {
    var prevCell = prevCells[i];
    return prevCell.column !== nextCell.column || prevCell.colSpan !== nextCell.colSpan;
  });
};
var VirtualRowLayout = (0, import_react.memo)(function(_a) {
  var row = _a.row, cells = _a.cells, Row = _a.rowComponent, Cell = _a.cellComponent, forwardedRef = _a.forwardedRef;
  return (0, import_react.createElement)(Row, { forwardedRef, tableRow: row, style: getRowStyle({ row }) }, cells.map(function(_a2) {
    var column = _a2.column, colSpan = _a2.colSpan;
    return (0, import_react.createElement)(Cell, { key: column.key, tableRow: row, tableColumn: column, colSpan });
  }));
}, shouldUpdateRow);
var VirtualTableLayoutBlock = function(_super) {
  __extends(VirtualTableLayoutBlock2, _super);
  function VirtualTableLayoutBlock2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  VirtualTableLayoutBlock2.prototype.render = function() {
    var _a = this.props, collapsedGrid = _a.collapsedGrid, rowRefsHandler = _a.rowRefsHandler, Body = _a.bodyComponent, cellComponent = _a.cellComponent, rowComponent = _a.rowComponent, isFixed = _a.isFixed;
    return (0, import_react.createElement)(Body, { isFixed }, collapsedGrid.rows.map(function(visibleRow) {
      var row = visibleRow.row, _a2 = visibleRow.cells, cells = _a2 === void 0 ? [] : _a2;
      return (0, import_react.createElement)(VirtualRowLayout, { key: row.key, forwardedRef: function(ref) {
        return rowRefsHandler(row, ref);
      }, row, cells, rowComponent, cellComponent });
    }));
  };
  VirtualTableLayoutBlock2.defaultProps = {
    rowRefsHandler: function() {
    }
  };
  return VirtualTableLayoutBlock2;
}(import_react.PureComponent);
var ColumnGroup = function(_super) {
  __extends(ColumnGroup2, _super);
  function ColumnGroup2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ColumnGroup2.prototype.render = function() {
    var columns = this.props.columns;
    return (0, import_react.createElement)("colgroup", null, columns.map(function(_a) {
      var key = _a.key, width = _a.width;
      var styleWidth = typeof width === "number" ? width + "px" : width;
      return (0, import_react.createElement)("col", { key, style: width !== void 0 ? { width: styleWidth } : void 0 });
    }));
  };
  return ColumnGroup2;
}(import_react.PureComponent);
var AUTO_HEIGHT = "auto";
var defaultProps$3 = {
  headerRows: [],
  footerRows: [],
  headComponent: function() {
    return null;
  },
  footerComponent: function() {
    return null;
  },
  tableComponent: function() {
    return null;
  },
  containerComponent: (0, import_react.forwardRef)(function() {
    return null;
  })
};
var VirtualTableLayout = function(_super) {
  __extends(VirtualTableLayout2, _super);
  function VirtualTableLayout2(props) {
    var _this = _super.call(this, props) || this;
    _this.rowRefs = /* @__PURE__ */ new Map();
    _this.blockRefs = /* @__PURE__ */ new Map();
    _this.viewportTop = 0;
    _this.containerHeight = 600;
    _this.containerWidth = 800;
    _this.viewportLeft = 0;
    _this.getRowHeight = function(row) {
      var rowHeights = _this.state.rowHeights;
      var estimatedRowHeight = _this.props.estimatedRowHeight;
      if (row) {
        var storedHeight = rowHeights.get(row.key);
        if (storedHeight !== void 0)
          return storedHeight;
        if (row.height)
          return row.height;
      }
      return estimatedRowHeight;
    };
    _this.registerRowRef = function(row, ref) {
      if (ref === null) {
        _this.rowRefs.delete(row);
      } else {
        _this.rowRefs.set(row, ref);
      }
    };
    _this.registerBlockRef = function(name, ref) {
      if (ref === null) {
        _this.blockRefs.delete(name);
      } else {
        _this.blockRefs.set(name, ref);
      }
    };
    _this.onScroll = function(e) {
      var node = e.target;
      if (_this.shouldSkipScrollEvent(e)) {
        return;
      }
      var viewportTop = node.scrollTop, viewportLeft = node.scrollLeft;
      _this.viewportTop = viewportTop;
      _this.viewportLeft = viewportLeft;
      _this.updateViewport();
    };
    _this.handleContainerSizeChange = function(_a) {
      var width = _a.width, height = _a.height;
      _this.containerHeight = height;
      _this.containerWidth = width;
      _this.updateViewport();
    };
    _this.state = {
      rowHeights: /* @__PURE__ */ new Map(),
      height: 0,
      visibleRowBoundaries: {}
    };
    _this.getColumnWidthGetter = memoize(function(tableColumns, tableWidth, minColumnWidth) {
      return getColumnWidthGetter(tableColumns, tableWidth, minColumnWidth);
    });
    return _this;
  }
  VirtualTableLayout2.prototype.componentDidMount = function() {
    this.storeRowHeights();
  };
  VirtualTableLayout2.prototype.componentDidUpdate = function(prevProps) {
    setTimeout(this.storeRowHeights.bind(this));
    var _a = this.props, bodyRows = _a.bodyRows, columns = _a.columns;
    var bodyRowsChanged = prevProps.bodyRows !== bodyRows;
    var columnCountChanged = prevProps.columns.length !== columns.length;
    if (bodyRowsChanged || columnCountChanged || columns[0].width !== void 0 && prevProps.columns.some(function(column, index) {
      return column.width !== columns[index].width;
    })) {
      this.updateViewport();
    }
  };
  VirtualTableLayout2.getDerivedStateFromProps = function(nextProps, prevState) {
    var prevRowHeight = prevState.rowHeights;
    var rowHeights = __spread2(nextProps.headerRows, nextProps.bodyRows, nextProps.footerRows).reduce(function(acc, row) {
      var rowHeight = prevRowHeight.get(row.key);
      if (rowHeight !== void 0) {
        acc.set(row.key, rowHeight);
      }
      return acc;
    }, /* @__PURE__ */ new Map());
    return { rowHeights };
  };
  VirtualTableLayout2.prototype.storeRowHeights = function() {
    var _this = this;
    var rowsWithChangedHeights = Array.from(this.rowRefs.entries()).map(function(_a) {
      var _b = __read2(_a, 2), row = _b[0], ref = _b[1];
      return [row, ref];
    }).filter(function(_a) {
      var _b = __read2(_a, 2), node = _b[1];
      return !!node;
    }).map(function(_a) {
      var _b = __read2(_a, 2), row = _b[0], node = _b[1];
      return [row, node.getBoundingClientRect().height];
    }).filter(function(_a) {
      var _b = __read2(_a, 1), row = _b[0];
      return row.type !== TABLE_STUB_TYPE;
    }).filter(function(_a) {
      var _b = __read2(_a, 2), row = _b[0], height = _b[1];
      return height !== _this.getRowHeight(row);
    });
    if (rowsWithChangedHeights.length) {
      var rowHeights_1 = this.state.rowHeights;
      rowsWithChangedHeights.forEach(function(_a) {
        var _b = __read2(_a, 2), row = _b[0], height = _b[1];
        return rowHeights_1.set(row.key, height);
      });
      this.setState({
        rowHeights: rowHeights_1
      });
    }
  };
  VirtualTableLayout2.prototype.shouldSkipScrollEvent = function(e) {
    var node = e.target;
    if (node !== e.currentTarget) {
      return true;
    }
    var correction = 1;
    var nodeHorizontalOffset = parseInt(node.scrollLeft + node.clientWidth, 10) - correction;
    var nodeVerticalOffset = parseInt(node.scrollTop + node.clientHeight, 10) - correction;
    if (node.scrollTop < 0 || node.scrollLeft < 0 || nodeHorizontalOffset > Math.max(node.scrollWidth, node.clientWidth) || nodeVerticalOffset > Math.max(node.scrollHeight, node.clientHeight)) {
      return true;
    }
    return false;
  };
  VirtualTableLayout2.prototype.updateViewport = function() {
    var _a = this.props, viewport = _a.viewport, setViewport = _a.setViewport;
    var newViewport = this.calculateViewport();
    if (viewport !== newViewport) {
      setViewport(newViewport);
    }
  };
  VirtualTableLayout2.prototype.calculateViewport = function() {
    var _a = this, state = _a.state, viewportTop = _a.viewportTop, viewportLeft = _a.viewportLeft, containerHeight = _a.containerHeight, containerWidth = _a.containerWidth;
    var _b = this.props, loadedRowsStart2 = _b.loadedRowsStart, bodyRows = _b.bodyRows, headerRows = _b.headerRows, footerRows = _b.footerRows, estimatedRowHeight = _b.estimatedRowHeight, columns = _b.columns, minColumnWidth = _b.minColumnWidth, isDataRemote = _b.isDataRemote, viewport = _b.viewport;
    var getColumnWidth2 = this.getColumnWidthGetter(columns, containerWidth, minColumnWidth);
    return getViewport(__assign2(__assign2({}, state), { viewportTop, viewportLeft, containerHeight, containerWidth }), { loadedRowsStart: loadedRowsStart2, columns, bodyRows, headerRows, footerRows, isDataRemote, viewport }, estimatedRowHeight, this.getRowHeight, getColumnWidth2);
  };
  VirtualTableLayout2.prototype.getCollapsedGrids = function(viewport) {
    var _a = this, containerWidth = _a.containerWidth, viewportLeft = _a.viewportLeft;
    var _b = this.props, headerRows = _b.headerRows, bodyRows = _b.bodyRows, footerRows = _b.footerRows, columns = _b.columns, loadedRowsStart2 = _b.loadedRowsStart, totalRowCount = _b.totalRowCount, getCellColSpan = _b.getCellColSpan, minColumnWidth = _b.minColumnWidth;
    var getColumnWidth2 = this.getColumnWidthGetter(columns, containerWidth, minColumnWidth);
    return getCollapsedGrids({
      headerRows,
      bodyRows,
      footerRows,
      columns,
      loadedRowsStart: loadedRowsStart2,
      totalRowCount,
      getCellColSpan,
      viewportLeft,
      containerWidth,
      viewport,
      getRowHeight: this.getRowHeight,
      getColumnWidth: getColumnWidth2
    });
  };
  VirtualTableLayout2.prototype.render = function() {
    var _a = this.props, Container = _a.containerComponent, Table2 = _a.tableComponent, Head = _a.headComponent, Body = _a.bodyComponent, Footer = _a.footerComponent, tableRef = _a.tableRef, height = _a.height, headerRows = _a.headerRows, footerRows = _a.footerRows, minColumnWidth = _a.minColumnWidth, minWidth = _a.minWidth, cellComponent = _a.cellComponent, rowComponent = _a.rowComponent, viewport = _a.viewport, scrollTop = _a.scrollTop, columns = _a.columns, nextColumnId = _a.nextColumnId;
    var scrollLeft = getScrollLeft(columns.length, minColumnWidth, nextColumnId);
    var collapsedGrids = this.getCollapsedGrids(viewport);
    var commonProps = {
      cellComponent,
      rowComponent,
      minColumnWidth,
      minWidth,
      blockRefsHandler: this.registerBlockRef,
      rowRefsHandler: this.registerRowRef
    };
    var sizerHeight = height === AUTO_HEIGHT ? null : height;
    return (0, import_react.createElement)(
      Sizer,
      { onSizeChange: this.handleContainerSizeChange, containerComponent: Container, style: { height: sizerHeight }, onScroll: this.onScroll, scrollTop, scrollLeft },
      (0, import_react.createElement)(
        Table2,
        { forwardedRef: tableRef, style: {
          minWidth: minWidth + "px"
        } },
        (0, import_react.createElement)(ColumnGroup, { columns: collapsedGrids.bodyGrid.columns }),
        !!headerRows.length && (0, import_react.createElement)(VirtualTableLayoutBlock, __assign2({}, commonProps, { name: "header", isFixed: true, collapsedGrid: collapsedGrids.headerGrid, bodyComponent: Head })),
        (0, import_react.createElement)(VirtualTableLayoutBlock, __assign2({}, commonProps, { name: "body", collapsedGrid: collapsedGrids.bodyGrid, bodyComponent: Body })),
        !!footerRows.length && (0, import_react.createElement)(VirtualTableLayoutBlock, __assign2({}, commonProps, { name: "footer", isFixed: true, collapsedGrid: collapsedGrids.footerGrid, bodyComponent: Footer }))
      )
    );
  };
  VirtualTableLayout2.defaultProps = defaultProps$3;
  return VirtualTableLayout2;
}(import_react.PureComponent);
var getColumnStyle = function(_a) {
  var column = _a.column;
  return column.animationState;
};
var RowLayout = (0, import_react.memo)(function(props) {
  var row = props.row, columns = props.columns, Row = props.rowComponent, Cell = props.cellComponent, getCellColSpan = props.getCellColSpan;
  var getColSpan = (0, import_react.useCallback)(function(tableRow, tableColumn) {
    return getCellColSpan({ tableRow, tableColumn, tableColumns: columns });
  }, [columns, getCellColSpan]);
  return (0, import_react.createElement)(Row, { tableRow: row, style: getRowStyle({ row }) }, columns.map(function(column) {
    return (0, import_react.createElement)(Cell, { key: column.key, tableRow: row, tableColumn: column, style: getColumnStyle({ column }), colSpan: getColSpan(row, column) });
  }));
});
var RowsBlockLayout = function(_super) {
  __extends(RowsBlockLayout2, _super);
  function RowsBlockLayout2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  RowsBlockLayout2.prototype.render = function() {
    var _a = this.props, rows = _a.rows, columns = _a.columns, Block = _a.blockComponent, rowComponent = _a.rowComponent, cellComponent = _a.cellComponent, getCellColSpan = _a.getCellColSpan;
    return (0, import_react.createElement)(Block, null, rows.map(function(row) {
      return (0, import_react.createElement)(RowLayout, { key: row.key, row, columns, rowComponent, cellComponent, getCellColSpan });
    }));
  };
  return RowsBlockLayout2;
}(import_react.PureComponent);
var defaultProps$4 = {
  headerRows: [],
  footerRows: [],
  headComponent: function() {
    return null;
  },
  footerComponent: function() {
    return null;
  }
};
var StaticTableLayout = function(_super) {
  __extends(StaticTableLayout2, _super);
  function StaticTableLayout2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  StaticTableLayout2.prototype.render = function() {
    var _a = this.props, headerRows = _a.headerRows, bodyRows = _a.bodyRows, footerRows = _a.footerRows, columns = _a.columns, minWidth = _a.minWidth, Container = _a.containerComponent, Table2 = _a.tableComponent, headComponent = _a.headComponent, bodyComponent = _a.bodyComponent, footerComponent = _a.footerComponent, rowComponent = _a.rowComponent, cellComponent = _a.cellComponent, getCellColSpan = _a.getCellColSpan, tableRef = _a.tableRef;
    var commonProps = {
      columns,
      rowComponent,
      cellComponent,
      getCellColSpan
    };
    return (0, import_react.createElement)(
      Container,
      null,
      (0, import_react.createElement)(
        Table2,
        { forwardedRef: tableRef, style: { minWidth: "calc(" + minWidth + ")" } },
        (0, import_react.createElement)(ColumnGroup, { columns }),
        !!headerRows.length && (0, import_react.createElement)(RowsBlockLayout, __assign2({ rows: headerRows, blockComponent: headComponent }, commonProps)),
        (0, import_react.createElement)(RowsBlockLayout, __assign2({ rows: bodyRows, blockComponent: bodyComponent }, commonProps)),
        !!footerRows.length && (0, import_react.createElement)(RowsBlockLayout, __assign2({ rows: footerRows, blockComponent: footerComponent }, commonProps))
      )
    );
  };
  StaticTableLayout2.defaultProps = defaultProps$4;
  return StaticTableLayout2;
}(import_react.PureComponent);
var emptyViewport = {
  columns: [[0, 0]],
  rows: [0, 0],
  headerRows: [0, 0],
  footerRows: [0, 0],
  top: 0,
  left: 0,
  width: 800,
  height: 600
};
var tableColumnsComputed = function(_a) {
  var tableColumns = _a.tableColumns;
  return checkColumnWidths(tableColumns);
};
var makeVirtualTable = function(Table2, _a) {
  var VirtualLayout = _a.VirtualLayout, FixedHeader = _a.FixedHeader, FixedFooter = _a.FixedFooter, SkeletonCell = _a.SkeletonCell, defaultEstimatedRowHeight = _a.defaultEstimatedRowHeight, defaultHeight = _a.defaultHeight;
  var VirtualTable = function(_super) {
    __extends(VirtualTable2, _super);
    function VirtualTable2(props) {
      var _this = _super.call(this, props) || this;
      _this.setViewport = function(viewport) {
        _this.setState({ viewport });
      };
      _this.state = {
        viewport: emptyViewport,
        nextRowId: void 0,
        nextColumnId: void 0
      };
      _this.scrollToRow = function(nextRowId) {
        return _this.setState({ nextRowId });
      };
      _this.scrollToColumn = function(nextColumnId) {
        return _this.setState({ nextColumnId });
      };
      return _this;
    }
    VirtualTable2.prototype.componentDidUpdate = function(prevProps, prevState) {
      var prevId = prevState.nextRowId;
      var currentId = this.state.nextRowId;
      var areIdsEqual = currentId !== void 0 && currentId === prevId;
      if (areIdsEqual) {
        this.setState({ nextRowId: void 0 });
      }
    };
    VirtualTable2.prototype.render = function() {
      var _this = this;
      var _a2 = this.props, height = _a2.height, estimatedRowHeight = _a2.estimatedRowHeight, SkeletonStubCell = _a2.skeletonCellComponent, children = _a2.children, restProps = __rest2(_a2, ["height", "estimatedRowHeight", "skeletonCellComponent", "children"]);
      var _b = this.state, stateViewport = _b.viewport, nextId = _b.nextRowId, nextColumnId = _b.nextColumnId;
      return (0, import_react.createElement)(
        Plugin,
        { name: "VirtualTable" },
        (0, import_react.createElement)(Table2, __assign2({ layoutComponent: VirtualLayout }, restProps)),
        (0, import_react.createElement)(Action, { name: "setViewport", action: this.setViewport }),
        (0, import_react.createElement)(Action, { name: "scrollToRow", action: this.scrollToRow }),
        (0, import_react.createElement)(Action, { name: "scrollToColumn", action: this.scrollToColumn }),
        (0, import_react.createElement)(Getter, { name: "viewport", value: stateViewport }),
        (0, import_react.createElement)(Getter, { name: "tableColumns", computed: tableColumnsComputed }),
        (0, import_react.createElement)(Template, { name: "tableLayout" }, function(params) {
          return (0, import_react.createElement)(TemplateConnector, null, function(_a3, _b2) {
            var availableRowCount = _a3.availableRowCount, loadedRowsStart2 = _a3.loadedRowsStart, tableBodyRows = _a3.tableBodyRows, isDataRemote = _a3.isDataRemote, viewport = _a3.viewport;
            var setViewport = _b2.setViewport;
            var onTopRowChange = _this.props.onTopRowChange;
            var rowId = getTopRowId(viewport, tableBodyRows, isDataRemote);
            onTopRowChange(rowId);
            var totalRowCount = availableRowCount || tableBodyRows.length;
            var scrollTop = getScrollTop(tableBodyRows, totalRowCount, nextId, estimatedRowHeight, isDataRemote);
            return (0, import_react.createElement)(TemplatePlaceholder, { params: __assign2(__assign2({}, params), {
              totalRowCount,
              loadedRowsStart: loadedRowsStart2,
              isDataRemote,
              height,
              estimatedRowHeight,
              setViewport,
              viewport,
              scrollTop,
              nextColumnId
            }) });
          });
        }),
        (0, import_react.createElement)(Template, { name: "tableCell", predicate: function(_a3) {
          var tableRow = _a3.tableRow;
          return !!isStubTableCell(tableRow);
        } }, function(params) {
          return (0, import_react.createElement)(TemplateConnector, null, function(_a3) {
            var isDataRemote = _a3.isDataRemote;
            return isDataRemote ? (0, import_react.createElement)(SkeletonStubCell, __assign2({}, params)) : (0, import_react.createElement)(TemplatePlaceholder, null);
          });
        })
      );
    };
    VirtualTable2.defaultProps = {
      estimatedRowHeight: defaultEstimatedRowHeight,
      height: defaultHeight,
      skeletonCellComponent: SkeletonCell,
      onTopRowChange: function() {
      }
    };
    VirtualTable2.TOP_POSITION = TOP_POSITION;
    VirtualTable2.BOTTOM_POSITION = BOTTOM_POSITION;
    return VirtualTable2;
  }(import_react.PureComponent);
  Object.values(Table2.components).forEach(function(name) {
    VirtualTable[name] = Table2[name];
  });
  VirtualTable.FixedHeader = FixedHeader;
  VirtualTable.FixedFooter = FixedFooter;
  VirtualTable.SkeletonCell = SkeletonCell;
  return VirtualTable;
};
var Node = function() {
  function Node2(start, rows) {
    this.prev = null;
    this.next = null;
    this.start = start;
    this.rows = rows;
  }
  return Node2;
}();
var LRUCache = function() {
  function LRUCache2(pageSize, capacity) {
    if (capacity === void 0) {
      capacity = Number.POSITIVE_INFINITY;
    }
    this.pages = /* @__PURE__ */ new Map();
    this.pageSize = pageSize;
    this.capacity = capacity;
    this.initList();
  }
  LRUCache2.prototype.initList = function() {
    this.head = new Node(-1, []);
    this.tail = new Node(-1, []);
    this.head.next = this.tail;
    this.tail.prev = this.head;
  };
  LRUCache2.prototype.addPage = function(pageStart, rows) {
    if (this.pages.has(pageStart)) {
      this.removePage(pageStart);
    }
    var node = new Node(pageStart, rows);
    var last = this.tail.prev;
    last.next = node;
    node.next = this.tail;
    node.prev = last;
    this.tail.prev = node;
    this.pages.set(pageStart, node);
    if (this.pages.size > this.capacity) {
      this.removePage(this.head.next.start);
    }
  };
  LRUCache2.prototype.removePage = function(start) {
    var node = this.pages.get(start);
    node.prev.next = node.next;
    node.next.prev = node.prev;
    this.pages.delete(start);
  };
  LRUCache2.prototype.getPage = function(pageStart) {
    if (!this.pages.has(pageStart)) {
      return null;
    }
    var rows = this.pages.get(pageStart).rows;
    this.removePage(pageStart);
    this.addPage(pageStart, rows);
    return rows;
  };
  LRUCache2.prototype.clear = function() {
    this.pages.clear();
    this.initList();
  };
  return LRUCache2;
}();
var createRowCache = function(pageSize, capacity) {
  if (pageSize === void 0) {
    pageSize = 100;
  }
  if (capacity === void 0) {
    capacity = Number.POSITIVE_INFINITY;
  }
  var cache = new LRUCache(pageSize, capacity / pageSize);
  return {
    getRows: function(skip, take) {
      var result = [];
      var pageCount2 = Math.ceil(take / pageSize);
      for (var i = 0; i < pageCount2; i += 1) {
        var pageStart = skip + i * pageSize;
        var chunk = cache.getPage(pageStart);
        if (chunk !== null) {
          result = result.concat(chunk);
        }
        if (chunk === null || i !== pageCount2 - 1 && chunk.length !== pageSize) {
          return result;
        }
      }
      return result;
    },
    setRows: function(skip, rows) {
      var pageCount2 = Math.ceil(rows.length / pageSize);
      for (var i = 0; i < pageCount2; i += 1) {
        var pageStart = i * pageSize;
        var rowsChunk = rows.slice(pageStart, pageStart + pageSize);
        if (rowsChunk.length === pageSize || i === pageCount2 - 1) {
          cache.addPage(pageStart + skip, rowsChunk);
        }
      }
    },
    invalidate: function() {
      return cache.clear();
    }
  };
};
var withKeyboardNavigation = function(key1, key2) {
  return function(Component) {
    var ComponentWithNavigation = function(_super) {
      __extends(ComponentWithNavigation2, _super);
      function ComponentWithNavigation2(props) {
        var _this = _super.call(this, props) || this;
        _this.ref = { current: null };
        _this.handleClick = _this.handleClick.bind(_this);
        _this.setForwardedRef = _this.setForwardedRef.bind(_this);
        return _this;
      }
      ComponentWithNavigation2.prototype.setForwardedRef = function(node) {
        var _a, _b;
        (_a = this.ref.current) === null || _a === void 0 ? void 0 : _a.removeEventListener("mouseup", this.handleClick);
        this.ref.current = node;
        (_b = this.ref.current) === null || _b === void 0 ? void 0 : _b.addEventListener("mouseup", this.handleClick);
      };
      ComponentWithNavigation2.prototype.componentDidMount = function() {
        var _a = this.props, updateRefForKeyboardNavigation = _a.updateRefForKeyboardNavigation, tableRow = _a.tableRow, tableColumn = _a.tableColumn;
        if (this.ref.current && updateRefForKeyboardNavigation) {
          updateRefForKeyboardNavigation({
            ref: this.ref,
            key1: key1 || tableRow.key,
            key2: key2 || tableColumn.key,
            action: "add"
          });
        }
      };
      ComponentWithNavigation2.prototype.componentWillUnmount = function() {
        var _a = this.props, updateRefForKeyboardNavigation = _a.updateRefForKeyboardNavigation, tableRow = _a.tableRow, tableColumn = _a.tableColumn;
        if (this.ref.current && updateRefForKeyboardNavigation) {
          updateRefForKeyboardNavigation({
            ref: this.ref,
            key1: key1 || tableRow.key,
            key2: key2 || tableColumn.key,
            action: "remove"
          });
          this.ref.current.removeEventListener("mouseup", this.handleClick);
        }
      };
      ComponentWithNavigation2.prototype.handleClick = function(event) {
        var _a = this.props, tableRow = _a.tableRow, tableColumn = _a.tableColumn, setFocusedElement = _a.setFocusedElement;
        if (setFocusedElement) {
          setFocusedElement({ key1: key1 || tableRow.key, key2: key2 || tableColumn.key, event });
        }
      };
      ComponentWithNavigation2.prototype.render = function() {
        var _a = this.props, setFocusedElement = _a.setFocusedElement, updateRefForKeyboardNavigation = _a.updateRefForKeyboardNavigation, restProps = __rest2(_a, ["setFocusedElement", "updateRefForKeyboardNavigation"]);
        return (0, import_react.createElement)(Component, __assign2({ forwardedRef: this.setForwardedRef }, restProps));
      };
      return ComponentWithNavigation2;
    }(import_react.PureComponent);
    return ComponentWithNavigation;
  };
};
var InlineSummaryItem = (0, import_react.memo)(function(_a) {
  var _b = _a.summary, messageKey = _b.messageKey, columnTitle = _b.columnTitle, SummaryComponent = _b.component, getMessage = _a.getMessage;
  return (0, import_react.createElement)(
    import_react.Fragment,
    null,
    getMessage(messageKey, { columnTitle }),
    (0, import_react.createElement)(SummaryComponent, null)
  );
});

export {
  firstRowOnPage,
  lastRowOnPage,
  calculateStartPage,
  getCellGeometries,
  Grid,
  ColumnChooser,
  FilteringState,
  IntegratedFiltering,
  EditingState,
  PagingState,
  IntegratedPaging,
  CustomPaging,
  GroupingState,
  IntegratedGrouping,
  CustomGrouping,
  SelectionState,
  IntegratedSelection,
  SortingState,
  IntegratedSorting,
  DragDropProvider2 as DragDropProvider,
  TableColumnReordering,
  Table,
  TableSelection,
  RowDetailState,
  TableRowDetail,
  defaultMessages$1,
  TableGroupRow,
  TableHeaderRow,
  TableBandHeader,
  TableFilterRow,
  TableEditRow,
  TableEditColumn,
  TableColumnResizing,
  PagingPanel,
  GroupPanelLayout,
  GroupingPanel,
  DataTypeProvider,
  TableColumnVisibility,
  Toolbar,
  TreeDataState,
  CustomTreeData,
  TableTreeColumn,
  SearchState,
  SearchPanel,
  TableFixedColumns,
  SummaryState,
  IntegratedSummary,
  CustomSummary,
  TableSummaryRowBase,
  TableSummaryRow,
  VirtualTableState,
  TableInlineCellEditing,
  ExportPanel,
  TableKeyboardNavigation,
  TableLayout,
  VirtualTableLayout,
  StaticTableLayout,
  emptyViewport,
  makeVirtualTable,
  createRowCache,
  withKeyboardNavigation,
  InlineSummaryItem
};
/*! Bundled license information:

@devexpress/dx-grid-core/dist/dx-grid-core.es.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

@devexpress/dx-react-grid/dist/dx-react-grid.es.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
*/
//# sourceMappingURL=chunk-XEOMATV3.js.map
