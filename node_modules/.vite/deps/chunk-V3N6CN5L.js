import {
  DAY_MARGIN,
  MobileKeyboardInputView,
  PickersArrowSwitcher_default,
  PickersCalendarHeader_default,
  PickersCalendar_default,
  PickersDay_default,
  PickersToolbarButton_default,
  PickersToolbar_default,
  WrapperVariantContext,
  areDayPropsEqual,
  defaultReduceAnimations,
  doNothing,
  executeInTheNextEventLoopTick,
  isEndOfRange,
  isRangeValid,
  isStartOfRange,
  isWithinRange,
  useCalendarState,
  useDefaultDates,
  useMaskedInput,
  useNextMonthDisabled,
  usePreviousMonthDisabled,
  useUtils
} from "./chunk-5WRRARR4.js";
import {
  Typography_default
} from "./chunk-7HY2XPMI.js";
import {
  styled_default
} from "./chunk-OLZETHCB.js";
import {
  composeClasses,
  generateUtilityClass,
  generateUtilityClasses,
  init_base
} from "./chunk-3U3DCDMU.js";
import {
  alpha,
  clsx_m_default,
  init_clsx_m
} from "./chunk-3D3V2OFD.js";
import {
  _objectWithoutPropertiesLoose,
  init_objectWithoutPropertiesLoose
} from "./chunk-LCB5PCMX.js";
import {
  _extends,
  init_extends
} from "./chunk-S4J2UMZF.js";
import {
  require_jsx_runtime
} from "./chunk-LDDDBTIY.js";
import {
  require_prop_types
} from "./chunk-P6ODHCVW.js";
import {
  require_react
} from "./chunk-LBQWZZ6Z.js";
import {
  __toESM
} from "./chunk-TFWDKVI3.js";

// node_modules/@mui/lab/DateRangePickerDay/DateRangePickerDay.js
init_objectWithoutPropertiesLoose();
init_extends();
var React = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());
init_clsx_m();
init_base();
var import_jsx_runtime = __toESM(require_jsx_runtime());
var _excluded = ["className", "day", "outsideCurrentMonth", "isEndOfHighlighting", "isEndOfPreviewing", "isHighlighting", "isPreviewing", "isStartOfHighlighting", "isStartOfPreviewing", "selected"];
function getDateRangePickerDayUtilityClass(slot) {
  return generateUtilityClass("MuiDateRangePickerDay", slot);
}
var dateRangePickerDayClasses = generateUtilityClasses("MuiDateRangePickerDay", ["root", "rangeIntervalDayHighlight", "rangeIntervalDayHighlightStart", "rangeIntervalDayHighlightEnd", "rangeIntervalPreview", "rangeIntervalDayPreview", "rangeIntervalDayPreviewStart", "rangeIntervalDayPreviewEnd", "day", "dayOutsideRangeInterval", "dayInsideRangeInterval", "notSelectedDate"]);
var useUtilityClasses = (ownerState) => {
  const {
    isHighlighting,
    outsideCurrentMonth,
    isStartOfHighlighting,
    isStartOfMonth,
    isEndOfHighlighting,
    isEndOfMonth,
    isPreviewing,
    isStartOfPreviewing,
    isEndOfPreviewing,
    selected,
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root", isHighlighting && !outsideCurrentMonth && "rangeIntervalDayHighlight", (isStartOfHighlighting || isStartOfMonth) && "rangeIntervalDayHighlightStart", (isEndOfHighlighting || isEndOfMonth) && "rangeIntervalDayHighlightEnd"],
    rangeIntervalPreview: ["rangeIntervalPreview", isPreviewing && !outsideCurrentMonth && "rangeIntervalDayPreview", (isStartOfPreviewing || isStartOfMonth) && "rangeIntervalDayPreviewStart", (isEndOfPreviewing || isEndOfMonth) && "rangeIntervalDayPreviewEnd"],
    day: ["day", !selected && "notSelectedDate", !isHighlighting && "dayOutsideRangeInterval", !selected && isHighlighting && "dayInsideRangeInterval"]
  };
  return composeClasses(slots, getDateRangePickerDayUtilityClass, classes2);
};
var endBorderStyle = {
  borderTopRightRadius: "50%",
  borderBottomRightRadius: "50%"
};
var startBorderStyle = {
  borderTopLeftRadius: "50%",
  borderBottomLeftRadius: "50%"
};
var DateRangePickerDayRoot = styled_default("div", {
  name: "MuiDateRangePickerDay",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})(({
  theme,
  ownerState
}) => _extends({
  [`&:first-of-type .${dateRangePickerDayClasses.rangeIntervalDayPreview}`]: _extends({}, startBorderStyle, {
    borderLeftColor: theme.palette.divider
  }),
  [`&:last-of-type .${dateRangePickerDayClasses.rangeIntervalDayPreview}`]: _extends({}, endBorderStyle, {
    borderRightColor: theme.palette.divider
  })
}, ownerState.isHighlighting && !ownerState.outsideCurrentMonth && {
  borderRadius: 0,
  color: theme.palette.primary.contrastText,
  backgroundColor: alpha(theme.palette.primary.light, 0.6),
  "&:first-of-type": startBorderStyle,
  "&:last-of-type": endBorderStyle
}, (ownerState.isStartOfHighlighting || ownerState.isStartOfMonth) && _extends({}, startBorderStyle, {
  paddingLeft: 0,
  marginLeft: DAY_MARGIN / 2
}), (ownerState.isEndOfHighlighting || ownerState.isEndOfMonth) && _extends({}, endBorderStyle, {
  paddingRight: 0,
  marginRight: DAY_MARGIN / 2
})));
var DateRangePickerDayRangeIntervalPreview = styled_default("div", {
  name: "MuiDateRangePickerDay",
  slot: "RangeIntervalPreview"
})(({
  theme,
  ownerState
}) => _extends({
  // replace default day component margin with transparent border to avoid jumping on preview
  border: "2px solid transparent"
}, ownerState.isPreviewing && !ownerState.outsideCurrentMonth && _extends({
  borderRadius: 0,
  border: `2px dashed ${theme.palette.divider}`,
  borderLeftColor: "transparent",
  borderRightColor: "transparent"
}, (ownerState.isStartOfPreviewing || ownerState.isStartOfMonth) && _extends({
  borderLeftColor: theme.palette.divider
}, startBorderStyle), (ownerState.isEndOfPreviewing || ownerState.isEndOfMonth) && _extends({
  borderRightColor: theme.palette.divider
}, endBorderStyle))));
var DateRangePickerDayDay = styled_default(PickersDay_default, {
  name: "MuiDateRangePickerDay",
  slot: "Day"
})(({
  theme,
  ownerState
}) => _extends({
  // Required to overlap preview border
  transform: "scale(1.1)",
  "& > *": {
    transform: "scale(0.9)"
  }
}, !ownerState.selected && {
  backgroundColor: "transparent"
}, !ownerState.isHighlighting && {
  "&:hover": {
    border: `1px solid ${theme.palette.grey[500]}`
  }
}, !ownerState.selected && ownerState.isHighlighting && {
  color: theme.palette.getContrastText(alpha(theme.palette.primary.light, 0.6))
}));
var DateRangePickerDay = React.forwardRef(function DateRangePickerDay2(props, ref) {
  const {
    className,
    day,
    outsideCurrentMonth,
    isHighlighting,
    isPreviewing,
    selected = false
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded);
  const utils = useUtils();
  const isEndOfMonth = utils.isSameDay(day, utils.endOfMonth(day));
  const isStartOfMonth = utils.isSameDay(day, utils.startOfMonth(day));
  const shouldRenderHighlight = isHighlighting && !outsideCurrentMonth;
  const shouldRenderPreview = isPreviewing && !outsideCurrentMonth;
  const ownerState = _extends({}, props, {
    selected,
    isStartOfMonth,
    isEndOfMonth
  });
  const classes2 = useUtilityClasses(ownerState);
  return (0, import_jsx_runtime.jsx)(DateRangePickerDayRoot, {
    className: clsx_m_default(classes2.root, className),
    ownerState,
    children: (0, import_jsx_runtime.jsx)(DateRangePickerDayRangeIntervalPreview, {
      role: "cell",
      className: classes2.rangeIntervalPreview,
      ownerState,
      children: (0, import_jsx_runtime.jsx)(DateRangePickerDayDay, _extends({}, other, {
        ref,
        disableMargin: true,
        allowSameDateSelection: true,
        day,
        selected,
        outsideCurrentMonth,
        className: classes2.day,
        ownerState
      }))
    })
  });
});
true ? DateRangePickerDay.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit TypeScript types and run "yarn proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: import_prop_types.default.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types.default.object,
  /**
   * @ignore
   */
  className: import_prop_types.default.string,
  /**
   * The date to show.
   */
  day: import_prop_types.default.any.isRequired,
  /**
   * Set to `true` if the `day` is the end of a highlighted date range.
   */
  isEndOfHighlighting: import_prop_types.default.bool.isRequired,
  /**
   * Set to `true` if the `day` is the start of a highlighted date range.
   */
  isEndOfPreviewing: import_prop_types.default.bool.isRequired,
  /**
   * Set to `true` if the `day` is in a highlighted date range.
   */
  isHighlighting: import_prop_types.default.bool.isRequired,
  /**
   * Set to `true` if the `day` is in a preview date range.
   */
  isPreviewing: import_prop_types.default.bool.isRequired,
  /**
   * Set to `true` if the `day` is the start of a highlighted date range.
   */
  isStartOfHighlighting: import_prop_types.default.bool.isRequired,
  /**
   * Set to `true` if the `day` is the end of a highlighted date range.
   */
  isStartOfPreviewing: import_prop_types.default.bool.isRequired,
  /**
   * If `true`, day is outside of month and will be hidden.
   */
  outsideCurrentMonth: import_prop_types.default.bool.isRequired,
  /**
   * If `true`, renders as selected.
   * @default false
   */
  selected: import_prop_types.default.bool,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object])
} : void 0;
var DateRangePickerDay_default = React.memo(DateRangePickerDay, (prevProps, nextProps) => {
  return prevProps.isHighlighting === nextProps.isHighlighting && prevProps.isEndOfHighlighting === nextProps.isEndOfHighlighting && prevProps.isStartOfHighlighting === nextProps.isStartOfHighlighting && prevProps.isPreviewing === nextProps.isPreviewing && prevProps.isEndOfPreviewing === nextProps.isEndOfPreviewing && prevProps.isStartOfPreviewing === nextProps.isStartOfPreviewing && areDayPropsEqual(prevProps, nextProps);
});

// node_modules/@mui/lab/DateRangePicker/DateRangePickerInput.js
init_extends();
init_objectWithoutPropertiesLoose();
var React2 = __toESM(require_react());
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var _excluded2 = ["currentlySelectingRangeEnd", "disableOpenPicker", "endText", "onBlur", "onChange", "open", "openPicker", "rawValue", "rawValue", "readOnly", "renderInput", "setCurrentlySelectingRangeEnd", "startText", "TextFieldProps", "validationError"];
var DateRangePickerInputRoot = styled_default("div", {
  skipSx: true
})(({
  theme
}) => ({
  display: "flex",
  alignItems: "baseline",
  [theme.breakpoints.down("xs")]: {
    flexDirection: "column",
    alignItems: "center"
  }
}));
var DateRangePickerInput = React2.forwardRef(function DateRangePickerInput2(props, ref) {
  const {
    currentlySelectingRangeEnd,
    disableOpenPicker,
    endText,
    onBlur,
    onChange,
    open,
    openPicker,
    rawValue: [start, end],
    readOnly,
    renderInput,
    setCurrentlySelectingRangeEnd,
    startText,
    TextFieldProps,
    validationError: [startValidationError, endValidationError]
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded2);
  const utils = useUtils();
  const startRef = React2.useRef(null);
  const endRef = React2.useRef(null);
  const wrapperVariant = React2.useContext(WrapperVariantContext);
  React2.useEffect(() => {
    if (!open) {
      return;
    }
    if (currentlySelectingRangeEnd === "start") {
      var _startRef$current;
      (_startRef$current = startRef.current) == null ? void 0 : _startRef$current.focus();
    } else if (currentlySelectingRangeEnd === "end") {
      var _endRef$current;
      (_endRef$current = endRef.current) == null ? void 0 : _endRef$current.focus();
    }
  }, [currentlySelectingRangeEnd, open]);
  const lazyHandleChangeCallback = React2.useCallback((...args) => executeInTheNextEventLoopTick(() => onChange(...args)), [onChange]);
  const handleStartChange = (date, inputString) => {
    lazyHandleChangeCallback([date, utils.date(end)], inputString);
  };
  const handleEndChange = (date, inputString) => {
    lazyHandleChangeCallback([utils.date(start), date], inputString);
  };
  const openRangeStartSelection = () => {
    if (setCurrentlySelectingRangeEnd) {
      setCurrentlySelectingRangeEnd("start");
    }
    if (!readOnly && !disableOpenPicker) {
      openPicker();
    }
  };
  const openRangeEndSelection = () => {
    if (setCurrentlySelectingRangeEnd) {
      setCurrentlySelectingRangeEnd("end");
    }
    if (!readOnly && !disableOpenPicker) {
      openPicker();
    }
  };
  const openOnFocus = wrapperVariant === "desktop";
  const startInputProps = useMaskedInput(_extends({}, other, {
    readOnly,
    rawValue: start,
    onChange: handleStartChange,
    label: startText,
    validationError: startValidationError !== null,
    TextFieldProps: _extends({}, TextFieldProps, {
      ref: startRef,
      focused: open && currentlySelectingRangeEnd === "start"
    }),
    inputProps: {
      onClick: !openOnFocus ? openRangeStartSelection : void 0,
      onFocus: openOnFocus ? openRangeStartSelection : void 0
    }
  }));
  const endInputProps = useMaskedInput(_extends({}, other, {
    readOnly,
    label: endText,
    rawValue: end,
    onChange: handleEndChange,
    validationError: endValidationError !== null,
    TextFieldProps: _extends({}, TextFieldProps, {
      ref: endRef,
      focused: open && currentlySelectingRangeEnd === "end"
    }),
    inputProps: {
      onClick: !openOnFocus ? openRangeEndSelection : void 0,
      onFocus: openOnFocus ? openRangeEndSelection : void 0
    }
  }));
  return (0, import_jsx_runtime2.jsx)(DateRangePickerInputRoot, {
    onBlur,
    ref,
    children: renderInput(startInputProps, endInputProps)
  });
});
var DateRangePickerInput_default = DateRangePickerInput;

// node_modules/@mui/lab/DateRangePicker/DateRangePickerView.js
init_extends();
init_objectWithoutPropertiesLoose();
var React6 = __toESM(require_react());
var import_prop_types2 = __toESM(require_prop_types());

// node_modules/@mui/lab/DateRangePicker/date-range-manager.js
function calculateRangeChange({
  utils,
  range,
  newDate: selectedDate,
  currentlySelectingRangeEnd
}) {
  const [start, end] = range;
  if (currentlySelectingRangeEnd === "start") {
    return Boolean(end) && utils.isAfter(selectedDate, end) ? {
      nextSelection: "end",
      newRange: [selectedDate, null]
    } : {
      nextSelection: "end",
      newRange: [selectedDate, end]
    };
  }
  return Boolean(start) && utils.isBefore(selectedDate, start) ? {
    nextSelection: "end",
    newRange: [selectedDate, null]
  } : {
    nextSelection: "start",
    newRange: [start, selectedDate]
  };
}
function calculateRangePreview(options) {
  if (!options.newDate) {
    return [null, null];
  }
  const [start, end] = options.range;
  const {
    newRange
  } = calculateRangeChange(options);
  if (!start || !end) {
    return newRange;
  }
  const [previewStart, previewEnd] = newRange;
  return options.currentlySelectingRangeEnd === "end" ? [end, previewEnd] : [previewStart, start];
}

// node_modules/@mui/lab/DateRangePicker/DateRangePickerToolbar.js
var React3 = __toESM(require_react());
init_base();
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var _Typography;
var classes = generateUtilityClasses("PrivateDateRangePickerToolbar", ["penIcon"]);
var DateRangePickerToolbarRoot = styled_default(PickersToolbar_default, {
  skipSx: true
})({
  [`& .${classes.penIcon}`]: {
    position: "relative",
    top: 4
  }
});
var DateRangePickerToolbarContainer = styled_default("div", {
  skipSx: true
})({
  display: "flex"
});
var DateRangePickerToolbar = ({
  currentlySelectingRangeEnd,
  date: [start, end],
  endText,
  isMobileKeyboardViewOpen,
  setCurrentlySelectingRangeEnd,
  startText,
  toggleMobileKeyboardView,
  toolbarFormat,
  toolbarTitle = "Select date range"
}) => {
  const utils = useUtils();
  const startDateValue = start ? utils.formatByString(start, toolbarFormat || utils.formats.shortDate) : startText;
  const endDateValue = end ? utils.formatByString(end, toolbarFormat || utils.formats.shortDate) : endText;
  return (0, import_jsx_runtime3.jsx)(DateRangePickerToolbarRoot, {
    toolbarTitle,
    isMobileKeyboardViewOpen,
    toggleMobileKeyboardView,
    isLandscape: false,
    penIconClassName: classes.penIcon,
    children: (0, import_jsx_runtime4.jsxs)(DateRangePickerToolbarContainer, {
      children: [(0, import_jsx_runtime3.jsx)(PickersToolbarButton_default, {
        variant: start !== null ? "h5" : "h6",
        value: startDateValue,
        selected: currentlySelectingRangeEnd === "start",
        onClick: () => setCurrentlySelectingRangeEnd("start")
      }), _Typography || (_Typography = (0, import_jsx_runtime4.jsxs)(Typography_default, {
        variant: "h5",
        children: [" ", "–", " "]
      })), (0, import_jsx_runtime3.jsx)(PickersToolbarButton_default, {
        variant: end !== null ? "h5" : "h6",
        value: endDateValue,
        selected: currentlySelectingRangeEnd === "end",
        onClick: () => setCurrentlySelectingRangeEnd("end")
      })]
    })
  });
};
var DateRangePickerToolbar_default = DateRangePickerToolbar;

// node_modules/@mui/lab/DateRangePicker/DateRangePickerViewMobile.js
init_extends();
init_objectWithoutPropertiesLoose();
var React4 = __toESM(require_react());
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var import_jsx_runtime6 = __toESM(require_jsx_runtime());
var _excluded3 = ["changeMonth", "components", "componentsProps", "date", "leftArrowButtonText", "maxDate", "minDate", "onChange", "renderDay", "rightArrowButtonText"];
var onlyDayView = ["day"];
function DateRangePickerViewMobile(props) {
  const {
    changeMonth,
    components,
    componentsProps,
    date,
    leftArrowButtonText,
    maxDate: maxDateProp,
    minDate: minDateProp,
    onChange,
    renderDay = (_, dayProps) => (0, import_jsx_runtime5.jsx)(DateRangePickerDay_default, _extends({}, dayProps)),
    rightArrowButtonText
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded3);
  const utils = useUtils();
  const defaultDates = useDefaultDates();
  const minDate = minDateProp != null ? minDateProp : defaultDates.minDate;
  const maxDate = maxDateProp != null ? maxDateProp : defaultDates.maxDate;
  return (0, import_jsx_runtime6.jsxs)(React4.Fragment, {
    children: [(0, import_jsx_runtime5.jsx)(PickersCalendarHeader_default, _extends({
      components,
      componentsProps,
      leftArrowButtonText,
      maxDate,
      minDate,
      onMonthChange: changeMonth,
      openView: "day",
      rightArrowButtonText,
      views: onlyDayView
    }, other)), (0, import_jsx_runtime5.jsx)(PickersCalendar_default, _extends({}, other, {
      date,
      onChange,
      onFocusedDayChange: doNothing,
      renderDay: (day, _, DayProps) => renderDay(day, _extends({
        isPreviewing: false,
        isStartOfPreviewing: false,
        isEndOfPreviewing: false,
        isHighlighting: isWithinRange(utils, day, date),
        isStartOfHighlighting: isStartOfRange(utils, day, date),
        isEndOfHighlighting: isEndOfRange(utils, day, date)
      }, DayProps))
    }))]
  });
}

// node_modules/@mui/lab/DateRangePicker/DateRangePickerViewDesktop.js
init_extends();
init_objectWithoutPropertiesLoose();
var React5 = __toESM(require_react());
var import_jsx_runtime7 = __toESM(require_jsx_runtime());
var import_react = __toESM(require_react());
var import_jsx_runtime8 = __toESM(require_jsx_runtime());
var _excluded4 = ["calendars", "changeMonth", "components", "componentsProps", "currentlySelectingRangeEnd", "currentMonth", "date", "disableFuture", "disablePast", "leftArrowButtonText", "maxDate", "minDate", "onChange", "renderDay", "rightArrowButtonText"];
var DateRangePickerViewDesktopRoot = styled_default("div", {
  skipSx: true
})({
  display: "flex",
  flexDirection: "row"
});
var DateRangePickerViewDesktopContainer = styled_default("div", {
  skipSx: true
})(({
  theme
}) => ({
  "&:not(:last-of-type)": {
    borderRight: `2px solid ${theme.palette.divider}`
  }
}));
var DateRangePickerViewDesktopCalendar = styled_default(PickersCalendar_default, {
  skipSx: true
})({
  minWidth: 312,
  minHeight: 288
});
var DateRangePickerViewDesktopArrowSwitcher = styled_default(PickersArrowSwitcher_default, {
  skipSx: true
})({
  padding: "16px 16px 8px 16px",
  display: "flex",
  alignItems: "center",
  justifyContent: "space-between"
});
function getCalendarsArray(calendars) {
  switch (calendars) {
    case 1:
      return [0];
    case 2:
      return [0, 0];
    case 3:
      return [0, 0, 0];
    default:
      return new Array(calendars).fill(0);
  }
}
function DateRangePickerViewDesktop(props) {
  const {
    calendars,
    changeMonth,
    components,
    componentsProps,
    currentlySelectingRangeEnd,
    currentMonth,
    date,
    disableFuture,
    disablePast,
    leftArrowButtonText = "Previous month",
    maxDate: maxDateProp,
    minDate: minDateProp,
    onChange,
    renderDay = (_, dateRangeProps) => (0, import_jsx_runtime7.jsx)(DateRangePickerDay_default, _extends({}, dateRangeProps)),
    rightArrowButtonText = "Next month"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded4);
  const utils = useUtils();
  const defaultDates = useDefaultDates();
  const minDate = minDateProp != null ? minDateProp : defaultDates.minDate;
  const maxDate = maxDateProp != null ? maxDateProp : defaultDates.maxDate;
  const [rangePreviewDay, setRangePreviewDay] = React5.useState(null);
  const isNextMonthDisabled = useNextMonthDisabled(currentMonth, {
    disableFuture,
    maxDate
  });
  const isPreviousMonthDisabled = usePreviousMonthDisabled(currentMonth, {
    disablePast,
    minDate
  });
  const previewingRange = calculateRangePreview({
    utils,
    range: date,
    newDate: rangePreviewDay,
    currentlySelectingRangeEnd
  });
  const handleDayChange = React5.useCallback((day) => {
    setRangePreviewDay(null);
    onChange(day);
  }, [onChange]);
  const handlePreviewDayChange = (newPreviewRequest) => {
    if (!isWithinRange(utils, newPreviewRequest, date)) {
      setRangePreviewDay(newPreviewRequest);
    } else {
      setRangePreviewDay(null);
    }
  };
  const CalendarTransitionProps = React5.useMemo(() => ({
    onMouseLeave: () => setRangePreviewDay(null)
  }), []);
  const selectNextMonth = React5.useCallback(() => {
    changeMonth(utils.getNextMonth(currentMonth));
  }, [changeMonth, currentMonth, utils]);
  const selectPreviousMonth = React5.useCallback(() => {
    changeMonth(utils.getPreviousMonth(currentMonth));
  }, [changeMonth, currentMonth, utils]);
  return (0, import_jsx_runtime7.jsx)(DateRangePickerViewDesktopRoot, {
    children: getCalendarsArray(calendars).map((_, index) => {
      const monthOnIteration = utils.setMonth(currentMonth, utils.getMonth(currentMonth) + index);
      return (0, import_jsx_runtime8.jsxs)(DateRangePickerViewDesktopContainer, {
        children: [(0, import_jsx_runtime7.jsx)(DateRangePickerViewDesktopArrowSwitcher, {
          onLeftClick: selectPreviousMonth,
          onRightClick: selectNextMonth,
          isLeftHidden: index !== 0,
          isRightHidden: index !== calendars - 1,
          isLeftDisabled: isPreviousMonthDisabled,
          isRightDisabled: isNextMonthDisabled,
          leftArrowButtonText,
          components,
          componentsProps,
          rightArrowButtonText,
          children: utils.format(monthOnIteration, "monthAndYear")
        }), (0, import_react.createElement)(DateRangePickerViewDesktopCalendar, _extends({}, other, {
          key: index,
          date,
          onFocusedDayChange: doNothing,
          onChange: handleDayChange,
          currentMonth: monthOnIteration,
          TransitionProps: CalendarTransitionProps,
          renderDay: (day, __, DayProps) => renderDay(day, _extends({
            isPreviewing: isWithinRange(utils, day, previewingRange),
            isStartOfPreviewing: isStartOfRange(utils, day, previewingRange),
            isEndOfPreviewing: isEndOfRange(utils, day, previewingRange),
            isHighlighting: isWithinRange(utils, day, date),
            isStartOfHighlighting: isStartOfRange(utils, day, date),
            isEndOfHighlighting: isEndOfRange(utils, day, date),
            onMouseEnter: () => handlePreviewDayChange(day)
          }, DayProps))
        }))]
      }, index);
    })
  });
}
var DateRangePickerViewDesktop_default = DateRangePickerViewDesktop;

// node_modules/@mui/lab/DateRangePicker/DateRangePickerView.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime());
var import_jsx_runtime10 = __toESM(require_jsx_runtime());
var _excluded5 = ["calendars", "className", "currentlySelectingRangeEnd", "date", "DateInputProps", "defaultCalendarMonth", "disableAutoMonthSwitching", "disableFuture", "disableHighlightToday", "disablePast", "endText", "isMobileKeyboardViewOpen", "maxDate", "minDate", "onDateChange", "onMonthChange", "open", "reduceAnimations", "setCurrentlySelectingRangeEnd", "shouldDisableDate", "showToolbar", "startText", "toggleMobileKeyboardView", "toolbarFormat", "toolbarTitle"];
function DateRangePickerView(props) {
  const {
    calendars,
    className,
    currentlySelectingRangeEnd,
    date,
    DateInputProps,
    defaultCalendarMonth,
    disableAutoMonthSwitching = false,
    disableFuture,
    disableHighlightToday,
    disablePast,
    endText,
    isMobileKeyboardViewOpen,
    maxDate,
    minDate,
    onDateChange,
    onMonthChange,
    open,
    reduceAnimations = defaultReduceAnimations,
    setCurrentlySelectingRangeEnd,
    shouldDisableDate,
    showToolbar,
    startText,
    toggleMobileKeyboardView,
    toolbarFormat,
    toolbarTitle
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded5);
  const utils = useUtils();
  const wrapperVariant = React6.useContext(WrapperVariantContext);
  const [start, end] = date;
  const {
    changeMonth,
    calendarState,
    isDateDisabled,
    onMonthSwitchingAnimationEnd,
    changeFocusedDay
  } = useCalendarState({
    date: start || end,
    defaultCalendarMonth,
    disableFuture,
    disablePast,
    disableSwitchToMonthOnDayFocus: true,
    maxDate,
    minDate,
    onMonthChange,
    reduceAnimations,
    shouldDisableDate
  });
  const toShowToolbar = showToolbar != null ? showToolbar : wrapperVariant !== "desktop";
  const scrollToDayIfNeeded = (day) => {
    if (!day || !utils.isValid(day) || isDateDisabled(day)) {
      return;
    }
    const currentlySelectedDate = currentlySelectingRangeEnd === "start" ? start : end;
    if (currentlySelectedDate === null) {
      return;
    }
    const displayingMonthRange = wrapperVariant === "mobile" ? 0 : calendars - 1;
    const currentMonthNumber = utils.getMonth(calendarState.currentMonth);
    const requestedMonthNumber = utils.getMonth(day);
    if (!utils.isSameYear(calendarState.currentMonth, day) || requestedMonthNumber < currentMonthNumber || requestedMonthNumber > currentMonthNumber + displayingMonthRange) {
      const newMonth = currentlySelectingRangeEnd === "start" ? currentlySelectedDate : (
        // If need to focus end, scroll to the state when "end" is displaying in the last calendar
        utils.addMonths(currentlySelectedDate, -displayingMonthRange)
      );
      changeMonth(newMonth);
    }
  };
  React6.useEffect(() => {
    if (disableAutoMonthSwitching || !open) {
      return;
    }
    scrollToDayIfNeeded(currentlySelectingRangeEnd === "start" ? start : end);
  }, [currentlySelectingRangeEnd, date]);
  const handleChange = React6.useCallback((newDate) => {
    const {
      nextSelection,
      newRange
    } = calculateRangeChange({
      newDate,
      utils,
      range: date,
      currentlySelectingRangeEnd
    });
    setCurrentlySelectingRangeEnd(nextSelection);
    const isFullRangeSelected = currentlySelectingRangeEnd === "end" && isRangeValid(utils, newRange);
    onDateChange(newRange, wrapperVariant, isFullRangeSelected ? "finish" : "partial");
  }, [currentlySelectingRangeEnd, date, onDateChange, setCurrentlySelectingRangeEnd, utils, wrapperVariant]);
  const renderView = () => {
    const sharedCalendarProps = _extends({
      date,
      isDateDisabled,
      changeFocusedDay,
      onChange: handleChange,
      reduceAnimations,
      disableHighlightToday,
      onMonthSwitchingAnimationEnd,
      changeMonth,
      currentlySelectingRangeEnd,
      disableFuture,
      disablePast,
      minDate,
      maxDate
    }, calendarState, other);
    switch (wrapperVariant) {
      case "desktop": {
        return (0, import_jsx_runtime9.jsx)(DateRangePickerViewDesktop_default, _extends({
          calendars
        }, sharedCalendarProps));
      }
      default: {
        return (0, import_jsx_runtime9.jsx)(DateRangePickerViewMobile, _extends({}, sharedCalendarProps));
      }
    }
  };
  return (0, import_jsx_runtime10.jsxs)("div", {
    className,
    children: [toShowToolbar && (0, import_jsx_runtime9.jsx)(DateRangePickerToolbar_default, {
      date,
      isMobileKeyboardViewOpen,
      toggleMobileKeyboardView,
      currentlySelectingRangeEnd,
      setCurrentlySelectingRangeEnd,
      startText,
      endText,
      toolbarTitle,
      toolbarFormat
    }), isMobileKeyboardViewOpen ? (0, import_jsx_runtime9.jsx)(MobileKeyboardInputView, {
      children: (0, import_jsx_runtime9.jsx)(DateRangePickerInput_default, _extends({
        disableOpenPicker: true,
        ignoreInvalidInputs: true
      }, DateInputProps))
    }) : renderView()]
  });
}
true ? DateRangePickerView.propTypes = {
  calendars: import_prop_types2.default.oneOf([1, 2, 3]),
  disableAutoMonthSwitching: import_prop_types2.default.bool
} : void 0;

export {
  getDateRangePickerDayUtilityClass,
  dateRangePickerDayClasses,
  DateRangePickerDay_default,
  DateRangePickerInput_default,
  DateRangePickerView
};
//# sourceMappingURL=chunk-V3N6CN5L.js.map
