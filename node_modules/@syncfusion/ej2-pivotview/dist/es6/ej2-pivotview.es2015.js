import { Ajax, Browser, ChildProperty, Collection, Complex, Component, Draggable, Droppable, Event, EventHandler, Fetch, Internationalization, KeyboardEvents, L10n, NotifyPropertyChanges, Property, SanitizeHtmlHelper, Touch, addClass, append, closest, compile, createElement, detach, extend, formatUnit, getElement, getInstance, initializeCSPTemplate, isNullOrUndefined, prepend, remove, removeClass, select, selectAll, setStyleAttribute, setValue } from '@syncfusion/ej2-base';
import { DataManager, Deferred, Query } from '@syncfusion/ej2-data';
import { PdfBitmap, PdfBorders, PdfColor, PdfDocument, PdfFontFamily, PdfFontStyle, PdfGrid, PdfPageOrientation, PdfPageTemplateElement, PdfPen, PdfSolidBrush, PdfStandardFont, PdfStringFormat, PdfTextAlignment, PdfVerticalAlignment, PointF, RectangleF, SizeF } from '@syncfusion/ej2-pdf-export';
import { Dialog, Tooltip, createSpinner, hideSpinner, showSpinner } from '@syncfusion/ej2-popups';
import { ColumnChooser, CommandColumn, ContextMenu, Edit, ExcelExport, Freeze, Grid, Page, Pager, PdfExport, Reorder, Resize, Selection, Toolbar, VirtualScroll, getObject, headerRefreshed, setStyleAndAttributes } from '@syncfusion/ej2-grids';
import { Accordion, ContextMenu as ContextMenu$1, Menu, Tab, Toolbar as Toolbar$1, TreeView } from '@syncfusion/ej2-navigations';
import { ColorPicker, MaskedTextBox, NumericTextBox, TextBox } from '@syncfusion/ej2-inputs';
import { CheckBoxSelection, DropDownList, MultiSelect } from '@syncfusion/ej2-dropdowns';
import { DateTimePicker } from '@syncfusion/ej2-calendars';
import { DropDownButton } from '@syncfusion/ej2-splitbuttons';
import { Button, CheckBox, RadioButton } from '@syncfusion/ej2-buttons';
import { AccumulationChart, AccumulationDataLabel, AccumulationLegend, AccumulationTooltip, AreaSeries, BarSeries, BubbleSeries, Category, Chart, ColumnSeries, Crosshair, DataLabel, Export, FunnelSeries, Legend, LineSeries, MultiColoredAreaSeries, MultiColoredLineSeries, MultiLevelLabel, ParetoSeries, PieSeries, PolarSeries, PyramidSeries, RadarSeries, RangeAreaSeries, RangeColumnSeries, ScatterSeries, ScrollBar, Selection as Selection$1, SplineAreaSeries, SplineSeries, StackingAreaSeries, StackingBarSeries, StackingColumnSeries, StackingLineSeries, StepAreaSeries, StepLineSeries, StripLine, Tooltip as Tooltip$1, Zoom, getSeriesColor } from '@syncfusion/ej2-charts';
import { SvgRenderer } from '@syncfusion/ej2-svg-base';
import { Save } from '@syncfusion/ej2-file-utils';
import { Workbook } from '@syncfusion/ej2-excel-export';

/**
 * This is a file to perform common utility for OLAP and Relational datasource
 *
 * @hidden
 */
class PivotUtil {
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any
    static getType(value) {
        let val; // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const dateValue = new Date(value);
        if (typeof value === 'boolean') {
            val = 'boolean';
        }
        else if (!isNaN(Number(value))) {
            val = 'number';
        }
        else if (dateValue instanceof Date && !isNaN(dateValue.valueOf())) {
            val = (dateValue && dateValue.getDay() && (dateValue.getHours() > 0 || dateValue.getMinutes() > 0 ||
                dateValue.getSeconds() > 0 || dateValue.getMilliseconds() > 0) ? 'datetime' : 'date');
        }
        else {
            val = typeof (value);
        }
        return val;
    }
    static resetTime(date) {
        date.setHours(0, 0, 0, 0);
        return date;
    }
    static getClonedData(data) {
        const clonedData = [];
        if (data) {
            for (const item of data) { /* eslint-enable @typescript-eslint/ban-types */
                const fields = Object.keys(item);
                let keyPos = 0; // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const framedSet = {};
                while (keyPos < fields.length) {
                    framedSet[fields[keyPos]] = item[fields[keyPos]];
                    keyPos++;
                }
                clonedData.push(framedSet);
            }
        }
        return clonedData;
    }
    /* eslint-disable @typescript-eslint/no-explicit-any */
    static getDefinedObj(data) {
        let keyPos = 0;
        let framedSet = {}; /* eslint-enable @typescript-eslint/no-explicit-any */
        if (!(data === null || data === undefined)) {
            const fields = Object.keys(data);
            while (keyPos < fields.length) {
                if (!(data[fields[keyPos]] === null || data[fields[keyPos]] === undefined)) {
                    framedSet[fields[keyPos]] = data[fields[keyPos]];
                }
                keyPos++;
            }
        }
        else {
            framedSet = data;
        }
        return framedSet;
    }
    static inArray(value, collection) {
        if (collection) {
            for (let i = 0, cnt = collection.length; i < cnt; i++) {
                if (collection[i] === value) {
                    return i;
                }
            }
        }
        return -1;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
    static setPivotProperties(control, properties) {
        control.allowServerDataBinding = false;
        if (control.pivotGridModule) {
            control.pivotGridModule.allowServerDataBinding = false;
        }
        control.setProperties(properties, true);
        control.allowServerDataBinding = true;
        if (control.pivotGridModule) {
            control.pivotGridModule.allowServerDataBinding = true;
        }
    }
    static getClonedDataSourceSettings(dataSourceSettings) {
        const clonesDataSource = this.getDefinedObj({
            type: dataSourceSettings.type,
            catalog: dataSourceSettings.catalog,
            cube: dataSourceSettings.cube,
            providerType: dataSourceSettings.providerType,
            url: dataSourceSettings.url,
            localeIdentifier: dataSourceSettings.localeIdentifier,
            excludeFields: isNullOrUndefined(dataSourceSettings.excludeFields) ? [] : [...dataSourceSettings.excludeFields],
            expandAll: dataSourceSettings.expandAll,
            allowLabelFilter: dataSourceSettings.allowLabelFilter,
            allowValueFilter: dataSourceSettings.allowValueFilter,
            allowMemberFilter: dataSourceSettings.allowMemberFilter,
            enableSorting: dataSourceSettings.enableSorting ? true : false,
            rows: this.cloneFieldSettings(dataSourceSettings.rows),
            columns: this.cloneFieldSettings(dataSourceSettings.columns),
            filters: this.cloneFieldSettings(dataSourceSettings.filters),
            values: this.cloneFieldSettings(dataSourceSettings.values),
            filterSettings: this.cloneFilterSettings(dataSourceSettings.filterSettings),
            sortSettings: this.cloneSortSettings(dataSourceSettings.sortSettings),
            drilledMembers: this.cloneDrillMemberSettings(dataSourceSettings.drilledMembers),
            valueSortSettings: this.CloneValueSortObject(dataSourceSettings.valueSortSettings),
            valueAxis: dataSourceSettings.valueAxis,
            grandTotalsPosition: dataSourceSettings.grandTotalsPosition,
            formatSettings: this.cloneFormatSettings(dataSourceSettings.formatSettings),
            calculatedFieldSettings: this.cloneCalculatedFieldSettings(dataSourceSettings.calculatedFieldSettings),
            fieldMapping: this.cloneFieldSettings(dataSourceSettings.fieldMapping),
            showSubTotals: dataSourceSettings.showSubTotals,
            showRowSubTotals: dataSourceSettings.showRowSubTotals,
            showColumnSubTotals: dataSourceSettings.showColumnSubTotals,
            subTotalsPosition: dataSourceSettings.subTotalsPosition,
            showGrandTotals: dataSourceSettings.showGrandTotals,
            showRowGrandTotals: dataSourceSettings.showRowGrandTotals,
            showColumnGrandTotals: dataSourceSettings.showColumnGrandTotals,
            showHeaderWhenEmpty: dataSourceSettings.showHeaderWhenEmpty,
            alwaysShowValueHeader: dataSourceSettings.alwaysShowValueHeader,
            conditionalFormatSettings: this.cloneConditionalFormattingSettings(dataSourceSettings.conditionalFormatSettings),
            emptyCellsTextContent: dataSourceSettings.emptyCellsTextContent,
            groupSettings: this.cloneGroupSettings(dataSourceSettings.groupSettings),
            showAggregationOnValueField: dataSourceSettings.showAggregationOnValueField,
            authentication: this.CloneAuthenticationObject(dataSourceSettings.authentication)
        }); /* eslint-disable-line @typescript-eslint/no-explicit-any */
        return clonesDataSource;
    }
    static getClonedFieldList(fieldListObj) {
        const keys = Object.keys(fieldListObj);
        const clonedfieldlistObj = {};
        for (let i = 0, keysLength = keys.length; i < keysLength; i++) {
            const fieldlistObj = fieldListObj[keys[i]];
            if (fieldListObj[keys[i]]) {
                clonedfieldlistObj[keys[i]] = {
                    type: fieldlistObj.type,
                    caption: fieldlistObj.caption,
                    id: fieldlistObj.id,
                    isSelected: fieldlistObj.isSelected,
                    sort: fieldlistObj.sort,
                    filterType: fieldlistObj.filterType,
                    index: fieldlistObj.index,
                    filter: fieldlistObj.filter,
                    isCustomField: fieldlistObj.isCustomField,
                    showRemoveIcon: fieldlistObj.showRemoveIcon,
                    showFilterIcon: fieldlistObj.showFilterIcon,
                    showSortIcon: fieldlistObj.showSortIcon,
                    showNoDataItems: fieldlistObj.showNoDataItems,
                    isCalculatedField: fieldlistObj.isCalculatedField,
                    showEditIcon: fieldlistObj.showEditIcon,
                    showValueTypeIcon: fieldlistObj.showValueTypeIcon,
                    allowDragAndDrop: fieldlistObj.allowDragAndDrop,
                    showSubTotals: fieldlistObj.showSubTotals,
                    expandAll: fieldlistObj.expandAll,
                    pid: fieldlistObj.pid,
                    aggregateType: fieldlistObj.aggregateType,
                    baseField: fieldlistObj.baseField,
                    baseItem: fieldlistObj.baseItem,
                    dateMember: this.cloneDateMembers(fieldlistObj.dateMember),
                    formattedMembers: this.cloneFormatMembers(fieldlistObj.formattedMembers),
                    members: this.cloneFormatMembers(fieldlistObj.members),
                    formatString: fieldlistObj.formatString,
                    format: fieldlistObj.format,
                    formula: fieldlistObj.formula,
                    isExcelFilter: fieldlistObj.isExcelFilter,
                    membersOrder: (fieldlistObj.membersOrder ? [...fieldlistObj.membersOrder] :
                        fieldlistObj.membersOrder),
                    isAlphanumeric: fieldlistObj.isAlphanumeric,
                    tag: fieldlistObj.tag,
                    expanded: fieldlistObj.expanded,
                    spriteCssClass: fieldlistObj.spriteCssClass,
                    name: fieldlistObj.name,
                    defaultHierarchy: fieldlistObj.defaultHierarchy,
                    hasAllMember: fieldlistObj.hasAllMember,
                    allMember: fieldlistObj.allMember,
                    isChecked: fieldlistObj.isChecked,
                    filterMembers: this.cloneFieldMembers(fieldlistObj.filterMembers),
                    childMembers: this.cloneFieldMembers(fieldlistObj.childMembers),
                    searchMembers: this.cloneFieldMembers(fieldlistObj.searchMembers),
                    htmlAttributes: this.getDefinedObj(fieldlistObj.htmlAttributes),
                    currrentMembers: this.cloneFormatMembers(fieldlistObj.currrentMembers),
                    isHierarchy: fieldlistObj.isHierarchy,
                    isNamedSets: fieldlistObj.isNamedSets,
                    actualFilter: fieldlistObj.actualFilter ? [...fieldlistObj.actualFilter] : fieldlistObj.actualFilter,
                    levels: this.cloneFieldMembers(fieldlistObj.levels),
                    levelCount: fieldlistObj.levelCount,
                    fieldType: fieldlistObj.fieldType,
                    memberType: fieldlistObj.memberType,
                    parentHierarchy: fieldlistObj.parentHierarchy
                };
            }
        }
        return clonedfieldlistObj;
    }
    static cloneDateMembers(collection) {
        if (collection) {
            const clonedCollection = [];
            for (const set of collection) {
                clonedCollection.push({
                    formattedText: set.formattedText,
                    actualText: set.actualText
                });
            }
            return clonedCollection;
        }
        else {
            return collection;
        }
    }
    static cloneFormatMembers(collection) {
        if (collection) {
            const keys = Object.keys(collection);
            const clonedFormatMembers = {}; /* eslint-disable-line @typescript-eslint/no-explicit-any */
            for (let i = 0, keysLength = keys.length; i < keysLength; i++) {
                const cloneFormatMembersObj = collection[keys[i]];
                clonedFormatMembers[keys[i]] = {
                    index: cloneFormatMembersObj.index ? [...cloneFormatMembersObj.index] : cloneFormatMembersObj.index,
                    isDrilled: cloneFormatMembersObj.isDrilled,
                    ordinal: cloneFormatMembersObj.ordinal
                };
            }
            return clonedFormatMembers;
        }
        else {
            return collection;
        }
    }
    static cloneFieldMembers(collection) {
        if (collection) {
            const clonedCollection = [];
            for (const set of collection) {
                clonedCollection.push({
                    caption: set.caption,
                    hasChildren: set.hasChildren,
                    id: set.id,
                    isSelected: set.isSelected,
                    name: set.name,
                    tag: set.tag,
                    htmlAttributes: this.getDefinedObj(set.htmlAttributes),
                    type: set.type,
                    spriteCssClass: set.spriteCssClass,
                    pid: set.pid,
                    isChecked: set.isChecked
                });
            }
            return clonedCollection;
        }
        else {
            return collection;
        }
    }
    static updateDataSourceSettings(control, dataSourceSettings) {
        if (control) {
            this.setPivotProperties(control, {
                dataSourceSettings: this.getDefinedObj({
                    type: dataSourceSettings.type,
                    catalog: dataSourceSettings.catalog,
                    cube: dataSourceSettings.cube,
                    providerType: dataSourceSettings.providerType,
                    url: dataSourceSettings.url,
                    localeIdentifier: dataSourceSettings.localeIdentifier,
                    excludeFields: isNullOrUndefined(dataSourceSettings.excludeFields) ? [] : dataSourceSettings.excludeFields,
                    expandAll: dataSourceSettings.expandAll,
                    allowLabelFilter: dataSourceSettings.allowLabelFilter,
                    allowValueFilter: dataSourceSettings.allowValueFilter,
                    allowMemberFilter: dataSourceSettings.allowMemberFilter,
                    enableSorting: dataSourceSettings.enableSorting ? true : false,
                    rows: dataSourceSettings.rows,
                    columns: dataSourceSettings.columns,
                    filters: dataSourceSettings.filters,
                    values: dataSourceSettings.values,
                    filterSettings: dataSourceSettings.filterSettings,
                    sortSettings: dataSourceSettings.sortSettings,
                    drilledMembers: dataSourceSettings.drilledMembers,
                    valueSortSettings: dataSourceSettings.valueSortSettings,
                    valueAxis: dataSourceSettings.valueAxis,
                    grandTotalsPosition: dataSourceSettings.grandTotalsPosition,
                    formatSettings: dataSourceSettings.formatSettings,
                    calculatedFieldSettings: dataSourceSettings.calculatedFieldSettings,
                    fieldMapping: dataSourceSettings.fieldMapping,
                    showSubTotals: dataSourceSettings.showSubTotals,
                    showRowSubTotals: dataSourceSettings.showRowSubTotals,
                    showColumnSubTotals: dataSourceSettings.showColumnSubTotals,
                    subTotalsPosition: dataSourceSettings.subTotalsPosition,
                    showGrandTotals: dataSourceSettings.showGrandTotals,
                    showRowGrandTotals: dataSourceSettings.showRowGrandTotals,
                    showColumnGrandTotals: dataSourceSettings.showColumnGrandTotals,
                    showHeaderWhenEmpty: dataSourceSettings.showHeaderWhenEmpty,
                    alwaysShowValueHeader: dataSourceSettings.alwaysShowValueHeader,
                    conditionalFormatSettings: dataSourceSettings.conditionalFormatSettings,
                    emptyCellsTextContent: dataSourceSettings.emptyCellsTextContent,
                    groupSettings: dataSourceSettings.groupSettings,
                    showAggregationOnValueField: dataSourceSettings.showAggregationOnValueField,
                    authentication: this.CloneAuthenticationObject(dataSourceSettings.authentication)
                }) /* eslint-disable-line @typescript-eslint/no-explicit-any */
            });
        }
    }
    static cloneFieldSettings(collection) {
        if (collection) {
            const clonedCollection = [];
            for (const set of collection) {
                clonedCollection.push(this.getDefinedObj({
                    name: set.name,
                    caption: set.caption,
                    axis: set.axis,
                    baseField: set.baseField,
                    baseItem: set.baseItem,
                    isCalculatedField: set.isCalculatedField,
                    isNamedSet: set.isNamedSet,
                    showNoDataItems: set.showNoDataItems,
                    showSubTotals: set.showSubTotals,
                    type: set.type,
                    dataType: set.dataType,
                    showFilterIcon: set.showFilterIcon,
                    showSortIcon: set.showSortIcon,
                    showRemoveIcon: set.showRemoveIcon,
                    showValueTypeIcon: set.showValueTypeIcon,
                    showEditIcon: set.showEditIcon,
                    allowDragAndDrop: set.allowDragAndDrop,
                    expandAll: set.expandAll,
                    groupName: set.groupName
                })); /* eslint-disable-line @typescript-eslint/no-explicit-any */
            }
            return clonedCollection;
        }
        else {
            return collection;
        }
    }
    static cloneOlapFieldSettings(collection) {
        if (collection) {
            const clonedCollection = [];
            for (const set of collection) {
                clonedCollection.push(this.getDefinedObj({
                    caption: set.caption,
                    hasChildren: set.hasChildren,
                    id: set.id,
                    isSelected: set.isSelected,
                    name: set.name,
                    spriteCssClass: set.spriteCssClass,
                    tag: set.tag,
                    type: set.type,
                    pid: set.pid,
                    expanded: set.expanded,
                    defaultHierarchy: set.defaultHierarchy,
                    hasAllMember: set.hasAllMember,
                    allMember: set.allMember,
                    isChecked: set.isChecked,
                    filterMembers: set.filterMembers,
                    childMembers: set.childMembers,
                    searchMembers: set.searchMembers,
                    htmlAttributes: this.getDefinedObj(set.htmlAttributes),
                    currrentMembers: set.currrentMembers,
                    isHierarchy: set.isHierarchy,
                    isNamedSets: set.isNamedSets,
                    formatString: set.formatString,
                    actualFilter: set.actualFilter,
                    levels: set.levels,
                    levelCount: set.levelCount,
                    memberType: set.memberType,
                    fieldType: set.fieldType,
                    parentHierarchy: set.parentHierarchy
                })); /* eslint-disable-line @typescript-eslint/no-explicit-any */
            }
            return clonedCollection;
        }
        else {
            return collection;
        }
    }
    static cloneFilterSettings(collection) {
        if (collection) {
            const clonedCollection = [];
            for (const set of collection) {
                clonedCollection.push(this.getDefinedObj({
                    name: set.name,
                    type: set.type,
                    condition: set.condition,
                    items: set.items ? [...set.items] : set.items,
                    levelCount: set.levelCount,
                    measure: set.measure,
                    selectedField: set.selectedField,
                    showDateFilter: set.showDateFilter,
                    showLabelFilter: set.showLabelFilter,
                    showNumberFilter: set.showNumberFilter,
                    value1: set.value1,
                    value2: set.value2
                })); /* eslint-disable-line @typescript-eslint/no-explicit-any */
            }
            return clonedCollection;
        }
        else {
            return collection;
        }
    }
    static cloneSortSettings(collection) {
        if (collection) {
            const clonedCollection = [];
            for (const set of collection) {
                clonedCollection.push(this.getDefinedObj({
                    name: set.name,
                    order: set.order,
                    membersOrder: set.membersOrder ? [...set.membersOrder] : set.membersOrder
                })); /* eslint-disable-line @typescript-eslint/no-explicit-any */
            }
            return clonedCollection;
        }
        else {
            return collection;
        }
    }
    static cloneDrillMemberSettings(collection) {
        if (collection) {
            const clonedCollection = [];
            for (const set of collection) {
                clonedCollection.push(this.getDefinedObj({
                    name: set.name,
                    delimiter: set.delimiter,
                    items: set.items ? [...set.items] : set.items
                })); /* eslint-disable-line @typescript-eslint/no-explicit-any */
            }
            return clonedCollection;
        }
        else {
            return collection;
        }
    }
    static cloneFormatSettings(collection) {
        if (collection) {
            const clonedCollection = [];
            for (const set of collection) {
                clonedCollection.push(this.getDefinedObj({
                    name: set.name,
                    calendar: set.calendar,
                    currency: set.currency,
                    format: set.format,
                    maximumFractionDigits: set.maximumFractionDigits,
                    maximumSignificantDigits: set.maximumSignificantDigits,
                    minimumFractionDigits: set.minimumFractionDigits,
                    minimumIntegerDigits: set.minimumIntegerDigits,
                    minimumSignificantDigits: set.minimumSignificantDigits,
                    skeleton: set.skeleton,
                    type: set.type,
                    useGrouping: set.useGrouping
                })); /* eslint-disable-line @typescript-eslint/no-explicit-any */
            }
            return clonedCollection;
        }
        else {
            return collection;
        }
    }
    static CloneValueSortObject(collection) {
        if (collection) {
            const clonedCollection = {
                columnIndex: collection.columnIndex,
                headerDelimiter: collection.headerDelimiter,
                headerText: collection.headerText,
                measure: collection.measure,
                sortOrder: collection.sortOrder
            };
            return clonedCollection;
        }
        else {
            return collection;
        }
    }
    static CloneAuthenticationObject(collection) {
        if (collection) {
            const clonedCollection = {
                userName: collection.userName,
                password: collection.password
            };
            return clonedCollection;
        }
        else {
            return collection;
        }
    }
    static cloneCalculatedFieldSettings(collection) {
        if (collection) {
            const clonedCollection = [];
            for (const set of collection) {
                clonedCollection.push(this.getDefinedObj({
                    name: set.name,
                    formatString: set.formatString,
                    formula: set.formula,
                    hierarchyUniqueName: set.hierarchyUniqueName
                })); /* eslint-disable-line @typescript-eslint/no-explicit-any */
            }
            return clonedCollection;
        }
        else {
            return collection;
        }
    }
    static cloneConditionalFormattingSettings(collection) {
        if (collection) {
            const clonedCollection = [];
            for (const set of collection) {
                clonedCollection.push(this.getDefinedObj({
                    applyGrandTotals: set.applyGrandTotals,
                    conditions: set.conditions,
                    label: set.label,
                    measure: set.measure,
                    style: set.style ? {
                        backgroundColor: set.style.backgroundColor,
                        color: set.style.color,
                        fontFamily: set.style.fontFamily,
                        fontSize: set.style.fontSize
                    } : set.style,
                    value1: set.value1,
                    value2: set.value2
                })); /* eslint-disable-line @typescript-eslint/no-explicit-any */
            }
            return clonedCollection;
        }
        else {
            return collection;
        }
    }
    static cloneGroupSettings(collection) {
        if (collection) {
            const clonedCollection = [];
            for (const set of collection) {
                clonedCollection.push(this.getDefinedObj({
                    name: set.name,
                    caption: set.caption,
                    customGroups: this.cloneCustomGroups(set.customGroups),
                    endingAt: set.endingAt,
                    startingAt: set.startingAt,
                    groupInterval: set.groupInterval,
                    rangeInterval: set.rangeInterval,
                    type: set.type
                })); /* eslint-disable-line @typescript-eslint/no-explicit-any */
            }
            return clonedCollection;
        }
        else {
            return collection;
        }
    }
    static cloneCustomGroups(collection) {
        if (collection) {
            const clonedCollection = [];
            for (const set of collection) {
                clonedCollection.push(this.getDefinedObj({
                    groupName: set.groupName,
                    items: set.items ? [...set.items] : set.items
                })); /* eslint-disable-line @typescript-eslint/no-explicit-any */
            }
            return clonedCollection;
        }
        else {
            return collection;
        }
    }
    static getFilterItemByName(fieldName, fields) {
        const filterItems = new DataManager({ json: fields }).executeLocal(new Query().where('name', 'equal', fieldName));
        if (filterItems && filterItems.length > 0) {
            return filterItems[filterItems.length - 1];
        }
        return undefined;
    }
    // eslint-disable-next-line max-len
    static getFieldByName(fieldName, fields) {
        return new DataManager({ json: fields }).executeLocal(new Query().where('name', 'equal', fieldName))[0];
    }
    static getFieldInfo(fieldName, control, hasAllField) {
        if (!hasAllField) {
            const rows = this.cloneFieldSettings(control.dataSourceSettings.rows);
            const columns = this.cloneFieldSettings(control.dataSourceSettings.columns);
            const values = this.cloneFieldSettings(control.dataSourceSettings.values);
            const filters = this.cloneFieldSettings(control.dataSourceSettings.filters);
            const fields = [rows, columns, values, filters];
            for (let i = 0, len = fields.length; i < len; i++) {
                for (let j = 0, cnt = (fields[i] ? fields[i].length : 0); j < cnt; j++) {
                    if (fields[i][j] && fields[i][j].name === fieldName) {
                        return { fieldName: fieldName, fieldItem: fields[i][j], axis: i === 0 ? 'rows' : i === 1 ? 'columns' : i === 2 ? 'values' : 'filters', position: j };
                    }
                }
            }
        }
        const fieldList = control.dataType === 'olap' ?
            control.olapEngineModule.fieldList[fieldName] : control.engineModule.fieldList[fieldName];
        const fieldItem = (fieldList ? {
            name: fieldName,
            caption: fieldList.caption,
            baseField: fieldList.baseField,
            baseItem: fieldList.baseItem,
            isCalculatedField: fieldList.isCalculatedField,
            isNamedSet: fieldList.isNamedSets,
            showNoDataItems: fieldList.showNoDataItems,
            showSubTotals: fieldList.showSubTotals,
            type: fieldList.aggregateType,
            showFilterIcon: fieldList.showFilterIcon,
            showSortIcon: fieldList.showSortIcon,
            showRemoveIcon: fieldList.showRemoveIcon,
            showValueTypeIcon: fieldList.showValueTypeIcon,
            showEditIcon: fieldList.showEditIcon,
            allowDragAndDrop: fieldList.allowDragAndDrop,
            expandAll: fieldList.expandAll
        } : undefined);
        return { fieldName: fieldName, fieldItem: fieldItem, axis: 'fieldlist', position: -1 };
    }
    // eslint-disable-next-line max-len
    static isButtonIconRefesh(prop, oldProp, newProp) {
        let isButtonRefresh = false;
        try {
            if (prop === 'dataSourceSettings' && oldProp.dataSourceSettings && newProp.dataSourceSettings) {
                const propValidation = ['notAvail', 'notAvail', 'notAvail', 'notAvail'];
                const oldAxesProp = Object.keys(oldProp.dataSourceSettings);
                const newAxesProp = Object.keys(newProp.dataSourceSettings);
                if (oldAxesProp && newAxesProp && newAxesProp.length > 0 && oldAxesProp.length === newAxesProp.length) {
                    const axes = ['rows', 'columns', 'values', 'filters']; /* eslint-disable @typescript-eslint/no-explicit-any */
                    for (let i = 0; i < newAxesProp.length; i++) {
                        const oldAxis = (newAxesProp[i] in oldProp.dataSourceSettings &&
                            !isNullOrUndefined(oldProp.dataSourceSettings[newAxesProp[i]])) ?
                            Object.keys(oldProp.dataSourceSettings[newAxesProp[i]]) : [];
                        const newAxis = (newAxesProp[i] in newProp.dataSourceSettings &&
                            !isNullOrUndefined(newProp.dataSourceSettings[newAxesProp[i]])) ?
                            Object.keys(newProp.dataSourceSettings[newAxesProp[i]]) : [];
                        if (axes.indexOf(newAxesProp[i]) !== -1 && axes.indexOf(oldAxesProp[i]) !== -1 &&
                            oldAxis && newAxis && newAxis.length > 0 && oldAxis.length === newAxis.length) {
                            const options = ['showFilterIcon', 'showSortIcon', 'showRemoveIcon', 'showValueTypeIcon', 'showEditIcon', 'allowDragAndDrop', 'expandAll'];
                            for (let j = 0; j < newAxis.length; j++) {
                                const oldAxisProp = Object.keys(oldProp.dataSourceSettings[newAxesProp[i]][newAxis[j]]);
                                const newAxisProp = Object.keys(newProp.dataSourceSettings[newAxesProp[i]][newAxis[j]]);
                                for (let k = 0; k < newAxisProp.length; k++) { /* eslint-enable @typescript-eslint/no-explicit-any */
                                    if (options.indexOf(newAxisProp[k]) !== -1 &&
                                        options.indexOf(oldAxisProp[k]) !== -1) {
                                        propValidation[i] = 'update';
                                    }
                                    else {
                                        propValidation[i] = 'break';
                                        break;
                                    }
                                }
                                if (propValidation[i] === 'break') {
                                    break;
                                }
                            }
                        }
                        else {
                            propValidation[i] = 'break';
                        }
                        if (propValidation[i] === 'break') {
                            break;
                        }
                    }
                    /* eslint-enable @typescript-eslint/no-explicit-any */
                }
                let a = 0;
                let b = 0;
                let c = 0;
                for (const validation of propValidation) {
                    if (validation === 'break') {
                        a++;
                    }
                    if (validation === 'notAvail') {
                        b++;
                    }
                    if (validation === 'update') {
                        c++;
                    }
                }
                isButtonRefresh = (a > 0 || b === 4) ? false : (a === 0 && b < 4 && c > 0);
            }
        }
        catch (exception) {
            isButtonRefresh = false;
        }
        return isButtonRefresh;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
    static formatPivotValues(pivotValues) {
        const values = [];
        for (let i = 0; i < pivotValues.length; i++) {
            if (pivotValues[i]) {
                values[i] = [];
                for (let j = 0; j < pivotValues[i].length; j++) {
                    if (pivotValues[i][j]) {
                        values[i][j] = {
                            axis: pivotValues[i][j].Axis,
                            actualText: pivotValues[i][j].ActualText,
                            indexObject: pivotValues[i][j].IndexObject,
                            index: pivotValues[i][j].Index,
                            rowHeaders: pivotValues[i][j].RowHeaders,
                            columnHeaders: pivotValues[i][j].ColumnHeaders,
                            formattedText: pivotValues[i][j].FormattedText,
                            actualValue: pivotValues[i][j].ActualValue,
                            rowIndex: pivotValues[i][j].RowIndex,
                            colIndex: pivotValues[i][j].ColIndex,
                            colSpan: pivotValues[i][j].ColSpan,
                            level: pivotValues[i][j].Level,
                            rowSpan: pivotValues[i][j].RowSpan,
                            isSum: pivotValues[i][j].IsSum,
                            isGrandSum: pivotValues[i][j].IsGrandSum,
                            valueSort: pivotValues[i][j].ValueSort,
                            ordinal: pivotValues[i][j].Ordinal,
                            hasChild: pivotValues[i][j].HasChild,
                            isDrilled: pivotValues[i][j].IsDrilled,
                            value: pivotValues[i][j].Value,
                            type: pivotValues[i][j].Type,
                            members: pivotValues[i][j].Members
                        };
                    }
                }
            }
        }
        return values;
    }
    /* eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types */
    static formatFieldList(fieldList) {
        const keys = Object.keys(fieldList);
        const fList = {}; /* eslint-disable-line @typescript-eslint/no-explicit-any */
        for (let i = 0; i < keys.length; i++) {
            if (fieldList[keys[i]]) {
                fList[keys[i]] = {
                    id: fieldList[keys[i]].Id,
                    caption: fieldList[keys[i]].Caption,
                    type: fieldList[keys[i]].Type,
                    formatString: fieldList[keys[i]].FormatString,
                    index: fieldList[keys[i]].Index,
                    members: fieldList[keys[i]].Members,
                    formattedMembers: fieldList[keys[i]].FormattedMembers,
                    dateMember: fieldList[keys[i]].DateMember,
                    filter: fieldList[keys[i]].Filter,
                    sort: fieldList[keys[i]].Sort,
                    aggregateType: fieldList[keys[i]].AggregateType,
                    baseField: fieldList[keys[i]].BaseField,
                    baseItem: fieldList[keys[i]].BaseItem,
                    filterType: fieldList[keys[i]].FilterType,
                    format: fieldList[keys[i]].Format,
                    formula: fieldList[keys[i]].Formula,
                    isSelected: fieldList[keys[i]].IsSelected,
                    isExcelFilter: fieldList[keys[i]].IsExcelFilter,
                    showNoDataItems: fieldList[keys[i]].ShowNoDataItems,
                    isCustomField: fieldList[keys[i]].IsCustomField,
                    showFilterIcon: fieldList[keys[i]].ShowFilterIcon,
                    showSortIcon: fieldList[keys[i]].ShowSortIcon,
                    showRemoveIcon: fieldList[keys[i]].ShowRemoveIcon,
                    showEditIcon: fieldList[keys[i]].ShowEditIcon,
                    showValueTypeIcon: fieldList[keys[i]].ShowValueTypeIcon,
                    allowDragAndDrop: fieldList[keys[i]].AllowDragAndDrop,
                    isCalculatedField: fieldList[keys[i]].IsCalculatedField,
                    showSubTotals: fieldList[keys[i]].ShowSubTotals,
                    expandAll: fieldList[keys[i]].expandAll,
                    groupName: fieldList[keys[i]].groupName
                };
            }
        }
        return fList;
    }
    static frameContent(pivotValues, type, rowPosition, control) {
        const dataContent = [];
        const pivot = control;
        if (pivot.dataSourceSettings.values.length > 0 && !pivot.engineModule.isEmptyData) {
            if ((pivot.enableValueSorting) || !pivot.engineModule.isEngineUpdated) {
                let rowCnt = 0;
                const start = type === 'value' ? rowPosition : 0;
                const end = type === 'value' ? pivotValues.length : rowPosition;
                for (let rCnt = start; rCnt < end; rCnt++) {
                    if (pivotValues[rCnt]) {
                        rowCnt = type === 'header' ? rCnt : rowCnt;
                        dataContent[rowCnt] = {};
                        for (let cCnt = 0; cCnt < pivotValues[rCnt].length; cCnt++) {
                            if (pivotValues[rCnt][cCnt]) {
                                dataContent[rowCnt][cCnt] = pivotValues[rCnt][cCnt];
                            }
                        }
                        rowCnt++;
                    }
                }
            }
        }
        return dataContent;
    }
    static getLocalizedObject(control) {
        const locale = new Object(); /* eslint-enable @typescript-eslint/ban-types */
        /* eslint-disable @typescript-eslint/no-explicit-any */
        locale['Null'] = control.localeObj.getConstant('null');
        locale['Years'] = control.localeObj.getConstant('Years');
        locale['Quarters'] = control.localeObj.getConstant('Quarters');
        locale['Months'] = control.localeObj.getConstant('Months');
        locale['Days'] = control.localeObj.getConstant('Days');
        locale['Hours'] = control.localeObj.getConstant('Hours');
        locale['Minutes'] = control.localeObj.getConstant('Minutes');
        locale['Seconds'] = control.localeObj.getConstant('Seconds');
        locale['QuarterYear'] = control.localeObj.getConstant('QuarterYear');
        locale['Of'] = control.localeObj.getConstant('of');
        locale['Qtr'] = control.localeObj.getConstant('qtr');
        locale['Undefined'] = control.localeObj.getConstant('undefined');
        locale['GroupOutOfRange'] = control.localeObj.getConstant('groupOutOfRange');
        locale['Group'] = control.localeObj.getConstant('group');
        return locale; /* eslint-enable @typescript-eslint/no-explicit-any */
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
    static updateReport(control, report) {
        control.setProperties({ dataSourceSettings: { rows: [] } }, true);
        control.setProperties({ dataSourceSettings: { columns: [] } }, true);
        control.setProperties({ dataSourceSettings: { formatSettings: [] } }, true);
        for (let i = 0; i < report.Rows.length; i++) {
            control.dataSourceSettings.rows.push({
                name: report.Rows[i].Name,
                caption: report.Rows[i].Caption,
                showNoDataItems: report.Rows[i].ShowNoDataItems,
                baseField: report.Rows[i].BaseField,
                baseItem: report.Rows[i].BaseItem,
                showFilterIcon: report.Rows[i].ShowFilterIcon,
                showSortIcon: report.Rows[i].ShowSortIcon,
                showEditIcon: report.Rows[i].ShowEditIcon,
                showRemoveIcon: report.Rows[i].ShowRemoveIcon,
                showSubTotals: report.Rows[i].ShowValueTypeIcon,
                allowDragAndDrop: report.Rows[i].AllowDragAndDrop,
                axis: report.Rows[i].Axis,
                dataType: report.Rows[i].DataType,
                isCalculatedField: report.Rows[i].IsCalculatedField,
                showValueTypeIcon: report.Rows[i].ShowValueTypeIcon,
                type: report.Rows[i].Type,
                expandAll: report.Rows[i].expandAll
            });
        }
        for (let i = 0; i < report.Columns.length; i++) {
            control.dataSourceSettings.columns.push({
                name: report.Columns[i].Name,
                caption: report.Columns[i].Caption,
                showNoDataItems: report.Columns[i].ShowNoDataItems,
                baseField: report.Columns[i].BaseField,
                baseItem: report.Columns[i].BaseItem,
                showFilterIcon: report.Columns[i].ShowFilterIcon,
                showSortIcon: report.Columns[i].ShowSortIcon,
                showEditIcon: report.Columns[i].ShowEditIcon,
                showRemoveIcon: report.Columns[i].ShowRemoveIcon,
                showSubTotals: report.Columns[i].ShowValueTypeIcon,
                allowDragAndDrop: report.Columns[i].AllowDragAndDrop,
                axis: report.Columns[i].Axis,
                dataType: report.Columns[i].DataType,
                isCalculatedField: report.Columns[i].IsCalculatedField,
                showValueTypeIcon: report.Columns[i].ShowValueTypeIcon,
                type: report.Columns[i].Type,
                expandAll: report.Columns[i].expandAll
            });
        }
        for (let i = 0; i < report.FormatSettings.length; i++) {
            control.dataSourceSettings.formatSettings.push({
                name: report.FormatSettings[i].Name,
                format: report.FormatSettings[i].Format,
                type: report.FormatSettings[i].Type,
                currency: report.FormatSettings[i].Currency,
                maximumFractionDigits: report.FormatSettings[i].MaximumFractionDigits,
                maximumSignificantDigits: report.FormatSettings[i].MaximumSignificantDigits,
                minimumFractionDigits: report.FormatSettings[i].MinimumFractionDigits,
                minimumIntegerDigits: report.FormatSettings[i].MinimumIntegerDigits,
                minimumSignificantDigits: report.FormatSettings[i].MinimumSignificantDigits,
                skeleton: report.FormatSettings[i].Skeleton,
                useGrouping: report.FormatSettings[i].UseGrouping
            });
        }
    }
    static generateUUID() {
        let d = new Date().getTime();
        let d2 = (performance && performance.now && (performance.now() * 1000)) || 0;
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
            let r = Math.random() * 16;
            if (d > 0) {
                r = (d + r) % 16 | 0;
                d = Math.floor(d / 16);
            }
            else {
                r = (d2 + r) % 16 | 0;
                d2 = Math.floor(d2 / 16);
            }
            return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
        });
    }
    /**
     * It performing the Custom Sorting.
     *
     * @param {HeadersSortEventArgs} sortDetails - It contains the sort Details.
     * @param {IAxisSet[]} sortMembersOrder - It contains the sort Members Order.
     * @param {string | boolean} type - It contains the type.
     * @param {boolean} hasMembersOrder - It contains the has Members Order.
     * @param {boolean} isOlap - It contains the isOlap.
     * @returns {IAxisSet[]} - It returns the sorted data as IAxisSet[].
     * @hidden
     */
    static applyCustomSort(sortDetails, sortMembersOrder, type, hasMembersOrder, isOlap) {
        let grandTotal;
        let order = [];
        if (sortDetails.IsOrderChanged) {
            order = sortDetails.members;
        }
        else {
            order = (sortDetails.sortOrder === 'Ascending' || sortDetails.sortOrder === 'None' || sortDetails.sortOrder === undefined) ? [].concat(sortDetails.members) : [].concat(sortDetails.members).reverse();
        }
        const updatedMembers = [];
        const isNormalType = type === undefined || type === 'string' || type === 'number';
        if (sortMembersOrder[0].actualText === 'Grand Total') {
            grandTotal = sortMembersOrder[0];
            sortMembersOrder.shift();
        }
        for (let i = 0, j = 0; i < sortMembersOrder.length; i++) {
            const member = sortMembersOrder[i];
            const sortText = isOlap ? member.formattedText : isNormalType ? member.actualText :
                type === true ? member.actualText.toString() : member.dateText;
            if (order[j] === sortText) {
                sortMembersOrder.splice(j++, 0, member);
                sortMembersOrder.splice(++i, 1);
                if (j < order.length) {
                    i = -1;
                }
                else {
                    if (!hasMembersOrder) {
                        updatedMembers.splice(--j, 0, sortText);
                    }
                    break;
                }
            }
            if (i >= 0 && !hasMembersOrder) {
                updatedMembers[i] = sortText;
            }
        }
        if (!hasMembersOrder) {
            for (let i = updatedMembers.length; i < sortMembersOrder.length; i++) {
                const member = sortMembersOrder[i];
                const sortText = isOlap ? member.formattedText : isNormalType ? member.actualText :
                    type === true ? member.actualText.toString() : member.dateText;
                updatedMembers[i] = sortText;
            }
            if (updatedMembers[updatedMembers.length - 1] === 'Grand Total') {
                updatedMembers.pop();
            }
            sortDetails.members = updatedMembers;
        }
        if (grandTotal) {
            sortMembersOrder.splice(0, 0, grandTotal);
        }
        return sortMembersOrder;
    }
    /**
     * It performs to returnssorted headers.
     *
     * @param {IAxisSet[]} sortMembersOrder - It contains the sort members order.
     * @param {string} sortOrder - It contains the sort order.
     * @param {string | boolean} type - It contains the type.
     * @returns {IAxisSet[]} - It returns the sorted data as IAxisSet[].
     * @hidden
     */
    static applyHeadersSort(sortMembersOrder, sortOrder, type) {
        if (type === 'datetime' || type === 'date' || type === 'time') {
            sortMembersOrder = sortOrder === 'Ascending' ?
                (sortMembersOrder.sort((a, b) => (a.dateText > b.dateText) ? 1 :
                    ((b.dateText > a.dateText) ? -1 : 0))) : sortOrder === 'Descending' ?
                (sortMembersOrder.sort((a, b) => (a.dateText < b.dateText) ? 1 :
                    ((b.dateText < a.dateText) ? -1 : 0))) : sortMembersOrder;
        }
        else if (type === true) {
            sortMembersOrder = sortOrder === 'Ascending' ?
                (sortMembersOrder.sort((a, b) => (a.actualText === 'Grand Total' || b.actualText === 'Grand Total') ? 0 : (a.actualText === 'Out of Range') ? 1 : (b.actualText === 'Out of Range') ? -1 : (Number(a.actualText.toString().match(/\d+/)) > Number(b.actualText.toString().match(/\d+/))) ? 1 : ((Number(b.actualText.toString().match(/\d+/)) > Number(a.actualText.toString().match(/\d+/))) ? -1 : 0))) :
                sortOrder === 'Descending' ?
                    (sortMembersOrder.sort((a, b) => (a.actualText === 'Grand Total' || b.actualText === 'Grand Total') ? 0 : (a.actualText === 'Out of Range') ? -1 : (b.actualText === 'Out of Range') ? 1 : (Number(a.actualText.toString().match(/\d+/)) < Number(b.actualText.toString().match(/\d+/))) ? 1 : ((Number(b.actualText.toString().match(/\d+/)) < Number(a.actualText.toString().match(/\d+/))) ? -1 : 0))) :
                    sortMembersOrder;
        }
        else {
            sortMembersOrder = sortOrder === 'Ascending' ?
                (sortMembersOrder.sort(function (a, b) { return (a.actualText === 'Grand Total' || b.actualText === 'Grand Total') ? 0 : ((a.actualText > b.actualText) ? 1 : ((b.actualText > a.actualText) ? -1 : 0)); })) :
                sortOrder === 'Descending' ?
                    (sortMembersOrder.sort(function (a, b) { return (a.actualText === 'Grand Total' || b.actualText === 'Grand Total') ? 0 : ((a.actualText < b.actualText) ? 1 : ((b.actualText < a.actualText) ? -1 : 0)); })) :
                    sortMembersOrder;
        }
        return sortMembersOrder;
    }
    /**
     *
     * @param {any} header - It contains the value of header
     * @returns {IAxisSet} - It frame Header With Keys
     * @hidden */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
    static frameHeaderWithKeys(header) {
        const keys = Object.keys(header);
        let keyPos = 0; // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const framedHeader = {};
        while (keyPos < keys.length) {
            framedHeader[keys[keyPos]] = header[keys[keyPos]];
            keyPos++;
        }
        return framedHeader;
    }
    /**
     *
     * @param {PdfPageSize} pageSize - It contains the value of page Size
     * @returns {SizeF} - It returns the value as SizeF
     * @hidden */
    static getPageSize(pageSize) {
        switch (pageSize) {
            case 'Letter':
                return new SizeF(612, 792);
            case 'Note':
                return new SizeF(540, 720);
            case 'Legal':
                return new SizeF(612, 1008);
            case 'A0':
                return new SizeF(2380, 3368);
            case 'A1':
                return new SizeF(1684, 2380);
            case 'A2':
                return new SizeF(1190, 1684);
            case 'A3':
                return new SizeF(842, 1190);
            case 'A5':
                return new SizeF(421, 595);
            case 'A6':
                return new SizeF(297, 421);
            case 'A7':
                return new SizeF(210, 297);
            case 'A8':
                return new SizeF(148, 210);
            case 'A9':
                return new SizeF(105, 148);
            case 'B0':
                return new SizeF(2836, 4008);
            case 'B1':
                return new SizeF(2004, 2836);
            case 'B2':
                return new SizeF(1418, 2004);
            case 'B3':
                return new SizeF(1002, 1418);
            case 'B4':
                return new SizeF(709, 1002);
            case 'B5':
                return new SizeF(501, 709);
            case 'Archa':
                return new SizeF(648, 864);
            case 'Archb':
                return new SizeF(864, 1296);
            case 'Archc':
                return new SizeF(1296, 1728);
            case 'Archd':
                return new SizeF(1728, 2592);
            case 'Arche':
                return new SizeF(2592, 3456);
            case 'Flsa':
                return new SizeF(612, 936);
            case 'HalfLetter':
                return new SizeF(396, 612);
            case 'Letter11x17':
                return new SizeF(792, 1224);
            case 'Ledger':
                return new SizeF(1224, 792);
            default:
                return new SizeF(595, 842);
        }
    }
}

/**
 * PivotEngine is used to manipulate the relational or Multi-Dimensional data as pivoting values.
 */
/** @hidden */
class PivotEngine {
    constructor() {
        /** @hidden */
        this.aggregatedValueMatrix = [];
        /** @hidden */
        this.valueContent = [];
        /** @hidden */
        this.formatFields = {};
        /** @hidden */
        this.groupingFieldsInfo = {};
        /** @hidden */
        this.dateFormatFunction = {};
        /** @hidden */
        this.calculatedFields = {};
        /** @hidden */
        this.calculatedFormulas = {};
        /** @hidden */
        this.valueAxis = 0;
        /** @hidden */
        this.saveDataHeaders = {};
        /** @hidden */
        this.columnCount = 0;
        /** @hidden */
        this.rowCount = 0;
        /** @hidden */
        this.columnPageCount = 0;
        /** @hidden */
        this.rowPageCount = 0;
        /** @hidden */
        this.colFirstLvl = 0;
        /** @hidden */
        this.rowFirstLvl = 0;
        /** @hidden */
        this.rowStartPos = 0;
        /** @hidden */
        this.colStartPos = 0;
        /** @hidden */
        this.enableValueSorting = false;
        /** @hidden */
        this.headerCollection = { rowHeaders: [], columnHeaders: [], rowHeadersCount: 0, columnHeadersCount: 0 };
        /** @hidden */
        this.rMembers = [];
        /** @hidden */
        this.cMembers = [];
        /** @hidden */
        this.groupingFields = {};
        /** @hidden */
        this.isLastHeaderHasMeasures = true;
        /** @hidden */
        this.measureIndex = -1;
        /** @hidden */
        this.isPagingOrVirtualizationEnabled = false;
        /** @hidden */
        this.valueMatrix = [];
        /** @hidden */
        this.indexMatrix = [];
        this.memberCnt = -1;
        this.pageInLimit = false;
        this.endPos = 0;
        this.removeCount = 0;
        this.colHdrBufferCalculated = false;
        this.colValuesLength = 1;
        this.rowValuesLength = 1;
        this.slicedHeaders = [];
        this.fieldFilterMem = {};
        this.filterPosObj = {};
        this.selectedHeaders = { selectedHeader: [], values: [] };
        this.rowGrandTotal = null;
        this.columnGrandTotal = null;
        this.removeRowGrandTotal = false;
        this.removeColumnGrandTotal = false;
        this.isValueHasAdvancedAggregate = false;
        this.rawIndexObject = {};
        this.valueAxisFields = {};
        this.reformAxisCount = 0;
        this.isEditing = false;
        /** @hidden */
        this.data = [];
        /** @hidden */
        this.actualData = [];
        /** @hidden */
        this.groupRawIndex = {};
        /** @hidden */
        this.fieldKeys = {};
        this.allowDataCompression = false;
        this.dataSourceSettings = {};
        this.frameHeaderObjectsCollection = false;
        this.headerObjectsCollection = {};
        this.columnKeys = {};
        this.fieldDrillCollection = {}; // eslint-disable-next-line security/detect-unsafe-regex
        this.formatRegex = /(^[ncpae]{1})([0-1]?[0-9]|20)?$/i;
        this.measureNames = {};
        this.enablePaging = false;
        this.enableVirtualization = false;
        this.enableHtmlSanitizer = false;
        this.isParentLevelAdded = true;
        /* private makeMirrorObject(elements: number[], obj: NumberIndex): void {
             for (let lp: number = 0, end: number = elements.length; lp < end; lp++) {
                 obj[elements[lp]] = elements[lp];
             }
         } */
    }
    /**
     * It is used to clear properties.
     *
     * @returns {void}
     * @hidden
     */
    clearProperties() {
        if (!this.isPagingOrVirtualizationEnabled) {
            this.columnKeys = {};
            this.headerCollection = { rowHeaders: [], columnHeaders: [], rowHeadersCount: 0, columnHeadersCount: 0 };
        }
        this.aggregatedValueMatrix = [];
        if (this.enableValueSorting) {
            this.valueContent = [];
        }
        this.saveDataHeaders = {};
        this.rMembers = [];
        this.cMembers = [];
        this.slicedHeaders = [];
        this.fieldFilterMem = {};
        this.filterPosObj = {};
        this.selectedHeaders = { selectedHeader: [], values: [] };
        this.rowGrandTotal = null;
        this.columnGrandTotal = null;
        this.rawIndexObject = {};
        if (this.dataSourceSettings.valueIndex > -1) {
            this.valueAxisFields = {};
        }
        this.headerObjectsCollection = {};
        this.fieldDrillCollection = {};
    }
    /**
     * It is used to render the pivot engine.
     *
     * @param {IDataOptions} dataSource -  It contains the dataSourceSettings.
     * @param {ICustomProperties} customProperties -  It contains the custom Properties.
     * @param {Function} fn - It contains aggreagateCellnInfo method.
     * @param {Function} onHeadersSort -  It contains onHeaderSort method.
     * @returns {void}
     * @hidden
     */
    renderEngine(dataSource, customProperties, fn, onHeadersSort) {
        this.getValueCellInfo = fn;
        this.getHeaderSortInfo = onHeadersSort;
        this.formatFields = {};
        this.dateFormatFunction = {};
        this.calculatedFields = {};
        this.calculatedFormulas = {};
        this.valueAxis = 0;
        this.saveDataHeaders = {};
        this.columnCount = 0;
        this.rowCount = 0;
        this.columnPageCount = 0;
        this.rowPageCount = 0;
        this.colFirstLvl = 0;
        this.rowFirstLvl = 0;
        this.rowStartPos = 0;
        this.colStartPos = 0;
        this.dataSourceSettings.excludeFields = isNullOrUndefined(dataSource.excludeFields) ? [] : dataSource.excludeFields;
        this.enableValueSorting = false;
        this.headerCollection = { rowHeaders: [], columnHeaders: [], rowHeadersCount: 0, columnHeadersCount: 0 };
        this.valueMatrix = [];
        this.indexMatrix = [];
        this.aggregatedValueMatrix = [];
        this.rMembers = [];
        this.cMembers = [];
        this.memberCnt = -1;
        this.pageInLimit = false;
        this.endPos = 0;
        this.removeCount = 0;
        this.colHdrBufferCalculated = false;
        this.colValuesLength = 1;
        this.rowValuesLength = 1;
        this.slicedHeaders = [];
        this.fieldFilterMem = {};
        this.filterPosObj = {};
        this.selectedHeaders = { selectedHeader: [], values: [] };
        this.rowGrandTotal = null;
        this.columnGrandTotal = null;
        this.removeRowGrandTotal = false;
        this.removeColumnGrandTotal = false;
        this.isValueHasAdvancedAggregate = false;
        this.rawIndexObject = {};
        this.isLastHeaderHasMeasures = true;
        this.isEditing = false;
        let fields;
        this.globalize = (customProperties && customProperties.globalize) ? customProperties.globalize : new Internationalization();
        this.currencyCode = (customProperties && customProperties.currenyCode) ? customProperties.currenyCode : undefined;
        this.localeObj = customProperties ? customProperties.localeObj : undefined;
        this.fieldsType = customProperties ? customProperties.fieldsType : {};
        this.clonedReport = customProperties ? (customProperties.clonedReport &&
            customProperties.clonedReport.properties ?
            customProperties.clonedReport.properties :
            customProperties.clonedReport) : {};
        this.enablePaging = customProperties.enablePaging;
        this.enableVirtualization = customProperties.enableVirtualization;
        this.enableHtmlSanitizer = customProperties.enableHtmlSanitizer;
        this.isPagingOrVirtualizationEnabled = this.enablePaging || this.enableVirtualization;
        this.enableSort = dataSource.enableSorting;
        this.dataSourceSettings.alwaysShowValueHeader = dataSource.alwaysShowValueHeader; // eslint-disable-next-line max-len
        this.dataSourceSettings.showHeaderWhenEmpty = isNullOrUndefined(dataSource.showHeaderWhenEmpty) ? true : dataSource.showHeaderWhenEmpty;
        this.dataSourceSettings.showSubTotals = isNullOrUndefined(dataSource.showSubTotals) ? true : dataSource.showSubTotals;
        this.dataSourceSettings.showRowSubTotals = isNullOrUndefined(dataSource.showRowSubTotals) ? true : dataSource.showRowSubTotals; // eslint-disable-next-line max-len
        this.dataSourceSettings.showColumnSubTotals = isNullOrUndefined(dataSource.showColumnSubTotals) ? true : dataSource.showColumnSubTotals;
        this.dataSourceSettings.showGrandTotals = isNullOrUndefined(dataSource.showGrandTotals) ? true : dataSource.showGrandTotals;
        this.dataSourceSettings.grandTotalsPosition = isNullOrUndefined(dataSource.grandTotalsPosition) ? 'Bottom' : dataSource.grandTotalsPosition; // eslint-disable-next-line max-len
        this.dataSourceSettings.showRowGrandTotals = isNullOrUndefined(dataSource.showRowGrandTotals) ? true : dataSource.showRowGrandTotals; // eslint-disable-next-line max-len
        this.dataSourceSettings.showColumnGrandTotals = isNullOrUndefined(dataSource.showColumnGrandTotals) ? true : dataSource.showColumnGrandTotals;
        this.showSubTotalsAtTop = this.dataSourceSettings.showSubTotals && this.dataSourceSettings.showColumnSubTotals && dataSource.subTotalsPosition === 'Top';
        this.showSubTotalsAtBottom = this.dataSourceSettings.showSubTotals && this.dataSourceSettings.showRowSubTotals && dataSource.subTotalsPosition === 'Bottom';
        this.allowValueFilter = dataSource.allowValueFilter;
        this.isValueFilterEnabled = false;
        this.enableValueSorting = customProperties ? customProperties.enableValueSorting : false;
        this.isDrillThrough = customProperties ? (customProperties.isDrillThrough ? customProperties.isDrillThrough : false) : false;
        this.valueContent = [];
        this.dataSourceSettings = PivotUtil.getClonedDataSourceSettings(dataSource);
        if (!(dataSource.dataSource instanceof DataManager)) {
            this.data = dataSource.dataSource;
        }
        if (this.data && this.data[0]) {
            if (!this.fieldList) {
                if (dataSource.type === 'CSV') {
                    this.fields = this.data.shift();
                }
                else {
                    this.fields = Object.keys(this.data[0]);
                }
                for (let i = 0; i < this.fields.length; i++) {
                    this.fieldKeys[this.fields[i]] = dataSource.type === 'CSV' ? i : this.fields[i];
                }
            }
            if (customProperties && customProperties.pageSettings && customProperties.allowDataCompression) {
                this.actualData = this.data;
                this.data = this.getGroupedRawData(dataSource);
            }
            this.dataSourceSettings.rows = dataSource.rows ? dataSource.rows : [];
            this.dataSourceSettings.columns = dataSource.columns ? dataSource.columns : [];
            this.dataSourceSettings.filters = dataSource.filters ? dataSource.filters : [];
            this.dataSourceSettings.values = dataSource.values ? dataSource.values : [];
            this.dataSourceSettings.formatSettings = dataSource.formatSettings ? dataSource.formatSettings : [];
            this.dataSourceSettings.groupSettings = dataSource.groupSettings ? dataSource.groupSettings : [];
            this.dataSourceSettings.calculatedFieldSettings = dataSource.calculatedFieldSettings ? dataSource.calculatedFieldSettings : [];
            this.enableSort = dataSource.enableSorting === undefined ? true : dataSource.enableSorting;
            this.dataSourceSettings.fieldMapping = dataSource.fieldMapping ? dataSource.fieldMapping : [];
            for (const value of this.dataSourceSettings.values) {
                this.valueAxisFields[value.name] = value;
            }
            fields = this.getGroupData(this.data);
            for (let i = 0; i < this.fields.length; i++) {
                this.fieldKeys[this.fields[i]] = dataSource.type === 'CSV' ? i : this.fields[i];
            }
            this.validateFilters(dataSource);
            this.isExpandAll = (this.isValueFiltersAvail && dataSource.allowValueFilter) ? true : dataSource.expandAll;
            this.drilledMembers =
                dataSource.drilledMembers ? (this.isValueFiltersAvail && dataSource.allowValueFilter) ? [] : dataSource.drilledMembers : [];
            this.isMultiMeasures = this.dataSourceSettings.values.length > 1 ? true : false;
            this.valueAxis = dataSource.valueAxis === 'row' ? 1 : 0;
            this.measureIndex = !isNullOrUndefined(dataSource.valueIndex) ? dataSource.valueIndex : -1;
            this.emptyCellTextContent = dataSource.emptyCellsTextContent ? dataSource.emptyCellsTextContent : '';
            this.rowValuesLength = this.valueAxis === 1 ? this.dataSourceSettings.values.length : 1;
            this.colValuesLength = this.valueAxis === 0 ? this.dataSourceSettings.values.length : 1;
            this.valueSortSettings = dataSource.valueSortSettings ||
                { sortOrder: 'None', headerDelimiter: '.', headerText: '', columnIndex: undefined };
            this.valueSortData = [];
            this.pageSettings = customProperties ? (customProperties.pageSettings ? customProperties.pageSettings : this.pageSettings)
                : undefined;
            this.allowDataCompression = customProperties && customProperties.allowDataCompression;
            this.savedFieldList = customProperties ? customProperties.savedFieldList : undefined;
            this.getFieldList(fields, this.enableSort, dataSource.allowValueFilter);
            this.removeIrrelevantFields(Object.keys(this.fieldList));
            this.fillFieldMembers(this.data, this.indexMatrix);
            this.updateSortSettings(dataSource.sortSettings, this.enableSort);
            this.valueMatrix = this.generateValueMatrix(this.data);
            this.filterMembers = [];
            let columnLength = this.dataSourceSettings.columns.length - 1;
            this.columnKeys = {};
            while (columnLength > -1) { // eslint-disable-next-line max-len
                this.columnKeys[this.dataSourceSettings.columns[columnLength].name] = this.dataSourceSettings.columns[columnLength];
                columnLength--;
            }
            this.updateFilterMembers(dataSource);
            this.generateGridData(dataSource);
        }
    }
    removeIrrelevantFields(fields) {
        const report = {};
        report[0] = this.dataSourceSettings.rows;
        report[1] = this.dataSourceSettings.columns;
        report[2] = this.dataSourceSettings.values;
        report[3] = this.dataSourceSettings.filters;
        let pos = 0;
        while (pos < 4) {
            if (report[pos]) {
                for (let cnt = 0; cnt < report[pos].length; cnt++) {
                    const fieldName = report[pos][cnt].name; // eslint-disable-next-line max-len
                    if ((this.dataSourceSettings.excludeFields.indexOf(fieldName) > -1) || (!isNullOrUndefined(fields) && fields.indexOf(fieldName) === -1)) {
                        report[pos].splice(cnt, 1);
                        cnt--;
                    }
                    else if (pos === 2) {
                        this.measureNames[fieldName] =
                            report[pos][cnt].caption ? report[pos][cnt].caption : fieldName;
                        this.measureNames[report[pos][cnt].caption ?
                            report[pos][cnt].caption : fieldName] = fieldName;
                    }
                }
            }
            pos++;
        }
        this.isMultiMeasures = this.dataSourceSettings.values.length > 1 ? true : false;
        this.measureIndex = this.measureIndex === -1 ? (this.valueAxis ? report[0].length : report[1].length) : this.measureIndex;
    }
    updateDataSourceSettings(dataSource, requireDatasourceUpdate) {
        if (requireDatasourceUpdate) {
            this.emptyCellTextContent = dataSource.emptyCellsTextContent ? dataSource.emptyCellsTextContent : '';
            this.valueAxis = dataSource.valueAxis === 'row' ? 1 : 0;
            this.rowValuesLength = this.valueAxis === 1 ? this.dataSourceSettings.values.length : 1;
            this.colValuesLength = this.valueAxis === 0 ? this.dataSourceSettings.values.length : 1;
            this.measureIndex = !isNullOrUndefined(dataSource.valueIndex) ? dataSource.valueIndex : -1;
            this.enableSort = dataSource.enableSorting;
            this.dataSourceSettings.alwaysShowValueHeader = dataSource.alwaysShowValueHeader; // eslint-disable-next-line max-len
            this.dataSourceSettings.showHeaderWhenEmpty = isNullOrUndefined(dataSource.showHeaderWhenEmpty) ? true : dataSource.showHeaderWhenEmpty;
            this.dataSourceSettings.showSubTotals = isNullOrUndefined(dataSource.showSubTotals) ? true : dataSource.showSubTotals;
            this.dataSourceSettings.showRowSubTotals = isNullOrUndefined(dataSource.showRowSubTotals) ? true : dataSource.showRowSubTotals; // eslint-disable-next-line max-len
            this.dataSourceSettings.showColumnSubTotals = isNullOrUndefined(dataSource.showColumnSubTotals) ? true : dataSource.showColumnSubTotals;
            this.dataSourceSettings.showGrandTotals = isNullOrUndefined(dataSource.showGrandTotals) ? true : dataSource.showGrandTotals;
            this.dataSourceSettings.grandTotalsPosition = isNullOrUndefined(dataSource.grandTotalsPosition) ? 'Bottom' : dataSource.grandTotalsPosition; // eslint-disable-next-line max-len
            this.dataSourceSettings.showRowGrandTotals = isNullOrUndefined(dataSource.showRowGrandTotals) ? true : dataSource.showRowGrandTotals; // eslint-disable-next-line max-len
            this.dataSourceSettings.showColumnGrandTotals = isNullOrUndefined(dataSource.showColumnGrandTotals) ? true : dataSource.showColumnGrandTotals;
            this.showSubTotalsAtTop = this.dataSourceSettings.showSubTotals && dataSource.subTotalsPosition === 'Top' && dataSource.showColumnSubTotals;
            this.showSubTotalsAtBottom = this.dataSourceSettings.showSubTotals && dataSource.subTotalsPosition === 'Bottom' && dataSource.showRowSubTotals;
            this.allowValueFilter = dataSource.allowValueFilter;
            this.dataSourceSettings.formatSettings = dataSource.formatSettings ? dataSource.formatSettings : [];
            this.dataSourceSettings.groupSettings = dataSource.groupSettings ? dataSource.groupSettings : [];
            this.dataSourceSettings.calculatedFieldSettings = dataSource.calculatedFieldSettings ? dataSource.calculatedFieldSettings : [];
            this.enableSort = dataSource.enableSorting === undefined ? true : dataSource.enableSorting;
            this.dataSourceSettings.fieldMapping = dataSource.fieldMapping ? dataSource.fieldMapping : [];
            this.removeIrrelevantFields(Object.keys(this.fieldList));
        }
    }
    getGroupedRawData(dataSourceSettings) {
        this.data = [];
        for (const data of this.actualData) { // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this.data[this.data.length] = PivotUtil.frameHeaderWithKeys(data);
        }
        const countFields = dataSourceSettings.values.filter((item) => {
            return item.type === 'Count' || item.type === 'DistinctCount';
        }).map((item) => { return item.name; });
        const hasCountField = countFields.length > 0;
        const realData = this.data;
        const headerFields = dataSourceSettings.rows.concat(dataSourceSettings.columns.concat(dataSourceSettings.filters)).map((item) => {
            return item.name;
        });
        const groupRawData = {};
        const finalData = [];
        this.groupRawIndex = {};
        const groupKeys = {};
        let indexLength = 0;
        /* eslint-disable @typescript-eslint/no-explicit-any */
        for (let i = 0; i < realData.length; i++) {
            const currData = realData[i];
            const members = [];
            if (hasCountField) {
                for (let vPos = 0; vPos < countFields.length; vPos++) {
                    currData[this.fieldKeys[countFields[vPos]]] =
                        isNullOrUndefined(currData[this.fieldKeys[countFields[vPos]]]) ?
                            currData[this.fieldKeys[countFields[vPos]]] : 1;
                }
            }
            for (let hPos = 0; hPos < headerFields.length; hPos++) {
                members.push(currData[this.fieldKeys[headerFields[hPos]]]);
            }
            const memberJoin = members.join('-');
            if (groupRawData[memberJoin]) {
                for (let vPos = 0; vPos < dataSourceSettings.values.length; vPos++) {
                    const currFieldName = dataSourceSettings.values[vPos].name;
                    const currValue = currData[this.fieldKeys[currFieldName]];
                    const savedData = groupRawData[memberJoin];
                    let summType = dataSourceSettings.values[vPos].type;
                    if (!isNullOrUndefined(currValue)) {
                        if (typeof currValue !== 'number' || summType === 'DistinctCount') {
                            summType = 'Count';
                        }
                        if (isNullOrUndefined(savedData[currFieldName])) {
                            savedData[currFieldName] = summType === 'Product' ? 1 : ((summType === 'Min' || summType === 'Max')
                                ? undefined : 0);
                        }
                        else if (typeof savedData[currFieldName] !== 'number') {
                            savedData[currFieldName] = 1;
                        }
                        if (summType === 'Count') {
                            savedData[currFieldName] += 1;
                        }
                        else if (summType === 'Min') {
                            if (!isNullOrUndefined(savedData[currFieldName])) {
                                savedData[currFieldName] = savedData[currFieldName] > currValue ?
                                    currValue : savedData[currFieldName];
                            }
                        }
                        else if (summType === 'Max') {
                            if (!isNullOrUndefined(savedData[currFieldName])) {
                                savedData[currFieldName] = savedData[currFieldName] < currValue ?
                                    currValue : savedData[currFieldName];
                            }
                        }
                        else if (summType === 'Product') {
                            savedData[currFieldName] *= currValue;
                        }
                        else {
                            savedData[currFieldName] += currValue;
                        }
                    }
                }
                if (this.isDrillThrough) {
                    this.groupRawIndex[groupKeys[memberJoin]].push(i);
                }
            }
            else {
                groupRawData[memberJoin] = currData;
                finalData.push(currData);
                if (this.isDrillThrough) {
                    this.groupRawIndex[indexLength] = [i];
                    groupKeys[memberJoin] = indexLength;
                    indexLength++;
                }
            }
        } /* eslint-enable @typescript-eslint/no-explicit-any */
        return finalData;
    }
    getGroupData(data) {
        let fieldkeySet = data[0];
        for (const group of this.dataSourceSettings.groupSettings) {
            const fieldName = group.name;
            const caption = group.caption;
            if (this.fields.indexOf(fieldName) > -1) {
                const groupFields = {};
                let customGroupFieldName;
                if ((group.type === 'Date' && this.groupingFields[fieldName]) ||
                    (group.type === 'Custom' && this.groupingFields[fieldName])) {
                    return fieldkeySet;
                }
                else if (group.type === 'Number') {
                    if (PivotUtil.getType(fieldkeySet[fieldName]) === 'number' ||
                        !this.groupingFields[fieldName]) {
                        /* eslint-disable @typescript-eslint/no-explicit-any */
                        if (group.rangeInterval) {
                            data.sort((a, b) => (Number(a[this.fieldKeys[fieldName]]) >
                                Number(b[this.fieldKeys[fieldName]])) ? 1 :
                                ((Number(b[this.fieldKeys[fieldName]]) >
                                    Number(a[this.fieldKeys[fieldName]])) ? -1 : 0));
                        } /* eslint-enable @typescript-eslint/no-explicit-any */
                    }
                    else {
                        return fieldkeySet;
                    }
                }
                // else if (group.type === 'Custom' && this.fields.indexOf(fieldName + '_custom_group') > -1) {
                //     return fieldkeySet;
                // }
                let len = data.length;
                while (len--) {
                    const item = data[len]; // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    if (item[this.fieldKeys[fieldName]] && group.type === 'Date') { // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        const date = new Date(item[this.fieldKeys[fieldName]].toString());
                        if (!isNullOrUndefined(date) && group.groupInterval.length > 0) {
                            for (let i = 0, len = group.groupInterval.length; i < len; i++) {
                                const interval = group.groupInterval[i];
                                const isInRangeAvail = this.getRange(group, date.getTime());
                                const newDate = PivotUtil.resetTime(new Date());
                                switch (interval) {
                                    case 'Years':
                                        {
                                            const newFieldName = (i === group.groupInterval.length - 1) ? fieldName :
                                                fieldName + '_date_group_years';
                                            groupFields[newFieldName] = interval;
                                            this.fieldKeys[newFieldName] = this.dataSourceSettings.type === 'CSV' ?
                                                (this.fieldKeys[newFieldName] ? this.fieldKeys[newFieldName] :
                                                    this.fields.length) : newFieldName;
                                            if (this.fields.indexOf(newFieldName) === -1) {
                                                this.fields.push(newFieldName);
                                            } // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                            item[this.fieldKeys[newFieldName]] = (isInRangeAvail ? undefined :
                                                new Date(newDate.setFullYear(date.getFullYear())).toString());
                                        }
                                        break;
                                    case 'Quarters':
                                        {
                                            const newFieldName = (i === group.groupInterval.length - 1) ? fieldName :
                                                fieldName + '_date_group_quarters';
                                            groupFields[newFieldName] = interval;
                                            const month = Math.ceil((date.getMonth() + 1) / 3);
                                            this.fieldKeys[newFieldName] = this.dataSourceSettings.type === 'CSV' ?
                                                (this.fieldKeys[newFieldName] ? this.fieldKeys[newFieldName] :
                                                    this.fields.length) : newFieldName;
                                            if (this.fields.indexOf(newFieldName) === -1) {
                                                this.fields.push(newFieldName);
                                            } // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                            item[this.fieldKeys[newFieldName]] = (isInRangeAvail ? undefined :
                                                ((this.localeObj ? this.localeObj.getConstant('qtr') : 'Qtr') + month.toString()));
                                        }
                                        break;
                                    case 'QuarterYear':
                                        {
                                            const newFieldName = (i === group.groupInterval.length - 1) ? fieldName :
                                                fieldName + '_date_group_quarterYear';
                                            groupFields[newFieldName] = interval;
                                            const month = Math.ceil((date.getMonth() + 1) / 3);
                                            this.fieldKeys[newFieldName] = this.dataSourceSettings.type === 'CSV' ?
                                                (this.fieldKeys[newFieldName] ? this.fieldKeys[newFieldName] :
                                                    this.fields.length) : newFieldName;
                                            if (this.fields.indexOf(newFieldName) === -1) {
                                                this.fields.push(newFieldName);
                                            } // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                            item[this.fieldKeys[newFieldName]] = (isInRangeAvail ? undefined :
                                                ((this.localeObj ? this.localeObj.getConstant('qtr') : 'Qtr') + month.toString() + ' '
                                                    + (this.localeObj ? this.localeObj.getConstant('of') : 'of') + ' '
                                                    + date.getFullYear().toString()));
                                        }
                                        break;
                                    case 'Months':
                                        {
                                            const newFieldName = (i === group.groupInterval.length - 1) ? fieldName :
                                                fieldName + '_date_group_months';
                                            groupFields[newFieldName] = interval;
                                            this.fieldKeys[newFieldName] = this.dataSourceSettings.type === 'CSV' ?
                                                (this.fieldKeys[newFieldName] ? this.fieldKeys[newFieldName] :
                                                    this.fields.length) : newFieldName;
                                            if (this.fields.indexOf(newFieldName) === -1) {
                                                this.fields.push(newFieldName);
                                            } // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                            item[this.fieldKeys[newFieldName]] = (isInRangeAvail ? undefined :
                                                new Date(newDate.setMonth(date.getMonth(), 1)).toString());
                                        }
                                        break;
                                    case 'Days':
                                        {
                                            const newFieldName = (i === group.groupInterval.length - 1) ? fieldName :
                                                fieldName + '_date_group_days';
                                            groupFields[newFieldName] = interval;
                                            this.fieldKeys[newFieldName] = this.dataSourceSettings.type === 'CSV' ?
                                                (this.fieldKeys[newFieldName] ? this.fieldKeys[newFieldName] :
                                                    this.fields.length) : newFieldName;
                                            if (this.fields.indexOf(newFieldName) === -1) {
                                                this.fields.push(newFieldName);
                                            } // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                            item[this.fieldKeys[newFieldName]] = (isInRangeAvail ? undefined :
                                                new Date(newDate.setMonth(date.getMonth(), date.getDate())).toString());
                                        }
                                        break;
                                    case 'Hours':
                                        {
                                            const newFieldName = (i === group.groupInterval.length - 1) ? fieldName :
                                                fieldName + '_date_group_hours';
                                            groupFields[newFieldName] = interval;
                                            this.fieldKeys[newFieldName] = this.dataSourceSettings.type === 'CSV' ?
                                                (this.fieldKeys[newFieldName] ? this.fieldKeys[newFieldName] :
                                                    this.fields.length) : newFieldName;
                                            if (this.fields.indexOf(newFieldName) === -1) {
                                                this.fields.push(newFieldName);
                                            } // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                            item[this.fieldKeys[newFieldName]] = (isInRangeAvail ? undefined :
                                                new Date(newDate.setHours(date.getHours())).toString());
                                        }
                                        break;
                                    case 'Minutes':
                                        {
                                            const newFieldName = (i === group.groupInterval.length - 1) ? fieldName :
                                                fieldName + '_date_group_minutes';
                                            groupFields[newFieldName] = interval;
                                            this.fieldKeys[newFieldName] = this.dataSourceSettings.type === 'CSV' ?
                                                (this.fieldKeys[newFieldName] ? this.fieldKeys[newFieldName] :
                                                    this.fields.length) : newFieldName;
                                            if (this.fields.indexOf(newFieldName) === -1) {
                                                this.fields.push(newFieldName);
                                            } // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                            item[this.fieldKeys[newFieldName]] = (isInRangeAvail ? undefined :
                                                new Date(newDate.setMinutes(date.getMinutes())).toString());
                                        }
                                        break;
                                    case 'Seconds':
                                        {
                                            const newFieldName = (i === group.groupInterval.length - 1) ? fieldName :
                                                fieldName + '_date_group_seconds';
                                            groupFields[newFieldName] = interval;
                                            this.fieldKeys[newFieldName] = this.dataSourceSettings.type === 'CSV' ?
                                                (this.fieldKeys[newFieldName] ? this.fieldKeys[newFieldName] :
                                                    this.fields.length) : newFieldName;
                                            if (this.fields.indexOf(newFieldName) === -1) {
                                                this.fields.push(newFieldName);
                                            } // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                            item[this.fieldKeys[newFieldName]] = (isInRangeAvail ? undefined :
                                                new Date(newDate.setSeconds(date.getSeconds())).toString());
                                        }
                                        break;
                                }
                            }
                        } /* eslint-disable @typescript-eslint/no-explicit-any */
                    }
                    else if (!isNaN(Number(item[this.fieldKeys[fieldName]])) && group.type === 'Number') {
                        const isInRangeAvail = this.getRange(group, Number(item[this.fieldKeys[fieldName]]));
                        item[this.fieldKeys[fieldName]] = isInRangeAvail ? undefined :
                            item[this.fieldKeys[fieldName]];
                    }
                    else if (item[this.fieldKeys[fieldName]] && group.type === 'Custom' &&
                        group.customGroups && group.customGroups.length > 0) {
                        const newFieldName = fieldName + '_custom_group';
                        const customGroups = group.customGroups;
                        let groupValue;
                        this.groupingFieldsInfo[fieldName] = fieldName;
                        this.groupingFieldsInfo[newFieldName] = fieldName;
                        for (let i = 0, len = customGroups.length; i < len; i++) {
                            const cGroup = customGroups[i];
                            if (cGroup.items && cGroup.items.length > 1) {
                                customGroupFieldName = newFieldName;
                                this.fieldKeys[newFieldName] = this.dataSourceSettings.type === 'CSV' ?
                                    (this.fieldKeys[newFieldName] ? this.fieldKeys[newFieldName] :
                                        this.fields.length) : newFieldName;
                                if (this.fields.indexOf(newFieldName) === -1) {
                                    this.fields.push(newFieldName);
                                }
                                const isDataMatch = PivotUtil.inArray(item[this.fieldKeys[fieldName]].toString(), cGroup.items) === -1 ?
                                    false : true;
                                item[this.fieldKeys[newFieldName]] =
                                    (isDataMatch ? (cGroup.groupName && cGroup.groupName !== '') ? cGroup.groupName :
                                        this.localeObj.getConstant('group') + ' ' + i :
                                        (groupValue && groupValue !== item[this.fieldKeys[fieldName]].toString()) ?
                                            groupValue : item[this.fieldKeys[fieldName]].toString());
                                groupValue = item[this.fieldKeys[newFieldName]];
                            }
                        }
                    } /* eslint-enable @typescript-eslint/no-explicit-any */
                    const keys = Object.keys(item);
                    const isCompleteSet = [];
                    for (const key of keys) {
                        isCompleteSet.push((item[key]) ? true : false);
                    }
                    fieldkeySet =
                        (((isCompleteSet.indexOf(false) === -1) && keys.length === Object.keys(data[0]).length) ? item : fieldkeySet);
                    //this.fields = Object.keys(fieldkeySet);
                }
                if (group.type === 'Date') {
                    let isDataSource = false; // eslint-disable-next-line max-len
                    const axisFields = [this.dataSourceSettings.rows, this.dataSourceSettings.columns, this.dataSourceSettings.values, this.dataSourceSettings.filters];
                    const groupKeys = Object.keys(groupFields);
                    let gCnt = Object.keys(groupKeys).length;
                    let groupField;
                    for (const axis of axisFields) {
                        if (!isDataSource && axis) {
                            const cnt = axis.length;
                            let i = 0;
                            while (i < cnt) {
                                if (axis[i].name === fieldName) {
                                    isDataSource = true;
                                    const actualField = axis[i];
                                    axis.splice(i, 1);
                                    let dataFields = this.dataSourceSettings.rows; // eslint-disable-next-line max-len
                                    dataFields = dataFields.concat(this.dataSourceSettings.columns, this.dataSourceSettings.values, this.dataSourceSettings.filters);
                                    while (gCnt--) {
                                        let caption = actualField.caption ? actualField.caption : actualField.name;
                                        if (this.clonedReport) {
                                            let clonedFields = this.clonedReport.rows;
                                            clonedFields = clonedFields.concat(this.clonedReport.columns, this.clonedReport.values, this.clonedReport.filters);
                                            const cloneField = PivotUtil.getFieldByName(groupKeys[gCnt], clonedFields);
                                            if (cloneField) {
                                                caption = cloneField.caption ? cloneField.caption : cloneField.name;
                                            }
                                        }
                                        if (!PivotUtil.getFieldByName(groupKeys[gCnt], dataFields)) {
                                            groupField = groupFields[groupKeys[gCnt]];
                                            caption = (caption.indexOf(' (') !== -1 && caption.indexOf(')') !== -1) ?
                                                caption.slice(caption.indexOf('(') + 1, caption.length - 1) : caption;
                                            const newField = {
                                                name: groupKeys[gCnt],
                                                caption: (this.localeObj ? this.localeObj.getConstant(groupField) : groupField) + ' (' + caption + ')',
                                                type: 'Count',
                                                showNoDataItems: actualField.showNoDataItems,
                                                baseField: actualField.baseField,
                                                baseItem: actualField.baseItem,
                                                showFilterIcon: actualField.showFilterIcon,
                                                showSortIcon: actualField.showSortIcon,
                                                showEditIcon: actualField.showEditIcon,
                                                showRemoveIcon: actualField.showRemoveIcon,
                                                showSubTotals: actualField.showValueTypeIcon,
                                                allowDragAndDrop: actualField.allowDragAndDrop,
                                                expandAll: actualField.expandAll,
                                                groupName: actualField.groupName
                                            };
                                            axis.splice(i, 0, newField);
                                            this.groupingFieldsInfo[newField.name] = fieldName;
                                        }
                                    }
                                    break;
                                }
                                else if (axis[i].name.indexOf(fieldName) > -1) {
                                    const axisField = groupFields[axis[i].name];
                                    const currentField = axis.filter((axisField) => { return axisField.name === fieldName; })[0];
                                    const currentFieldCaption = (currentField.caption.indexOf(' (') !== -1 && currentField.caption.indexOf(')') !== -1) ?
                                        currentField.caption.slice(currentField.caption.indexOf('(') + 1, currentField.caption.length - 1) : currentField.caption;
                                    axis[i].caption = (this.localeObj ? this.localeObj.getConstant(axisField) : currentField) + ' (' + currentFieldCaption + ')';
                                }
                                i++;
                            }
                            if (isDataSource) {
                                break;
                            }
                        }
                    }
                    gCnt = Object.keys(groupKeys).length;
                    const field = this.getMappingField(fieldName, this.clonedReport ? this.clonedReport.fieldMapping : this.dataSourceSettings.fieldMapping);
                    const caption = field.caption ? field.caption : fieldName;
                    while (gCnt--) {
                        groupField = groupFields[groupKeys[gCnt]];
                        for (let i = 0, len = this.dataSourceSettings.formatSettings.length; i < len; i++) {
                            if (this.dataSourceSettings.formatSettings[i].name === groupKeys[gCnt]) {
                                this.dataSourceSettings.formatSettings.splice(i, 1);
                                break;
                            }
                        }
                        if (groupField !== 'Quarters' && groupField !== 'QuarterYear') {
                            const formatSettings = {
                                name: groupKeys[gCnt],
                                type: ['Years', 'Months', 'Days'].indexOf(groupField) > -1 ? 'date' : 'time',
                                format: ((groupField === 'Years') ? 'yyyy' : (groupField === 'Months') ? 'MMM' :
                                    (groupField === 'Days') ? 'd-MMM' : (groupField === 'Hours') ? 'hh a' :
                                        (groupField === 'Minutes') ? ':mm' : (groupField === 'Seconds') ? ':ss' : undefined)
                            };
                            this.dataSourceSettings.formatSettings.push(formatSettings);
                        }
                        if (!isDataSource) { // eslint-disable-next-line max-len
                            const mappingField = this.getMappingField(groupKeys[gCnt], this.dataSourceSettings.fieldMapping);
                            if (groupKeys[gCnt] !== fieldName && isNullOrUndefined(mappingField.name)) {
                                const newField = {
                                    name: groupKeys[gCnt],
                                    caption: (this.localeObj ? this.localeObj.getConstant(groupField) : groupField) + ' (' + caption + ')'
                                };
                                this.dataSourceSettings.fieldMapping.push(newField);
                                this.groupingFieldsInfo[newField.name] = fieldName;
                            }
                            else if (groupKeys[gCnt] !== fieldName) {
                                mappingField.caption = (this.localeObj ? this.localeObj.getConstant(groupField) : groupField) + ' (' + caption + ')';
                            }
                        }
                    }
                    if (!isDataSource) {
                        const mappingField = this.getMappingField(fieldName, this.dataSourceSettings.fieldMapping);
                        groupField = groupFields[fieldName];
                        if (groupKeys[gCnt] !== fieldName && isNullOrUndefined(mappingField.name)) {
                            const newField = {
                                name: fieldName,
                                caption: (this.localeObj ? this.localeObj.getConstant(groupField) : groupField) + ' (' + caption + ')'
                            };
                            this.dataSourceSettings.fieldMapping.push(newField);
                            this.groupingFieldsInfo[newField.name] = fieldName;
                        }
                        else {
                            mappingField.caption = (this.localeObj ? this.localeObj.getConstant(groupField) : groupField) + ' (' + caption + ')';
                        }
                    }
                }
                else if (group.type === 'Number' && group.rangeInterval) {
                    let cEndValue;
                    const framedSet = [];
                    const unframedSet = [];
                    let dataLength = data.length;
                    let cnt = 0;
                    this.groupingFields[fieldName] = fieldName;
                    let endingAt;
                    const groupName = [];
                    while (cnt < dataLength) {
                        const numericFieldName = Number(data[cnt][fieldName]);
                        unframedSet.push(numericFieldName);
                        if (!isNaN(numericFieldName) && framedSet.indexOf(numericFieldName) === -1) {
                            framedSet.push(numericFieldName);
                        }
                        cnt++;
                    }
                    dataLength = data.length;
                    cnt = 0;
                    while (cnt < dataLength) {
                        const currentData = data[cnt];
                        if (currentData && !isNaN(Number(currentData[fieldName]))) {
                            endingAt = typeof (group.endingAt) === 'string' ? parseInt(group.endingAt, 10) : group.endingAt;
                            cEndValue = endingAt ? endingAt : Math.max(...framedSet);
                            const currentStartValue = Math.round(Number(currentData[fieldName]));
                            const currentEndValue = Math.round(currentStartValue + (group.rangeInterval - 1));
                            if (currentStartValue >= groupName[0] && currentStartValue <= groupName[groupName.length - 1]) {
                                const startValue = groupName[0];
                                const endValue = groupName[groupName.length - 1];
                                currentData[fieldName] = this.getNumberGroupHeaders(startValue, endValue, cEndValue);
                            }
                            else {
                                if (groupName.length === 0) {
                                    for (let i = currentStartValue; i <= currentEndValue; i++) {
                                        groupName.push(i);
                                    }
                                    const startValue = groupName[0];
                                    const endValue = groupName[groupName.length - 1];
                                    currentData[fieldName] = this.getNumberGroupHeaders(startValue, endValue, cEndValue);
                                }
                                else {
                                    let startValue = groupName[groupName.length - 1] + 1;
                                    let endValue = startValue + (group.rangeInterval - 1);
                                    let grouping = true;
                                    groupName.splice(0, groupName.length);
                                    while (grouping) {
                                        if (currentStartValue >= startValue && currentStartValue <= endValue) {
                                            currentData[fieldName] = this.getNumberGroupHeaders(startValue, endValue, cEndValue);
                                            groupName.push(startValue);
                                            groupName.push(endValue);
                                            grouping = false;
                                        }
                                        startValue = endValue + 1;
                                        endValue = startValue + (group.rangeInterval - 1);
                                    }
                                }
                            }
                            const keys = Object.keys(currentData);
                            const isCompleteSet = [];
                            for (const key of keys) {
                                isCompleteSet.push((currentData[key]) ? true : false);
                            }
                            fieldkeySet = (((isCompleteSet.indexOf(false) === -1) && keys.length === Object.keys(data[0]).length) ?
                                currentData : fieldkeySet);
                        }
                        cnt++;
                    } // eslint-disable-next-line max-len
                    const axisFields = [this.dataSourceSettings.rows, this.dataSourceSettings.columns, this.dataSourceSettings.values, this.dataSourceSettings.filters];
                    for (const fields of axisFields) {
                        let field = PivotUtil.getFieldByName(fieldName, fields);
                        if (field) {
                            field = field.properties ? field.properties : field;
                            field.type = 'Count';
                        }
                    }
                    for (let i = 0, len = this.dataSourceSettings.formatSettings.length; i < len; i++) {
                        if (this.dataSourceSettings.formatSettings[i].name === fieldName) {
                            this.dataSourceSettings.formatSettings.splice(i, 1);
                            break;
                        }
                    }
                }
                else if (group.type === 'Custom' && customGroupFieldName) {
                    const customFieldName = customGroupFieldName;
                    // this.groupingFields[customFieldName] = customFieldName;
                    let isDataSource = false; // eslint-disable-next-line max-len
                    const axisFields = [this.dataSourceSettings.rows, this.dataSourceSettings.columns, this.dataSourceSettings.values, this.dataSourceSettings.filters];
                    let dataFields = this.dataSourceSettings.rows; // eslint-disable-next-line max-len
                    dataFields = dataFields.concat(this.dataSourceSettings.columns, this.dataSourceSettings.values, this.dataSourceSettings.filters);
                    let pattern = [];
                    if (!caption || caption === '') {
                        pattern = customFieldName.match(/_custom_group/g);
                    }
                    // let actualFieldName: string = fieldName.replace(/_custom_group/g, '');
                    const parentField = PivotUtil.getFieldByName(fieldName.replace(/_custom_group/g, ''), dataFields);
                    const customGroupField = PivotUtil.getFieldByName(customFieldName, dataFields);
                    for (const axis of axisFields) {
                        if (!isDataSource && axis) {
                            const cnt = axis.length;
                            let i = 0;
                            while (i < cnt) {
                                if (axis[i].name === group.name && !customGroupField) {
                                    isDataSource = true;
                                    const actualField = axis[i];
                                    const newField = {
                                        name: customFieldName,
                                        caption: (!caption || caption === '') ? (parentField.caption ? parentField.caption : parentField.name) + (pattern.length + 1) : caption,
                                        type: 'Count',
                                        showNoDataItems: actualField.showNoDataItems,
                                        baseField: actualField.baseField,
                                        baseItem: actualField.baseItem,
                                        showSubTotals: actualField.showValueTypeIcon,
                                        allowDragAndDrop: actualField.allowDragAndDrop,
                                        showFilterIcon: actualField.showFilterIcon,
                                        showSortIcon: actualField.showSortIcon,
                                        showRemoveIcon: actualField.showRemoveIcon,
                                        showEditIcon: actualField.showEditIcon,
                                        expandAll: actualField.expandAll,
                                        groupName: actualField.groupName
                                    };
                                    axis.splice(i, 0, newField);
                                    this.groupingFieldsInfo[newField.name] = fieldName;
                                    this.groupingFieldsInfo[fieldName] = fieldName;
                                    break;
                                }
                                else if (axis[i].name === customFieldName && customGroupField) {
                                    const newField = {
                                        name: customGroupField.name,
                                        caption: (!caption || caption === '') ? customGroupField.caption : caption,
                                        type: customGroupField.type,
                                        showNoDataItems: customGroupField.showNoDataItems,
                                        baseField: customGroupField.baseField,
                                        baseItem: customGroupField.baseItem,
                                        showRemoveIcon: customGroupField.showRemoveIcon,
                                        showSubTotals: customGroupField.showValueTypeIcon,
                                        allowDragAndDrop: customGroupField.allowDragAndDrop,
                                        showFilterIcon: customGroupField.showFilterIcon,
                                        showSortIcon: customGroupField.showSortIcon,
                                        showEditIcon: customGroupField.showEditIcon,
                                        expandAll: customGroupField.expandAll,
                                        groupName: customGroupField.groupName
                                    };
                                    axis.splice(i, 1, newField);
                                    this.groupingFieldsInfo[newField.name] = fieldName;
                                    this.groupingFieldsInfo[fieldName] = fieldName;
                                    break;
                                }
                                i++;
                            }
                            if (isDataSource) {
                                break;
                            }
                        }
                    }
                    const formatfield = PivotUtil.getFieldByName(fieldName, PivotUtil.cloneFormatSettings(this.dataSourceSettings.formatSettings));
                    if (formatfield) {
                        formatfield.name = customFieldName;
                        this.dataSourceSettings.formatSettings.push(formatfield);
                    }
                    this.groupingFields[fieldName] = fieldName;
                }
                this.groupingFields = extend(this.groupingFields, groupFields);
            }
            else {
                return fieldkeySet;
            }
        }
        //this.fields = Object.keys(fieldkeySet);
        return fieldkeySet;
    }
    getNumberGroupHeaders(startValue, endValue, cEndValue) {
        const fieldName = (startValue === endValue) ? startValue.toString() : (cEndValue >= startValue && cEndValue <= endValue) ?
            (cEndValue === startValue) ? startValue.toString() : startValue.toString() + '-' + cEndValue.toString() :
            startValue.toString() + '-' + endValue.toString();
        return fieldName;
    }
    frameData(data) {
        const fields = Object.keys(data);
        let keyPos = 0; // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const framedSet = {};
        while (keyPos < fields.length) {
            framedSet[fields[keyPos]] = undefined;
            keyPos++;
        }
        return framedSet;
    }
    getRange(group, cValue) {
        let isRangeAvail;
        if (group.type === 'Date') {
            const cDate = new Date(cValue);
            const startDate = typeof (group.startingAt) === 'string' ? new Date(group.startingAt) : group.startingAt;
            const endDate = typeof (group.endingAt) === 'string' ? new Date(group.endingAt) : group.endingAt;
            if (startDate && cDate.getTime() < startDate.getTime() ||
                endDate && cDate.getTime() > endDate.getTime()) {
                isRangeAvail = true;
            }
            else {
                isRangeAvail = false;
            }
        }
        else {
            const startValue = typeof (group.startingAt) === 'string' ? parseInt(group.startingAt, 10) : group.startingAt;
            const endValue = typeof (group.endingAt) === 'string' ? parseInt(group.endingAt, 10) : group.endingAt;
            if (!isNaN(startValue) && cValue < startValue || !isNaN(endValue) && cValue > endValue) {
                isRangeAvail = true;
            }
            else {
                isRangeAvail = false;
            }
        }
        return isRangeAvail;
    }
    getPercentFormat(formatField, currentField) {
        const isHavingFormat = (!isNullOrUndefined(formatField[currentField]) && !isNullOrUndefined(this.formatFields[currentField].format)) ? (this.formatFields[currentField].format).toLowerCase().match(/p[0-9]/) : undefined;
        return !isNullOrUndefined(isHavingFormat) ? (Number((this.formatFields[currentField].format).replace(/[^0-9]/g, ''))) : 2;
    } // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getFormattedFields(fields) {
        let cnt = this.dataSourceSettings.formatSettings.length;
        while (cnt--) { // eslint-disable-next-line max-len
            this.formatFields[this.dataSourceSettings.formatSettings[cnt].name] = this.dataSourceSettings.formatSettings[cnt];
            if (this.dataSourceSettings.formatSettings[cnt].type) {
                this.dateFormatFunction[this.dataSourceSettings.formatSettings[cnt].name] = {
                    exactFormat: this.globalize.getDateFormat(this.dataSourceSettings.formatSettings[cnt]),
                    fullFormat: this.globalize.getDateFormat({
                        format: 'yyyy/MM/dd/HH/mm/ss', type: this.dataSourceSettings.formatSettings[cnt].type
                    })
                };
            }
            // for (let len: number = 0, lnt: number = fields.length; len < lnt; len++) {
            // if (fields[len as number] && fields[len as number].name === this.dataSourceSettings.formatSettings[cnt as number].name) {
            //     this.formatFields[fields[len as number].name] = this.dataSourceSettings.formatSettings[cnt as number];
            // }
            // }
        }
    }
    getFieldList(fields, isSort, isValueFilteringEnabled) {
        let type;
        let lenE = this.dataSourceSettings.excludeFields.length - 1;
        while (lenE > -1) {
            const index = this.fields.indexOf(this.dataSourceSettings.excludeFields[lenE]);
            if (index !== -1) {
                this.fields.splice(index, 1);
            }
            if (this.fieldList) {
                delete this.fieldList[this.dataSourceSettings.excludeFields[lenE]];
            }
            lenE--;
        }
        let keys = this.fields;
        let dataFields = extend([], this.dataSourceSettings.rows, null, true);
        dataFields = dataFields.concat(this.dataSourceSettings.columns, this.dataSourceSettings.values, this.dataSourceSettings.filters);
        this.getFormattedFields(dataFields);
        this.getCalculatedField(keys);
        keys = this.fields;
        let len = keys.length;
        const dataTypes = ['string', 'number', 'datetime', 'date', 'boolean'];
        if (this.savedFieldList) {
            this.fieldList = this.savedFieldList;
            while (len--) { /** while is used for better performance than for */
                const key = keys[len];
                const field = this.getMappingField(key, this.dataSourceSettings.fieldMapping);
                if (this.fieldList[key]) {
                    this.fieldList[key].isSelected = false;
                    this.fieldList[key].index = len;
                    this.fieldList[key].filter = [];
                    this.fieldList[key].sort = isSort ? 'Ascending' : 'None';
                    this.fieldList[key].isExcelFilter = false;
                    this.fieldList[key].filterType = '';
                    this.fieldList[key].showFilterIcon = (field && 'showFilterIcon' in field) ?
                        field.showFilterIcon : true;
                    this.fieldList[key].showRemoveIcon = (field && 'showRemoveIcon' in field) ?
                        field.showRemoveIcon : true;
                    this.fieldList[key].showSortIcon = (field && 'showSortIcon' in field) ?
                        field.showSortIcon : true;
                    this.fieldList[key].showEditIcon = (field && 'showEditIcon' in field) ?
                        field.showEditIcon : true;
                    this.fieldList[key].showValueTypeIcon = (field && 'showValueTypeIcon' in field) ?
                        field.showValueTypeIcon : true;
                    this.fieldList[key].allowDragAndDrop = (field && 'allowDragAndDrop' in field) ?
                        field.allowDragAndDrop : true;
                    this.fieldList[key].isCalculatedField = (field && 'isCalculatedField' in field) ?
                        field.isCalculatedField : false;
                    this.fieldList[key].showNoDataItems = (field && 'showNoDataItems' in field) ?
                        field.showNoDataItems : false;
                    this.fieldList[key].showSubTotals = (field && 'showSubTotals' in field) ?
                        field.showSubTotals : true;
                    this.fieldList[key].expandAll = (field && 'expandAll' in field) ?
                        field.expandAll : false;
                    this.fieldList[key].pid = (field && 'groupName' in field && field.groupName) ? field.groupName :
                        this.groupingFieldsInfo[key] ? this.groupingFieldsInfo[key] : undefined;
                    if (this.isValueFiltersAvail && isValueFilteringEnabled) {
                        this.fieldList[key].dateMember = [];
                        this.fieldList[key].formattedMembers = {};
                        this.fieldList[key].members = {};
                    }
                    this.updateMembersOrder(key);
                }
                else {
                    type = (field && 'dataType' in field && field.dataType && dataTypes.indexOf(field.dataType.toLowerCase()) > -1) ?
                        field.dataType.toLowerCase() : type;
                    this.fieldList[key] = {
                        caption: (field && 'caption' in field && field.caption) ? field.caption : key,
                        id: key,
                        type: ((key.indexOf('_custom_group') !== -1) || (key.indexOf('_date_group') !== -1)) ?
                            'string' : (type === undefined || type === 'undefined') ? 'number' : type,
                        isSelected: false,
                        sort: isSort ? 'Ascending' : 'None',
                        filterType: '',
                        index: len,
                        filter: [],
                        isCustomField: ((key.indexOf('_custom_group') !== -1) || (key.indexOf('_date_group') !== -1)),
                        showRemoveIcon: (field && 'showRemoveIcon' in field) ?
                            field.showRemoveIcon : true,
                        showFilterIcon: (field && 'showFilterIcon' in field) ?
                            field.showFilterIcon : true,
                        showSortIcon: (field && 'showSortIcon' in field) ?
                            field.showSortIcon : true,
                        showNoDataItems: (field && 'showNoDataItems' in field) ?
                            field.showNoDataItems : false,
                        isCalculatedField: (field && 'isCalculatedField' in field) ?
                            field.isCalculatedField : false,
                        showEditIcon: (field && 'showEditIcon' in field) ?
                            field.showEditIcon : true,
                        showValueTypeIcon: (field && 'showValueTypeIcon' in field) ?
                            field.showValueTypeIcon : true,
                        allowDragAndDrop: (field && 'allowDragAndDrop' in field) ?
                            field.allowDragAndDrop : true,
                        showSubTotals: (field && 'showSubTotals' in field) ?
                            field.showSubTotals : true,
                        expandAll: (field && 'expandAll' in field) ?
                            field.expandAll : false,
                        pid: (field && 'groupName' in field && field.groupName) ? field.groupName :
                            this.groupingFieldsInfo[key] ? this.groupingFieldsInfo[key] : undefined,
                        aggregateType: (field && 'type' in field) ? field.type :
                            (((key.indexOf('_custom_group') !== -1) || (key.indexOf('_date_group') !== -1)) ? 'string' :
                                (type === undefined || type === 'undefined') ? 'number' : type) === 'number' ? 'Sum' : 'Count',
                        baseField: (field && 'baseField' in field) ?
                            field.baseField : undefined,
                        baseItem: (field && 'baseItem' in field) ?
                            field.baseItem : undefined
                    };
                    this.updateMembersOrder(key);
                }
            }
        }
        else {
            this.fieldList = {};
            while (len--) { /** while is used for better performance than for */
                const key = keys[len];
                const field = this.getMappingField(key, this.dataSourceSettings.fieldMapping);
                type = (field && 'dataType' in field && field.dataType && dataTypes.indexOf(field.dataType.toLowerCase()) > -1) ?
                    field.dataType.toLowerCase() : PivotUtil.getType(fields[this.fieldKeys[key]]); // eslint-disable-line @typescript-eslint/no-explicit-any
                this.fieldList[key] = {
                    id: key,
                    pid: (field && 'groupName' in field && field.groupName) ? field.groupName :
                        this.groupingFieldsInfo[key] ? this.groupingFieldsInfo[key] : undefined,
                    caption: (field && 'caption' in field && field.caption) ? field.caption : key,
                    type: ((key.indexOf('_custom_group') !== -1) || (key.indexOf('_date_group') !== -1)) ?
                        'string' : (type === undefined || type === 'undefined') ? 'number' : type,
                    filterType: '',
                    index: len,
                    filter: [],
                    sort: isSort ? 'Ascending' : 'None',
                    isSelected: false,
                    isCustomField: ((key.indexOf('_custom_group') !== -1) || (key.indexOf('_date_group') !== -1)),
                    showFilterIcon: (field && 'showFilterIcon' in field) ?
                        field.showFilterIcon : true,
                    showRemoveIcon: (field && 'showRemoveIcon' in field) ?
                        field.showRemoveIcon : true,
                    showSortIcon: (field && 'showSortIcon' in field) ?
                        field.showSortIcon : true,
                    showEditIcon: (field && 'showEditIcon' in field) ?
                        field.showEditIcon : true,
                    showValueTypeIcon: (field && 'showValueTypeIcon' in field) ?
                        field.showValueTypeIcon : true,
                    allowDragAndDrop: (field && 'allowDragAndDrop' in field) ?
                        field.allowDragAndDrop : true,
                    showSubTotals: (field && 'showSubTotals' in field) ?
                        field.showSubTotals : true,
                    showNoDataItems: (field && 'showNoDataItems' in field) ?
                        field.showNoDataItems : false,
                    isCalculatedField: (field && 'isCalculatedField' in field) ?
                        field.isCalculatedField : false,
                    expandAll: (field && 'expandAll' in field) ?
                        field.expandAll : false,
                    aggregateType: (field && 'type' in field) ? field.type :
                        (((key.indexOf('_custom_group') !== -1) || (key.indexOf('_date_group') !== -1)) ? 'string' :
                            (type === undefined || type === 'undefined') ? 'number' : type) === 'number' ? 'Sum' : 'Count',
                    baseField: (field && 'baseField' in field) ?
                        field.baseField : undefined,
                    baseItem: (field && 'baseItem' in field) ?
                        field.baseItem : undefined
                };
                this.updateMembersOrder(key);
            }
        }
        this.updateTreeViewData(dataFields);
    }
    updateMembersOrder(key) {
        for (const sortInfo of this.dataSourceSettings.sortSettings) {
            if (key === sortInfo.name && sortInfo.membersOrder) {
                this.fieldList[key].membersOrder = sortInfo.membersOrder;
                break;
            }
        }
    }
    getMappingField(key, fieldMapping) {
        let field = {};
        if (fieldMapping.length > 0) {
            for (let index = 0, cnt = fieldMapping.length; index < cnt; index++) {
                if (fieldMapping[index].name === key) {
                    field = fieldMapping[index];
                    break;
                }
            }
        }
        return field;
    }
    updateFieldList(savedFieldList) {
        const keys = this.fields;
        let len = keys.length;
        while (len--) { /** while is used for better performance than for */
            this.fieldList[keys[len]].isExcelFilter = savedFieldList[keys[len]].isExcelFilter;
        }
    }
    updateTreeViewData(fields) {
        let cnt = fields.length;
        let lnt = this.dataSourceSettings.calculatedFieldSettings.length;
        while (cnt--) {
            if (this.fieldList[fields[cnt].name]) {
                const field = this.fieldList[fields[cnt].name];
                field.type = fields[cnt].dataType ? fields[cnt].dataType.toLowerCase() : field.type;
                field.caption = fields[cnt].caption ? fields[cnt].caption : fields[cnt].name;
                field.isSelected = true;
                field.showNoDataItems = fields[cnt].showNoDataItems;
                field.aggregateType = fields[cnt].type;
                field.baseField = fields[cnt].baseField;
                field.baseItem = fields[cnt].baseItem;
                field.allowDragAndDrop = fields[cnt].allowDragAndDrop;
                field.showFilterIcon = fields[cnt].showFilterIcon;
                field.showSortIcon = fields[cnt].showSortIcon;
                field.showRemoveIcon = fields[cnt].showRemoveIcon;
                field.showValueTypeIcon = fields[cnt].showValueTypeIcon;
                field.showEditIcon = fields[cnt].showEditIcon;
                field.showSubTotals = fields[cnt].showSubTotals;
                field.expandAll = fields[cnt].expandAll;
            }
        }
        while (lnt--) {
            if (this.fieldList[this.dataSourceSettings.calculatedFieldSettings[lnt].name]) {
                this.fieldList[this.dataSourceSettings.calculatedFieldSettings[lnt].name].aggregateType = 'CalculatedField';
                this.fieldList[this.dataSourceSettings.calculatedFieldSettings[lnt].name].isCalculatedField = true;
                this.fieldList[this.dataSourceSettings.calculatedFieldSettings[lnt].name].formula
                    = this.dataSourceSettings.calculatedFieldSettings[lnt].formula;
            }
        }
    }
    getCalculatedField(keys) {
        for (const field of this.dataSourceSettings.calculatedFieldSettings) {
            this.calculatedFields[field.name] = extend({}, field, null, true);
            this.calculatedFields[field.name].actualFormula = field.formula;
        }
        const fieldKeys = Object.keys(this.calculatedFields);
        for (let calc = 0, cnt = fieldKeys.length; calc < cnt; calc++) {
            const field = this.calculatedFields[fieldKeys[calc]];
            const calcProperties = field.properties;
            const actualFormula = (calcProperties ? calcProperties.formula : field.formula).trim();
            const formula = actualFormula.replace(/"/g, '');
            field.formula = formula.indexOf('^') > -1 ? this.powerFunction(formula) : formula;
            if (field.formula.indexOf('Math.min(') === -1 && field.formula.indexOf('min(') > -1) {
                field.formula = field.formula.replace(/min\(/g, 'Math.min(');
            }
            if (field.formula.indexOf('Math.max(') === -1 && field.formula.indexOf('max(') > -1) {
                field.formula = field.formula.replace(/max\(/g, 'Math.max(');
            }
            if (field.formula.indexOf('Math.abs(') === -1 && field.formula.indexOf('abs(') > -1) {
                field.formula = field.formula.replace(/abs\(/g, 'Math.abs(');
            }
            field.name = calcProperties ? calcProperties.name : field.name;
            keys = keys.filter((key) => { return key !== field.name; });
            keys.push(field.name); // eslint-disable-next-line no-useless-escape
            const formulaType = actualFormula.split('\"');
            for (let len = 0, lmt = formulaType.length; len < lmt; len++) {
                const type = formulaType[len].trim(); // eslint-disable-next-line no-useless-escape
                const aggregateValue = type.split(/[ .:;?!~,`"&|()<>{}\[\]\r\n/\\]+/);
                const matchStrings = type.match(/^([^()]+)\((.*)\)$/);
                const selectedString = (aggregateValue[0] === 'DistinctCount' ?
                    'DistinctCount' : aggregateValue[0] === 'PopulationStDev' ?
                    'PopulationStDev' : aggregateValue[0] === 'SampleStDev' ? 'SampleStDev' : aggregateValue[0] === 'PopulationVar' ?
                    'PopulationVar' : aggregateValue[0] === 'SampleVar' ? 'SampleVar' : aggregateValue[0]);
                if (['Sum', 'Count', 'Min', 'Max', 'Avg', 'Product', 'DistinctCount',
                    'PopulationStDev', 'SampleStDev', 'PopulationVar', 'SampleVar', 'Median'].indexOf(selectedString) !== -1) {
                    const index = (keys.indexOf(aggregateValue[1]) === -1 && matchStrings[2]) ?
                        keys.indexOf(matchStrings[2]) : keys.indexOf(aggregateValue[1]);
                    if (!this.calculatedFormulas[field.name]) {
                        this.calculatedFormulas[field.name] = [{
                                index: index,
                                type: selectedString,
                                formula: type
                            }];
                    }
                    else {
                        this.calculatedFormulas[field.name].push({
                            index: index,
                            type: selectedString,
                            formula: type
                        });
                    }
                }
            }
        }
        this.fields = keys;
    }
    validateFilters(data) {
        this.isValueFiltersAvail = false;
        const filterElements = data.filterSettings ? data.filterSettings : [];
        let dataFields = extend([], this.dataSourceSettings.rows, null, true);
        dataFields = dataFields.concat(this.dataSourceSettings.columns);
        for (const filter of filterElements) {
            for (const field of dataFields) {
                if (filter.name === field.name && filter.type === 'Value') {
                    this.isValueFiltersAvail = true;
                    break;
                }
            }
            if (this.isValueFiltersAvail) {
                break;
            }
        }
    }
    validateValueFields() {
        this.isValueHasAdvancedAggregate = false;
        for (const value of this.dataSourceSettings.values) {
            if ((['DifferenceFrom', 'PercentageOfDifferenceFrom', 'PercentageOfParentRowTotal', 'PercentageOfParentColumnTotal', 'PercentageOfParentTotal', 'RunningTotals']).indexOf(value.type) !== -1) {
                this.isValueHasAdvancedAggregate = true;
                break;
            }
        }
    }
    fillFieldMembers(data, indMat) {
        const keys = this.fields;
        const dlen = data.length;
        const fList = this.fieldList;
        const kLn = keys.length;
        for (let kl = 0; kl < kLn; kl++) {
            const key = keys[kl];
            if (!fList[key].members || this.allowDataCompression) {
                fList[key].members = {};
            }
            if (!fList[key].formattedMembers || this.allowDataCompression) {
                fList[key].formattedMembers = {};
            }
            if (!fList[key].dateMember || this.allowDataCompression) {
                fList[key].dateMember = [];
            }
            const members = fList[key].members;
            const isDataAvail = Object.keys(members).length > 0 ? true : false;
            const formattedMembers = fList[key].formattedMembers;
            const dateMember = fList[key].dateMember;
            let membersCnt = 0;
            let fmembersCnt = 0;
            const isFieldHasExpandAll = fList[key].expandAll;
            //let sort: string[] = [];
            for (let dl = 0; dl < dlen; dl++) {
                let mkey = data[dl][this.fieldKeys[key]];
                mkey = this.enableHtmlSanitizer ? SanitizeHtmlHelper.sanitize(mkey) : mkey;
                // if (!isNullOrUndefined(mkey)) {
                if (!isDataAvail) {
                    let fKey = mkey;
                    const formattedValue = (this.pageSettings && (this.formatFields[key] &&
                        !this.valueAxisFields[key])) ? this.getFormattedValue(mkey, key) : ({
                        formattedText: mkey === null ? (this.localeObj ? this.localeObj.getConstant('null') : String(mkey)) :
                            mkey === undefined ? (this.localeObj ? (key in this.groupingFields) ?
                                this.localeObj.getConstant('groupOutOfRange') : this.localeObj.getConstant('undefined') :
                                String(mkey)) : mkey.toString(), actualText: mkey === null ? (this.localeObj ?
                            this.localeObj.getConstant('null') : String(mkey)) : mkey === undefined ? (this.localeObj ?
                            (key in this.groupingFields) ? this.localeObj.getConstant('groupOutOfRange') :
                                this.localeObj.getConstant('undefined') : String(mkey)) : mkey
                    });
                    if (formattedValue.formattedText) {
                        fKey = formattedValue.formattedText;
                    }
                    if (!members.hasOwnProperty(mkey)) { // eslint-disable-line no-prototype-builtins
                        membersCnt++;
                        members[mkey] = {
                            index: [dl], ordinal: membersCnt,
                            isDrilled: this.isExpandAll || isFieldHasExpandAll ? true : false
                        };
                        dateMember.push({ formattedText: formattedValue.formattedText, actualText: (formattedValue.dateText ?
                                formattedValue.dateText : formattedValue.actualText) });
                        //sort.push(mkey);
                    }
                    else {
                        members[mkey].index.push(dl);
                    }
                    if (!formattedMembers.hasOwnProperty(fKey)) { // eslint-disable-line no-prototype-builtins
                        fmembersCnt++;
                        formattedMembers[fKey] = {
                            index: [dl], ordinal: fmembersCnt,
                            isDrilled: this.isExpandAll || isFieldHasExpandAll ? true : false
                        };
                    }
                    else {
                        formattedMembers[fKey].index.push(dl);
                    }
                }
                if (!(indMat[dl])) {
                    indMat[dl] = [];
                    indMat[dl][kl] = members[mkey].ordinal;
                }
                else {
                    indMat[dl][kl] = members[mkey].ordinal;
                }
                // }
            }
            /*sort = Object.keys(members).sort();
            let sortedMembers: Members = {};
            for (let sln: number = 0, slt: number = sort.length; sln < slt; sln++) {
                sortedMembers[sort[sln]] = members[sort[sln]];
            }
            fList[key].members = sortedMembers; */
        }
    }
    generateValueMatrix(data) {
        const keys = this.fields;
        let len = data.length;
        const vMat = [];
        const keyLen = keys.length;
        const flList = this.fieldList;
        while (len--) {
            let tkln = keyLen;
            //if (isNullOrUndefined(vMat[len as number])) {
            vMat[len] = [];
            //}
            while (tkln--) {
                const key = keys[tkln]; /* eslint-disable @typescript-eslint/no-explicit-any */
                vMat[len][tkln] = (flList[key].type === 'number' ||
                    isNullOrUndefined(data[len][this.fieldKeys[key]])) ?
                    isNullOrUndefined(data[len][this.fieldKeys[key]]) ?
                        data[len][this.fieldKeys[key]] :
                        !isNaN(Number(data[len][this.fieldKeys[key]])) ?
                            Number(data[len][this.fieldKeys[key]]) : undefined : 1;
            } /* eslint-enable @typescript-eslint/no-explicit-any */
        }
        return vMat;
    }
    updateSortSettings(sortSettings, isSort) {
        for (let sln = 0, slt = sortSettings ? sortSettings.length : 0; sln < slt && isSort; sln++) {
            if (this.fieldList[sortSettings[sln].name]) {
                this.fieldList[sortSettings[sln].name].sort = sortSettings[sln].order;
            }
        }
    }
    updateFilterMembers(source) {
        const filterRw = this.filterMembers;
        const list = {};
        //let eList: {[key: string] : number} = {};
        const isInclude = this.getFilters(source, list);
        //this.getFilterExcludeList(source.rows, flist);
        //this.getFilterExcludeList(source.columns, flist);
        //this.getFilterExcludeList(source.filters, flist);
        // let filters: Iterator = isInclude ? iList : eList;
        const dln = this.indexMatrix.length;
        if (isInclude) {
            const keys = list.include.index;
            for (let ln = 0; ln < keys.length; ln++) {
                if (list.exclude === undefined || list.exclude.indexObject[keys[ln]] === undefined) {
                    filterRw.push(keys[ln]);
                }
            }
        }
        else {
            for (let ln = 0; ln < dln; ln++) {
                if (list.exclude === undefined || list.exclude.indexObject[ln] === undefined) {
                    filterRw.push(ln);
                }
            }
        }
    }
    getFilters(source, ilist) {
        const filterElements = source.filterSettings ? source.filterSettings : [];
        let isInclude = false;
        let filter = [];
        for (let rln = 0, rlt = filterElements.length; rln < rlt; rln++) {
            const filterElement = filterElements[rln].properties ?
                filterElements[rln].properties : filterElements[rln];
            if (this.fieldList[filterElement.name] &&
                this.fieldList[filterElement.name].isSelected &&
                this.isValidFilterField(filterElement, source.allowMemberFilter, source.allowLabelFilter)) {
                this.applyLabelFilter(filterElement);
                if (filterElement) {
                    filter = filterElement.items;
                }
                if (filterElement.type && filterElement.type === 'Include') {
                    this.frameFilterList(filter, filterElement.name, ilist, 'include', filterElement.showLabelFilter, isInclude);
                    isInclude = true;
                }
                else {
                    this.frameFilterList(filter, filterElement.name, ilist, 'exclude', filterElement.showLabelFilter);
                }
                if (filterElement.showLabelFilter) {
                    filterElement.items = [];
                    filterElement.type = filterElement.showDateFilter ? 'Date' : filterElement.showNumberFilter ? 'Number' : 'Label';
                }
            }
        }
        /* for (let cln: number = 0, clt: number = cols.length; cln < clt; cln ++) {
             filter = cols[cln as number].filter ? cols[cln as number].filter.items : [];
             if (filter.length && cols[cln as number].filter.type && cols[cln as number].filter.type === 'include') {
                 //type = cols[cln as number].filter.type;
                 this.frameFilterList(filter, cols[cln as number].name, ilist, 'include', isInclude);
                 isInclude = true;
             } else {
                 this.frameFilterList(filter, cols[cln as number].name, ilist, 'exclude');
             }
         }
         for (let vln: number = 0, vlt: number = filters.length; vln < vlt; vln ++) {
             filter = filters[vln].filter ? filters[vln].filter.items : [];
             if (filter.length && filters[vln].filter.type && filters[vln].filter.type === 'include') {
                 this.frameFilterList(filter, filters[vln].name, ilist, 'include', isInclude);
                 isInclude = true;
             } else {
                 this.frameFilterList(filter, filters[vln].name, ilist, 'exclude');
             }
         } */
        return isInclude;
    }
    isValidFilterField(filterElement, allowMemberFiltering, allowLabelFiltering) {
        const fieldName = filterElement.name;
        let isValidFilterElement = false;
        const filterTypes = ['Include', 'Exclude'];
        let dataFields = extend([], this.dataSourceSettings.rows, null, true);
        dataFields = dataFields.concat(this.dataSourceSettings.columns);
        if (this.fieldList[fieldName].isSelected && allowMemberFiltering && filterTypes.indexOf(filterElement.type) >= 0) {
            isValidFilterElement = true;
            for (const field of this.dataSourceSettings.values) {
                if (fieldName === field.name) {
                    isValidFilterElement = false;
                    break;
                }
            }
        }
        else if (allowLabelFiltering) {
            for (const field of dataFields) {
                if (fieldName === field.name &&
                    (['Label', 'Date', 'Number'].indexOf(filterElement.type) >= 0)) {
                    isValidFilterElement = true;
                    break;
                }
            }
        }
        return isValidFilterElement;
    }
    applyLabelFilter(filterElement) {
        if (['Label', 'Date', 'Number'].indexOf(filterElement.type) >= 0) {
            const members = Object.keys(this.fieldList[filterElement.name].members);
            filterElement.showLabelFilter = true;
            if (filterElement.type === 'Label') {
                filterElement.items = this.getLabelFilterMembers(members, filterElement.condition, filterElement.value1, filterElement.value2);
            }
            else if (filterElement.type === 'Date') {
                filterElement.showDateFilter = true;
                const date1 = typeof (filterElement.value1) === 'string' ?
                    new Date(filterElement.value1) : filterElement.value1;
                const date2 = typeof (filterElement.value2) === 'string' ?
                    new Date(filterElement.value2) : filterElement.value2; // eslint-disable-next-line max-len
                filterElement.items = this.getDateFilterMembers(members, filterElement.name, filterElement.condition, date1, date2);
            }
            else {
                filterElement.showNumberFilter = true;
                filterElement.items = [];
                for (const member of members) {
                    const operand1 = this.getParsedValue(filterElement.name, filterElement.value1);
                    const operand2 = this.getParsedValue(filterElement.name, filterElement.value2);
                    const cValue = this.getParsedValue(filterElement.name, member);
                    if (this.validateFilterValue(cValue, filterElement.condition, operand1, operand2)) {
                        filterElement.items.push(member);
                    }
                }
            }
            const excludeOperators = ['DoesNotBeginWith', 'DoesNotContains', 'DoesNotEndsWith', 'DoesNotEquals', 'NotBetween'];
            filterElement.type = (filterElement.condition ? (excludeOperators.indexOf(filterElement.condition) > -1 &&
                !filterElement.showNumberFilter) ? 'Exclude' : 'Include' : 'Exclude');
        }
        else {
            filterElement.showLabelFilter = false;
        }
    }
    getLabelFilterMembers(members, operator, value1, value2) {
        const items = [];
        for (const member of members) {
            const filterValue = member.toLowerCase();
            if (value1.toString()) {
                switch (operator) {
                    case 'Equals':
                    case 'DoesNotEquals':
                        if (filterValue === value1.toLowerCase()) {
                            items.push(member);
                        }
                        break;
                    case 'BeginWith':
                    case 'DoesNotBeginWith':
                        if (filterValue.indexOf(value1.toLowerCase()) === 0) {
                            items.push(member);
                        }
                        break;
                    case 'EndsWith':
                    case 'DoesNotEndsWith':
                        if (filterValue.match(value1.toLowerCase() + '$') !== null) {
                            items.push(member);
                        }
                        break;
                    case 'Contains':
                    case 'DoesNotContains':
                        if (filterValue.indexOf(value1.toLowerCase()) > -1) {
                            items.push(member);
                        }
                        break;
                    case 'GreaterThan':
                        if (filterValue > value1.toLowerCase()) {
                            items.push(member);
                        }
                        break;
                    case 'GreaterThanOrEqualTo':
                        if (filterValue >= value1.toLowerCase()) {
                            items.push(member);
                        }
                        break;
                    case 'LessThan':
                        if (filterValue < value1.toLowerCase()) {
                            items.push(member);
                        }
                        break;
                    case 'LessThanOrEqualTo':
                        if (filterValue <= value1.toLowerCase()) {
                            items.push(member);
                        }
                        break;
                    case 'Between':
                    case 'NotBetween':
                        if ((filterValue >= value1.toLowerCase()) && (filterValue <= value2.toLowerCase())) {
                            items.push(member);
                        }
                        break;
                    default:
                        if (filterValue === value1.toLowerCase()) {
                            items.push(member);
                        }
                        break;
                }
            }
        }
        return items;
    }
    getDateFilterMembers(members, name, operator, value1, value2) {
        const items = [];
        for (const member of members) {
            const filterValue = new Date(member);
            if (value1) {
                switch (operator) {
                    case 'Equals':
                    case 'DoesNotEquals':
                        if (this.getFormattedValue(filterValue.toString(), name).formattedText === this.getFormattedValue(value1.toString(), name).formattedText) {
                            items.push(this.getFormattedValue(member, name).formattedText);
                        }
                        break;
                    case 'After':
                        if (filterValue.getTime() > value1.getTime()) {
                            items.push(this.getFormattedValue(member, name).formattedText);
                        }
                        break;
                    case 'AfterOrEqualTo':
                        if (filterValue.getTime() >= value1.getTime()) {
                            items.push(this.getFormattedValue(member, name).formattedText);
                        }
                        break;
                    case 'Before':
                        if (filterValue.getTime() < value1.getTime()) {
                            items.push(this.getFormattedValue(member, name).formattedText);
                        }
                        break;
                    case 'BeforeOrEqualTo':
                        if (filterValue.getTime() <= value1.getTime()) {
                            items.push(this.getFormattedValue(member, name).formattedText);
                        }
                        break;
                    case 'Between':
                    case 'NotBetween':
                        if ((filterValue.getTime() >= value1.getTime()) &&
                            (filterValue.getTime() <= value2.getTime())) {
                            items.push(this.getFormattedValue(member, name).formattedText);
                        }
                        break;
                    default:
                        if (this.getFormattedValue(filterValue.toString(), name).formattedText === this.getFormattedValue(value1.toString(), name).formattedText) {
                            items.push(this.getFormattedValue(member, name).formattedText);
                        }
                        break;
                }
            }
        }
        return items;
    }
    validateFilterValue(val, operator, value1, value2) {
        let isMemberInclude = false;
        if (typeof (value1) === 'number') {
            switch (operator) {
                case 'Equals':
                    if (val === value1) {
                        isMemberInclude = true;
                    }
                    break;
                case 'DoesNotEquals':
                    if (val !== value1) {
                        isMemberInclude = true;
                    }
                    break;
                case 'GreaterThan':
                    if (val > value1) {
                        isMemberInclude = true;
                    }
                    break;
                case 'GreaterThanOrEqualTo':
                    if (val >= value1) {
                        isMemberInclude = true;
                    }
                    break;
                case 'LessThan':
                    if (val < value1) {
                        isMemberInclude = true;
                    }
                    break;
                case 'LessThanOrEqualTo':
                    if (val <= value1) {
                        isMemberInclude = true;
                    }
                    break;
                case 'Between':
                    if ((val >= value1) && (val <= value2)) {
                        isMemberInclude = true;
                    }
                    break;
                case 'NotBetween':
                    if (!((val >= value1) && (val <= value2))) {
                        isMemberInclude = true;
                    }
                    break;
                default:
                    if (val !== value1) {
                        isMemberInclude = true;
                    }
                    break;
            }
        }
        return isMemberInclude;
    }
    frameFilterList(filter, name, list, type, isLabelFilter, isInclude) {
        if (!list[type]) {
            list[type] = { indexObject: {}, index: [] };
            this.updateFilter(filter, name, list, type, isLabelFilter, isInclude);
        }
        else {
            this.updateFilter(filter, name, list, type, isLabelFilter, isInclude);
        }
    }
    updateFilter(filter, name, list, type, isLabelFilter, isInclude) {
        let fln = 0;
        const field = this.fieldList[name];
        field.filter = filter;
        field.filterType = type;
        field.isExcelFilter = isLabelFilter;
        const members = ((this.formatFields[name] &&
            (['date', 'dateTime', 'time'].indexOf(this.formatFields[name].type) > -1)) || (name in this.groupingFields)) ?
            field.formattedMembers : field.members;
        const allowFil = isInclude;
        const final = {};
        const filterObj = {};
        final[type] = { indexObject: {}, index: [] };
        this.fieldFilterMem[name] = { memberObj: {} };
        while (!isNullOrUndefined(filter[fln])) {
            if (members[filter[fln]]) {
                const indx = members[filter[fln]].index;
                if (type === 'include') {
                    for (let iln = 0, ilt = indx.length; iln < ilt; iln++) {
                        if (!allowFil || list[type].indexObject[indx[iln]] !== undefined) {
                            final[type].indexObject[indx[iln]] = indx[iln];
                            final[type].index.push(indx[iln]);
                        }
                    }
                }
                else {
                    for (let iln = 0, ilt = indx.length; iln < ilt; iln++) {
                        if (list[type].indexObject[indx[iln]] === undefined) {
                            list[type].indexObject[indx[iln]] = indx[iln];
                            list[type].index.push(indx[iln]);
                        }
                    }
                    this.fieldFilterMem[name].memberObj[filter[fln]] = filter[fln];
                }
            }
            fln++;
        }
        if (type === 'include') {
            list[type] = final[type];
            for (let iln = 0; iln < filter.length; iln++) {
                if (members[filter[iln]]) {
                    filterObj[filter[iln]] = filter[iln];
                }
            }
            const items = Object.keys(members);
            for (let iln = 0, ilt = items.length; iln < ilt; iln++) {
                if (filterObj[items[iln]] === undefined) {
                    this.fieldFilterMem[name].memberObj[items[iln]] = items[iln];
                }
            }
        }
    }
    applyValueFiltering(rowData, level, rows, columns, valueFilter, rowFilterData, type) {
        this.isValueFiltered = false;
        const allMember = extend({}, (type === 'row' && this.rowGrandTotal ? this.rowGrandTotal : type === 'column' && this.columnGrandTotal ? this.columnGrandTotal : (!(this.dataSourceSettings.grandTotalsPosition === 'Top') ? rows[rows.length - 1] : rows[0])), null, true);
        this.getFilteredData(rows, columns, valueFilter, rowFilterData, level, rowData.name, allMember, type);
        if (this.isValueFiltered) {
            if ((type === 'row' && this.rowGrandTotal === null) || (type === 'column' && this.columnGrandTotal === null)) {
                rowFilterData.push(allMember);
            }
            rows = rowFilterData;
        }
        return rows;
    }
    getFilteredData(rows, columns, filterSettings, rowFilterData, level, fieldName, allMember, type) {
        const rLen = rows.length;
        for (let i = 0; i < rLen; i++) {
            if (filterSettings[fieldName]) {
                if (rows[i].level === level) {
                    this.isValueFiltered = true;
                    this.fieldList[fieldName].isExcelFilter = true;
                    let value = 0;
                    const measure = filterSettings[fieldName].measure;
                    const mPos = this.fieldList[measure].index;
                    const aggregate = this.fieldList[measure].aggregateType;
                    this.rawIndexObject = {};
                    value = (type === 'row' ? this.getAggregateValue(rows[i].index, columns.indexObject, mPos, aggregate, false) :
                        this.getAggregateValue(columns.index, rows[i].indexObject, mPos, aggregate, false));
                    const cellDetails = {
                        fieldName: measure,
                        row: rows[i],
                        column: columns,
                        value: value,
                        cellSets: this.getValueCellInfo ? this.getCellSet(this.rawIndexObject) : [],
                        rowCellType: (rows[i].hasChild && rows[i].isDrilled ? 'subTotal' : rows[i].type === 'grand sum' ? 'grandTotal' : 'value'),
                        columnCellType: (columns.hasChild && columns.isDrilled ? 'subTotal' : columns.type === 'grand sum' ? 'grandTotal' : 'value'),
                        aggregateType: aggregate,
                        skipFormatting: false
                    };
                    if (this.getValueCellInfo) {
                        this.getValueCellInfo(cellDetails);
                    }
                    value = cellDetails.value;
                    this.rawIndexObject = {};
                    const operand1 = this.getParsedValue(measure, filterSettings[fieldName].value1);
                    const operand2 = this.getParsedValue(measure, filterSettings[fieldName].value2);
                    if (!this.validateFilterValue(value, filterSettings[fieldName].condition, operand1, operand2) && rows[i].type !== 'grand sum') {
                        const data = this.removefilteredData(rows[i], this.valueFilteredData);
                        const row = data ? data : rows[i];
                        this.validateFilteredParentData(row, this.valueFilteredData, allMember, 0, level, type);
                    }
                    else if (rows[i].type !== 'grand sum') {
                        rowFilterData.push(extend({}, rows[i], null, true));
                        rowFilterData[rowFilterData.length - 1].isLevelFiltered = true;
                    }
                }
                else if (rows[i].hasChild && rows[i].members.length > 0 && rows[i].type !== 'grand sum') {
                    rowFilterData.push(extend({}, rows[i], null, true));
                    rowFilterData[rowFilterData.length - 1].members = [];
                    rowFilterData[rowFilterData.length - 1].isLevelFiltered = true;
                    this.getFilteredData(rows[i].members, columns, filterSettings, rowFilterData[rowFilterData.length - 1].members, level, fieldName, allMember, type);
                }
            }
        }
    }
    getParsedValue(measure, value) {
        const cValue = value ? value.toString() : '';
        if (this.formatFields[measure] && value) {
            const formatSetting = extend({}, this.formatFields[measure], null, true);
            delete formatSetting.name;
            return this.globalize.parseNumber(cValue, formatSetting);
        }
        else {
            return this.globalize.parseNumber(cValue, { format: 'N' });
        }
    }
    removefilteredData(row, rowFilterData) {
        const rows = extend([], rowFilterData, null, true);
        let filteredData;
        for (let i = 0; i < rows.length; i++) {
            if (row.isLevelFiltered && row.axis === rows[i].axis &&
                row.valueSort.levelName === rows[i].valueSort.levelName &&
                row.actualText === rows[i].actualText && row.axis === rows[i].axis &&
                row.level === rows[i].level && row.ordinal === rows[i].ordinal) {
                filteredData = rows[i];
                rowFilterData.splice(i, 1);
                break;
            }
            else if (rowFilterData[i].hasChild && rowFilterData[i].members.length > 0) {
                this.removefilteredData(row, rowFilterData[i].members);
            }
        }
        return filteredData;
    }
    validateFilteredParentData(row, rows, allMemberData, i, level, type) {
        if (rows.length > 0) {
            for (const rowFilteredData of rows) {
                if (rowFilteredData.level === i) {
                    if (type === 'row') {
                        const index = row.index;
                        for (const key of index) {
                            if (allMemberData.index.indexOf(key) >= 0) {
                                allMemberData.index.splice(allMemberData.index.indexOf(key), 1);
                            }
                            if (((row.valueSort.levelName.toString()).indexOf(rowFilteredData.valueSort.levelName.toString()) >= 0) &&
                                rowFilteredData.level !== level && rowFilteredData.index.indexOf(key) >= 0) {
                                rowFilteredData.index.splice(rowFilteredData.index.indexOf(key), 1);
                            }
                        }
                    }
                    else {
                        const index = row.indexObject;
                        for (const key of Object.keys(index)) {
                            if (index.hasOwnProperty(key)) { // eslint-disable-line no-prototype-builtins
                                delete allMemberData.indexObject[key];
                                if (((row.valueSort.levelName.toString()).indexOf(rowFilteredData.valueSort.levelName.toString()) >= 0) &&
                                    rowFilteredData.level !== level) {
                                    delete rowFilteredData.indexObject[key];
                                }
                            }
                        }
                    }
                    if (rowFilteredData && rowFilteredData.members.length > 0 &&
                        rowFilteredData.members[0].level === i + 1 && rowFilteredData.members[0].level !== level) {
                        this.validateFilteredParentData(row, rowFilteredData.members, allMemberData, i + 1, level, type);
                    }
                }
            }
        }
        else {
            if (type === 'row') {
                const index = row.index;
                for (const key of index) {
                    if (allMemberData.index.indexOf(key) >= 0) {
                        allMemberData.index.splice(allMemberData.index.indexOf(key), 1);
                    }
                }
            }
            else {
                const index = row.indexObject;
                for (const key of Object.keys(index)) {
                    if (index.hasOwnProperty(key)) { // eslint-disable-line no-prototype-builtins
                        delete allMemberData.indexObject[key];
                    }
                }
            }
        }
    }
    updateFramedHeaders(framedHeaders, dataHeaders, filteredHeaders, headers, type) {
        for (const dHeader of framedHeaders) {
            this.isHeaderAvail = false;
            if (this.validateFilteredHeaders(dHeader, filteredHeaders, type) || dHeader.type === 'grand sum') {
                if (type === 'row') {
                    this.rowCount += this.rowValuesLength;
                }
                else {
                    this.columnCount += this.colValuesLength;
                }
                headers.push(extend({}, dHeader, null, true));
                headers[headers.length - 1].members = [];
                if (dHeader.hasChild && dHeader.isDrilled && dHeader.members.length > 0) {
                    this.updateFramedHeaders(dHeader.members, dataHeaders, filteredHeaders, headers[headers.length - 1].members, type);
                }
            }
        }
        return this.filterFramedHeaders;
    }
    validateFilteredHeaders(dHeader, filteredHeaders, type) {
        for (const vHeader of filteredHeaders) {
            if (!this.isHeaderAvail) {
                if (dHeader.actualText === vHeader.actualText &&
                    dHeader.level === vHeader.level &&
                    dHeader.valueSort.levelName === vHeader.valueSort.levelName) {
                    if (type === 'row') {
                        if (vHeader.index.length > 0) {
                            this.isHeaderAvail = true;
                            dHeader.index = vHeader.index;
                            return true;
                        }
                        else {
                            this.isHeaderAvail = false;
                            dHeader.index = vHeader.index;
                            return false;
                        }
                    }
                    else {
                        if (Object.keys(vHeader.indexObject).length > 0) {
                            this.isHeaderAvail = true;
                            dHeader.indexObject = vHeader.indexObject;
                            return true;
                        }
                        else {
                            this.isHeaderAvail = false;
                            dHeader.indexObject = vHeader.indexObject;
                            return false;
                        }
                    }
                }
                else if (vHeader.hasChild && vHeader.members.length > 0 && vHeader.type !== 'grand sum') {
                    this.validateFilteredHeaders(dHeader, vHeader.members, type);
                }
            }
        }
        return this.isHeaderAvail;
    }
    isEmptyDataAvail(rowHeaders, columnHeaders) {
        this.isEmptyData = false;
        if (rowHeaders.length > 0 && rowHeaders[rowHeaders.length - 1].type === 'grand sum' &&
            rowHeaders[rowHeaders.length - 1].index.length === 0) {
            this.isEmptyData = true;
        }
        if (columnHeaders.length > 0 && columnHeaders[columnHeaders.length - 1].type === 'grand sum' &&
            Object.keys(columnHeaders[columnHeaders.length - 1].indexObject).length === 0) {
            this.isEmptyData = true;
        }
        if (rowHeaders.length === 0 || columnHeaders.length === 0) {
            this.isEmptyData = true;
        }
    }
    /**
     * It is used to update the grid data.
     *
     * @param {IDataOptions} dataSource -  It contains the dataSourceSettings.
     * @returns {void}
     * @hidden
     */
    updateGridData(dataSource) {
        this.updateDataSourceSettings(dataSource, true);
        this.data = dataSource.dataSource;
        if (this.allowDataCompression) {
            this.actualData = this.data;
            this.data = this.getGroupedRawData(dataSource);
        }
        this.indexMatrix = [];
        for (const field of this.fields) {
            this.fieldList[field].members = {};
            this.fieldList[field].formattedMembers = {};
            this.fieldList[field].dateMember = [];
        }
        this.fillFieldMembers(this.data, this.indexMatrix);
        this.valueMatrix = this.generateValueMatrix(this.data);
        this.filterMembers = [];
        this.cMembers = [];
        this.rMembers = [];
        this.updateFilterMembers(dataSource);
        this.isEditing = true;
        this.isDrillThrough = true;
        this.generateGridData(dataSource);
        this.isEditing = false;
    }
    generateGridData(dataSource, requireDatasourceUpdate = false, headerCollection) {
        this.updateDataSourceSettings(dataSource, requireDatasourceUpdate);
        const columns = dataSource.columns ? dataSource.columns : [];
        const data = this.data;
        const rows = dataSource.rows ? dataSource.rows : [];
        const filterSettings = dataSource.filterSettings;
        const values = dataSource.values ? dataSource.values : [];
        this.removeCount = 0;
        this.isExpandAll = dataSource.expandAll;
        this.drilledMembers = dataSource.drilledMembers ? dataSource.drilledMembers : [];
        this.isEmptyData = false;
        const filterMembers = [];
        const showNoDataItems = (rows[0] && rows[0].showNoDataItems) || (columns[0] && columns[0].showNoDataItems);
        // let dataFields: IFieldOptions[] = extend([], this.dataSourceSettings.rows, null, true) as IFieldOptions[];
        // dataFields = dataFields.concat(this.dataSourceSettings.columns, this.dataSourceSettings.values, this.dataSourceSettings.filters);
        if (showNoDataItems) {
            for (let ln = 0; ln < this.indexMatrix.length; ln++) {
                filterMembers.push(ln);
            }
        }
        for (let ln = 0; ln < this.filterMembers.length; ln++) {
            this.filterPosObj[this.filterMembers[ln]] = this.filterMembers[ln];
        }
        //let childrens: Field = this.fieldList[rows[0].name + ''];
        this.valueSortSettings.columnIndex = undefined;
        this.validateValueFields();
        this.frameDrillObject();
        if (!this.isValueFilterEnabled || this.isEditing) {
            if (!headerCollection) {
                this.isLastHeaderHasMeasures = true;
                this.columnCount = 0;
                this.rowCount = 0;
                this.cMembers = [];
                this.rMembers = [];
                if (rows.length !== 0) {
                    this.rMembers =
                        this.getIndexedHeaders(rows, data, 0, rows[0].showNoDataItems ? filterMembers : this.filterMembers, 'row', '', this.allowValueFilter);
                }
                if (columns.length !== 0) {
                    this.cMembers = this.getIndexedHeaders(columns, data, 0, columns[0].showNoDataItems ?
                        filterMembers : this.filterMembers, 'column', '', this.allowValueFilter);
                }
                this.insertAllMembersCommon();
                this.saveDataHeaders = (this.isValueFiltersAvail && dataSource.allowValueFilter) ? {
                    rowHeaders: extend([], this.rMembers, null, true),
                    columnHeaders: extend([], this.cMembers, null, true)
                } : {};
            }
        }
        this.pivotValues = [];
        this.headerContent = [];
        this.valueContent = [];
        this.valueFilteredData = [];
        this.filterFramedHeaders = [];
        const rowheads = [];
        const colheads = [];
        let rowFilteredData = [];
        let columnFilteredData = [];
        const updatedRowMembers = [];
        const valuesCount = (this.dataSourceSettings.values.length);
        if (this.isValueFiltersAvail && dataSource.allowValueFilter && !headerCollection) {
            this.valueFilteredData = [];
            let rowHeaders = this.saveDataHeaders.rowHeaders;
            let columnHeaders = this.saveDataHeaders.columnHeaders;
            if (filterSettings.length > 0) {
                const valueFilters = {};
                const valueFields = {};
                for (const value of values) {
                    valueFields[value.name] = value;
                }
                for (const filter of filterSettings) {
                    rowHeaders = (rowFilteredData.length > 0 ? rowFilteredData : rowHeaders);
                    columnHeaders = (columnFilteredData.length > 0 ? columnFilteredData : columnHeaders);
                    this.valueFilteredData = [];
                    const filterElement = filter.properties ?
                        filter.properties : filter;
                    if (filterElement.type === 'Value' && this.fieldList[filter.name] && this.fieldList[filter.name].isSelected) {
                        valueFilters[filter.name] = filter;
                        filterElement.items = [];
                        let isAvail = false;
                        const rLen = rows.length;
                        const cLen = columns.length;
                        for (let i = 0; i < rLen; i++) {
                            if (filterElement.name === rows[i].name && valueFields[filterElement.measure] && !isAvail) {
                                isAvail = true;
                                rowFilteredData = this.applyValueFiltering(rows[i], i, rowHeaders, (this.columnGrandTotal ? this.columnGrandTotal : (this.dataSourceSettings.grandTotalsPosition === 'Top' && this.dataSourceSettings.showGrandTotals) ? columnHeaders[0] : columnHeaders[columnHeaders.length - 1]), valueFilters, this.valueFilteredData, 'row');
                                break;
                            }
                        }
                        for (let j = 0; j < cLen; j++) {
                            if (filterElement.name === columns[j].name && valueFields[filterElement.measure] && !isAvail) {
                                isAvail = true;
                                columnFilteredData = this.applyValueFiltering(columns[j], j, columnHeaders, (this.rowGrandTotal ? this.rowGrandTotal : (this.dataSourceSettings.grandTotalsPosition === 'Top' && this.dataSourceSettings.showGrandTotals) ? rowHeaders[0] : rowHeaders[rowHeaders.length - 1]), valueFilters, this.valueFilteredData, 'column');
                                break;
                            }
                        }
                    }
                }
            }
            rowFilteredData = (rowFilteredData.length > 0 ? rowFilteredData : rowHeaders);
            columnFilteredData = (columnFilteredData.length > 0 ? columnFilteredData : columnHeaders);
            this.isEmptyDataAvail(rowFilteredData, columnFilteredData);
            const savedFieldList = PivotUtil.getClonedFieldList(this.fieldList);
            this.indexMatrix = [];
            const fields = this.data[0];
            this.getFieldList(fields, this.enableSort, dataSource.allowValueFilter);
            this.fillFieldMembers(this.data, this.indexMatrix);
            this.updateSortSettings(dataSource.sortSettings, this.enableSort);
            this.valueMatrix = this.generateValueMatrix(this.data);
            this.filterMembers = [];
            this.updateFilterMembers(dataSource);
            this.isLastHeaderHasMeasures = true;
            this.rMembers = rows.length !== 0 ?
                this.getIndexedHeaders(rows, data, 0, rows[0].showNoDataItems ?
                    filterMembers : this.filterMembers, 'row', '') : [];
            this.cMembers = columns.length !== 0 ?
                this.getIndexedHeaders(columns, data, 0, columns[0].showNoDataItems ?
                    filterMembers : this.filterMembers, 'column', '') : [];
            this.insertAllMembersCommon();
            this.updateFieldList(savedFieldList);
            this.rowCount = 0;
            this.columnCount = 0;
            this.rMembers = this.updateFramedHeaders(this.rMembers, this.rMembers, rowFilteredData, this.filterFramedHeaders, 'row');
            this.filterFramedHeaders = [];
            this.cMembers = this.updateFramedHeaders(this.cMembers, this.cMembers, columnFilteredData, this.filterFramedHeaders, 'column');
            this.isValueFilterEnabled = true;
        }
        if (!headerCollection) {
            this.applyValueSorting();
        }
        if (this.isPagingOrVirtualizationEnabled) {
            if (!headerCollection) {
                this.headerCollection.rowHeaders = this.rMembers;
                this.headerCollection.columnHeaders = this.cMembers;
                this.headerCollection.rowHeadersCount = this.rowCount;
                this.headerCollection.columnHeadersCount = this.columnCount;
            }
            else {
                this.rMembers = headerCollection.rowHeaders;
                this.cMembers = headerCollection.columnHeaders;
                this.rowCount = headerCollection.rowHeadersCount;
                this.columnCount = headerCollection.columnHeadersCount;
            }
            this.calculatePagingValues();
        }
        if (!this.valueAxis && this.isLastHeaderHasMeasures) {
            this.getAggregatedHeaders(rows, columns, this.rMembers, this.cMembers, values);
        }
        this.getHeaderData(rows, columns, values, updatedRowMembers, this.cMembers, colheads, this.pivotValues, 0, this.valueAxis ? 1 : valuesCount);
        this.insertSubTotals();
        this.getTableData((updatedRowMembers.length > 0 ? updatedRowMembers : this.rMembers), rowheads, colheads, 0, this.pivotValues, valuesCount, 0, (this.rowGrandTotal ? this.rowGrandTotal :
            this.rMembers[this.rMembers.length - 1]), (this.columnGrandTotal ? this.columnGrandTotal :
            this.cMembers[this.cMembers.length - 1]));
        this.applyAdvancedAggregate(rowheads, colheads, this.pivotValues);
        this.isEngineUpdated = true;
        this.isEmptyDataAvail(this.rMembers, this.cMembers);
        //  console.log(st1 - st2);
        this.clearProperties();
    }
    updateHeaders(rowFlag, columnFlag) {
        /* removing the row grant-total members */
        rowFlag = (isNullOrUndefined(rowFlag) ? (this.dataSourceSettings.showGrandTotals && this.dataSourceSettings.showRowGrandTotals) ?
            true : (this.dataSourceSettings.rows.length > 0) ? false : true : rowFlag);
        if (((this.pageSettings && (this.removeRowGrandTotal)) || (!rowFlag && !this.rowGrandTotal)) &&
            this.rMembers[this.rMembers.length - 1].type === 'grand sum') {
            this.rMembers = this.rMembers.slice(0, this.rMembers.length - 1);
        }
        /* removing the column gran-total members */
        // eslint-disable-next-line max-len
        columnFlag = (isNullOrUndefined(columnFlag) ? (this.dataSourceSettings.showGrandTotals && this.dataSourceSettings.showColumnGrandTotals) ?
            true : (this.dataSourceSettings.columns.length > 0) ? false : true : columnFlag);
        if (((this.pageSettings && (this.removeColumnGrandTotal)) || (!columnFlag && !this.columnGrandTotal)) &&
            this.cMembers[this.cMembers.length - 1].type === 'grand sum') {
            this.cMembers = this.cMembers.slice(0, this.cMembers.length - 1);
        }
    }
    updatePivotValues(updateHeaders) {
        const rowFlag = (this.dataSourceSettings.showGrandTotals && this.dataSourceSettings.showRowGrandTotals) ? true : (this.dataSourceSettings.rows.length > 0) ? false : true; // eslint-disable-next-line max-len
        const columnFlag = (this.dataSourceSettings.showGrandTotals && this.dataSourceSettings.showColumnGrandTotals) ? true : (this.dataSourceSettings.columns.length > 0) ? false : true;
        if (updateHeaders) {
            this.updateHeaders(rowFlag, columnFlag);
        }
        /* removing the row grant-totals */
        if (((this.pageSettings && (this.removeRowGrandTotal)) ||
            (!rowFlag && !this.rowGrandTotal)) && this.valueContent.length > 0) {
            let slicePos = 1;
            if (this.valueAxis && this.dataSourceSettings.values.length > 0) {
                slicePos = 1 + this.dataSourceSettings.values.length;
            }
            if (this.pivotValues[this.pivotValues.length - slicePos] &&
                this.pivotValues[this.pivotValues.length - slicePos][0].type === 'grand sum') {
                this.pivotValues = this.pivotValues.slice(0, this.pivotValues.length - slicePos);
                this.valueContent = this.valueContent.slice(0, this.valueContent.length - slicePos);
            }
        }
        /* removing the column gran-totals */
        if (((this.pageSettings && (this.removeColumnGrandTotal)) ||
            (!columnFlag && !this.columnGrandTotal)) && this.headerContent.length > 0) {
            let slicePos = this.dataSourceSettings.values.length;
            if (this.valueAxis && this.dataSourceSettings.values.length > 0) {
                slicePos = 1;
            }
            if (this.pivotValues[0][this.pivotValues[0].length - slicePos] &&
                this.pivotValues[0][this.pivotValues[0].length - slicePos].type === 'grand sum') {
                for (let ln = 0; ln < this.pivotValues.length; ln++) {
                    if (this.pivotValues[ln]) {
                        this.pivotValues[ln] =
                            this.pivotValues[ln].slice(0, this.pivotValues[ln].length - slicePos);
                    }
                    if (this.headerContent[ln]) {
                        for (let pos = this.pivotValues[ln].length; pos < (this.pivotValues[ln].length + slicePos); pos++) {
                            delete this.headerContent[ln][pos];
                        }
                    }
                }
            }
        }
        this.removeRowGrandTotal = this.removeColumnGrandTotal = false;
    }
    /**
     * It performs the updateing Engine by the drilled item.
     *
     * @param {IDrilledItem} drilledItem -  It cotains the drilled items.
     * @returns {void}
     * @hidden
     */
    onDrill(drilledItem) {
        this.frameDrillObject(drilledItem);
        const headersInfo = this.getHeadersInfo(drilledItem.fieldName, drilledItem.axis);
        this.performDrillOperation(headersInfo.headers, drilledItem, headersInfo.fields, headersInfo.position, 0);
        this.headerCollection.rowHeadersCount = this.rowCount;
        this.headerCollection.columnHeadersCount = this.columnCount;
        if (headersInfo.axis === 'row') {
            this.headerCollection.rowHeaders = headersInfo.headers;
        }
        else {
            this.headerCollection.columnHeaders = headersInfo.headers;
        }
        this.updateEngine();
    }
    /**
     * It performs to update the engine by sorting data.
     *
     * @param {ISort} sortItem - It cotains the drilled item data.
     * @returns {void}
     * @hidden
     */
    onSort(sortItem) {
        const headersInfo = this.getHeadersInfo(sortItem.name, '');
        this.fieldList[sortItem.name].sort = sortItem.order;
        this.performSortOperation(headersInfo.headers, sortItem, headersInfo, 0);
        this.updateEngine();
    }
    /**
     * It performs to update the engine by filtering data.
     *
     * @param {IFilter} filterItem - It contains the value of filter Item.
     * @param {IDataOptions} dataSource - It contains dataSource.
     * @returns {void}
     * @hidden
     */
    onFilter(filterItem, dataSource) {
        this.updateDataSourceSettings(dataSource, true);
        const headersInfo = this.getHeadersInfo(filterItem.name, '');
        this.isLastHeaderHasMeasures = (this.valueAxis && headersInfo.axis === 'row') ||
            (!this.valueAxis && headersInfo.axis === 'column') ? true : this.isLastHeaderHasMeasures;
        if (filterItem.type === 'Include' && filterItem.items.length === this.fieldList[filterItem.name].dateMember.length) {
            this.fieldList[filterItem.name].filter = [];
            this.fieldList[filterItem.name].filterType = '';
        }
        else {
            this.fieldList[filterItem.name].filter = filterItem.items;
            this.fieldList[filterItem.name].filterType = filterItem.type;
        }
        const posObj = {};
        for (const pos of this.filterMembers) {
            posObj[pos] = pos;
        }
        this.filterMembers = [];
        this.fieldFilterMem = {};
        this.updateFilterMembers(dataSource);
        let addPos = this.filterMembers.filter((pos) => { return posObj[pos] === undefined; });
        for (const item of filterItem.items) {
            
        }
        const showNoDataItems = (this.dataSourceSettings.rows[0] && this.dataSourceSettings.rows[0].showNoDataItems) || (this.dataSourceSettings.columns[0] && this.dataSourceSettings.columns[0].showNoDataItems);
        if (showNoDataItems) {
            const filterMembers = [];
            this.filterPosObj = {};
            for (let ln = 0; ln < addPos.length; ln++) {
                this.filterPosObj[addPos[ln]] = addPos[ln];
            }
            for (let ln = 0; ln < this.indexMatrix.length; ln++) {
                filterMembers.push(ln);
            }
            addPos = filterMembers;
        }
        this.performFilterCommonUpdate(filterItem, headersInfo, addPos);
        this.frameHeaderObjectsCollection = false;
        this.headerObjectsCollection = {};
        this.updateEngine();
    }
    /**
     * It performs to update the engine by the aggregation.
     *
     * @param {IFieldOptions} field -  It cotains the field data.
     * @returns {void}
     * @hidden
     */
    onAggregation(field) {
        this.fieldList[field.name].aggregateType = field.type;
        this.rMembers = this.headerCollection.rowHeaders;
        this.cMembers = this.headerCollection.columnHeaders;
        if (this.allowDataCompression) {
            this.data = this.getGroupedRawData(this.dataSourceSettings);
            this.valueMatrix = this.generateValueMatrix(this.data);
        }
        this.updateEngine();
    }
    /**
     * It performs to update the engine by the calculated field operation.
     *
     * @param {ICalculatedFields} field -  It cotains the Calculated Fields.
     * @param {IDataOptions} dataSourceSettings -  It cotains the dataSourceSettings.
     * @returns {void}
     * @hidden
     */
    onCalcOperation(field, dataSourceSettings) {
        this.dataSourceSettings.calculatedFieldSettings = dataSourceSettings.calculatedFieldSettings ? dataSourceSettings.calculatedFieldSettings : [];
        this.dataSourceSettings.values = dataSourceSettings.values ? dataSourceSettings.values : [];
        this.rMembers = this.headerCollection.rowHeaders;
        this.cMembers = this.headerCollection.columnHeaders;
        this.getCalculatedField(this.fields);
        if (this.fieldList[field.name]) {
            this.fieldList[field.name].formula = field.formula;
        }
        else {
            this.fieldList[field.name] = {
                id: field.name,
                caption: field.name,
                type: 'number',
                aggregateType: 'CalculatedField',
                filterType: '',
                index: this.fields.length - 1,
                filter: [],
                sort: this.enableSort ? 'Ascending' : 'None',
                isSelected: true,
                isExcelFilter: false,
                formula: field.formula
            };
            if (this.valueAxis === 1) {
                this.headerCollection.rowHeadersCount = this.rowCount = (this.rowCount / (this.dataSourceSettings.values.length - 1)) * this.dataSourceSettings.values.length;
            }
            else {
                this.headerCollection.columnHeadersCount = this.columnCount = (this.columnCount / (this.dataSourceSettings.values.length - 1)) * this.dataSourceSettings.values.length;
            }
        }
        this.updateEngine();
    }
    performDrillOperation(headers, drilledItem, fields, position, currentPosition) {
        let count = 0;
        while (count < headers.length) {
            if (position === currentPosition) {
                const levelName = headers[count].valueSort.levelName.split(this.valueSortSettings.headerDelimiter);
                if (drilledItem.memberName === levelName.join(drilledItem.delimiter ? drilledItem.delimiter : '**')) {
                    if (drilledItem.action === 'down') {
                        headers[count].isDrilled = true;
                        headers[count].members = this.getIndexedHeaders(fields, this.data, position + 1, headers[count].index, drilledItem.axis, drilledItem.memberName.
                            split(drilledItem.delimiter ? drilledItem.delimiter : '**').join(this.valueSortSettings.headerDelimiter));
                        let sortedHeaders;
                        if (drilledItem.axis === 'row') {
                            sortedHeaders = this.applyValueSorting(headers[count].members, this.cMembers);
                            headers[count].members = sortedHeaders.rMembers;
                        }
                        else { // eslint-disable-next-line max-len
                            const showSubTotals = this.dataSourceSettings.showSubTotals && this.dataSourceSettings.showColumnSubTotals &&
                                fields[position].showSubTotals;
                            this.columnCount -= !showSubTotals ? this.colValuesLength : 0;
                            sortedHeaders = this.applyValueSorting(this.rMembers, headers[count].members);
                            headers[count].members = sortedHeaders.cMembers;
                        }
                    }
                    else {
                        headers[count].isDrilled = false;
                        this.updateHeadersCount(headers[count].members, drilledItem.axis, position, fields, 'minus', true);
                        headers[count].members = [];
                    }
                    break;
                }
            }
            else if (headers[count].members.length > 0) {
                headers[count].members = this.performDrillOperation(headers[count].members, drilledItem, fields, position, currentPosition + 1);
            }
            count++;
        }
        return headers;
    }
    performSortOperation(headers, sortItem, headersInfo, currentPosition) {
        let count = 0;
        while (count < headers.length) {
            if (headersInfo.position === currentPosition) {
                headers = this.getSortedHeaders(headers, sortItem.order.toString());
                break;
            }
            else if (headers[count].members.length > 0) {
                headers[count].members =
                    this.performSortOperation(headers[count].members, sortItem, headersInfo, currentPosition + 1);
            }
            count++;
        }
        return headers;
    }
    performFilterDeletion(headers, filterItem, headersInfo, filterObjects, currentPosition) {
        let count = 0;
        let loopIn = true;
        while (count < headers.length && loopIn) {
            if (headersInfo.position === currentPosition) {
                const engine = this; // eslint-disable-line @typescript-eslint/no-this-alias
                headers = headers.filter((item) => {
                    return !engine.fieldFilterMem[filterItem.name].memberObj[item.formattedText] || item.type === 'grand sum';
                });
                loopIn = false;
            }
            else if (headers[count].members.length > 0) {
                headers[count].members = this.performFilterDeletion(headers[count].members, filterItem, headersInfo, filterObjects, currentPosition + 1);
            }
            count++;
        } // eslint-disable-next-line @typescript-eslint/no-this-alias
        const engine = this;
        return headers.filter((item) => {
            return (item.members.length > 0 || item.type === 'grand sum') ? true : engine.matchIndexes(item.indexObject, filterObjects);
        });
    }
    matchIndexes(index, filterObjects) {
        const keys = Object.keys(index);
        let len = keys.length;
        if (len === 0) {
            return true;
        }
        while (len > -1) {
            if (filterObjects[index[keys[len]]] !== undefined) {
                return true;
            }
            len--;
        }
        return false;
    }
    performFilterAddition(headers, fields, headersInfo) {
        let count = 0;
        while (count < headers.length) {
            const levelName = headers[count].valueSort.levelName;
            if (this.headerObjectsCollection[levelName]) {
                const memberNameObj = {};
                for (const member of headers[count].members) {
                    memberNameObj[member.valueSort.levelName.toString()] = member.valueSort.levelName.toString();
                }
                const excessHeaders = this.headerObjectsCollection[levelName].filter((member) => {
                    return !memberNameObj[member.valueSort.levelName.toString()];
                });
                headers[count].members = headers[count].members.concat(excessHeaders);
                headers[count].members = this.getSortedHeaders(headers[count].members, this.fieldList[headersInfo.fields[headers[count].members[0].level].name].sort);
                delete this.headerObjectsCollection[levelName];
            }
            if (headers[count].members.length > 0) {
                headers[count].members = this.performFilterAddition(headers[count].members, fields, headersInfo);
            }
            count++;
        }
        return headers;
    }
    performFilterCommonUpdate(filterItem, headersInfo, addPos) {
        if (headersInfo.axis === 'row' || headersInfo.axis === 'column') {
            let rawHeaders = headersInfo.axis === 'row' ? this.rMembers : this.cMembers;
            const filterObjects = {};
            for (const item of this.filterMembers) {
                filterObjects[item] = item;
            }
            if (this.fieldFilterMem[filterItem.name]) {
                rawHeaders = this.performFilterDeletion(headersInfo.headers, filterItem, headersInfo, filterObjects, 0);
            }
            if (addPos.length > 0 && headersInfo.fields.length > 0) {
                this.frameHeaderObjectsCollection = true;
                if (headersInfo.fields.filter((item) => { return item.showNoDataItems; }).length > 0) {
                    for (let i = 0; i < this.data.length; i++) {
                        addPos.push(i);
                    }
                    //addPos = (this.data as any).map((item, pos) => { return pos; });
                }
                this.headerObjectsCollection['parent'] = this.getIndexedHeaders(headersInfo.fields, this.data, 0, addPos, headersInfo.axis, '');
                rawHeaders = this.performFilterAddition(rawHeaders, headersInfo.fields, headersInfo);
                const headerNames = {};
                for (const header of rawHeaders) {
                    headerNames[header.valueSort.levelName.toString()] = header.valueSort.levelName.toString();
                }
                const excessHeaders = this.headerObjectsCollection['parent'].filter((header) => {
                    return !headerNames[header.valueSort.levelName.toString()];
                });
                const grandHeader = rawHeaders.filter((item) => { return item.type === 'grand sum'; });
                if (grandHeader.length > 0) {
                    rawHeaders.pop();
                }
                rawHeaders = this.getSortedHeaders(rawHeaders.concat(excessHeaders), this.fieldList[headersInfo.fields[0].name].sort).concat(grandHeader);
                if (headersInfo.axis === 'row') {
                    this.cMembers = this.getIndexedHeaders(this.dataSourceSettings.columns, this.data, 0, this.filterMembers, 'column', '');
                    this.insertAllMember(this.cMembers, this.filterMembers, '', 'column');
                }
                else {
                    this.rMembers = this.getIndexedHeaders(this.dataSourceSettings.rows, this.data, 0, this.filterMembers, 'row', '');
                    this.insertAllMember(this.rMembers, this.filterMembers, '', 'row');
                }
            }
            if (headersInfo.axis === 'row') {
                this.rowCount = 0;
            }
            else {
                this.columnCount = 0;
            }
            this.updateHeadersCount(rawHeaders, headersInfo.axis, 0, headersInfo.fields, 'plus', false);
            if (headersInfo.axis === 'row') {
                if (headersInfo.position > 0) {
                    this.insertPosition(this.dataSourceSettings.rows, this.data, 0, this.filterMembers, 'row', '', rawHeaders);
                }
                this.insertTotalPosition(rawHeaders);
                this.rMembers = this.headerCollection.rowHeaders = rawHeaders;
                this.headerCollection.rowHeadersCount = this.rowCount;
            }
            else {
                if (headersInfo.position > 0) {
                    this.insertPosition(this.dataSourceSettings.columns, this.data, 0, this.filterMembers, 'column', '', rawHeaders);
                }
                this.insertTotalPosition(rawHeaders);
                this.cMembers = this.headerCollection.columnHeaders = rawHeaders;
                this.headerCollection.columnHeadersCount = this.columnCount;
            }
        }
        else {
            const showNoDataItems = (this.dataSourceSettings.rows[0] && this.dataSourceSettings.rows[0].showNoDataItems) || (this.dataSourceSettings.columns[0] && this.dataSourceSettings.columns[0].showNoDataItems);
            if (this.dataSourceSettings.rows.length > 0) {
                this.rMembers = this.getIndexedHeaders(this.dataSourceSettings.rows, this.data, 0, showNoDataItems ? addPos : this.filterMembers, 'row', '');
            }
            if (this.dataSourceSettings.columns.length > 0) {
                this.cMembers = this.getIndexedHeaders(this.dataSourceSettings.columns, this.data, 0, showNoDataItems ? addPos : this.filterMembers, 'column', '');
            }
            this.insertAllMembersCommon();
            this.rowCount = 0;
            this.columnCount = 0;
            this.updateHeadersCount(this.cMembers, 'column', 0, this.dataSourceSettings.columns, 'plus', false);
            this.updateHeadersCount(this.rMembers, 'row', 0, this.dataSourceSettings.rows, 'plus', false);
            if (showNoDataItems) {
                this.insertPosition(this.dataSourceSettings.rows, this.data, 0, this.filterMembers, 'row', '', this.rMembers);
                this.insertPosition(this.dataSourceSettings.columns, this.data, 0, this.filterMembers, 'column', '', this.cMembers);
            }
            this.headerCollection.rowHeaders = this.rMembers;
            this.headerCollection.rowHeadersCount = this.rowCount;
            this.headerCollection.columnHeaders = this.cMembers;
            this.headerCollection.columnHeadersCount = this.columnCount;
        }
        this.applyValueSorting();
    }
    getHeadersInfo(fieldName, axis) {
        this.rMembers = this.headerCollection.rowHeaders;
        this.cMembers = this.headerCollection.columnHeaders;
        axis = axis === '' ? this.getAxisByFieldName(fieldName) : axis;
        const headers = axis === 'row' ? this.rMembers : this.cMembers;
        const fields = axis === 'row' ? this.dataSourceSettings.rows : this.dataSourceSettings.columns;
        let position = 0;
        for (const field of fields) {
            if (field.name === fieldName) {
                break;
            }
            position++;
        }
        return { axis: axis, fields: fields, headers: headers, position: position };
    }
    /**
     * It performs the updating engine.
     *
     * @returns {void}
     * @hidden
     */
    updateEngine() {
        this.removeCount = 0;
        this.validateValueFields();
        this.calculatePagingValues();
        this.pivotValues = [];
        this.headerContent = [];
        this.valueContent = [];
        const rowheads = [];
        const colheads = [];
        const updatedRowMembers = [];
        const valuesCount = (this.dataSourceSettings.values.length); // eslint-disable-next-line max-len
        this.getAggregatedHeaders(this.dataSourceSettings.rows, this.dataSourceSettings.columns, this.rMembers, this.cMembers, this.dataSourceSettings.values);
        this.getHeaderData(// eslint-disable-next-line max-len
        this.dataSourceSettings.rows, this.dataSourceSettings.columns, this.dataSourceSettings.values, updatedRowMembers, this.cMembers, colheads, this.pivotValues, 0, this.valueAxis ? 1 : valuesCount);
        this.insertSubTotals();
        this.getTableData((updatedRowMembers.length > 0 ? updatedRowMembers : this.rMembers), rowheads, colheads, 0, this.pivotValues, valuesCount, 0, (this.rowGrandTotal ? this.rowGrandTotal : this.rMembers[this.rMembers.length - 1]), (this.columnGrandTotal ? this.columnGrandTotal : this.cMembers[this.cMembers.length - 1]));
        this.applyAdvancedAggregate(rowheads, colheads, this.pivotValues);
        this.isEngineUpdated = true;
        this.isEmptyDataAvail(this.rMembers, this.cMembers);
    }
    getAxisByFieldName(fieldName) {
        let axisCount = 0;
        let axis = '';
        while (axisCount < 4 && axis === '') {
            switch (axisCount) {
                case 0:
                    axis = this.getFieldByName(fieldName, this.dataSourceSettings.rows) ? 'row' : '';
                    break;
                case 1:
                    axis = this.getFieldByName(fieldName, this.dataSourceSettings.columns) ? 'column' : '';
                    break;
            }
            axisCount++;
        }
        return axis;
    }
    getFieldByName(fieldName, fields) {
        return new DataManager({ json: fields }).executeLocal(new Query().where('name', 'equal', fieldName))[0];
    }
    updateHeadersCount(headers, axis, position, fields, action, isDrill) {
        let lenCnt = 0;
        const field = fields[position];
        let showSubTotals = true;
        if (axis === 'column') {
            // showSubTotals = this.dataSourceSettings.showSubTotals && this.dataSourceSettings.showColumnSubTotals && field ? field.showSubTotals : true;
            showSubTotals = this.dataSourceSettings.showSubTotals && this.dataSourceSettings.showColumnSubTotals && field.showSubTotals;
        }
        else {
            // eslint-disable-next-line max-len
            showSubTotals = this.dataSourceSettings.showSubTotals && this.dataSourceSettings.showRowSubTotals && field ? field.showSubTotals : true;
        }
        while (lenCnt < headers.length) {
            if (axis === 'row') {
                this.rowCount = this.rowCount - (action === 'plus' ? -(this.valueAxis === 1 ? this.dataSourceSettings.values.length : 1) :
                    (this.valueAxis === 1 ? this.dataSourceSettings.values.length : 1));
            }
            else {
                this.columnCount = this.columnCount - (action === 'plus' ? -(this.valueAxis === 1 ? 1 : this.dataSourceSettings.values.length) :
                    (this.valueAxis === 1 ? 1 : this.dataSourceSettings.values.length));
            }
            if (headers[lenCnt].members.length > 0) {
                this.updateHeadersCount(headers[lenCnt].members, axis, position + 1, fields, action, true);
            }
            lenCnt++;
        }
        if (axis === 'column' && !showSubTotals && isDrill) {
            this.columnCount += action === 'plus' ? -this.colValuesLength : this.colValuesLength;
        }
    }
    /**
     * It performs to retrieve the sorted headers.
     *
     * @param {IAxisSet[]} headers - It cotains the headers data.
     * @param {string} sortOrder -  It cotains the ortOrder data
     * @returns {IAxisSet[]} - return sorted headers as IAxisSet[].
     * @hidden
     */
    getSortedHeaders(headers, sortOrder) {
        const fieldName = headers[0].actualText !== 'Grand Total' ? headers[0].valueSort.axis : headers[1].valueSort.axis;
        const isNotDateType = !(this.formatFields && this.formatFields[fieldName] &&
            this.formatFields[fieldName].type);
        const childrens = this.fieldList[fieldName];
        if (isNotDateType) {
            if (childrens && childrens.type === 'number' && headers.length > 0 && (typeof (headers[0].actualText) === 'string')) {
                const stringValue = [];
                let alphaNumbervalue = [];
                const nullValue = [];
                for (let i = 0; i < headers.length; i++) { // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    if (isNaN(headers[i].actualText.toString().charAt(0))) {
                        stringValue.push(headers[i]);
                    }
                    else if (headers[i].actualText === '') {
                        nullValue.push(headers[i]);
                    }
                    else {
                        alphaNumbervalue.push(headers[i]);
                        break;
                    }
                }
                if (alphaNumbervalue.length > 0) {
                    alphaNumbervalue = this.sortHeaders(fieldName, childrens, headers, childrens.sort, childrens.isAlphanumeric);
                }
                return headers;
            }
            else {
                return this.sortHeaders(fieldName, childrens, headers, sortOrder, childrens.type);
            }
        }
        else {
            return this.sortHeaders(fieldName, childrens, headers, sortOrder, childrens.type);
        }
    }
    sortHeaders(fieldName, childrens, sortMembersOrder, sortOrder, type) {
        let isHeaderSortByDefault = false;
        const membersInfo = this.fieldList[fieldName] && this.fieldList[fieldName].membersOrder ?
            [...this.fieldList[fieldName].membersOrder] : [];
        const sortDetails = {
            fieldName: fieldName,
            sortOrder: sortOrder,
            members: membersInfo && membersInfo.length > 0 ? membersInfo : Object.keys(childrens.members),
            IsOrderChanged: false
        };
        type = (type === 'datetime' || type === 'date' || type === 'time') ? (this.formatFields[fieldName] &&
            (['date', 'dateTime', 'time'].indexOf(this.formatFields[fieldName].type) > -1)) ? type : 'string' : type;
        const isDateType = (type === 'datetime' || type === 'date' || type === 'time');
        if (membersInfo && membersInfo.length > 0) {
            PivotUtil.applyCustomSort(sortDetails, sortMembersOrder, type);
        }
        else {
            PivotUtil.applyHeadersSort(sortMembersOrder, sortOrder, type);
            isHeaderSortByDefault = true;
        }
        if (isHeaderSortByDefault && this.getHeaderSortInfo) {
            const copyOrder = [];
            for (let m = 0, n = 0; m < sortMembersOrder.length; m++) {
                const member = sortMembersOrder[m];
                const sortText = isDateType ?
                    member.dateText : member.actualText;
                if (member.actualText !== 'Grand Total') {
                    copyOrder[n++] = sortText;
                }
            }
            sortDetails.members = copyOrder;
        }
        if (this.getHeaderSortInfo) {
            this.getHeaderSortInfo(sortDetails);
        }
        if (sortDetails.IsOrderChanged) {
            PivotUtil.applyCustomSort(sortDetails, sortMembersOrder, type, true);
        }
        return sortMembersOrder;
    }
    /**
     * It performs to applying  the value sorting.
     *
     * @param {IAxisSet[]} rMembers - It contains the row members data.
     * @param {IAxisSet[]} cMembers - It contains the column members data.
     * @returns {ISortedHeaders} - It return the sorted value as ISortedHeaders.
     * @hidden
     */
    applyValueSorting(rMembers, cMembers) {
        let isNullArgument = false;
        if (rMembers === undefined || cMembers === undefined) {
            this.valueSortHeaderText = undefined;
            if (this.enableValueSorting && this.valueSortSettings.headerText && !this.valueSortHeaderText &&
                this.valueSortSettings.headerText !== '' && this.dataSourceSettings.values.length > 0) {
                this.valueSortHeaderText = this.valueSortSettings.headerText;
                const textArray = this.valueSortHeaderText.split(this.valueSortSettings.headerDelimiter);
                for (const field of this.dataSourceSettings.values) {
                    const name = field.caption ? field.caption : field.name;
                    const valueIndex = textArray.indexOf(name);
                    if (valueIndex > -1) {
                        textArray.splice(valueIndex, 1);
                        textArray.push(name);
                        this.valueSortHeaderText = textArray.join(this.valueSortSettings.headerDelimiter);
                        break;
                    }
                }
            }
            rMembers = this.rMembers;
            cMembers = this.cMembers;
            isNullArgument = true;
        }
        if (this.valueSortHeaderText) {
            const textArray = this.valueSortHeaderText.split(this.valueSortSettings.headerDelimiter);
            let hText = '';
            let mIndex;
            let mType;
            let caption;
            for (let i = 0; i < this.dataSourceSettings.values.length; i++) {
                if (this.dataSourceSettings.values[i].caption === textArray[textArray.length - 1]) {
                    caption = this.dataSourceSettings.values[i].name;
                    break;
                }
                else {
                    caption = textArray[textArray.length - 1];
                }
            } // eslint-disable-next-line max-len
            if (((this.dataSourceSettings.values.length === 1 && this.dataSourceSettings.columns.length === 0) || this.dataSourceSettings.values.length > 1) &&
                caption && this.fieldList[caption]) {
                for (let i = 0; i < textArray.length - 1; i++) {
                    hText = hText === '' ? textArray[i] : (hText + this.valueSortSettings.headerDelimiter + textArray[i]);
                }
                mIndex = this.fieldList[caption].index;
                mType = this.fieldList[caption].aggregateType;
            }
            else {
                if (!this.dataSourceSettings.alwaysShowValueHeader || textArray.length === 1) {
                    hText = this.valueSortHeaderText;
                }
                else {
                    for (let i = 0; i < textArray.length - 1; i++) {
                        hText = hText === '' ? textArray[i] : (hText + this.valueSortSettings.headerDelimiter + textArray[i]);
                    }
                }
                mIndex = this.fieldList[this.dataSourceSettings.values[0].name].index;
                mType = this.fieldList[this.dataSourceSettings.values[0].name].aggregateType;
            }
            let member;
            if (this.valueAxis === 0) {
                member = this.getMember(cMembers, hText);
                if (member) {
                    rMembers = this.sortByValueRow(rMembers, member, this.valueSortSettings.sortOrder, mIndex, mType);
                }
            }
            else {
                member = this.getMember(rMembers, hText);
                if (member) {
                    cMembers = this.sortByValueRow(cMembers, member, this.valueSortSettings.sortOrder, mIndex, mType);
                }
            }
            if (isNullArgument) {
                this.rMembers = rMembers;
                this.cMembers = cMembers;
                if (this.isPagingOrVirtualizationEnabled) {
                    this.headerCollection.rowHeaders = this.rMembers;
                    this.headerCollection.columnHeaders = this.cMembers;
                }
            }
        }
        return { rMembers: rMembers, cMembers: cMembers };
    }
    getMember(cMembers, headerText) {
        const vlen = cMembers.length;
        let member;
        for (let j = 0; j < vlen; j++) {
            if (cMembers[j].valueSort.levelName === headerText) {
                member = cMembers[j];
                break;
            }
            else if (cMembers[j].members.length > 0) {
                member = this.getMember(cMembers[j].members, headerText);
            }
            if (member) {
                return member;
            }
        }
        return member;
    }
    sortByValueRow(rMembers, member, sortOrder, mIndex, mType) {
        const aggreColl = [];
        for (const header of rMembers) {
            if (header.type === 'grand sum') {
                aggreColl.push({ 'header': header });
            }
            else {
                this.rawIndexObject = {};
                let value = this.getAggregateValue(header.index, member.indexObject, mIndex, mType, false);
                const cellDetails = {
                    fieldName: this.fields[mIndex],
                    row: header,
                    column: member,
                    value: value,
                    cellSets: this.getValueCellInfo ? this.getCellSet(this.rawIndexObject) : [],
                    rowCellType: (header.hasChild && header.isDrilled ? 'subTotal' : header.type === 'grand sum' ? 'grandTotal' : 'value'),
                    columnCellType: (member.hasChild && member.isDrilled ? 'subTotal' : member.type === 'grand sum' ? 'grandTotal' : 'value'),
                    aggregateType: mType,
                    skipFormatting: false
                };
                if (this.getValueCellInfo) {
                    this.getValueCellInfo(cellDetails);
                }
                value = cellDetails.value;
                this.rawIndexObject = {};
                aggreColl.push({ 'header': header, 'value': value });
            }
        }
        aggreColl.sort((a, b) => {
            return sortOrder === 'Descending' ? ((b['value'] || b['header']['type'] === 'grand sum' ?
                b['value'] : 0) - (a['value'] || a['header']['type'] === 'grand sum' ? a['value'] : 0)) :
                ((a['value'] || a['header']['type'] === 'grand sum' ?
                    a['value'] : 0) - (b['value'] || b['header']['type'] === 'grand sum' ? b['value'] : 0));
        });
        rMembers = aggreColl.map((item) => { return item['header']; }); // eslint-disable-line @typescript-eslint/no-explicit-any
        for (const header of rMembers) {
            if (header.members.length > 0) {
                header.members = this.sortByValueRow(header.members, member, sortOrder, mIndex, mType);
            }
        }
        return rMembers;
    }
    insertAllMembersCommon() {
        this.rowGrandTotal = this.columnGrandTotal = null; // eslint-disable-next-line max-len
        const rowFlag = (this.dataSourceSettings.showGrandTotals && this.dataSourceSettings.showRowGrandTotals) ? true : (this.dataSourceSettings.rows.length > 0) ? false : true; // eslint-disable-next-line max-len
        const columnFlag = (this.dataSourceSettings.showGrandTotals && this.dataSourceSettings.showColumnGrandTotals) ? true : (this.dataSourceSettings.columns.length > 0) ? false : true;
        if (this.isValueHasAdvancedAggregate) {
            /* inserting the row grant-total members */
            this.insertAllMember(this.rMembers, this.filterMembers, '', 'row');
            if (rowFlag) {
                this.rowCount += this.rowValuesLength;
            }
            /* inserting the column gran-total members */
            this.insertAllMember(this.cMembers, this.filterMembers, '', 'column');
            if (columnFlag) {
                this.columnCount += this.colValuesLength;
            }
        }
        else {
            if (rowFlag) {
                /* inserting the row grant-total members */
                this.insertAllMember(this.rMembers, this.filterMembers, '', 'row');
                this.rowCount += this.rowValuesLength;
            }
            else {
                this.rowGrandTotal = this.insertAllMember([], this.filterMembers, '', 'row')[0];
            }
            if (columnFlag) {
                /* inserting the column gran-total members */
                this.insertAllMember(this.cMembers, this.filterMembers, '', 'column');
                this.columnCount += this.colValuesLength;
            }
            else {
                this.columnGrandTotal = this.insertAllMember([], this.filterMembers, '', 'column')[0];
            }
        }
    }
    insertSubTotals() {
        const rowLength = this.pivotValues.length;
        for (let rowCnt = 0; rowCnt < rowLength; rowCnt++) {
            const rowCells = this.pivotValues[rowCnt];
            if (rowCells) {
                let savedCell;
                let spanCnt = 1;
                const colLength = rowCells.length;
                let indexObj;
                let startIndex = 1;
                const lastIndex = this.showSubTotalsAtTop ? this.reformAxisCount : colLength;
                let colCnt = this.showSubTotalsAtTop ? startIndex : lastIndex - 1;
                let columnSpan;
                let memberCnt;
                while (startIndex < lastIndex) {
                    const cell = rowCells[colCnt];
                    if (cell) {
                        // if (cell.rowSpan > 1) {
                        //     cell.rowSpan = 1;
                        // }
                        if (savedCell) {
                            savedCell.colSpan = spanCnt;
                            savedCell.colIndex = this.showSubTotalsAtTop ? savedCell.colIndex + (spanCnt - 1) :
                                savedCell.colIndex - (spanCnt - 1);
                        }
                        if (this.showSubTotalsAtTop) {
                            columnSpan = memberCnt = this.getMemberSpanCount(this.pivotValues[rowCnt], colCnt);
                        }
                        indexObj = { index: cell.index, indexObject: cell.indexObject };
                        cell.index = [];
                        cell.indexObject = {};
                        savedCell = extend({}, cell, null, true);
                        cell.index = indexObj.index;
                        cell.indexObject = indexObj.indexObject;
                        let rowPos = rowCnt + 1;
                        while (this.pivotValues[rowPos] && !this.pivotValues[rowPos][colCnt]) {
                            const curentCell = this.pivotValues[rowCnt][colCnt];
                            if (!curentCell.isDrilled && !(!this.valueAxis && !this.isLastHeaderHasMeasures && (curentCell.members
                                && curentCell.members.length > 0 && rowPos > this.measureIndex))) {
                                curentCell.rowSpan = (rowPos - rowCnt) + 1;
                                savedCell.rowSpan = (rowPos - rowCnt) + 1;
                            }
                            const cellType = (cell.type === 'sum' || cell.type === 'grand sum') ? cell.type : 'sum';
                            this.pivotValues[rowPos][colCnt] =
                                this.headerContent[rowPos][colCnt] = {
                                    type: cellType, formattedText: ((cell.type === 'sum' || cell.type === 'grand sum') ? cell.formattedText :
                                        (cell.formattedText + ' Total')), axis: 'column', hierarchyName: cell.hierarchyName,
                                    level: -1, colIndex: colCnt, rowIndex: rowPos, valueSort: cell.valueSort
                                };
                            if (cell.valueSort && cell.valueSort[this.valueSortSettings.headerText]) {
                                this.valueSortSettings.columnIndex = colCnt;
                            }
                            let isSpanned = false;
                            if (cellType === 'grand sum') {
                                curentCell.rowSpan = (rowPos - rowCnt) + 1;
                                savedCell.rowSpan = (rowPos - rowCnt) + 1;
                            }
                            else if (curentCell.type !== 'sum' && (curentCell.isDrilled || (this.valueAxisFields[curentCell.actualText] &&
                                !this.valueAxis && !this.isLastHeaderHasMeasures && curentCell.members && curentCell.members.length > 0))) {
                                this.pivotValues[rowCnt + 1][colCnt].rowSpan = rowPos - rowCnt;
                                isSpanned = true;
                            }
                            else {
                                this.pivotValues[rowPos][colCnt].rowSpan = -1;
                            }
                            if (rowPos > (rowCnt + 1) && (curentCell.type === 'sum' ||
                                isSpanned)) {
                                this.pivotValues[rowPos][colCnt].rowSpan = -1;
                            }
                            rowPos++;
                        }
                        spanCnt = 1;
                    }
                    else {
                        rowCells[colCnt] =
                            this.headerContent[rowCnt][colCnt] = extend({}, savedCell, null, true);
                        rowCells[colCnt].index =
                            this.headerContent[rowCnt][colCnt].index = indexObj.index;
                        rowCells[colCnt].indexObject =
                            this.headerContent[rowCnt][colCnt].indexObject = indexObj.indexObject;
                        spanCnt++;
                        if (this.showSubTotalsAtTop) {
                            memberCnt--;
                            rowCells[colCnt].colSpan = memberCnt;
                            rowCells[colCnt].colIndex = rowCells[colCnt].colIndex + (spanCnt - 1);
                        }
                        else {
                            rowCells[colCnt].colSpan = spanCnt;
                            rowCells[colCnt].colIndex = rowCells[colCnt].colIndex - (spanCnt - 1);
                        }
                    }
                    if (colCnt === 1 && savedCell) {
                        if (this.showSubTotalsAtTop) {
                            savedCell.colSpan = columnSpan;
                            savedCell.colIndex = savedCell.colIndex + (spanCnt - 1);
                        }
                        else {
                            savedCell.colSpan = spanCnt;
                            savedCell.colIndex = savedCell.colIndex - (spanCnt - 1);
                        }
                    }
                    if (this.showSubTotalsAtTop && (rowCells[colCnt + 1] || colCnt + 1 === this.reformAxisCount)) {
                        const cell = this.pivotValues[rowCnt][(colCnt - spanCnt) + 1];
                        cell.colSpan = columnSpan;
                        this.pivotValues[rowCnt][(colCnt - spanCnt) + 1] = cell;
                    }
                    colCnt = this.showSubTotalsAtTop ? colCnt + 1 : colCnt - 1;
                    startIndex++;
                }
            }
        }
    }
    getMemberSpanCount(rowCellArray, cellIndex) {
        let colIndex = 1;
        for (let i = cellIndex + 1; i < this.reformAxisCount; i++) {
            if (!rowCellArray[i]) {
                colIndex++;
            }
            else {
                break;
            }
        }
        return colIndex;
    }
    frameDrillObject(vDrilledItem = null) {
        this.fieldDrillCollection = {};
        for (let fieldCnt = 0; fieldCnt < this.drilledMembers.length; fieldCnt++) {
            const drillOption = this.drilledMembers[fieldCnt];
            let hasValueField = false;
            let levelCount = 1;
            let isFieldAvail = false;
            const field = this.fieldList[drillOption.name];
            const isDrillMemberExpand = (field && field.expandAll);
            for (let i = 0; i < this.dataSourceSettings.rows.length; i++) {
                if (this.dataSourceSettings.rows[i].name === drillOption.name) { // eslint-disable-next-line max-len
                    const hasMeasureIndex = this.valueAxis && (this.isMultiMeasures || this.dataSourceSettings.alwaysShowValueHeader) &&
                        this.measureIndex > -1 && this.measureIndex <= i;
                    levelCount = (hasMeasureIndex ? (i + 1) : i) + 1;
                    hasValueField = hasMeasureIndex ? true : false;
                    isFieldAvail = true;
                    break;
                }
            }
            if (!isFieldAvail) {
                for (let i = 0; i < this.dataSourceSettings.columns.length; i++) {
                    if (this.dataSourceSettings.columns[i].name === drillOption.name) { // eslint-disable-next-line max-len
                        const hasMeasureIndex = !this.valueAxis && (this.isMultiMeasures || this.dataSourceSettings.alwaysShowValueHeader) &&
                            this.measureIndex > -1 && this.measureIndex <= i;
                        levelCount = (hasMeasureIndex ? (i + 1) : i) + 1;
                        hasValueField = hasMeasureIndex ? true : false;
                        isFieldAvail = true;
                        break;
                    }
                }
            }
            for (const drilledItem of drillOption.items) {
                let members = drilledItem.split(drillOption.delimiter);
                if (levelCount === members.length) {
                    let memberString = drillOption.name + this.valueSortSettings.headerDelimiter +
                        members.join(this.valueSortSettings.headerDelimiter);
                    this.fieldDrillCollection[memberString] = memberString;
                    if (hasValueField) {
                        let isAllValuesAvail = false;
                        if (this.isExpandAll || isDrillMemberExpand) {
                            for (const field of this.dataSourceSettings.values) {
                                const name = field.caption ? field.caption : field.name;
                                members[this.measureIndex] = name;
                                if (drillOption.items.indexOf(members.join(drillOption.delimiter)) > -1) {
                                    isAllValuesAvail = true;
                                }
                                else {
                                    isAllValuesAvail = false;
                                    break;
                                }
                            }
                        }
                        if (((this.isExpandAll || isDrillMemberExpand) && isAllValuesAvail) || !this.isExpandAll || !isDrillMemberExpand) {
                            members = drilledItem.split(drillOption.delimiter);
                            members.splice(this.measureIndex, 1);
                            if (vDrilledItem && vDrilledItem.memberName === drilledItem) {
                                vDrilledItem.memberName = members.join(drillOption.delimiter);
                            }
                            memberString = drillOption.name + this.valueSortSettings.headerDelimiter +
                                members.join(this.valueSortSettings.headerDelimiter);
                            this.fieldDrillCollection[memberString] = memberString;
                        }
                    }
                }
            }
        }
    }
    getIndexedHeaders(keys, data, keyInd, position, axis, parentMember, valueFil) {
        const hierarchy = [];
        if (keys && keys.length > 0) {
            const rlen = keys.length;
            const decisionObj = {};
            const fieldName = keys[keyInd].name;
            const field = keys[keyInd];
            // let members: string[] = Object.keys(this.fieldList[field].members);
            const childrens = this.fieldList[fieldName];
            if (isNullOrUndefined(this.reportDataType)) {
                this.reportDataType = {};
                for (let i = 0; i < this.dataSourceSettings.rows.length; i++) {
                    this.reportDataType[this.dataSourceSettings.rows[i].name] =
                        this.dataSourceSettings.rows[i].dataType;
                }
                for (let i = 0; i < this.dataSourceSettings.columns.length; i++) {
                    this.reportDataType[this.dataSourceSettings.columns[i].name] =
                        this.dataSourceSettings.columns[i].dataType;
                }
                for (let i = 0; i < this.dataSourceSettings.values.length; i++) {
                    this.reportDataType[this.dataSourceSettings.values[i].name] =
                        this.dataSourceSettings.values[i].dataType;
                }
            }
            childrens.type = !isNullOrUndefined(this.reportDataType[childrens.id]) ? this.reportDataType[childrens.id] : childrens.type;
            let isNoData = false;
            const isDateType = (this.formatFields[fieldName] &&
                (['date', 'dateTime', 'time'].indexOf(this.formatFields[fieldName].type) > -1));
            const showNoDataItems = (position.length < 1 && keyInd > 0) || field.showNoDataItems;
            const savedMembers = {};
            if (showNoDataItems) {
                const members = Object.keys(childrens.members);
                for (let pos = 0, lt = members.length; pos < lt; pos++) {
                    if (this.dataSourceSettings.showHeaderWhenEmpty ||
                        (this.localeObj && members[pos] !== this.localeObj.getConstant('undefined'))) {
                        savedMembers[members[pos]] = members[pos];
                    }
                }
                if (position.length < 1) {
                    isNoData = true;
                    position.length = members.length;
                }
            }
            for (let pos = 0, lt = position.length; pos < lt; pos++) {
                const member = {};
                if (!isNullOrUndefined(keys[keyInd].showSubTotals) && !keys[keyInd].showSubTotals) {
                    member.showSubTotals = false;
                }
                member.hasChild = keyInd < rlen - 1;
                member.level = keyInd;
                member.axis = axis;
                member.colSpan = 1;
                const memInd = isNoData ? childrens.members[Object.keys(savedMembers)[0]].ordinal :
                    this.indexMatrix[position[pos]][childrens.index];
                let headerValue = isNoData ? Object.keys(savedMembers)[0] : // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    data[position[pos]][this.fieldKeys[fieldName]];
                headerValue = this.enableHtmlSanitizer ? SanitizeHtmlHelper.sanitize(headerValue) : headerValue;
                if ((isNullOrUndefined(headerValue) || (this.localeObj && headerValue === this.localeObj.getConstant('undefined')))
                    && !this.dataSourceSettings.showHeaderWhenEmpty) {
                    if (showNoDataItems && !isNoData && keyInd > 0 && pos + 1 === position.length &&
                        Object.keys(savedMembers).length > 0) {
                        lt = Object.keys(savedMembers).length;
                        isNoData = true;
                        pos = -1;
                    }
                    continue;
                }
                delete savedMembers[headerValue];
                if (showNoDataItems && this.fieldFilterMem[fieldName] &&
                    this.fieldFilterMem[fieldName].memberObj[headerValue] === headerValue) {
                    continue;
                }
                const formattedValue = isDateType || this.formatFields[fieldName] ? {
                    actualText: headerValue,
                    formattedText: childrens.dateMember[memInd - 1].formattedText,
                    dateText: childrens.dateMember[memInd - 1].actualText
                } : {
                    formattedText: headerValue === null ? (this.localeObj ? this.localeObj.getConstant('null') : String(headerValue)) :
                        headerValue === undefined ? (this.localeObj ? (fieldName in this.groupingFields) ?
                            this.localeObj.getConstant('groupOutOfRange') : this.localeObj.getConstant('undefined') :
                            String(headerValue)) : String(headerValue), actualText: headerValue === null ? (this.localeObj ?
                        this.localeObj.getConstant('null') : String(headerValue)) : headerValue === undefined ?
                        (this.localeObj ? (fieldName in this.groupingFields) ? this.localeObj.getConstant('groupOutOfRange') :
                            this.localeObj.getConstant('undefined') : String(headerValue)) : headerValue
                };
                member.actualText = formattedValue.actualText;
                member.formattedText = formattedValue.formattedText;
                if (isDateType) {
                    member.dateText = formattedValue.dateText;
                }
                const availData = showNoDataItems ? (this.filterPosObj[position[pos]] !== undefined &&
                    !isNoData ? true : false) : true;
                //member.name = members[memInd as number];
                // member.type = member.hasChild ? 'All' : 'Single';
                if (!(decisionObj && decisionObj[memInd])) {
                    decisionObj[memInd] = { index: [], indexObject: {} };
                    member.index = decisionObj[memInd].index;
                    member.indexObject = decisionObj[memInd].indexObject;
                    if (availData) {
                        member.index = decisionObj[memInd].index = [position[pos]];
                        decisionObj[memInd].indexObject[position[pos]] = position[pos];
                        member.indexObject = decisionObj[memInd].indexObject;
                    }
                    member.ordinal = memInd;
                    member.valueSort = {};
                    member.valueSort.axis = fieldName;
                    if (keyInd !== 0) {
                        member.valueSort.levelName = parentMember + this.valueSortSettings.headerDelimiter + member.formattedText;
                        member.valueSort[parentMember + this.valueSortSettings.headerDelimiter + member.formattedText] = 1;
                        member.valueSort.uniqueName = parentMember + this.valueSortSettings.headerDelimiter +
                            (member.actualText ? member.actualText : member.formattedText);
                        member.valueSort[parentMember + this.valueSortSettings.headerDelimiter + (member.actualText ?
                            member.actualText : member.formattedText)] = 1;
                    }
                    else {
                        member.valueSort[member.formattedText] = 1;
                        member.valueSort.levelName = member.formattedText;
                        member.valueSort[member.actualText ? member.actualText : member.formattedText] = 1;
                        member.valueSort.uniqueName = (member.actualText ? member.actualText : member.formattedText);
                    }
                    const memberString = member.valueSort.axis + this.valueSortSettings.headerDelimiter + member.valueSort.levelName;
                    const isExpandMember = this.isExpandAll || (field && field.expandAll);
                    member.isDrilled = (valueFil && this.isValueFiltersAvail) ? true :
                        (member.hasChild && this.fieldDrillCollection[memberString]) ?
                            isExpandMember ? false : true : isExpandMember;
                    //if (!member.members) {
                    member.members = [];
                    //}
                    //let copyObj: AxisSet = Object.create(member);
                    hierarchy.push(member);
                }
                else if (availData) {
                    decisionObj[memInd].index.push(position[pos]);
                    decisionObj[memInd].indexObject[position[pos]] = position[pos];
                }
                if (showNoDataItems && !isNoData && keyInd > 0 && pos + 1 === position.length &&
                    Object.keys(savedMembers).length > 0) {
                    isNoData = true;
                    lt = Object.keys(savedMembers).length;
                    pos = -1;
                }
            }
            if (axis === this.dataSourceSettings.valueAxis && this.measureIndex === keyInd &&
                (this.dataSourceSettings.values.length > 1 || this.dataSourceSettings.alwaysShowValueHeader)) {
                this.isLastHeaderHasMeasures = false;
            }
            for (let iln = 0, ilt = hierarchy.length; iln < ilt; iln++) {
                if (!this.frameHeaderObjectsCollection) {
                    if (axis === 'row') {
                        this.rowCount += this.rowValuesLength;
                    }
                    else {
                        this.columnCount += this.colValuesLength;
                    }
                }
                let level = null;
                if (hierarchy[iln].valueSort && hierarchy[iln].valueSort.levelName) {
                    level = hierarchy[iln].valueSort.levelName;
                }
                parentMember = (level || hierarchy[iln].formattedText);
                if (!this.dataSourceSettings.showHeaderWhenEmpty && rlen - 1 > keyInd && hierarchy[iln].index &&
                    hierarchy[iln].index.length > 0) {
                    if (showNoDataItems && keys[keyInd + 1] && keys[keyInd + 1].name &&
                        Object.keys(this.fieldList[keys[keyInd + 1].name].members).length > 0) {
                        hierarchy[iln].hasChild = true;
                    }
                    else {
                        const hIndLen = hierarchy[iln].index.length;
                        let count = 0;
                        for (let len = 0; len < hIndLen; len++) {
                            // eslint-disable-next-line @typescript-eslint/no-explicit-any, max-len
                            const headerValue = data[hierarchy[iln].index[len]][this.fieldKeys[keys[keyInd + 1].name]];
                            if ((isNullOrUndefined(headerValue) || (this.localeObj &&
                                headerValue === this.localeObj.getConstant('undefined')))) {
                                count++;
                            }
                        }
                        hierarchy[iln].hasChild = count !== hIndLen;
                    }
                }
                if (rlen - 1 > keyInd && hierarchy[iln].isDrilled) {
                    this.columnCount -= (!(this.dataSourceSettings.showSubTotals && this.dataSourceSettings.showColumnSubTotals && field.showSubTotals) && axis === 'column') ?
                        this.colValuesLength : 0;
                    const filterPosition = hierarchy[iln].index;
                    hierarchy[iln].members = this.getIndexedHeaders(keys, data, keyInd + 1, (filterPosition === undefined ? [] : filterPosition), axis, parentMember, valueFil);
                    if (this.frameHeaderObjectsCollection) {
                        this.headerObjectsCollection[parentMember] = hierarchy[iln].members;
                    }
                }
            }
            if (this.enableSort) {
                // return new DataManager(hierarchy as JSON[]).executeLocal(new Query().sortBy('actualText', childrens.sort.toLowerCase()));
                if (isDateType) {
                    return this.sortHeaders(fieldName, childrens, hierarchy, childrens.sort, 'date');
                }
                else {
                    if (childrens.type === 'number' && hierarchy.length > 0 && (typeof (hierarchy[0].actualText) === 'string') && hierarchy[0].actualText.match(/[a-zA-Z]+/g)) {
                        const stringValue = [];
                        let outOfRange;
                        const alphaNumbervalue = [];
                        const nullValue = [];
                        for (let i = 0; i < hierarchy.length; i++) {
                            if (isNaN(hierarchy[i].actualText.toString().charAt(0))) { // eslint-disable-line @typescript-eslint/no-explicit-any
                                stringValue.push(hierarchy[i]);
                                if (!outOfRange && childrens.sort !== 'None') {
                                    if (hierarchy[i].actualText === 'Out of Range') {
                                        outOfRange = hierarchy[i];
                                        hierarchy.splice(i, 1);
                                    }
                                }
                            }
                            else if (hierarchy[i].actualText === '') {
                                nullValue.push(hierarchy[i]);
                            }
                            else {
                                this.fieldList[fieldName].isAlphanumeric = true;
                                alphaNumbervalue.push(hierarchy[i]);
                                break;
                            }
                        }
                        if (outOfRange) {
                            if (childrens.sort === 'Ascending') {
                                if (hierarchy[0].actualText === 'Grand Total') {
                                    hierarchy.splice(1, 0, outOfRange);
                                }
                                else {
                                    hierarchy.splice(0, 0, outOfRange);
                                }
                            }
                            else {
                                if (hierarchy[hierarchy.length - 1].actualText === 'Grand Total') {
                                    hierarchy.splice(hierarchy.length - 1, 0, outOfRange);
                                }
                                else {
                                    hierarchy.splice(hierarchy.length, 0, outOfRange);
                                }
                            }
                        }
                        if (alphaNumbervalue.length > 0) {
                            this.sortHeaders(fieldName, childrens, hierarchy, childrens.sort, childrens.isAlphanumeric);
                        }
                        return hierarchy;
                    }
                    else {
                        return this.sortHeaders(fieldName, childrens, hierarchy, childrens.sort, childrens.type);
                    }
                }
            }
            else {
                return hierarchy;
            }
        }
        else {
            return hierarchy;
        }
    }
    getOrderedIndex(headers) {
        const orderedIndex = {};
        for (let i = 0; i < headers.length; i++) {
            if (headers[i].type !== 'grand sum') {
                orderedIndex[headers[i].ordinal] = i;
            }
        }
        return orderedIndex;
    }
    insertPosition(keys, data, keyInd, position, axis, parentMember, slicedHeaders) {
        const hierarchy = [];
        const orderedIndex = this.getOrderedIndex(slicedHeaders);
        if (keys) {
            const decisionObj = {};
            const field = keys[keyInd].name;
            const childrens = this.fieldList[field];
            for (let pos = 0, lt = position.length; pos < lt; pos++) {
                const member = {};
                const memInd = this.indexMatrix[position[pos]][childrens.index];
                const slicedHeader = slicedHeaders[orderedIndex[memInd]]; // eslint-disable-next-line @typescript-eslint/no-explicit-any
                let value = data[position[pos]][this.fieldKeys[field]];
                value = value === null ? (this.localeObj ? this.localeObj.getConstant('null') : String(value)) : value;
                const formattedValue = (this.formatFields[field] &&
                    (['date', 'dateTime', 'time'].indexOf(this.formatFields[field].type) > -1)) ?
                    this.getFormattedValue(value, field) : { formattedText: value.toString(), actualText: value.toString() };
                if (!(slicedHeader && slicedHeader.formattedText === formattedValue.formattedText)) {
                    continue;
                }
                if (!(decisionObj && decisionObj[memInd])) {
                    decisionObj[memInd] = { index: [], indexObject: {} };
                    slicedHeader.index = decisionObj[memInd].index = [position[pos]];
                    decisionObj[memInd].indexObject[position[pos]] = position[pos];
                    slicedHeader.indexObject = decisionObj[memInd].indexObject;
                    slicedHeader.valueSort = {};
                    slicedHeader.valueSort.axis = field;
                    if (keyInd !== 0) {
                        slicedHeader.valueSort.levelName = parentMember + this.valueSortSettings.headerDelimiter +
                            slicedHeader.formattedText;
                        slicedHeader.valueSort[parentMember + this.valueSortSettings.headerDelimiter +
                            slicedHeader.formattedText] = 1;
                        slicedHeader.valueSort.uniqueName = parentMember + this.valueSortSettings.headerDelimiter +
                            (slicedHeader.actualText ? slicedHeader.actualText : slicedHeader.formattedText);
                        slicedHeader.valueSort[parentMember + this.valueSortSettings.headerDelimiter +
                            (slicedHeader.actualText ? slicedHeader.actualText : slicedHeader.formattedText)] = 1;
                    }
                    else {
                        slicedHeader.valueSort[slicedHeader.formattedText] = 1;
                        slicedHeader.valueSort.levelName = slicedHeader.formattedText;
                        slicedHeader.valueSort[(slicedHeader.actualText ? slicedHeader.actualText : slicedHeader.formattedText)] = 1;
                        slicedHeader.valueSort.uniqueName =
                            (slicedHeader.actualText ? slicedHeader.actualText : slicedHeader.formattedText);
                    }
                    member.members = [];
                    hierarchy.push(member);
                }
                else {
                    decisionObj[memInd].index.push(position[pos]);
                    decisionObj[memInd].indexObject[position[pos]] = position[pos];
                }
            }
            let diff = slicedHeaders.length - hierarchy.length;
            while (diff > 0) {
                hierarchy.push({ members: [] });
                diff--;
            }
            for (let iln = 0, ilt = hierarchy.length; iln < ilt; iln++) {
                if (slicedHeaders[iln].members.length > 0) {
                    let level = null;
                    if (slicedHeaders[iln].valueSort && slicedHeaders[iln].valueSort.levelName) {
                        level = slicedHeaders[iln].valueSort.levelName;
                    }
                    parentMember = (level || slicedHeaders[iln].formattedText);
                    hierarchy[iln].members = this.insertPosition(keys, data, keyInd + 1, slicedHeaders[iln].index, axis, parentMember, slicedHeaders[iln].members);
                }
            }
            return hierarchy;
        }
        else {
            return hierarchy;
        }
    }
    insertTotalPosition(headers) {
        const summCell = headers[headers.length - 1];
        if (summCell && summCell.type === 'grand sum') {
            summCell.index = this.filterMembers;
            summCell.indexObject = {};
            for (let ln = 0, lt = this.filterMembers.length; ln < lt; ln++) {
                summCell.indexObject[this.filterMembers[ln]] = this.filterMembers[ln];
            }
        }
        return headers;
    }
    calculatePagingValues() {
        if (this.isPagingOrVirtualizationEnabled) {
            if (this.valueAxis === 1) {
                this.rowValuesLength = this.dataSourceSettings.values.length;
            }
            else {
                this.colValuesLength = this.dataSourceSettings.values.length;
            }
            this.columnPageCount = Math.ceil(this.columnCount / this.pageSettings.columnPageSize);
            this.rowPageCount = Math.ceil(this.rowCount / this.pageSettings.rowPageSize);
            this.pageSettings.currentColumnPage = this.pageSettings.currentColumnPage >= this.columnPageCount ? this.columnPageCount :
                this.pageSettings.currentColumnPage;
            this.pageSettings.currentRowPage = this.pageSettings.currentRowPage >= this.rowPageCount ? this.rowPageCount :
                this.pageSettings.currentRowPage;
            const requirePageCount = this.enablePaging ? 1 : 3;
            this.memberCnt = this.enablePaging ? 0 : -this.rowValuesLength;
            this.rowStartPos = ((this.pageSettings.currentRowPage * this.pageSettings.rowPageSize) -
                (this.pageSettings.rowPageSize)) * (this.enablePaging ? 1 : this.rowValuesLength) + (this.enablePaging ? 1 : 0);
            let exactStartPos = this.enablePaging ? this.rowStartPos :
                (this.rowStartPos + (this.pageSettings.rowPageSize * requirePageCount * this.rowValuesLength)) > this.rowCount ?
                    (this.rowCount - (this.pageSettings.rowPageSize * requirePageCount * this.rowValuesLength)) : this.rowStartPos;
            if (exactStartPos < 0) {
                exactStartPos = this.rowStartPos = 0;
                this.pageSettings.currentRowPage = 1;
            }
            this.rowFirstLvl = (this.rowStartPos - exactStartPos) % this.pageSettings.rowPageSize;
            this.rowStartPos = exactStartPos;
            this.endPos = this.rowStartPos + (this.pageSettings.rowPageSize * requirePageCount * (this.enablePaging ? 1 :
                this.rowValuesLength)) - (this.enablePaging ? 1 : 0);
            this.endPos = this.endPos > (this.rowCount + 1) ? (this.rowCount + 1) : this.endPos;
            this.rMembers = this.performSlicing(this.rMembers, [], this.rowStartPos, 'row');
            this.memberCnt = this.enablePaging ? 0 : -this.colValuesLength;
            this.pageInLimit = false;
            this.colHdrBufferCalculated = false;
            this.colStartPos = ((this.pageSettings.currentColumnPage * this.pageSettings.columnPageSize) -
                (this.pageSettings.columnPageSize)) * (this.enablePaging ? 1 : this.colValuesLength) + (this.enablePaging ? 1 : 0);
            exactStartPos = this.enablePaging ? this.colStartPos : (this.colStartPos + (this.pageSettings.columnPageSize *
                requirePageCount * this.colValuesLength)) > this.columnCount ? (this.columnCount - (this.pageSettings.columnPageSize *
                requirePageCount * this.colValuesLength)) : this.colStartPos;
            if (exactStartPos < 0) {
                exactStartPos = this.colStartPos = 0;
                this.pageSettings.currentColumnPage = 1;
            }
            this.colFirstLvl = (this.colStartPos - exactStartPos) % this.pageSettings.columnPageSize;
            this.colStartPos = exactStartPos;
            this.endPos = this.colStartPos + (this.pageSettings.columnPageSize * requirePageCount *
                (this.enablePaging ? 1 : this.colValuesLength)) - (this.enablePaging ? 1 : 0);
            this.endPos = this.endPos > (this.columnCount + 1) ? (this.columnCount + 1) : this.endPos;
            this.cMembers = this.performSlicing(this.cMembers, [], this.colStartPos, 'column');
            this.memberCnt = -1;
            this.pageInLimit = false;
            if (this.isValueHasAdvancedAggregate) {
                if (this.rMembers[this.rMembers.length - 1].type !== 'grand sum' &&
                    this.headerCollection.rowHeaders[this.headerCollection.rowHeaders.length - 1].type === 'grand sum') {
                    this.rMembers.push(this.headerCollection.rowHeaders[this.headerCollection.rowHeaders.length - 1]);
                    this.removeRowGrandTotal = true;
                }
                if (this.cMembers[this.cMembers.length - 1].type !== 'grand sum' &&
                    this.headerCollection.columnHeaders[this.headerCollection.columnHeaders.length - 1].type === 'grand sum') {
                    this.cMembers.push(this.headerCollection.columnHeaders[this.headerCollection.columnHeaders.length - 1]);
                    this.removeColumnGrandTotal = true;
                }
            }
            else {
                this.rowGrandTotal = this.rowGrandTotal ? this.rowGrandTotal :
                    this.headerCollection.rowHeaders[this.headerCollection.rowHeaders.length - 1];
                this.columnGrandTotal = this.columnGrandTotal ? this.columnGrandTotal :
                    this.headerCollection.columnHeaders[this.headerCollection.columnHeaders.length - 1];
            }
        }
    }
    performSlicing(headers, slicedHeaders, startPos, axis) {
        let pos = 0;
        while (headers[pos]) {
            if (this.enablePaging && this.endPos <= this.memberCnt && pos !== 0) {
                break;
            }
            this.memberCnt += headers[pos].level <= this.measureIndex ? (axis === 'column' ? this.colValuesLength : this.rowValuesLength) : 1;
            if (startPos <= this.memberCnt && this.endPos >= this.memberCnt && !this.pageInLimit) {
                if (axis === 'column') {
                    this.colFirstLvl = this.colFirstLvl + headers[pos].level;
                }
                else {
                    this.rowFirstLvl = this.rowFirstLvl + headers[pos].level;
                }
                this.isParentLevelAdded = axis === 'column' ? (this.colFirstLvl > 0 ? false : true) : (this.rowFirstLvl > 0 ? false : true);
                this.pageInLimit = true;
            }
            if (this.pageInLimit && !this.enablePaging) {
                if (this.endPos <= this.memberCnt) {
                    if (axis === 'column') {
                        if (headers[pos].members.length === 0) {
                            if (this.colHdrBufferCalculated) {
                                break;
                            }
                            this.colHdrBufferCalculated = true;
                            this.endPos += (headers[pos].level * this.colValuesLength);
                        }
                        else if (this.colHdrBufferCalculated) {
                            break;
                        }
                    }
                    else {
                        break;
                    }
                }
            }
            slicedHeaders.push(headers[pos].members.length > 0 ?
                this.removeChildMembers(headers[pos]) : headers[pos]);
            if (headers[pos].members.length > 0) {
                if (axis === 'column') {
                    this.memberCnt -= !(this.dataSourceSettings.showSubTotals && this.dataSourceSettings.showColumnSubTotals && // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        this.columnKeys[headers[pos].valueSort.axis].showSubTotals) ? this.colValuesLength : 0;
                }
                else if (this.showSubTotalsAtBottom) {
                    this.memberCnt++;
                }
                slicedHeaders[slicedHeaders.length - 1].members =
                    this.performSlicing(headers[pos].members, [], startPos, axis);
            }
            if (!this.isParentLevelAdded && this.enablePaging) {
                this.memberCnt += (slicedHeaders[slicedHeaders.length - 1].level <= this.measureIndex ?
                    (axis === 'column' ? this.colValuesLength : this.rowValuesLength) : 1) * slicedHeaders[slicedHeaders.length - 1].level;
                this.isParentLevelAdded = true;
            }
            if (!this.pageInLimit) {
                slicedHeaders.pop();
            }
            if (headers[pos].level === 0 && this.pageInLimit && this.endPos <= this.memberCnt) {
                break;
            }
            pos++;
        }
        return slicedHeaders;
    } /* eslint-disable @typescript-eslint/no-explicit-any */
    removeChildMembers(member) {
        const keys = Object.keys(member);
        let keyPos = 0;
        const framedMember = {};
        while (keyPos < keys.length) {
            framedMember[keys[keyPos]] = member[keys[keyPos]];
            if (keys[keyPos] === 'members') {
                framedMember['members'] = [];
            }
            keyPos++;
        }
        return framedMember;
    } /* eslint-enable @typescript-eslint/no-explicit-any */
    insertAllMember(set, filter, customText, axis) {
        const len = set.length;
        customText = ' Total';
        const grandTotalSet = {
            hasChild: false,
            index: filter,
            level: 0,
            axis: axis,
            isDrilled: false,
            indexObject: {},
            members: [],
            actualText: 'Grand' + customText,
            formattedText: 'Grand' + customText,
            ordinal: len,
            type: 'grand sum',
            valueSort: {}
        };
        grandTotalSet.valueSort[grandTotalSet.formattedText] = 1;
        grandTotalSet.valueSort.levelName = grandTotalSet.formattedText;
        grandTotalSet.valueSort[grandTotalSet.actualText] = 1;
        grandTotalSet.valueSort.uniqueName = grandTotalSet.actualText;
        for (let ln = 0, lt = filter.length; ln < lt; ln++) {
            grandTotalSet.indexObject[filter[ln]] = filter[ln];
        }
        if (this.dataSourceSettings.grandTotalsPosition === 'Top' && this.dataSourceSettings.showGrandTotals) {
            set.unshift(grandTotalSet);
        }
        else {
            set.push(grandTotalSet);
        }
        // if (axis === 'row') {
        //     this.rowCount += this.rowValuesLength;
        // } else {
        //     this.columnCount += this.colValuesLength;
        // }
        return set;
    }
    getTableData(rows, reformAxis, columns, pIndex, data, vlt, level, rTotal, cTotal, valueParentIndex) {
        for (let rlt = rows.length, rln = 0; rln < rlt; rln++) { // eslint-disable-next-line max-len
            const tnum = (!this.valueAxis && !this.isLastHeaderHasMeasures && data.length < (this.dataSourceSettings.columns.length + 1)) ?
                (this.dataSourceSettings.columns.length + 1) : data.length;
            const row = rows[rln];
            reformAxis[tnum] = row;
            const actCnt = tnum - Number(Object.keys(reformAxis)[0]);
            const isLeastNode = !reformAxis[tnum].members.length;
            row.colIndex = 0;
            row.rowIndex = tnum;
            let isRowFieldsAvail = false;
            const delimiter = this.dataSourceSettings.valueSortSettings.headerDelimiter;
            if (this.valueAxis && this.dataSourceSettings.rows.length === 0 && this.dataSourceSettings.values.length > 1) {
                this.rowIndex = (isNullOrUndefined(this.rowIndex) && !isLeastNode &&
                    this.dataSourceSettings.rows.length === 0) ? row.index : this.rowIndex;
                isRowFieldsAvail = (this.valueAxis && this.dataSourceSettings.rows.length === 0 && row.valueSort.levelName &&
                    row.valueSort.levelName.toString().indexOf('Grand Total' + delimiter) !== 0);
                if (this.valueAxis && this.dataSourceSettings.rows.length === 0 &&
                    row.valueSort.levelName.toString().indexOf('Grand Total' + delimiter) === 0) {
                    row.index = this.rowIndex;
                }
            }
            if (!isRowFieldsAvail) {
                let isValue = false;
                if (this.showSubTotalsAtBottom && reformAxis[pIndex] && reformAxis[pIndex].hasChild) {
                    let axis;
                    for (axis of reformAxis[pIndex].members) {
                        if (axis.type === 'value') {
                            isValue = true;
                            break;
                        }
                    }
                }
                if (isValue && !reformAxis[tnum].isSum && reformAxis[tnum].members &&
                    reformAxis[tnum].members.length === 0) {
                    continue;
                }
                if (!data[tnum]) {
                    data[tnum] = [];
                    this.valueContent[actCnt] = {};
                    data[tnum][0] = this.valueContent[actCnt][0] = PivotUtil.frameHeaderWithKeys(row);
                }
                else {
                    data[tnum][0] = this.valueContent[actCnt][0] = PivotUtil.frameHeaderWithKeys(row);
                }
                if (this.valueAxis && (this.isMultiMeasures || this.dataSourceSettings.alwaysShowValueHeader)) {
                    const hPos = tnum;
                    const actpos = actCnt;
                    const rowIndex = tnum;
                    let isValueCellUpdated = false;
                    if ((((!(level === 0 && this.measureIndex === 0) && !isLeastNode) || isLeastNode) && row.type === 'value' && !row.valueSort.axis) ||
                        (level > this.measureIndex && row.axis === 'row' && row.valueSort.axis)) {
                        let vln = 0;
                        let isValueIndexFound = false;
                        const rowUniqueName = row.valueSort.uniqueName ?
                            row.valueSort.uniqueName.toString().split(this.valueSortSettings.headerDelimiter) : [];
                        for (let cln = 0, dln = 1, clt = columns.length; cln < clt; ++cln) {
                            if (!isValueIndexFound) {
                                for (vln = 0; vln < vlt; vln++) {
                                    if (rowUniqueName.indexOf(this.dataSourceSettings.values[vln].name) > -1) {
                                        isValueIndexFound = true;
                                        isValueCellUpdated = true;
                                        break;
                                    }
                                }
                            }
                            if (level > this.measureIndex && row.axis === 'row' && row.valueSort.axis) {
                                this.updateRowData(rows, columns, tnum, data, vln, rln, cln, dln, actCnt, rTotal, cTotal);
                            }
                            else {
                                if (!reformAxis[pIndex]) {
                                    isValueCellUpdated = false;
                                    break;
                                }
                                const parentIndex = this.showSubTotalsAtBottom && valueParentIndex ? valueParentIndex : pIndex;
                                this.updateRowData(reformAxis, columns, tnum, data, vln, parentIndex, cln, dln, actCnt, rTotal, cTotal);
                            }
                            dln = data[tnum].length;
                        }
                    }
                    if (!isValueCellUpdated) {
                        for (let cln = 0, dln = 1, clt = columns.length; cln < clt; ++cln) {
                            dln = data[tnum].length;
                            data[hPos][dln] = this.valueContent[actpos][dln] = {
                                axis: 'value', actualText: '', colSpan: 1,
                                colIndex: dln, formattedText: '', hasChild: false
                            };
                        }
                    }
                    this.recursiveRowData(rows, reformAxis, columns, rowIndex, data, vlt, isLeastNode, rln, vlt, level, rTotal, cTotal);
                }
                else {
                    for (let cln = 0, dln = 1, clt = columns.length; cln < clt; ++cln) {
                        const columnUniqueName = columns[cln].valueSort.uniqueName ?
                            columns[cln].valueSort.uniqueName.toString().split(this.valueSortSettings.headerDelimiter) : [];
                        for (let vln = 0; vln < vlt; vln++) {
                            if (!this.valueAxis && !this.isLastHeaderHasMeasures) {
                                if (columnUniqueName.indexOf(this.dataSourceSettings.values[vln].name) > -1) {
                                    this.updateRowData(rows, columns, tnum, data, vln, rln, cln, dln, actCnt, rTotal, cTotal);
                                    dln = data[tnum].length;
                                }
                            }
                            else {
                                this.updateRowData(rows, columns, tnum, data, vln, rln, cln, dln, actCnt, rTotal, cTotal);
                                dln = data[tnum].length;
                            }
                        }
                    }
                    this.recursiveRowData(rows, reformAxis, columns, tnum, data, vlt, isLeastNode, rln, 0, level, rTotal, cTotal);
                }
            }
            else if (!isLeastNode) {
                this.recursiveRowData(rows, reformAxis, columns, tnum, data, vlt, isLeastNode, rln, 0, level, rTotal, cTotal);
            }
        }
    }
    insertRowSubTotals(reformAxis, columns, tnum, data, vlt, level, rTotal, cTotal) {
        const isValueAxis = reformAxis[tnum].type ? reformAxis[tnum].type === 'value' &&
            reformAxis[tnum].valueSort.levelName !== reformAxis[tnum].actualText : false;
        if ((reformAxis[tnum].hasChild && reformAxis[tnum].isDrilled) &&
            reformAxis[tnum].members.length > 0) {
            let parentIndexes = [];
            const subTotal = PivotUtil.frameHeaderWithKeys(reformAxis[tnum]);
            if (reformAxis[tnum].members[0].type === 'value') {
                let startIndex = 0;
                const valueCells = [];
                let i = 1;
                for (const axis of subTotal.members) {
                    if (axis.type === 'value') {
                        valueCells[valueCells.length] = axis;
                    }
                } // eslint-disable-next-line @typescript-eslint/no-explicit-any
                while (startIndex < valueCells.length) {
                    const valueCell = PivotUtil.frameHeaderWithKeys(valueCells[startIndex]);
                    let index;
                    for (i; i < reformAxis.length; i++) {
                        if (reformAxis[i] && reformAxis[i].valueSort.levelName === valueCell.valueSort.levelName) {
                            index = reformAxis.indexOf(reformAxis[i]);
                            break;
                        }
                    }
                    if (index > -1) {
                        parentIndexes[parentIndexes.length] = index;
                    }
                    valueCell.formattedText = subTotal.formattedText + ' ' + valueCell.formattedText;
                    valueCell.isSum = true;
                    valueCell.members = [];
                    this.getTableData([valueCell], reformAxis, columns, tnum, data, vlt, level, rTotal, cTotal);
                    startIndex++;
                }
            }
            else {
                subTotal.formattedText = subTotal.formattedText + ' Total';
                subTotal.members = [];
                subTotal.isDrilled = false;
                subTotal.hasChild = false;
                subTotal.isSum = true;
                subTotal.type = 'sum';
                const parentIndex = isValueAxis ? this.getParentIndex(reformAxis, subTotal) : 0;
                this.getTableData([subTotal], reformAxis, columns, tnum, data, vlt, level, rTotal, cTotal, parentIndex);
                parentIndexes = [tnum];
            }
            for (let index = 0; index < parentIndexes.length; index++) {
                let parentInfo = data[parentIndexes[index]];
                parentInfo = parentInfo.map((dataValue) => {
                    dataValue.formattedText = dataValue.colIndex === 0 ? dataValue.formattedText : '';
                    return dataValue;
                });
                data[parentIndexes[index]] = parentInfo;
            }
        }
    }
    getParentIndex(reformAxis, axis) {
        let parentIndex = 0;
        for (let i = reformAxis.length - 1; i > 0; i--) {
            if (axis.level === reformAxis[i].level && reformAxis[i].index) {
                parentIndex = i;
                break;
            }
        }
        return parentIndex;
    }
    getAggregatedHeaders(rows, columns, rMembers, cMembers, values) {
        this.selectedHeaders = { selectedHeader: [], values: [] };
        for (let vlt = values.length, vln = 0; vln < vlt; vln++) {
            switch (values[vln].type) {
                case 'DifferenceFrom':
                case 'PercentageOfDifferenceFrom':
                    {
                        let baseField;
                        let baseItem;
                        this.selectedHeaders.values.push(values[vln].name);
                        if (values[vln].baseField && values[vln].baseItem) {
                            baseField = values[vln].baseField;
                            baseItem = values[vln].baseItem; // eslint-disable-next-line max-len
                        }
                        else if (this.valueAxis && (this.isMultiMeasures || this.dataSourceSettings.alwaysShowValueHeader) && columns.length > 0) {
                            baseField = columns[0].name;
                            baseItem = Object.keys(this.fieldList[columns[0].name].members)[0];
                        }
                        else if (rows.length > 0) {
                            baseField = rows[0].name;
                            baseItem = Object.keys(this.fieldList[rows[0].name].members)[0];
                        }
                        let isHeaderSelected = false;
                        for (const row of rows) {
                            if (row.name === baseField) {
                                this.getAggregatedHeaderData(rMembers, values[vln].name, baseItem, false, 'row', values[vln].type, this.selectedHeaders.selectedHeader, vln);
                                isHeaderSelected = true;
                                break;
                            }
                        }
                        if (!isHeaderSelected) {
                            for (const column of columns) {
                                if (column.name === baseField) {
                                    this.getAggregatedHeaderData(cMembers, values[vln].name, baseItem, false, 'column', values[vln].type, this.selectedHeaders.selectedHeader, vln);
                                    break;
                                }
                            }
                        }
                    }
                    break;
                case 'PercentageOfParentRowTotal':
                case 'PercentageOfParentColumnTotal':
                    {
                        this.selectedHeaders.values.push(values[vln].name);
                        this.getAggregatedHeaderData((values[vln].type === 'PercentageOfParentRowTotal' ? rMembers : cMembers), values[vln].name, undefined, false, (values[vln].type === 'PercentageOfParentRowTotal' ? 'row' : 'column'), values[vln].type, this.selectedHeaders.selectedHeader, vln);
                    }
                    break;
                case 'RunningTotals':
                    {
                        this.selectedHeaders.values.push(values[vln].name);
                        this.getAggregatedHeaderData((this.valueAxis && (this.isMultiMeasures || this.dataSourceSettings.alwaysShowValueHeader) ? cMembers : rMembers), values[vln].name, undefined, false, (this.valueAxis && (this.isMultiMeasures || this.dataSourceSettings.alwaysShowValueHeader) ? 'column' : 'row'), values[vln].type, this.selectedHeaders.selectedHeader, vln);
                    }
                    break;
                case 'PercentageOfParentTotal':
                    {
                        let baseField;
                        this.selectedHeaders.values.push(values[vln].name);
                        if (values[vln].baseField) {
                            baseField = values[vln].baseField; // eslint-disable-next-line max-len
                        }
                        else if (this.valueAxis && (this.isMultiMeasures || this.dataSourceSettings.alwaysShowValueHeader) && columns.length > 0) {
                            baseField = columns[0].name;
                        }
                        else if (rows.length > 0) {
                            baseField = rows[0].name;
                        }
                        let isHeaderSelected = false;
                        for (let len = rows.length, i = 0; i < len; i++) {
                            if (rows[i].name === baseField) {
                                const level = i >= this.measureIndex ? i + 1 : i;
                                this.getAggregatedHeaderData(rMembers, values[vln].name, undefined, false, 'row', values[vln].type, this.selectedHeaders.selectedHeader, vln, level);
                                isHeaderSelected = true;
                                break;
                            }
                        }
                        if (!isHeaderSelected) {
                            for (let len = columns.length, i = 0; i < len; i++) {
                                if (columns[i].name === baseField) {
                                    let level = i;
                                    if (!this.valueAxis && !this.isLastHeaderHasMeasures) {
                                        level = i >= this.measureIndex ? i + 1 : i;
                                    }
                                    this.getAggregatedHeaderData(cMembers, values[vln].name, undefined, false, 'column', values[vln].type, this.selectedHeaders.selectedHeader, vln, level);
                                    break;
                                }
                            }
                        }
                    }
                    break;
            }
        }
    }
    getAggregatedHeaderData(headers, name, baseItem, isChildren, type, aggregateType, selectedHeaders, vln, level) {
        for (const rln of headers) {
            switch (aggregateType) {
                case 'DifferenceFrom':
                case 'PercentageOfDifferenceFrom':
                    {
                        const levelName = rln.valueSort.levelName.toString().split(this.valueSortSettings.headerDelimiter);
                        if (levelName.indexOf(baseItem) !== -1) {
                            const actualHeaders = [];
                            if (!isChildren && type === 'row') {
                                for (const header of headers) {
                                    if (header.level >= rln.level) {
                                        actualHeaders.push(header);
                                    }
                                }
                            }
                            selectedHeaders.push(this.updateSelectedHeaders(baseItem, rln.level, type, isChildren, name, aggregateType, rln.valueSort.levelName, (isChildren ? [rln] : (type === 'column' ? headers : actualHeaders)), vln + 1));
                            if (rln.members.length > 0) {
                                let isValuesAvail = false;
                                const members = [];
                                if (type === 'row') {
                                    for (const member of rln.members) {
                                        if (member.type === 'value' && member.members.length === 0) {
                                            isValuesAvail = true;
                                        }
                                        else {
                                            members.push(member);
                                            isValuesAvail = false;
                                            break;
                                        }
                                    }
                                }
                                if ((!isValuesAvail && members.length > 0) || type === 'column') {
                                    this.getAggregatedHeaderData(type === 'column' ? rln.members : members, name, baseItem, true, type, aggregateType, selectedHeaders[selectedHeaders.length - 1].childMembers, vln);
                                }
                            }
                        }
                        else if (rln.members.length > 0) {
                            this.getAggregatedHeaderData(rln.members, name, baseItem, false, type, aggregateType, selectedHeaders, vln);
                        }
                    }
                    break;
                case 'RunningTotals':
                case 'PercentageOfParentRowTotal':
                case 'PercentageOfParentColumnTotal':
                    {
                        if (rln.type === 'grand sum') {
                            selectedHeaders.push(this.updateSelectedHeaders(undefined, rln.level, type, false, name, aggregateType, rln.valueSort.levelName, headers, vln + 1));
                        }
                        else {
                            if (rln.members.length > 0) {
                                selectedHeaders.push(this.updateSelectedHeaders(undefined, rln.level, type, false, name, aggregateType, rln.valueSort.levelName, rln.members, vln + 1));
                                this.getAggregatedHeaderData(rln.members, name, undefined, false, type, aggregateType, selectedHeaders, vln);
                            }
                        }
                    }
                    break;
                case 'PercentageOfParentTotal':
                    {
                        if (rln.type !== 'grand sum') {
                            if ((rln.valueSort.levelName.split(this.valueSortSettings.headerDelimiter).length - 1) === level) {
                                if (rln.members.length > 0) {
                                    if (isChildren) {
                                        const aggregateHeaders = selectedHeaders[selectedHeaders.length - 1].aggregateHeaders;
                                        for (const member of rln.members) {
                                            aggregateHeaders.push(extend({}, member, null, true));
                                        }
                                    }
                                    else {
                                        const children = extend([], rln.members, null, true);
                                        selectedHeaders.push(this.updateSelectedHeaders(undefined, rln.level, type, false, name, aggregateType, rln.valueSort.levelName, children, vln + 1));
                                        const aggregateHeaders = selectedHeaders[selectedHeaders.length - 1].aggregateHeaders;
                                        aggregateHeaders.push(extend({}, rln, null, true));
                                    }
                                    this.getAggregatedHeaderData(rln.members, name, undefined, true, type, aggregateType, selectedHeaders, vln, level + 1);
                                }
                                else {
                                    if (!isChildren) {
                                        selectedHeaders.push(this.updateSelectedHeaders(undefined, rln.level, type, false, name, aggregateType, rln.valueSort.levelName, [rln], vln + 1));
                                    }
                                }
                            }
                            else if (rln.members.length > 0) {
                                this.getAggregatedHeaderData(rln.members, name, undefined, false, type, aggregateType, selectedHeaders, vln, level);
                            }
                        }
                    }
                    break;
            }
        }
    }
    updateSelectedHeaders(baseItem, level, type, isChildren, name, aggregateType, levelName, headers, vCount) {
        const headerData = {
            name: baseItem,
            level: level,
            axis: type,
            isChild: isChildren,
            value: name,
            type: aggregateType,
            uniqueName: levelName,
            aggregateHeaders: extend([], headers, null, true),
            childMembers: [],
            valueCount: vCount
        };
        return headerData;
    }
    applyAdvancedAggregate(rowheads, colheads, data) {
        this.aggregatedValueMatrix = [];
        if (this.selectedHeaders.values.length > 0) {
            const pivotIndex = {};
            const colIndex = [];
            const rowIndex = [];
            let isIndexFilled = false;
            for (let rlt = data.length, rln = 0; rln < rlt; rln++) {
                if (data[rln] !== undefined && data[rln][0] !== undefined) {
                    if (!isIndexFilled) {
                        for (let clt = data[rln].length, cln = 0; cln < clt; cln++) {
                            const actualText = data[rln][cln].actualText;
                            if (data[rln][cln].axis === 'value' &&
                                this.selectedHeaders.values.indexOf(actualText) !== -1) {
                                colIndex.push(cln);
                                isIndexFilled = true;
                            }
                        }
                    }
                    const isTotal = this.showSubTotalsAtBottom && data[rln][0].isDrilled &&
                        data[rln][0].hasChild;
                    if (!isTotal) {
                        if (colIndex.length > 0 && data[rln][colIndex[0]].axis === 'value' &&
                            this.selectedHeaders.values.indexOf(data[rln][colIndex[0]].actualText) !== -1) {
                            rowIndex.push(rln);
                            for (const index of colIndex) {
                                pivotIndex[rln + ',' + index] = [rln, index];
                            }
                        }
                    }
                }
            }
            this.updateAggregates(rowheads, colheads, data, this.selectedHeaders.selectedHeader, colIndex, rowIndex, pivotIndex);
            const indexCollection = Object.keys(pivotIndex);
            for (const index of indexCollection) {
                const currentSet = data[pivotIndex[index][0]][pivotIndex[index][1]];
                // currentSet.formattedText = '0';
                currentSet.formattedText = (this.selectedHeaders.selectedHeader.length > 0 ? this.emptyCellTextContent : '#N/A');
                if (!this.aggregatedValueMatrix[pivotIndex[index][0]]) {
                    this.aggregatedValueMatrix[pivotIndex[index][0]] = [];
                }
                this.aggregatedValueMatrix[pivotIndex[index][0]][pivotIndex[index][1]] = 0;
            }
            this.updatePivotValues(true);
        }
        else {
            return;
        }
    }
    updateAggregates(rowheads, colheads, data, selectedHeaders, colIndex, rowIndex, pivotIndex) {
        for (const headers of selectedHeaders) {
            const selectedHeaderCollection = headers.aggregateHeaders;
            const name = headers.value;
            // let valueCount: number = (this.valueAxis && (this.isMutiMeasures || this.dataSourceSettings.alwaysShowValueHeader) ? headers.valueCount : 0);
            const aggregateType = headers.type;
            const uniqueName = headers.uniqueName;
            const axis = headers.axis;
            const isRowBaseField = axis === 'row' ? true : false;
            let activeValues;
            const indexCollection = [];
            let activeColumn = [];
            const columnHeaders = [];
            const rowindexCollection = [];
            let selectedRowValues = [];
            const selectedColumnValues = [];
            if ((['DifferenceFrom', 'PercentageOfDifferenceFrom', 'PercentageOfParentRowTotal', 'PercentageOfParentColumnTotal', 'PercentageOfParentTotal', 'RunningTotals']).indexOf(headers.type) !== -1) {
                if (isRowBaseField) {
                    if (headers.type !== 'RunningTotals') {
                        for (const rln of rowIndex) {
                            if (rowheads[rln] !== undefined) {
                                if (rowheads[rln].valueSort[uniqueName]) {
                                    activeValues = rowheads[rln];
                                    if (this.valueAxis === 0 || (this.valueAxis && data[rln] && data[rln][1] &&
                                        data[rln][1].actualText === name)) {
                                        selectedRowValues = data[rln];
                                    }
                                    else {
                                        selectedRowValues = [];
                                    }
                                    break;
                                }
                            }
                        }
                    }
                }
                else {
                    for (let len = data.length, i = 0; i < len; i++) {
                        if (data[i] !== undefined && data[i][0] === undefined) {
                            columnHeaders.push(data[i]);
                        }
                        else {
                            break;
                        }
                    }
                    let len = columnHeaders.length;
                    while (len--) {
                        const axisObj = columnHeaders[len][colIndex[0]];
                        const cLevelName = axisObj.actualText;
                        if (this.selectedHeaders.values.indexOf(cLevelName) === -1) {
                            activeColumn = columnHeaders[len];
                            len = 0;
                        }
                    }
                    if (headers.type !== 'RunningTotals') {
                        for (let clt = activeColumn.length, cln = 0; cln < clt; cln++) {
                            let isSelectedColumn = false;
                            if (activeColumn[cln] !== undefined && activeColumn[cln].valueSort[uniqueName]) {
                                activeValues = activeColumn[cln];
                                for (let len = data.length, i = 0; i < len; i++) {
                                    const axisObj = data[i];
                                    if (axisObj !== undefined && axisObj[0] !== undefined && axisObj[cln].axis === 'value' && this.selectedHeaders.values.indexOf(axisObj[cln].actualText) !== -1) {
                                        isSelectedColumn = true;
                                        selectedColumnValues[i] = axisObj[cln];
                                        rowindexCollection.push(i);
                                    }
                                }
                                if (isSelectedColumn) {
                                    break;
                                }
                            }
                        }
                        if (selectedColumnValues.length === 0 && rowindexCollection.length === 0) {
                            for (let clt = activeColumn.length, cln = 0; cln < clt; cln++) {
                                let isSelectedColumn = false;
                                if (activeColumn[cln] !== undefined &&
                                    activeColumn[cln].valueSort.levelName.indexOf(uniqueName) === 0) {
                                    activeValues = activeColumn[cln];
                                    for (let lnt = data.length, j = 0; j < lnt; j++) {
                                        const axisObj = data[j];
                                        if (axisObj !== undefined && axisObj[0] !== undefined && axisObj[cln].axis === 'value' && this.selectedHeaders.values.indexOf(axisObj[cln].actualText) !== -1) {
                                            isSelectedColumn = true;
                                            // selectedColumnValues[i as number] = axisObj[cln as number] as IAxisSet;
                                            rowindexCollection.push(j);
                                        }
                                    }
                                    if (isSelectedColumn) {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            switch (headers.type) {
                case 'DifferenceFrom':
                case 'PercentageOfDifferenceFrom':
                    {
                        const isChildren = headers.isChild;
                        if (isRowBaseField) {
                            if (!isChildren) {
                                for (const item of selectedHeaderCollection) {
                                    for (const rln of rowIndex) {
                                        if (rowheads[rln] !== undefined) {
                                            if (rowheads[rln].valueSort[item.valueSort.levelName] &&
                                                rowheads[rln].level === activeValues.level && rowheads[rln].type !== 'grand sum') {
                                                for (const index of colIndex) {
                                                    const currentSet = data[rln][index];
                                                    if (currentSet.axis === 'value' && currentSet.actualText === name) {
                                                        indexCollection.push([rln, index]);
                                                        if (pivotIndex[rln + ',' + index]) {
                                                            delete pivotIndex[rln + ',' + index];
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            else {
                                const uniqueLevelName = uniqueName.split(this.valueSortSettings.headerDelimiter);
                                for (const rlen of rowIndex) {
                                    if (rowheads[rlen] !== undefined) {
                                        const levelName = rowheads[rlen].valueSort.levelName.split(this.valueSortSettings.headerDelimiter);
                                        if (levelName.indexOf(uniqueLevelName[uniqueLevelName.length - 1]) !== -1 && activeValues &&
                                            rowheads[rlen].level === activeValues.level) {
                                            for (const index of colIndex) {
                                                const currentSet = data[rlen][index];
                                                if (currentSet.axis === 'value' && currentSet.actualText === name) {
                                                    indexCollection.push([rlen, index]);
                                                    if (pivotIndex[rlen + ',' + index]) {
                                                        delete pivotIndex[rlen + ',' + index];
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            for (const index of indexCollection) {
                                const currentSet = data[index[0]][index[1]];
                                const actualValue = isNullOrUndefined(selectedRowValues[index[1]].actualValue) ? 0 : selectedRowValues[index[1]].actualValue;
                                // let cVal: number = currentSet.value - (selectedRowValues[index[1]] as IAxisSet).value;
                                let cVal = (isNullOrUndefined(currentSet.actualValue) ? 0 : currentSet.actualValue) - actualValue;
                                cVal = isNaN(cVal) ? 0 : (currentSet.value === 0 && selectedRowValues[index[1]].value === 0) ? 0 : cVal;
                                if (!this.aggregatedValueMatrix[index[0]]) {
                                    this.aggregatedValueMatrix[index[0]] = [];
                                }
                                if (aggregateType === 'DifferenceFrom') {
                                    this.aggregatedValueMatrix[index[0]][index[1]] = cVal;
                                    currentSet.formattedText = cVal === 0 ? this.emptyCellTextContent :
                                        this.getFormattedValue(cVal, name).formattedText;
                                }
                                else {
                                    // cVal = ((selectedRowValues[index[1]] as IAxisSet).value === 0 ?
                                    // 0 : (cVal / (selectedRowValues[index[1]] as IAxisSet).value));
                                    cVal = (actualValue === 0 ? 0 : (cVal / actualValue));
                                    this.aggregatedValueMatrix[index[0]][index[1]] = cVal;
                                    currentSet.formattedText = currentSet.showSubTotals ? (cVal !== 0 ? this.globalize.formatNumber(cVal, { format: 'P', maximumFractionDigits: this.getPercentFormat(this.formatFields, currentSet.actualText) }) : this.emptyCellTextContent) : currentSet.formattedText;
                                }
                            }
                        }
                        else {
                            if (!isChildren) {
                                for (const item of selectedHeaderCollection) {
                                    for (let clt = activeColumn.length, cln = 0; cln < clt; cln++) {
                                        let isSelectedColumn = false;
                                        if (activeColumn[cln] !== undefined &&
                                            activeColumn[cln].valueSort[item.valueSort.levelName] && activeValues &&
                                            activeColumn[cln].level === activeValues.level && activeColumn[cln].type !== 'grand sum') {
                                            for (const index of rowindexCollection) {
                                                const currentSet = data[index][cln];
                                                if (currentSet.axis === 'value' && currentSet.actualText === name) {
                                                    isSelectedColumn = true;
                                                    indexCollection.push([index, cln]);
                                                    if (pivotIndex[index + ',' + cln]) {
                                                        delete pivotIndex[index + ',' + cln];
                                                    }
                                                }
                                            }
                                            if (isSelectedColumn) {
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                            else {
                                const uniqueLevelName = uniqueName.split(this.valueSortSettings.headerDelimiter);
                                for (let clt = activeColumn.length, clen = 0; clen < clt; clen++) {
                                    let isSelectedColumn = false;
                                    if (activeColumn[clen] !== undefined) {
                                        const levelName = activeColumn[clen].valueSort.levelName.split(this.valueSortSettings.headerDelimiter);
                                        if (levelName.indexOf(uniqueLevelName[uniqueLevelName.length - 1]) !== -1 &&
                                            activeColumn[clen].level === activeValues.level) {
                                            for (const index of rowindexCollection) {
                                                const currentSet = data[index][clen];
                                                if (currentSet.axis === 'value' && currentSet.actualText === name) {
                                                    isSelectedColumn = true;
                                                    indexCollection.push([index, clen]);
                                                    if (pivotIndex[index + ',' + clen]) {
                                                        delete pivotIndex[index + ',' + clen];
                                                    }
                                                }
                                            }
                                            if (isSelectedColumn) {
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                            let selectedColumn;
                            if (selectedColumnValues.length === 0) {
                                selectedColumn = this.getSelectedColumn(headers.uniqueName, colheads);
                            }
                            for (const index of indexCollection) {
                                const currentSet = data[index[0]][index[1]];
                                let selectedColumnValue = 0;
                                if (selectedColumnValues.length === 0) {
                                    const selectedRow = this.getSelectedRow(currentSet.rowHeaders, rowheads);
                                    selectedColumnValue = this.getAggregateValue(selectedRow.index, selectedColumn.indexObject, this.fieldList[name].index, headers.type, false);
                                }
                                else {
                                    selectedColumnValue = selectedColumnValues[index[0]].value;
                                }
                                let cVal = currentSet.value - selectedColumnValue;
                                cVal = isNaN(cVal) ? 0 : cVal;
                                if (!this.aggregatedValueMatrix[index[0]]) {
                                    this.aggregatedValueMatrix[index[0]] = [];
                                }
                                if (aggregateType === 'DifferenceFrom') {
                                    currentSet.formattedText = cVal === 0 ? this.emptyCellTextContent :
                                        this.getFormattedValue(cVal, name).formattedText;
                                    this.aggregatedValueMatrix[index[0]][index[1]] = cVal;
                                }
                                else {
                                    cVal = (selectedColumnValues[index[0]].value === 0 ?
                                        0 : (cVal / selectedColumnValues[index[0]].value));
                                    currentSet.formattedText = (cVal !== 0 ? this.globalize.formatNumber(cVal, { format: 'P', maximumFractionDigits: this.getPercentFormat(this.formatFields, currentSet.actualText) }) : this.emptyCellTextContent);
                                    this.aggregatedValueMatrix[index[0]][index[1]] = cVal;
                                }
                            }
                        }
                        if (headers.childMembers.length > 0) {
                            this.updateAggregates(rowheads, colheads, data, headers.childMembers, colIndex, rowIndex, pivotIndex);
                        }
                    }
                    break;
                case 'PercentageOfParentRowTotal':
                case 'PercentageOfParentColumnTotal':
                case 'PercentageOfParentTotal':
                    {
                        if (isRowBaseField) {
                            for (const item of selectedHeaderCollection) {
                                for (const i of rowIndex) {
                                    if (rowheads[i] !== undefined) {
                                        if (rowheads[i].valueSort[item.valueSort.levelName] &&
                                            rowheads[i].level === item.level) {
                                            for (const index of colIndex) {
                                                const currentSet = data[i][index];
                                                if (currentSet.axis === 'value' && currentSet.actualText === name) {
                                                    indexCollection.push([i, index]);
                                                    if (pivotIndex[i + ',' + index]) {
                                                        delete pivotIndex[i + ',' + index];
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            for (const i of indexCollection) {
                                const currentSet = data[i[0]][i[1]];
                                // let cVal: number = currentSet.value / (selectedRowValues[i[1]] as IAxisSet).value;
                                let selectedRowValue = 0;
                                if (selectedRowValues.length === 0 && activeValues) {
                                    selectedRowValue = this.getAggregateValue(activeValues.index, colheads[i[1] - 1].indexObject, this.fieldList[name].index, headers.type, false);
                                }
                                else {
                                    selectedRowValue = selectedRowValues[i[1]] ? selectedRowValues[i[1]].actualValue : 0;
                                }
                                let cVal = currentSet.value / selectedRowValue;
                                cVal = isNaN(cVal) ? 0 : cVal;
                                currentSet.formattedText = currentSet.showSubTotals ? (cVal !== 0 ? this.globalize.formatNumber(cVal, { format: 'P', maximumFractionDigits: this.getPercentFormat(this.formatFields, currentSet.actualText) }) : this.emptyCellTextContent) : currentSet.formattedText;
                                if (!this.aggregatedValueMatrix[i[0]]) {
                                    this.aggregatedValueMatrix[i[0]] = [];
                                }
                                this.aggregatedValueMatrix[i[0]][i[1]] = cVal;
                            }
                        }
                        else {
                            for (const item of selectedHeaderCollection) {
                                for (let clt = activeColumn.length, j = 0; j < clt; j++) {
                                    let isSelectedColumn = false;
                                    if (activeColumn[j] !== undefined &&
                                        activeColumn[j].valueSort[item.valueSort.levelName]) {
                                        for (const index of rowindexCollection) {
                                            const isTotals = this.showSubTotalsAtBottom && data[index][0].isDrilled && data[index][0].hasChild;
                                            if (!isTotals) {
                                                const currentSet = data[index][j];
                                                if (currentSet.axis === 'value' && currentSet.actualText === name) {
                                                    isSelectedColumn = true;
                                                    indexCollection.push([index, j]);
                                                    if (pivotIndex[index + ',' + j]) {
                                                        delete pivotIndex[index + ',' + j];
                                                    }
                                                }
                                            }
                                        }
                                        if (isSelectedColumn) {
                                            break;
                                        }
                                    }
                                }
                            }
                            let selectedCol;
                            if (selectedColumnValues.length === 0) {
                                selectedCol = this.getSelectedColumn(headers.uniqueName, colheads);
                            }
                            for (const i of indexCollection) {
                                const currentSet = data[i[0]][i[1]];
                                let selectedColValue = 0;
                                if (selectedColumnValues.length === 0) {
                                    const selectedRow = this.getSelectedRow(currentSet.rowHeaders, rowheads);
                                    selectedColValue = this.getAggregateValue(selectedRow.index, selectedCol.indexObject, this.fieldList[name].index, headers.type, false);
                                }
                                else {
                                    selectedColValue = selectedColumnValues[i[0]].value;
                                }
                                let val = currentSet.value / selectedColValue;
                                val = isNaN(val) ? 0 : val;
                                currentSet.formattedText = (val !== 0 ? this.globalize.formatNumber(val, { format: 'P', maximumFractionDigits: this.getPercentFormat(this.formatFields, currentSet.actualText) }) : this.emptyCellTextContent);
                                if (!this.aggregatedValueMatrix[i[0]]) {
                                    this.aggregatedValueMatrix[i[0]] = [];
                                }
                                this.aggregatedValueMatrix[i[0]][i[1]] = val;
                            }
                        }
                    }
                    break;
                case 'RunningTotals':
                    {
                        if (isRowBaseField) {
                            for (const index of colIndex) {
                                let cVal = 0;
                                for (const item of selectedHeaderCollection) {
                                    for (const rlen of rowIndex) {
                                        if (rowheads[rlen] !== undefined) {
                                            const currentSet = data[rlen][index];
                                            if (rowheads[rlen] !== undefined && rowheads[rlen].valueSort[item.valueSort.levelName] && rowheads[rlen].level === item.level && currentSet.axis === 'value' && currentSet.actualText === name) {
                                                if (rowheads[rlen].type !== 'grand sum') {
                                                    cVal += (!currentSet.showSubTotals && !(!isNullOrUndefined(currentSet.actualValue) && isNaN(currentSet.actualValue))) ?
                                                        currentSet.actualValue : (!isNullOrUndefined(currentSet.value) &&
                                                        !isNaN(currentSet.value)) ? currentSet.value : null;
                                                    currentSet.formattedText = currentSet.showSubTotals ? (cVal === 0 &&
                                                        (currentSet.actualValue && currentSet.actualValue !== 0) ? '' :
                                                        this.getFormattedValue(cVal, name).formattedText) : currentSet.formattedText;
                                                    if (!this.aggregatedValueMatrix[rlen]) {
                                                        this.aggregatedValueMatrix[rlen] = [];
                                                    }
                                                    this.aggregatedValueMatrix[rlen][index] = cVal;
                                                }
                                                if (pivotIndex[rlen + ',' + index]) {
                                                    delete pivotIndex[rlen + ',' + index];
                                                }
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        else {
                            for (const rln of rowIndex) {
                                if (data[rln] !== undefined) {
                                    let cVal = 0;
                                    for (const item of selectedHeaderCollection) {
                                        const subTotal = (rowheads[rln].hasChild && rowheads[rln].isDrilled &&
                                            ((!isNullOrUndefined(rowheads[rln].showSubTotals) && // eslint-disable-next-line max-len
                                                !rowheads[rln].showSubTotals) || !this.dataSourceSettings.showSubTotals || !this.dataSourceSettings.showRowSubTotals));
                                        for (let clt = activeColumn.length, cln = 0; cln < clt; cln++) {
                                            const currentSet = data[rln][cln];
                                            if (activeColumn[cln] !== undefined &&
                                                activeColumn[cln].valueSort[item.valueSort.levelName] &&
                                                currentSet.axis === 'value' && currentSet.actualText === name) {
                                                if (activeColumn[cln].type !== 'grand sum') {
                                                    if (!isNullOrUndefined(currentSet.value)) {
                                                        cVal += currentSet.value;
                                                    }
                                                    currentSet.formattedText = subTotal ? '' : this.getFormattedValue(cVal, name).formattedText;
                                                    if (!this.aggregatedValueMatrix[rln]) {
                                                        this.aggregatedValueMatrix[rln] = [];
                                                    }
                                                    this.aggregatedValueMatrix[rln][cln] = cVal;
                                                }
                                                if (pivotIndex[rln + ',' + cln]) {
                                                    delete pivotIndex[rln + ',' + cln];
                                                }
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    break;
            }
        }
    }
    getSelectedColumn(name, colheads) {
        const set = { axis: 'column', index: [], indexObject: {} };
        for (const head of colheads) {
            if (head && head.valueSort && head.valueSort.levelName.indexOf(name) === 0) {
                set.index = [...set.index, ...head.index].sort(function (a, b) { return a - b; });
                set.indexObject = Object.assign({}, set.indexObject, head.indexObject);
            }
        }
        return set;
    }
    getSelectedRow(name, rowheads) {
        for (const head of rowheads) {
            if (head) {
                if (head.valueSort && head.valueSort.levelName === name) {
                    return head;
                }
                else if (name === '' && head.type === 'grand sum') {
                    return head;
                }
            }
        }
        return null;
    }
    recursiveRowData(rows, reformAxis, columns, tnum, data, vlt, isLeastNode, rln, vln, level, rTotal, cTotal) {
        if (!isLeastNode) {
            this.getTableData(reformAxis[tnum].members, reformAxis, columns, tnum, data, vlt, level + 1, rTotal, cTotal);
        }
        if (this.showSubTotalsAtBottom && (!isNullOrUndefined(rows[rln].showSubTotals) ? rows[rln].showSubTotals : true)) {
            this.insertRowSubTotals(reformAxis, columns, tnum, data, vlt, level, rTotal, cTotal);
        }
        if (!this.isPagingOrVirtualizationEnabled) {
            reformAxis[tnum].members = [];
        }
    }
    updateRowData(rows, columns, tnum, data, vln, rln, cln, dln, actCnt, rTotal, cTotal) {
        const mPos = this.fieldList[this.dataSourceSettings.values[vln].name].index;
        const aggregate = this.fieldList[this.dataSourceSettings.values[vln].name].aggregateType;
        const field = this.dataSourceSettings.values[vln].name;
        let gTotalIndex = [];
        const totalValues = {};
        let value = 0;
        let actualValue = 0;
        // let isLeast: boolean = isLeastNode && (vln === vlt - 1);
        switch (aggregate) {
            case 'Index':
                {
                    gTotalIndex = [
                        [rows[rln], columns[cln]], [rows[rln], cTotal],
                        [rTotal, columns[cln]], [rTotal, cTotal]
                    ];
                    const valueContent = ['cVal', 'rTotalVal', 'cTotalVal', 'gTotalVal'];
                    let i = 0;
                    for (const rIndex of gTotalIndex) {
                        totalValues[valueContent[i]] = this.getAggregateValue((rIndex[0]).index, (rIndex[1]).indexObject, mPos, aggregate, i === 0 ? false : true);
                        i++;
                    }
                    const val = ((totalValues.cVal) * (totalValues.gTotalVal)) / ((totalValues.rTotalVal) * (totalValues.cTotalVal));
                    value = (rows[rln].members.length > 0 && rows[rln].hasChild && rows[rln].isDrilled &&
                        ((!isNullOrUndefined(rows[rln].showSubTotals) && !rows[rln].showSubTotals) ||
                            !this.dataSourceSettings.showRowSubTotals || !this.dataSourceSettings.showSubTotals)) ? undefined :
                        (isNullOrUndefined(totalValues.cVal) ? totalValues.cVal : (isNaN(val) ? 0 : val));
                    actualValue = (isNullOrUndefined(totalValues.cVal) ? totalValues.cVal : (isNaN(val) ? 0 : val));
                }
                break;
            case 'PercentageOfGrandTotal':
            case 'PercentageOfColumnTotal':
            case 'PercentageOfRowTotal':
                {
                    gTotalIndex = [[rows[rln], columns[cln]]];
                    gTotalIndex.push((aggregate === 'PercentageOfGrandTotal' ?
                        [rTotal, cTotal] : (aggregate === 'PercentageOfColumnTotal' ? [rTotal, columns[cln]] :
                        [rows[rln], cTotal])));
                    const valueContent = ['cVal', 'gTotalVal'];
                    let i = 0;
                    for (const rIndex of gTotalIndex) {
                        totalValues[valueContent[i]] = this.getAggregateValue((rIndex[0]).index, (rIndex[1]).indexObject, mPos, aggregate, i === 0 ? false : true);
                        i++;
                    }
                    const val = ((totalValues.cVal) / (totalValues.gTotalVal));
                    value = (rows[rln].members.length > 0 && rows[rln].hasChild && rows[rln].isDrilled &&
                        ((!isNullOrUndefined(rows[rln].showSubTotals) && !rows[rln].showSubTotals) ||
                            !this.dataSourceSettings.showSubTotals || !this.dataSourceSettings.showRowSubTotals)) ? undefined :
                        (isNullOrUndefined(totalValues.cVal) ? totalValues.cVal : (isNaN(val) ? 0 : val));
                    actualValue = (isNullOrUndefined(totalValues.cVal) ? totalValues.cVal : (isNaN(val) ? 0 : val));
                }
                break;
            default:
                {
                    const val = this.getAggregateValue(rows[rln].index, columns[cln].indexObject, mPos, aggregate, false);
                    value = (rows[rln].members.length > 0 && rows[rln].hasChild && rows[rln].isDrilled &&
                        ((!isNullOrUndefined(rows[rln].showSubTotals) && !rows[rln].showSubTotals) ||
                            !this.dataSourceSettings.showSubTotals || !this.dataSourceSettings.showRowSubTotals)) ? undefined : val;
                    actualValue = val;
                }
                break;
        }
        const cellDetails = {
            fieldName: this.dataSourceSettings.values[vln].name, row: rows[rln], column: columns[cln], value: value,
            cellSets: this.getValueCellInfo ? this.getCellSet(this.rawIndexObject) : [],
            rowCellType: (rows[rln].hasChild && rows[rln].isDrilled ? 'subTotal' : rows[rln].type === 'grand sum' ? 'grandTotal' : 'value'),
            columnCellType: (columns[cln].hasChild && columns[cln].isDrilled ? 'subTotal' : columns[cln].type === 'grand sum' ? 'grandTotal' : 'value'),
            aggregateType: aggregate, skipFormatting: false
        };
        if (this.getValueCellInfo) {
            this.getValueCellInfo(cellDetails);
        }
        value = cellDetails.value;
        const isSum = rows[rln].hasChild || columns[cln].hasChild || rows[rln].type === 'grand sum' ||
            columns[cln].type === 'grand sum' || (this.showSubTotalsAtBottom && rows[rln].isSum);
        const isGrand = rows[rln].type === 'grand sum' || columns[cln].type === 'grand sum';
        const subTotal = (rows[rln].members.length > 0 && rows[rln].hasChild &&
            rows[rln].isDrilled && ((!isNullOrUndefined(rows[rln].showSubTotals) &&
            !rows[rln].showSubTotals) || !this.dataSourceSettings.showSubTotals || !this.dataSourceSettings.showRowSubTotals));
        let formattedText = subTotal ?
            '' : (value === undefined) ? this.emptyCellTextContent :
            (aggregate === 'Count' || aggregate === 'DistinctCount') ? value.toLocaleString() :
                this.getFormattedValue(value, field).formattedText;
        if (!isNaN(value) && !isNullOrUndefined(value) && (['PercentageOfGrandTotal', 'PercentageOfColumnTotal', 'PercentageOfRowTotal']).indexOf(aggregate) >= 0) {
            formattedText = this.globalize.formatNumber(value, { format: 'P', maximumFractionDigits: this.getPercentFormat(this.formatFields, cellDetails.fieldName) });
        }
        else if (!subTotal &&
            isNaN(value) && !isNullOrUndefined(value) &&
            (['PopulationStDev', 'SampleStDev', 'PopulationVar', 'SampleVar']).indexOf(aggregate) !== -1) {
            formattedText = '#DIV/0!';
            value = 0;
        }
        //dln = data[tnum as number].length;
        formattedText = (cellDetails.skipFormatting ? isNullOrUndefined(value) ?
            this.emptyCellTextContent : value.toString() : formattedText);
        data[tnum][dln] = this.valueContent[actCnt][dln] = {
            axis: 'value', actualText: field, indexObject: this.isDrillThrough ? this.rawIndexObject : {},
            rowHeaders: rows[rln].type === 'grand sum' ? '' : rows[rln].valueSort.levelName,
            columnHeaders: columns[cln].type === 'grand sum' ? '' : columns[cln].valueSort.levelName,
            formattedText: formattedText, value: value,
            hierarchyName: columns[cln].hierarchyName,
            actualValue: actualValue,
            rowIndex: tnum, colIndex: dln, isSum: isSum, isGrandSum: isGrand, showSubTotals: !subTotal
        };
        this.rawIndexObject = {};
    }
    getCellSet(rawIndexObject) {
        const currentCellSets = [];
        const keys = Object.keys(rawIndexObject);
        for (const index of keys) {
            if (this.data[parseInt(index, 10)]) { // eslint-disable-next-line @typescript-eslint/no-explicit-any
                currentCellSets.push(this.data[parseInt(index, 10)]);
            }
        }
        return currentCellSets;
    }
    updateValueMembers(hasMeasureIndex, headerInfo, levelInfo, columnHeaders, axis, vcnt, levelIndex) {
        const levelName = levelInfo && !isNullOrUndefined(levelInfo.levelName) ? levelInfo.levelName.toString() : undefined;
        const uniqueName = levelInfo && !isNullOrUndefined(levelInfo.uniqueName) ? levelInfo.uniqueName.toString() : undefined;
        if (hasMeasureIndex) {
            for (let vln = 0; vln < vcnt; vln++) {
                const field = this.dataSourceSettings.values[vln];
                const name = field.caption ? field.caption : field.name;
                const calObj = {
                    axis: this.valueAxis ? 'row' : 'column',
                    rowIndex: !this.valueAxis ? (headerInfo && levelIndex <= headerInfo.rowIndex ?
                        (headerInfo.rowIndex + 1) : levelIndex) : 0,
                    actualText: field.name,
                    formattedText: name,
                    level: 0,
                    valueSort: {},
                    // colIndex: (tnum) + 1 + vln,
                    // rowIndex: this.measureIndex,
                    members: [],
                    type: this.valueAxis ? 'value' : (headerInfo ? headerInfo.type : null),
                    index: !this.valueAxis && headerInfo ? headerInfo.index : null,
                    indexObject: !this.valueAxis && headerInfo ? headerInfo.indexObject : null
                };
                if (axis.length > 0) {
                    calObj.showSubTotals = field.showSubTotals;
                }
                const vData = calObj.valueSort;
                vData.axis = !this.valueAxis ? field.name : undefined;
                vData[(levelName ? (levelName + this.valueSortSettings.headerDelimiter) : '') + name] = 1;
                vData[(uniqueName ? (uniqueName + this.valueSortSettings.headerDelimiter) : '') + field.name] = 1;
                vData.levelName = (levelName ? (levelName + this.valueSortSettings.headerDelimiter) : '') + name;
                vData.uniqueName = (uniqueName ? (uniqueName + this.valueSortSettings.headerDelimiter) : '') + field.name;
                columnHeaders.push(calObj);
                this.updateValueMembers(false, headerInfo, vData, calObj.members, axis, vcnt, levelIndex + 1);
            }
        }
        else {
            for (let rln = 0, rlt = axis.length; rln < rlt; rln++) {
                const header = PivotUtil.frameHeaderWithKeys(axis[rln]);
                header.members = [];
                header.rowIndex = !this.valueAxis ? (levelIndex < 0 ? 0 : levelIndex) : header.rowIndex;
                const hData = {};
                hData.axis = header.valueSort.axis;
                hData[(levelName ? (levelName + this.valueSortSettings.headerDelimiter) : '') + header.formattedText] = 1;
                hData[(uniqueName ? (uniqueName + this.valueSortSettings.headerDelimiter) : '') + header.actualText] = 1;
                hData.levelName = (levelName ? (levelName + this.valueSortSettings.headerDelimiter) : '') + header.formattedText;
                hData.uniqueName = (uniqueName ? (uniqueName + this.valueSortSettings.headerDelimiter) : '') + header.actualText;
                header.hierarchyName = header.valueSort.uniqueName;
                header.valueSort = hData;
                const drillInfo = hData.axis + this.valueSortSettings.headerDelimiter + hData.levelName;
                const isFieldValueHeader = this.fieldList[hData.axis];
                if (header.isDrilled && (((this.isExpandAll || isFieldValueHeader.expandAll) &&
                    this.fieldDrillCollection[drillInfo]) || ((!this.isExpandAll && !isFieldValueHeader.expandAll) &&
                    !this.fieldDrillCollection[drillInfo]))) {
                    header.isDrilled = false;
                }
                columnHeaders.push(header);
                if (header.isDrilled && axis[rln].members.length > 0) {
                    if (this.valueAxis && levelIndex < this.measureIndex && this.measureIndex !== (levelIndex + 1) && (!(axis[rln].hasChild &&
                        ((!isNullOrUndefined(axis[rln].showSubTotals) && !axis[rln].showSubTotals) ||
                            !this.dataSourceSettings.showSubTotals || !this.dataSourceSettings.showRowSubTotals)))) {
                        this.updateValueMembers(true, header, hData, columnHeaders[columnHeaders.length - 1].members, [], vcnt, levelIndex);
                    }
                    this.updateValueMembers(this.measureIndex === (levelIndex + 1), header, hData, columnHeaders[columnHeaders.length - 1].members, axis[rln].members, vcnt, levelIndex + 1);
                    if (!this.valueAxis && levelIndex < this.measureIndex && this.measureIndex !== (levelIndex + 1) &&
                        (!(axis[rln].hasChild && ((!isNullOrUndefined(axis[rln].showSubTotals) && // eslint-disable-next-line max-len
                            !axis[rln].showSubTotals) || !this.dataSourceSettings.showSubTotals || !this.dataSourceSettings.showColumnSubTotals)))) {
                        this.updateValueMembers(true, header, hData, columnHeaders[columnHeaders.length - 1].members, [], vcnt, levelIndex);
                    }
                }
                else if (levelIndex < this.measureIndex) {
                    this.updateValueMembers(true, header, hData, columnHeaders[columnHeaders.length - 1].members, [], vcnt, levelIndex);
                }
            }
        }
    }
    reArrangeValueMember(member) {
        const valueAxis = [];
        for (const axis of member) {
            if (this.valueAxisFields[axis.actualText]) {
                valueAxis[valueAxis.length] = axis;
            }
        }
        return valueAxis.concat(member).slice(0, member.length);
    }
    frameDefinedHeaderData(axis, reformAxis, data, levelIndex, tnum, vcnt) {
        // let sortText: string = this.valueSortSettings.headerText;
        for (let rln = 0, rlt = axis.length; rln < rlt; rln++) {
            let showSubTotals = true;
            if (axis[rln].members.length > 0 && ((!isNullOrUndefined(axis[rln].showSubTotals) && !axis[rln].showSubTotals) ||
                !this.dataSourceSettings.showSubTotals || !this.dataSourceSettings.showColumnSubTotals)) {
                showSubTotals = false;
            }
            const index = (this.measureIndex < levelIndex && showSubTotals ? 1 : ((this.measureIndex > levelIndex &&
                axis[rln].members.length > 0) || !(this.measureIndex === (levelIndex + 1) &&
                axis[rln].isDrilled) ? ((this.measureIndex === levelIndex && this.measureIndex !== 0 && showSubTotals) ? 1 : ((this.measureIndex > levelIndex && showSubTotals && axis[rln].valueSort &&
                axis[rln].valueSort.axis && this.measureNames[axis[rln].valueSort.axis.toString()]) ? 1 : 0)) : (this.measureIndex === 0 || !showSubTotals ? 0 : 1)));
            if (axis[rln].members.length) {
                let pos;
                let members = axis[rln].members;
                if (this.showSubTotalsAtTop) {
                    if (levelIndex + 1 < this.measureIndex && showSubTotals) {
                        pos = tnum;
                        members = this.reArrangeValueMember(members);
                    }
                    else {
                        pos = tnum + index;
                    }
                }
                else {
                    pos = tnum;
                }
                this.frameDefinedHeaderData(members, reformAxis, data, levelIndex + 1, pos, vcnt);
            }
            // let lvl: number = axis[rln as number].level;
            // axis[rln as number].rowIndex = lvl;
            const level = this.measureIndex > levelIndex && axis[rln].valueSort &&
                axis[rln].valueSort.axis && this.measureNames[axis[rln].valueSort.axis.toString()] ?
                this.measureIndex : levelIndex;
            tnum = this.showSubTotalsAtTop ? tnum + 1 : reformAxis.length + index;
            if (!reformAxis[tnum - 1]) {
                reformAxis[tnum - 1] = PivotUtil.frameHeaderWithKeys(axis[rln]);
            }
            axis[rln].colIndex = tnum;
            if (!data[level]) {
                data[level] = [];
                this.headerContent[level] = {};
                data[level][tnum] = this.headerContent[level][tnum]
                    = PivotUtil.frameHeaderWithKeys(axis[rln]);
            }
            else {
                data[level][tnum] = this.headerContent[level][tnum]
                    = PivotUtil.frameHeaderWithKeys(axis[rln]);
            }
            if (!this.isPagingOrVirtualizationEnabled && (this.showSubTotalsAtTop ? index !== 0 : true)) {
                if (reformAxis[tnum - 1]) {
                    reformAxis[tnum - 1].members = [];
                }
            }
            if (this.showSubTotalsAtTop) {
                tnum = reformAxis.length;
                if (rln + 1 === rlt && axis[rln].level === 0) {
                    this.reformAxisCount = reformAxis.length + 1;
                }
            }
        }
    }
    getHeaderData(rows, columns, values, rowAxis, axis, reformAxis, data, tnum, vcnt) {
        if (!this.valueAxis && !this.isLastHeaderHasMeasures) {
            const columnHeaders = [];
            if (this.dataSourceSettings.showGrandTotals && this.dataSourceSettings.showColumnGrandTotals && axis[axis.length - 1].type === 'grand sum') {
                this.updateValueMembers(this.measureIndex === 0 && axis.length > 1, null, null, columnHeaders, axis.slice(0, axis.length - 1), vcnt, 0);
                this.updateValueMembers(false, null, null, columnHeaders, axis.slice(axis.length - 1, axis.length), vcnt, -1);
            }
            else if (this.dataSourceSettings.grandTotalsPosition === 'Top' && this.dataSourceSettings.showGrandTotals && this.measureIndex === 0) {
                this.updateValueMembers(false, null, null, columnHeaders, axis.slice(0, 1), vcnt, -1);
                this.updateValueMembers(this.measureIndex === 0 && axis.length > 1, null, null, columnHeaders, axis.slice(1, axis.length), vcnt, 0);
            }
            else {
                const hasColumnTotal = columns.length === 0 && axis.length === 1 && axis[0].type === 'grand sum';
                this.updateValueMembers(!hasColumnTotal && this.measureIndex === 0, null, null, columnHeaders, axis, vcnt, hasColumnTotal ? -1 : 0);
            }
            this.getAggregatedHeaders(rows, columns, this.rMembers, columnHeaders, values);
            if (this.selectedHeaders.values.length > 0) {
                for (let clt = this.selectedHeaders.selectedHeader.length, i = 0; i < clt; i++) {
                    const headerData = this.selectedHeaders.selectedHeader[i];
                    if (headerData.axis === 'column') {
                        if (headerData.uniqueName === headerData.value) {
                            this.selectedHeaders.selectedHeader.splice(i, 1);
                            i--;
                            clt--;
                        }
                        else if (headerData.uniqueName === 'Grand Total') {
                            for (let clt = headerData.aggregateHeaders.length, j = 0; j < clt; j++) {
                                if (headerData.aggregateHeaders[j] &&
                                    headerData.aggregateHeaders[j].members.length > 0) {
                                    for (const member of headerData.aggregateHeaders[j].members) {
                                        if (member.actualText === headerData.value) {
                                            headerData.aggregateHeaders[j] = member;
                                            if (member.type === 'grand sum') {
                                                headerData.uniqueName = member.valueSort.levelName;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            this.frameDefinedHeaderData(columnHeaders, reformAxis, data, 0, this.showSubTotalsAtTop ? 0 : 1, vcnt);
            return;
        }
        else if (rowAxis.length === 0 && ( // eslint-disable-next-line max-len
        this.valueAxis && (this.isMultiMeasures || this.dataSourceSettings.alwaysShowValueHeader)) && this.dataSourceSettings.values.length > 0) {
            if (this.dataSourceSettings.showGrandTotals && this.dataSourceSettings.showRowGrandTotals &&
                this.rMembers[this.rMembers.length - 1].type === 'grand sum') {
                this.updateValueMembers(this.measureIndex === 0 && this.rMembers.length > 1, null, null, rowAxis, this.rMembers.slice(0, this.rMembers.length - 1), this.dataSourceSettings.values.length, 0);
                this.updateValueMembers(false, null, null, rowAxis, this.rMembers.slice(this.rMembers.length - 1, this.rMembers.length), this.dataSourceSettings.values.length, -1);
            }
            else if (this.dataSourceSettings.grandTotalsPosition === 'Top' && this.dataSourceSettings.showGrandTotals && this.measureIndex === 0) {
                this.updateValueMembers(false, null, null, rowAxis, this.rMembers.slice(0, 1), this.dataSourceSettings.values.length, -1);
                this.updateValueMembers(this.measureIndex === 0 && this.rMembers.length > 1, null, null, rowAxis, this.rMembers.slice(1, this.rMembers.length), this.dataSourceSettings.values.length, 0);
            }
            else {
                const hasRowTotal = rows.length === 0 && this.rMembers.length === 1 && this.rMembers[0].type === 'grand sum';
                this.updateValueMembers(// eslint-disable-next-line max-len
                !hasRowTotal && this.measureIndex === 0, null, null, rowAxis, this.rMembers, this.dataSourceSettings.values.length, hasRowTotal ? -1 : 0);
            }
            this.getAggregatedHeaders(rows, columns, rowAxis, axis, values);
            if (this.selectedHeaders.values.length > 0) {
                for (let clt = this.selectedHeaders.selectedHeader.length, i = 0; i < clt; i++) {
                    const headerData = this.selectedHeaders.selectedHeader[i];
                    if (headerData.axis === 'row') {
                        for (let clt = headerData.aggregateHeaders.length, j = 0; j < clt; j++) {
                            if (headerData.aggregateHeaders[j].actualText === headerData.value) {
                                if (headerData.aggregateHeaders[j].valueSort.levelName.indexOf(headerData.uniqueName) !== -1) {
                                    headerData.uniqueName = headerData.aggregateHeaders[j].valueSort.levelName;
                                    headerData.aggregateHeaders.splice(j, 1);
                                    j--;
                                    clt--;
                                }
                                else {
                                    for (let count = headerData.aggregateHeaders[j].members.length, k = 0; k < count; k++) {
                                        const member = headerData.aggregateHeaders[j].members[k];
                                        if (member.type !== 'value' && member.level ===
                                            headerData.aggregateHeaders[j].level) {
                                            const members = extend([], headerData.aggregateHeaders[j].members, null, true);
                                            headerData.aggregateHeaders = [].concat(headerData.aggregateHeaders, members, headerData.aggregateHeaders.splice(j));
                                            headerData.aggregateHeaders.splice(members.length + j, 1);
                                            j = (members.length + j) - 1;
                                            clt = headerData.aggregateHeaders.length;
                                        }
                                    }
                                }
                            }
                            else if (headerData.aggregateHeaders[j].actualText !== headerData.value &&
                                headerData.aggregateHeaders[j].members.length > 0) {
                                for (let count = headerData.aggregateHeaders[j].members.length, k = 0; k < count; k++) {
                                    const member = headerData.aggregateHeaders[j].members[k];
                                    if (member.actualText === headerData.value) {
                                        if (headerData.uniqueName ===
                                            headerData.aggregateHeaders[j].valueSort.levelName) {
                                            headerData.uniqueName = member.valueSort.levelName;
                                        }
                                        headerData.aggregateHeaders[j].members.splice(k, 1);
                                        headerData.aggregateHeaders[j] = member;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        const rlt = axis.length;
        const colItmLn = this.dataSourceSettings.columns.length;
        const sortText = this.valueSortSettings.headerText;
        //let valueLn: number = this.dataSourceSettings.values.length;
        for (let rln = 0; rln < rlt; rln++) {
            const isHidden = !isNullOrUndefined(axis[rln].showSubTotals) && !axis[rln].showSubTotals;
            if (axis[rln].members.length) {
                this.getHeaderData(rows, columns, values, rowAxis, axis[rln].members, reformAxis, data, this.showSubTotalsAtTop && !isHidden ? tnum + 1 : tnum, vcnt);
            }
            let isTotalHide = true;
            tnum = this.showSubTotalsAtTop ? tnum : reformAxis.length;
            if (isHidden || !this.dataSourceSettings.showSubTotals || !this.dataSourceSettings.showColumnSubTotals) {
                if (!(axis[rln].members.length > 0)) {
                    reformAxis[this.showSubTotalsAtTop ? tnum : reformAxis.length] = PivotUtil.frameHeaderWithKeys(axis[rln]);
                }
                else {
                    this.removeCount++;
                    isTotalHide = false;
                }
                tnum = this.showSubTotalsAtTop ? tnum : reformAxis.length - 1;
            }
            else {
                reformAxis[tnum] = PivotUtil.frameHeaderWithKeys(axis[rln]);
            }
            //  let rplus: number = rln + 1;
            const lvl = axis[rln].level;
            axis[rln].rowIndex = lvl;
            const index = (tnum * vcnt) + (this.showSubTotalsAtTop ? 1 : vcnt);
            axis[rln].colIndex = index;
            if (!data[lvl]) {
                data[lvl] = [];
                this.headerContent[lvl] = {};
                data[lvl][index] = this.headerContent[lvl][index]
                    = PivotUtil.frameHeaderWithKeys(axis[rln]);
            }
            else {
                data[lvl][index] = this.headerContent[lvl][index]
                    = PivotUtil.frameHeaderWithKeys(axis[rln]);
            } // eslint-disable-next-line max-len
            const isSingleMeasure = (this.dataSourceSettings.columns.length === 0 && this.dataSourceSettings.values.length === 1) ? true : false;
            // eslint-disable-next-line max-len
            if ((this.isMultiMeasures || this.dataSourceSettings.alwaysShowValueHeader || isSingleMeasure) && !this.valueAxis && isTotalHide) {
                for (let vln = 0; vln < vcnt; vln++) {
                    const name = this.dataSourceSettings.values[vln].caption ?
                        this.dataSourceSettings.values[vln].caption : this.dataSourceSettings.values[vln].name;
                    const calObj = {
                        axis: 'column', actualText: this.dataSourceSettings.values[vln].name, formattedText: name, level: 0, valueSort: {},
                        colIndex: (tnum * vcnt) + 1 + vln, rowIndex: colItmLn
                    };
                    if (!data[colItmLn]) {
                        data[colItmLn] = [];
                        this.headerContent[colItmLn] = {};
                        data[colItmLn][(tnum * vcnt) + 1 + vln] =
                            this.headerContent[colItmLn][(tnum * vcnt) + 1 + vln] = calObj;
                    }
                    else {
                        data[colItmLn][(tnum * vcnt) + 1 + vln] =
                            this.headerContent[colItmLn][(tnum * vcnt) + 1 + vln] = calObj;
                    }
                    const vData = data[colItmLn][(tnum * vcnt) + 1 + vln].valueSort;
                    vData[axis[rln].valueSort.levelName + this.valueSortSettings.headerDelimiter + name] = 1;
                    vData.levelName = axis[rln].valueSort.levelName + this.valueSortSettings.headerDelimiter + name;
                    vData[axis[rln].valueSort.uniqueName + this.valueSortSettings.headerDelimiter +
                        this.dataSourceSettings.values[vln].name] = 1;
                    vData.uniqueName = axis[rln].valueSort.uniqueName +
                        this.valueSortSettings.headerDelimiter + this.dataSourceSettings.values[vln].name;
                    if (vData && vData[sortText]) {
                        this.valueSortSettings.columnIndex = (tnum * vcnt) + 1 + vln;
                    }
                }
            }
            else if (axis[rln].valueSort && axis[rln].valueSort[sortText]) {
                this.valueSortSettings.columnIndex = (tnum * vcnt) + 1;
            }
            if (!this.isPagingOrVirtualizationEnabled) {
                reformAxis[tnum].members = [];
            }
            if (this.showSubTotalsAtTop) {
                tnum = reformAxis.length;
                if (axis[rln].level === 0 && rln + 1 === rlt) {
                    this.reformAxisCount = (reformAxis.length * vcnt) + 1;
                }
            }
        }
    }
    getAggregateValue(rowIndex, columnIndex, value, type, isGrandTotal) {
        //rowIndex = rowIndex.sort();
        //columnIndex = columnIndex.sort();
        //let clt: number = columnIndex.length;
        let ri = 0;
        let cellValue = 0;
        let avgCnt = 0;
        let isInit = true;
        let isValueExist = false;
        switch (type.toLowerCase()) {
            case 'median':
                {
                    const values = [];
                    let position = 0;
                    while (rowIndex[ri] !== undefined) {
                        if (columnIndex[rowIndex[ri]] !== undefined) {
                            isValueExist = true;
                            this.rawIndexObject[rowIndex[ri]] = rowIndex[ri];
                            if (!isNullOrUndefined(this.valueMatrix[rowIndex[ri]][value])) {
                                values.push(this.valueMatrix[rowIndex[ri]][value]);
                            }
                        }
                        ri++;
                    }
                    const len = values.length;
                    if (len > 0) {
                        values.sort((a, b) => a - b);
                        if (len % 2 === 0) {
                            position = (len / 2) <= 1 ? 0 : ((len / 2) - 1);
                            cellValue = (values[position] + values[position + 1]) / 2;
                        }
                        else {
                            position = (len + 1) / 2 <= 1 ? 0 : (((len + 1) / 2) - 1);
                            cellValue = values[position];
                        }
                    }
                }
                break;
            case 'count':
                {
                    while (rowIndex[ri] !== undefined) {
                        if (columnIndex[rowIndex[ri]] !== undefined) {
                            isValueExist = true;
                            this.rawIndexObject[rowIndex[ri]] = rowIndex[ri];
                            cellValue += (isNullOrUndefined(this.valueMatrix[rowIndex[ri]][value]) ?
                                0 : (this.allowDataCompression ? this.valueMatrix[rowIndex[ri]][value] : 1));
                        }
                        ri++;
                    }
                }
                break;
            case 'distinctcount':
                {
                    const duplicateValues = [];
                    while (rowIndex[ri] !== undefined) {
                        if (columnIndex[rowIndex[ri]] !== undefined) {
                            this.rawIndexObject[rowIndex[ri]] = rowIndex[ri];
                            isValueExist = true;
                            const val = (this.data[rowIndex[ri]][this.fieldKeys[this.fields[value]]]);
                            // let currentVal: number = this.valueMatrix[rowIndex[ri as number]][value as number];
                            if (!isNullOrUndefined(val)) {
                                const currentVal = val.toString();
                                if (duplicateValues.length === 0 || (duplicateValues.length > 0 &&
                                    duplicateValues.indexOf(currentVal) === -1)) {
                                    cellValue += (this.allowDataCompression && typeof val === 'number') ? val : 1;
                                    duplicateValues.push(currentVal);
                                }
                            }
                        }
                        ri++;
                    }
                }
                break;
            case 'product':
                {
                    while (rowIndex[ri] !== undefined) {
                        if (columnIndex[rowIndex[ri]] !== undefined) {
                            this.rawIndexObject[rowIndex[ri]] = rowIndex[ri];
                            isValueExist = true;
                            const currentVal = this.valueMatrix[rowIndex[ri]][value];
                            if (!isNullOrUndefined(currentVal)) {
                                cellValue = ((isInit || isNullOrUndefined(cellValue)) ? 1 : cellValue);
                                cellValue *= currentVal;
                            }
                            else if (isInit) {
                                cellValue = currentVal;
                            }
                            isInit = false;
                        }
                        ri++;
                    }
                }
                break;
            case 'populationstdev':
            case 'samplestdev':
            case 'populationvar':
            case 'samplevar':
                {
                    let i = 0;
                    let val = 0;
                    const indexVal = [];
                    let avgVal = 0;
                    let cVal = 0;
                    let avgDifferenceVal = 0;
                    while (rowIndex[ri] !== undefined) {
                        if (columnIndex[rowIndex[ri]] !== undefined) {
                            isValueExist = true;
                            this.rawIndexObject[rowIndex[ri]] = rowIndex[ri];
                            const currentVal = this.valueMatrix[rowIndex[ri]][value];
                            if (!isNullOrUndefined(currentVal)) {
                                val += currentVal;
                                indexVal.push(currentVal);
                                i++;
                            }
                        }
                        ri++;
                    }
                    if (i > 0) {
                        avgVal = val / i;
                        for (const index of indexVal) {
                            avgDifferenceVal += Math.pow((index - avgVal), 2);
                        }
                        if ((['populationstdev', 'samplestdev']).indexOf(type.toLowerCase()) !== -1) {
                            cVal = Math.sqrt(avgDifferenceVal / (type.toLowerCase() === 'populationstdev' ? i : (i - 1)));
                        }
                        else {
                            cVal = avgDifferenceVal / (type.toLowerCase() === 'populationvar' ? i : (i - 1));
                        }
                        cellValue = (cVal === 0 ? NaN : cVal);
                    }
                    else {
                        cellValue = val;
                    }
                }
                break;
            case 'min':
                {
                    let isFirst = true;
                    cellValue = undefined;
                    while (rowIndex[ri] !== undefined) {
                        if (columnIndex[rowIndex[ri]] !== undefined &&
                            this.valueMatrix[rowIndex[ri]][value] !== undefined) {
                            isValueExist = true;
                            this.rawIndexObject[rowIndex[ri]] = rowIndex[ri];
                            if (isNullOrUndefined(cellValue) && isNullOrUndefined(this.valueMatrix[rowIndex[ri]][value])) {
                                cellValue = this.valueMatrix[rowIndex[ri]][value];
                            }
                            else {
                                if (isFirst) {
                                    cellValue = this.valueMatrix[rowIndex[ri]][value];
                                    isFirst = false;
                                }
                                else {
                                    cellValue = this.valueMatrix[rowIndex[ri]][value] < cellValue ?
                                        this.valueMatrix[rowIndex[ri]][value] : cellValue;
                                }
                            }
                        }
                        ri++;
                    }
                }
                break;
            case 'max':
                {
                    let isMaxFirst = true;
                    while (rowIndex[ri] !== undefined) {
                        if (columnIndex[rowIndex[ri]] !== undefined &&
                            this.valueMatrix[rowIndex[ri]][value] !== undefined) {
                            isValueExist = true;
                            this.rawIndexObject[rowIndex[ri]] = rowIndex[ri];
                            if (isMaxFirst) {
                                cellValue = this.valueMatrix[rowIndex[ri]][value];
                                isMaxFirst = false;
                            }
                            else {
                                cellValue = this.valueMatrix[rowIndex[ri]][value] > cellValue ?
                                    this.valueMatrix[rowIndex[ri]][value] : cellValue;
                            }
                        }
                        ri++;
                    }
                }
                break;
            case 'calculatedfield':
                {
                    isValueExist = true;
                    const calcField = this.calculatedFields[this.fields[value]];
                    let actualFormula = calcField.formula;
                    const aggregateField = {};
                    if (this.calculatedFormulas[calcField.name]) {
                        const calculatedFormulas = this.calculatedFormulas[calcField.name];
                        for (let len = 0, lmt = calculatedFormulas.length; len < lmt; len++) {
                            const aggregatedValue = calculatedFormulas[len];
                            let value = aggregateField[aggregatedValue.formula];
                            if (value === undefined) {
                                const type = aggregatedValue.type;
                                value = this.getAggregateValue(rowIndex, columnIndex, aggregatedValue.index, type, false);
                                aggregateField[aggregatedValue.formula] = value;
                            }
                            actualFormula = (actualFormula).replace(aggregatedValue.formula, String(value));
                        }
                    }
                    cellValue = this.evaluate(actualFormula);
                    cellValue = (cellValue === Infinity || cellValue === -Infinity ? Infinity : (cellValue === undefined || isNaN(cellValue)) ?
                        undefined : JSON.parse(String(cellValue)));
                }
                break;
            default:
                {
                    cellValue = undefined;
                    while (rowIndex[ri] !== undefined) {
                        if (columnIndex[rowIndex[ri]] !== undefined) {
                            isValueExist = true;
                            if (!isGrandTotal) {
                                this.rawIndexObject[rowIndex[ri]] = rowIndex[ri];
                            }
                            //let cIndx: number = isLeastLevel ? columnIndex.splice(columnIndex.indexOf(rowIndex[ri as number]), 1)[0] : rowIndex[ri as number];
                            const currentVal = this.valueMatrix[rowIndex[ri]][value];
                            if (isNullOrUndefined(cellValue) && isNullOrUndefined(currentVal)) {
                                cellValue = currentVal;
                            }
                            else {
                                if (isNullOrUndefined(cellValue)) {
                                    cellValue = 0;
                                }
                                cellValue += (isNullOrUndefined(currentVal) ? 0 : currentVal);
                            }
                            if (!isNullOrUndefined(currentVal)) {
                                avgCnt++;
                            }
                        }
                        ri++;
                    }
                }
                break;
        }
        /* if (rlt > clt) {
             this.makeMirrorObject(rowIndex, mirror);
             while (columnIndex[ci] !== undefined) {
                 if (mirror[columnIndex[ci]]) {
                     let cIndx: number = isLeastLevel ? columnIndex.splice(ci, 1)[0] : columnIndex[ci];
                     //rowIndex.splice
                     sum += this.valueMatrix[cIndx][value as number];
                 }
                 ci++;
             }
         } else {
             this.makeMirrorObject(columnIndex, mirror);
             while (rowIndex[ri as number] !== undefined) {
                 if (mirror[rowIndex[ri as number]]) {
                     let cIndx: number = isLeastLevel ? columnIndex.splice(columnIndex.indexOf(rowIndex[ri as number]), 1)[0] : rowIndex[ri as number];
                     sum += this.valueMatrix[rowIndex[ri as number]][value as number];
                 }
                 ri++;
             }
         } */
        return ((type && type.toLowerCase() === 'avg' && cellValue !== 0 &&
            !isNullOrUndefined(cellValue)) ? (cellValue / avgCnt) : isValueExist ? cellValue : undefined);
    }
    evaluate(obj) {
        return Function('"use strict";return (' + obj + ')')();
    }
    /**
     * It performs the formatting to get formatted Value
     *
     * @param {number | string} value - It contains the value which went formatting.
     * @param {string} fieldName - It contains the field name.
     * @returns {IAxisSet} - It returns the formatted value as IAxisSet data.
     * @hidden
     */
    getFormattedValue(value, fieldName) {
        const commonValue = value === null ? (this.localeObj ? this.localeObj.getConstant('null') :
            String(value)) : value === undefined ?
            (this.localeObj ? (fieldName in this.groupingFields) ? this.localeObj.getConstant('groupOutOfRange') :
                this.localeObj.getConstant('undefined') : String(value)) : value;
        const formattedValue = {
            formattedText: commonValue.toString(),
            actualText: commonValue,
            dateText: commonValue
        };
        if (this.formatFields[fieldName] && this.formatFields[fieldName].format && !isNullOrUndefined(value)) {
            try {
                const formatField = (this.formatFields[fieldName].properties ?
                    this.formatFields[fieldName].properties :
                    this.formatFields[fieldName]);
                const formatSetting = extend({}, formatField, null, true);
                delete formatSetting.name;
                if (!formatSetting.minimumSignificantDigits && formatSetting.minimumSignificantDigits < 1) {
                    delete formatSetting.minimumSignificantDigits;
                }
                if (!formatSetting.maximumSignificantDigits && formatSetting.maximumSignificantDigits < 1) {
                    delete formatSetting.maximumSignificantDigits;
                }
                if (formatSetting.type) {
                    formattedValue.formattedText = this.dateFormatFunction[fieldName].exactFormat(new Date(value));
                    formattedValue.actualText = value;
                }
                else {
                    delete formatSetting.type;
                    if ((formatSetting.format) && !(this.formatRegex.test(formatSetting.format))) {
                        // eslint-disable-next-line security/detect-unsafe-regex
                        let pattern = formatSetting.format.match(/^(('[^']+'|''|[^*#@0,.])*)(\*.)?((([0#,]*[0,]*[0#]*)(\.[0#]*)?)|([#,]*@+#*))(E\+?0+)?(('[^']+'|''|[^*#@0,.E])*)$/);
                        let flag = true;
                        if (isNullOrUndefined(formatSetting.minimumFractionDigits)) {
                            delete formatSetting.minimumFractionDigits;
                        }
                        if (isNullOrUndefined(formatSetting.maximumFractionDigits)) {
                            delete formatSetting.maximumFractionDigits;
                        }
                        if (isNullOrUndefined(formatSetting.minimumIntegerDigits)) {
                            delete formatSetting.minimumIntegerDigits;
                        }
                        if (isNullOrUndefined(pattern)) {
                            // eslint-disable-next-line security/detect-unsafe-regex
                            pattern = formatSetting.format.match(/^(('[^']+'|''|[^*@0])*)(\*.)?((([0#,]*[0,]*[0#]*)(\.[0#]*)?)|([#,]*@+#*))(E\+?0+)?(('[^']+'|''|[^*#@,.E])*)$/);
                            delete formatSetting.useGrouping;
                            flag = false;
                        }
                        if (pattern && pattern.length > 5) {
                            const integerPart = pattern[6];
                            if (flag) {
                                formatSetting.useGrouping = integerPart.indexOf(',') !== -1;
                            }
                        }
                    }
                    formattedValue.formattedText =
                        this.globalize.formatNumber(!isNaN(Number(value)) ? Number(value) : value, formatSetting);
                    formattedValue.actualText = !isNaN(Number(value)) ? Number(value) : value;
                    formattedValue.dateText = !isNaN(Number(value)) ? Number(value) : value;
                }
                if (this.fieldList[fieldName].sort !== 'None' && formatSetting.type &&
                    ['date', 'dateTime', 'time'].indexOf(this.formatFields[fieldName].type) > -1) {
                    formattedValue.dateText = this.dateFormatFunction[fieldName].fullFormat(new Date(value));
                }
                if (this.fieldList[fieldName].isCustomField) {
                    formattedValue.formattedText = formattedValue.formattedText === 'NaN' ?
                        commonValue.toString() : formattedValue.formattedText;
                    formattedValue.dateText = formattedValue.dateText === 'NaN' ?
                        commonValue.toString() : formattedValue.dateText;
                }
            }
            catch (exception) {
                if (!this.fieldList[fieldName].isCustomField) {
                    throw exception;
                }
            }
            finally {
                if (this.fieldList[fieldName].isCustomField) {
                    formattedValue.formattedText =
                        (isNullOrUndefined(formattedValue.formattedText) || formattedValue.formattedText === 'NaN') ?
                            commonValue.toString() : formattedValue.formattedText;
                    formattedValue.dateText = (isNullOrUndefined(formattedValue.dateText) || formattedValue.dateText === 'NaN') ?
                        commonValue.toString() : formattedValue.dateText;
                }
            }
        }
        return formattedValue;
    }
    powerFunction(formula) {
        if (formula.indexOf('^') > -1) {
            const items = [];
            while (formula.indexOf('(') > -1) {
                // eslint-disable-next-line no-useless-escape
                formula = formula.replace(/(\([^\(\)]*\))/g, (text, item) => {
                    items.push(item);
                    return ('~' + (items.length - 1));
                });
            }
            items.push(formula);
            formula = '~' + (items.length - 1);
            while (formula.indexOf('~') > -1) {
                formula = formula.replace(new RegExp('~' + '(\\d+)', 'g'), (text, index) => {
                    return items[index].replace(/(\w*)\^(\w*)/g, 'Math.pow' + '($1,$2)');
                });
            }
        }
        return formula;
    }
}

/**
 * Specifies pivot external events
 *
 * @hidden
 */
/** @hidden */
const load = 'load';
/** @hidden */
const enginePopulating = 'enginePopulating';
/** @hidden */
const enginePopulated = 'enginePopulated';
/** @hidden */
const onFieldDropped = 'onFieldDropped';
/** @hidden */
const fieldDrop = 'fieldDrop';
/** @hidden */
const beforePivotTableRender = 'beforePivotTableRender';
/** @hidden */
const afterPivotTableRender = 'afterPivotTableRender';
/** @hidden */
const beforeExport = 'beforeExport';
/** @hidden */
const exportComplete = 'exportComplete';
/** @hidden */
const excelHeaderQueryCellInfo = 'excelHeaderQueryCellInfo';
/** @hidden */
const pdfHeaderQueryCellInfo = 'pdfHeaderQueryCellInfo';
/** @hidden */
const excelQueryCellInfo = 'excelQueryCellInfo';
/** @hidden */
const pdfQueryCellInfo = 'pdfQueryCellInfo';
/** @hidden */
const onPdfCellRender = 'onPdfCellRender';
/** @hidden */
const dataBound = 'dataBound';
/** @hidden */
const queryCellInfo = 'queryCellInfo';
/** @hidden */
const headerCellInfo = 'headerCellInfo';
/** @hidden */
const hyperlinkCellClick = 'hyperlinkCellClick';
/** @hidden */
const resizing = 'resizing';
/** @hidden */
const resizeStop = 'resizeStop';
/** @hidden */
const cellClick = 'cellClick';
/** @hidden */
const drillThrough = 'drillThrough';
/** @hidden */
const beforeColumnsRender = 'beforeColumnsRender';
/** @hidden */
const selected = 'selected';
/** @hidden */
const cellSelecting = 'cellSelecting';
/** @hidden */
const drill = 'drill';
/** @hidden */
const cellSelected = 'cellSelected';
/** @hidden */
const cellDeselected = 'cellDeselected';
/** @hidden */
const rowSelected = 'rowSelected';
/** @hidden */
const rowDeselected = 'rowDeselected';
/** @hidden */
const beginDrillThrough = 'beginDrillThrough';
/** @hidden */
const editCompleted = 'editCompleted';
/** @hidden */
const multiLevelLabelClick = 'multiLevelLabelClick';
/** @hidden */
const saveReport = 'saveReport';
/** @hidden */
const fetchReport = 'fetchReport';
/** @hidden */
const loadReport = 'loadReport';
/** @hidden */
const renameReport = 'renameReport';
/** @hidden */
const removeReport = 'removeReport';
/** @hidden */
const newReport = 'newReport';
/** @hidden */
const toolbarRender = 'toolbarRender';
/** @hidden */
const toolbarClick = 'toolbarClick';
/** @hidden */
const chartTooltipRender = 'chartTooltipRender';
/** @hidden */
const chartLegendClick = 'chartLegendClick';
/** @hidden */
const chartLoaded = 'chartLoaded';
/** @hidden */
const chartLoad = 'chartLoad';
/** @hidden */
const chartResized = 'chartResized';
/** @hidden */
const chartAxisLabelRender = 'chartAxisLabelRender';
/** @hidden */
const chartSeriesCreated = 'chartSeriesCreated';
/** @hidden */
const aggregateCellInfo = 'aggregateCellInfo';
/** @hidden */
const onHeadersSort = 'onHeadersSort';
/** @hidden */
const contextMenuClick = 'contextMenuClick';
/** @hidden */
const contextMenuOpen = 'contextMenuOpen';
/** @hidden */
const fieldListRefreshed = 'fieldListRefreshed';
/** @hidden */
const conditionalFormatting = 'conditionalFormatting';
/** @hidden */
const beforePdfExport = 'beforePdfExport';
/** @hidden */
const beforeExcelExport = 'beforeExcelExport';
/** @hidden */
const memberFiltering = 'memberFiltering';
/** @hidden */
const calculatedFieldCreate = 'calculatedFieldCreate';
/** @hidden */
const memberEditorOpen = 'memberEditorOpen';
/** @hidden */
const fieldRemove = 'fieldRemove';
/** @hidden */
const numberFormatting = 'numberFormatting';
/** @hidden */
const aggregateMenuOpen = 'aggregateMenuOpen';
/** @hidden */
const fieldDragStart = 'fieldDragStart';
/** @hidden */
const chartPointClick = 'chartPointClick';
/** @hidden */
const beforeServiceInvoke = 'beforeServiceInvoke';
/** @hidden */
const actionBegin = 'actionBegin';
/** @hidden */
const actionComplete = 'actionComplete';
/** @hidden */
const actionFailure = 'actionFailure';
/**
 * Specifies pivot internal events
 */
/** @hidden */
const initialLoad = 'initial-load';
/** @hidden */
const uiUpdate = 'ui-update';
/** @hidden */
const scroll = 'scroll';
/** @hidden */
const verticalScroll = 'vertical-scroll';
/** @hidden */
const horizontalScroll = 'horizontal-scroll';
/** @hidden */
const contentReady = 'content-ready';
/** @hidden */
const dataReady = 'data-ready';
/** @hidden */
const initSubComponent = 'init-groupingbar';
/** @hidden */
const treeViewUpdate = 'tree-view-update';
/** @hidden */
const pivotButtonUpdate = 'pivot-button-update';
/** @hidden */
const initCalculatedField = 'init-calculatedfield';
/** @hidden */
const click = 'click';
/** @hidden */
const initToolbar = 'init-toolbar';
/** @hidden */
const initPivotPager = 'init-pivotPager';
/** @hidden */
const initFormatting = 'init-formatting';
/** @hidden */
const initGrouping = 'init-grouping';
/**
 * Specifies action names of actionBegin events
 */
/** @hidden */
const sortValue = 'Sort value';
/** @hidden */
const drillUp = 'Drill up';
/** @hidden */
const drillDown = 'Drill down';
/** @hidden */
const addNewReport = 'Add new report';
/** @hidden */
const saveCurrentReport = 'Save current report';
/** @hidden */
const saveAsCurrentReport = 'Save as current report';
/** @hidden */
const renameCurrentReport = 'Rename current report';
/** @hidden */
const removeCurrentReport = 'Remove current report';
/** @hidden */
const loadReports = 'Load report';
/** @hidden */
const openConditionalFormatting = 'Open conditional formatting dialog';
/** @hidden */
const openNumberFormatting = 'Open number formatting dialog';
/** @hidden */
const MdxQuery = 'MdxQuery';
/** @hidden */
const showFieldList = 'Open field list';
/** @hidden */
const tableView = 'Show table view';
/** @hidden */
const chartView = 'Show chart view';
/** @hidden */
const multipleAxis = 'Multiple Axis';
/** @hidden */
const showLegend = 'Show legend';
/** @hidden */
const pdfExport = 'PDF export';
/** @hidden */
const pngExport = 'PNG export';
/** @hidden */
const excelExport = 'Excel export';
/** @hidden */
const csvExport = 'CSV export';
/** @hidden */
const jpegExport = 'JPEG export';
/** @hidden */
const svgExport = 'SVG export';
/** @hidden */
const hideSubTotals = 'Hide sub-totals';
/** @hidden */
const subTotalsRow = 'Show row sub-totals';
/** @hidden */
const subTotalsColumn = 'Show column sub-totals';
/** @hidden */
const showSubTotals = 'Show sub-totals';
/** @hidden */
const hideGrandTotals = 'Hide grand totals';
/** @hidden */
const grandTotalsRow = 'Show row grand totals';
/** @hidden */
const grandTotalsColumn = 'Show column grand totals';
/** @hidden */
const showGrandTotals = 'Show grand totals';
/** @hidden */
const numberFormattingMenu = 'Number Formatting menu';
/** @hidden */
const conditionalFormattingMenu = 'Conditional Formatting menu';
/** @hidden */
const reportChange = 'Report change';
/** @hidden */
const sortFieldTree = 'Sort field tree';
/** @hidden */
const editCalculatedField = 'Edit calculated field';
/** @hidden */
const sortField = 'Sort field';
/** @hidden */
const filterField = 'Filter field';
/** @hidden */
const removeField = 'Remove field';
/** @hidden */
const openCalculatedField = 'Open calculated field dialog';
/** @hidden */
const editRecord = 'Edit record';
/** @hidden */
const saveEditedRecords = 'Save edited records';
/** @hidden */
const addNewRecord = 'Add new record';
/** @hidden */
const removeRecord = 'Remove record';
/** @hidden */
const aggregateField = 'Aggregate field';
/** @hidden */
const contextMenuCalculatedField = 'CalculatedField Context menu';
/** @hidden */
const windowResize = 'Window resize';
/** @hidden */
const rowPageNavigation = 'Navigate row page';
/** @hidden */
const columnPageNavigation = 'Navigate column page';
/**
 * Specifies action names of actionComplete events
 */
/** @hidden */
const calculatedFieldApplied = 'Calculated field applied';
/** @hidden */
const editedRecordsSaved = 'Edited records saved';
/** @hidden */
const newRecordAdded = 'New record added';
/** @hidden */
const recordRemoved = 'Record removed';
/** @hidden */
const closeFieldlist = 'Field list closed';
/** @hidden */
const fieldTreeSorted = 'Field tree sorted';
/** @hidden */
const reportSaved = 'Report saved';
/** @hidden */
const newReportAdded = 'New report added';
/** @hidden */
const reportReSaved = 'Report re-saved';
/** @hidden */
const reportRenamed = 'Reportrenamed';
/** @hidden */
const reportRemoved = 'Report removed';
/** @hidden */
const excelExported = 'Excel exported';
/** @hidden */
const csvExported = 'CSV exported';
/** @hidden */
const pdfExported = 'PDF exported';
/** @hidden */
const pngExported = 'PNG exported';
/** @hidden */
const jpegExported = 'JPEG exported';
/** @hidden */
const svgExported = 'SVG exported';
/** @hidden */
const conditionallyFormatted = 'Conditional formatting applied';
/** @hidden */
const numberFormatted = 'Number formatting applied';
/** @hidden */
const tableViewed = 'Table view shown';
/** @hidden */
const chartViewed = 'Chart view shown';
/** @hidden */
const subTotalsHidden = 'Sub-totals hidden';
/** @hidden */
const subTotalsRowShown = 'Row sub-totals shown';
/** @hidden */
const subTotalsColumnShown = 'Column sub-totals shown';
/** @hidden */
const subTotalsShown = 'Sub-totals shown';
/** @hidden */
const grandTotalsHidden = 'Grand totals hidden';
/** @hidden */
const grandTotalsRowShown = 'Row grand totals shown';
/** @hidden */
const grandTotalsColumnShown = 'Column grand totals shown';
/** @hidden */
const grandTotalsShown = 'Grand totals shown';
/** @hidden */
const valueSorted = 'Value sorted';
/** @hidden */
const calculatedFieldEdited = 'Calculatedfield edited';
/** @hidden */
const fieldSorted = 'Field sorted';
/** @hidden */
const fieldFiltered = 'Field filtered';
/** @hidden */
const fieldRemoved = 'Field removed';
/** @hidden */
const fieldAggregated = 'Field aggregated';
/** @hidden */
const recordEdited = 'Record edited';
/** @hidden */
const reportChanged = 'Report changed';
/** @hidden */
const windowResized = 'Window resized';
/** @hidden */
const recordUpdated = 'Records updated';
/** @hidden */
const drillThroughClosed = 'Drill-through closed';
/** @hidden */
const verticalScrolled = 'Vertically scrolled';
/** @hidden */
const horizontalScrolled = 'Horizontally scrolled';
/** @hidden */
const rowPageNavigated = 'Row page navigated';
/** @hidden */
const columnPageNavigated = 'Column page navigated';
/** @hidden */
const actionDropped = 'Action dropped';

/**
 * CSS Constants
 *
 * @hidden
 */
/** @hidden */
const ROOT = 'e-pivotfieldlist';
/** @hidden */
const RTL = 'e-rtl';
/** @hidden */
const PIVOTCHART_LTR = 'e-ltr';
/** @hidden */
const DEVICE = 'e-device';
/** @hidden */
const ICON = 'e-icons';
/** @hidden */
const ICON_DISABLE = 'e-disable';
/** @hidden */
const ICON_HIDDEN = 'e-hide';
/** @hidden */
const FIRST_PAGER_ICON = 'e-icon-first';
/** @hidden */
const LAST_PAGER_ICON = 'e-icon-last';
/** @hidden */
const PREV_PAGER_ICON = 'e-icon-prev';
/** @hidden */
const NEXT_PAGER_ICON = 'e-icon-next';
/** @hidden */
const AXISFIELD_ICON_CLASS = 'e-dropdown-icon';
/** @hidden */
const WRAPPER_CLASS = 'e-pivotfieldlist-container';
/** @hidden */
const OLAP_WRAPPER_CLASS = 'e-olapfieldlist-container';
/** @hidden */
const CONTAINER_CLASS = 'e-field-list-container';
/** @hidden */
const TOGGLE_FIELD_LIST_CLASS = 'e-toggle-field-list';
/** @hidden */
const STATIC_FIELD_LIST_CLASS = 'e-static';
/** @hidden */
const TOGGLE_SELECT_CLASS = 'e-select-table';
/** @hidden */
const FIELD_TABLE_CLASS = 'e-field-table';
/** @hidden */
const BUTTON_DRAGGABLE = 'e-draggable';
/** @hidden */
const OLAP_FIELD_TABLE_CLASS = 'e-olap-field-table';
/** @hidden */
const FIELD_LIST_CLASS = 'e-field-list';
/** @hidden */
const OLAP_FIELD_LIST_CLASS = 'e-olap-field-list-tree';
/** @hidden */
const FIELD_LIST_TREE_CLASS = 'e-field-list-tree';
/** @hidden */
const FIELD_LIST_TREE_OUTER_DIV_CLASS = 'e-field-list-tree-outer-div';
/** @hidden */
const FIELD_LIST_TREE_OUTER_DIV_SEARCH_CLASS = 'e-field-list-tree-outer-div-searchMode';
/** @hidden */
const FIELD_LIST_SEARCH_MODE_CLASS = 'e-search-mode';
/** @hidden */
const FIELD_HEADER_CLASS = 'e-field-header';
/** @hidden */
const FIELD_TREE_PARENT = 'e-pivot-parent';
/** @hidden */
const FIELD_TREE_CHILD = 'e-pivot-child';
/** @hidden */
const FIELD_HEADER_CONTAINER_CLASS = 'e-field-header-container';
/** @hidden */
const FIELD_LIST_TITLE_CLASS = 'e-field-list-title';
/** @hidden */
const FIELD_LIST_TITLE_CONTENT_CLASS = 'e-title-content';
/** @hidden */
const FIELD_LIST_SEARCH_CLASS = 'e-field-list-search';
/** @hidden */
const FIELD_LIST_SEARCH_INPUT_CLASS = 'e-field-list-search-input';
/** @hidden */
const FIELD_LIST_SEARCH_ICON_CLASS = 'e-field-list-search-icon';
/** @hidden */
const FIELD_LIST_FOOTER_CLASS = 'e-field-list-footer';
/** @hidden */
const CALCULATED_FIELD_CLASS = 'e-calculated-field';
/** @hidden */
const FLAT_CLASS = 'e-flat e-primary';
/** @hidden */
const OUTLINE_CLASS = 'e-outline';
/** @hidden */
const AXIS_TABLE_CLASS = 'e-axis-table';
/** @hidden */
const OLAP_AXIS_TABLE_CLASS = 'e-olap-axis-table';
/** @hidden */
const LEFT_AXIS_PANEL_CLASS = 'e-left-axis-fields';
/** @hidden */
const RIGHT_AXIS_PANEL_CLASS = 'e-right-axis-fields';
/** @hidden */
const ALL_FIELDS_PANEL_CLASS = 'e-all-fields-axis';
/** @hidden */
const FIELD_PANEL_SCROLL_CLASS = 'e-hscroll';
/** @hidden */
const AXIS_HEADER_CLASS = 'e-axis-header';
/** @hidden */
const AXIS_CONTENT_CLASS = 'e-axis-content';
/** @hidden */
const AXIS_PROMPT_CLASS = 'e-draggable-prompt';
/** @hidden */
const PIVOT_BUTTON_WRAPPER_CLASS = 'e-pvt-btn-div';
/** @hidden */
const PIVOT_BUTTON_CLASS = 'e-pivot-button';
/** @hidden */

/** @hidden */
const PIVOT_BUTTON_CONTENT_CLASS = 'e-pvt-btn-content';
/** @hidden */
const DRAG_CLONE_CLASS = 'e-button-drag-clone';
/** @hidden */
const SORT_CLASS = 'e-sort';
/** @hidden */
const MEMBER_SORT_CLASS = 'e-member-sort';
/** @hidden */
const SORT_DESCEND_CLASS = 'e-descend';
/** @hidden */
const FILTER_COMMON_CLASS = 'e-btn-filter';
/** @hidden */
const FILTER_CLASS = 'e-pv-filter';
/** @hidden */
const FILTERED_CLASS = 'e-pv-filtered';
/** @hidden */
const REMOVE_CLASS = 'e-remove';
/** @hidden */
const DRAG_CLASS = 'e-drag';
/** @hidden */
const DRAG_DISABLE_CLASS = 'e-disable-drag';
/** @hidden */
const DROP_INDICATOR_CLASS = 'e-drop-indicator';
/** @hidden */
const INDICATOR_HOVER_CLASS = 'e-drop-hover';
/** @hidden */
const MEMBER_EDITOR_DIALOG_CLASS = 'e-member-editor-dialog';
/** @hidden */
const EDITOR_TREE_WRAPPER_CLASS = 'e-member-editor-outer-container';
/** @hidden */
const EDITOR_TREE_CONTAINER_CLASS = 'e-member-editor-container';
/** @hidden */
const DRILLTHROUGH_GRID_CLASS = 'e-drillthrough-grid';
/** @hidden */
const DRILLTHROUGH_BODY_CLASS = 'e-drillthrough-body';
/** @hidden */
const DRILLTHROUGH_BODY_HEADER_CONTAINER_CLASS = 'e-drillthrough-body-header-container';
/** @hidden */
const DRILLTHROUGH_BODY_HEADER_CLASS = 'e-drillthrough-body-header';
/** @hidden */
const DRILLTHROUGH_BODY_HEADER_COMMON_CLASS = 'e-drillthrough-body-header-common';
/** @hidden */
const DRILLTHROUGH_BODY_HEADER_VALUE_CLASS = 'e-drillthrough-body-header-value';
/** @hidden */
const DRILLTHROUGH_DIALOG = 'e-drillthrough-dialog';
/** @hidden */
const EDITOR_LABEL_WRAPPER_CLASS = 'e-editor-label-container';
/** @hidden */
const EDITOR_LABEL_CLASS = 'e-editor-label';
/** @hidden */
const CHECK_BOX_FRAME_CLASS = 'e-frame';
/** @hidden */
const NODE_CHECK_CLASS = 'e-check';
/** @hidden */
const NODE_STOP_CLASS = 'e-stop';
/** @hidden */
const OK_BUTTON_CLASS = 'e-ok-btn';
/** @hidden */
const CANCEL_BUTTON_CLASS = 'e-cancel-btn';
/** @hidden */
const ERROR_DIALOG_CLASS = 'e-pivot-error-dialog';
/** @hidden */
const DROPPABLE_CLASS = 'e-droppable';
/** @hidden */
const ROW_AXIS_CLASS = 'e-rows';
/** @hidden */
const COLUMN_AXIS_CLASS = 'e-columns';
/** @hidden */
const VALUE_AXIS_CLASS = 'e-values';
/** @hidden */
const FILTER_AXIS_CLASS = 'e-filters';
/** @hidden */
const GROUPING_BAR_CLASS = 'e-grouping-bar';
/** @hidden */

/** @hidden */
const GROUP_ALL_FIELDS_CLASS = 'e-group-all-fields';
/** @hidden */
const GROUP_ROW_CLASS = 'e-group-rows';
/** @hidden */
const GROUP_COLUMN_CLASS = 'e-group-columns';
/** @hidden */

/** @hidden */
const GROUP_VALUE_CLASS = 'e-group-values';
/** @hidden */
const GROUP_FILTER_CLASS = 'e-group-filters';
/** @hidden */

/** @hidden */
const NO_DRAG_CLASS = 'e-drag-restrict';
/** @hidden */
const SELECTED_NODE_CLASS = 'e-list-selected';
/** @hidden */
const TITLE_HEADER_CLASS = 'e-title-header';
/** @hidden */
const TITLE_CONTENT_CLASS = 'e-title-content';
/** @hidden */
const TEXT_CONTENT_CLASS = 'e-text-content';
/** @hidden */
const FOOTER_CONTENT_CLASS = 'e-footer-content';
/** @hidden */
const ADAPTIVE_CONTAINER_CLASS = 'e-adaptive-container';
/** @hidden */
const ADAPTIVE_FIELD_LIST_BUTTON_CLASS = 'e-field-list-btn';
/** @hidden */
const ADAPTIVE_CALCULATED_FIELD_BUTTON_CLASS = 'e-calculated-field-btn';
/** @hidden */
const BUTTON_SMALL_CLASS = 'e-small';
/** @hidden */
const BUTTON_ROUND_CLASS = 'e-round';
/** @hidden */
const ADD_ICON_CLASS = 'e-add-icon';
/** @hidden */
const BUTTON_FLAT_CLASS = 'e-flat';
/** @hidden */
const STATIC_CENTER_DIV_CLASS = 'e-center-div';
/** @hidden */
const STATIC_CENTER_HEADER_CLASS = 'e-center-title';
/** @hidden */
const ADAPTIVE_FIELD_LIST_DIALOG_CLASS = 'e-adaptive-field-list-dialog';
/** @hidden */
const LIST_TEXT_CLASS = 'e-list-text';
/** @hidden */
const LIST_SELECT_CLASS = 'e-selected-node';
/** @hidden */

/** @hidden */

/** @hidden */

/** @hidden */

/** @hidden */

/** @hidden */

/** @hidden */

/** @hidden */
const SELECT_CLASS = 'e-select';
/** @hidden */

/** @hidden */

/** @hidden */
const SELECTED_OPTION_ICON_CLASS = 'e-selected-option-icon';
/** @hidden */
const SELECTED_LEVEL_ICON_CLASS = 'e-selected-level-icon';
/** @hidden */
const FILTER_DIV_CONTENT_CLASS = 'e-filter-div-content';
/** @hidden */
const FILTER_TEXT_DIV_CLASS = 'e-filter-text-div';
/** @hidden */
const BETWEEN_TEXT_DIV_CLASS = 'e-between-text-div';
/** @hidden */
const SEPARATOR_DIV_CLASS = 'e-separator-div';
/** @hidden */
const FILTER_OPTION_WRAPPER_1_CLASS = 'e-filter-option-container-1';
/** @hidden */
const FILTER_OPTION_WRAPPER_2_CLASS = 'e-filter-option-container-2';
/** @hidden */
const FILTER_INPUT_DIV_1_CLASS = 'e-filter-input-div-1';
/** @hidden */
const FILTER_INPUT_DIV_2_CLASS = 'e-filter-input-div-2';
/** @hidden */
const VALUE_OPTIONS_CLASS = 'e-value-options';
/** @hidden */
const LEVEL_OPTIONS_CLASS = 'e-level-options';
/** @hidden */
const FILTER_OPERATOR_CLASS = 'e-filter-operator';
/** @hidden */
const FILTER_SORT_CLASS = 'e-filter-sort';
/** @hidden */
const SORT_ASCEND_ICON_CLASS = 'e-sort-ascend-icon';
/** @hidden */
const SORT_DESCEND_ICON_CLASS = 'e-sort-descend-icon';
/** @hidden */
const SORT_SELECTED_CLASS = 'e-active';
/** @hidden */
const COLLAPSE = 'e-collapse';
/** @hidden */
const EXPAND = 'e-expand';
/** @hidden */
const TABLE = 'e-table';
/** @hidden */

/** @hidden */

/** @hidden */
const COLUMNSHEADER = 'e-columnsheader';
/** @hidden */
const ROWSHEADER = 'e-rowsheader';
/** @hidden */
const VALUESCONTENT = 'e-valuescontent';
/** @hidden */

/** @hidden */

/** @hidden */

/** @hidden */

/** @hidden */

/** @hidden */
const SUMMARY = 'e-summary';
/** @hidden */
const CELLVALUE = 'e-cellvalue';
/** @hidden */

/** @hidden */
const PIVOTTOOLTIP = 'e-pivottooltip';
/** @hidden */
const TOOLTIP_HEADER = 'e-tooltipheader';
/** @hidden */
const TOOLTIP_CONTENT = 'e-tooltipcontent';
/** @hidden */
const NEXTSPAN = 'e-nextspan';
/** @hidden */
const LASTSPAN = 'e-lastspan';
/** @hidden */
const EDITOR_SEARCH_WRAPPER_CLASS = 'e-editor-search-container';
/** @hidden */
const EDITOR_SEARCH_CLASS = 'e-editor-search';
/** @hidden */
const EDITOR_SEARCH__INPUT_CLASS = 'e-editor-search-input';
/** @hidden */
const SELECT_ALL_WRAPPER_CLASS = 'e-select-all-container';
/** @hidden */
const SELECT_ALL_CLASS = 'e-select-all';
/** @hidden */
const PIVOTCALC = 'e-pivot-calc';
/** @hidden */
const CALCDIALOG = 'e-pivot-calc-dialog-div';
/** @hidden */
const OLAP_CALCDIALOG = 'e-olap-calc-dialog-div';
/** @hidden */
const CALCRADIO = 'e-pivot-calc-radio';
/** @hidden */
const CALCCHECK = 'e-pivot-calc-check';
/** @hidden */
const CALCINPUT = 'e-pivot-calc-input';
/** @hidden */
const CALC_FORMAT_INPUT = 'e-custom-format-input';
/** @hidden */
const CALCINPUTDIV = 'e-pivot-calc-input-div';
/** @hidden */
const PIVOT_CALC_CUSTOM_FORMAT_INPUTDIV = 'e-pivot-calc-custom-format-div';
/** @hidden */
const CALC_HIERARCHY_LIST_DIV = 'e-olap-calc-hierarchy-list-div';
/** @hidden */
const CALC_FORMAT_TYPE_DIV = 'e-pivot-calc-format-type-div';
/** @hidden */
const CALC_MEMBER_TYPE_DIV = 'e-olap-calc-member-type-div';
/** @hidden */
const MEMBER_OPTIONS_CLASS = 'e-member-options';
/** @hidden */

/** @hidden */

/** @hidden */

/** @hidden */
const CALCOUTERDIV = 'e-pivot-calc-outer-div';
/** @hidden */
const OLAP_CALCOUTERDIV = 'e-olap-calc-outer-div';
/** @hidden */
const FLAT = 'e-flat';
/** @hidden */
const FORMAT = 'e-format';
/** @hidden */
const FORMULA = 'e-pivot-formula';
/** @hidden */
const TREEVIEW = 'e-pivot-treeview';
/** @hidden */
const TREEVIEWOUTER = 'e-pivot-treeview-outer';
/** @hidden */
const TREE_CONTAINER = 'e-treeContainer';
/** @hidden */
const CALCCANCELBTN = 'e-pivot-cancel-button';
/** @hidden */
const CALCADDBTN = 'e-pivot-add-button';
/** @hidden */
const CALCOKBTN = 'e-pivot-ok-button';
/** @hidden */
const CALCACCORD = 'e-pivot-accord';
/** @hidden */
const CALCBUTTONDIV = 'e-pivot-button-div';
/** @hidden */
const AXIS_ICON_CLASS = 'e-axis';
/** @hidden */
const AXIS_ROW_CLASS = 'e-axis-row';
/** @hidden */
const AXIS_COLUMN_CLASS = 'e-axis-column';
/** @hidden */
const AXIS_VALUE_CLASS = 'e-axis-value';
/** @hidden */
const AXIS_FILTER_CLASS = 'e-axis-filter';
/** @hidden */

/** @hidden */

/** @hidden */

/** @hidden */

/** @hidden */

/** @hidden */
const GRID_CLASS = 'e-grid';
/** @hidden */
const PIVOT_VIEW_CLASS = 'e-pivotview';
/** @hidden */
const PIVOT_ALL_FIELD_TITLE_CLASS = 'e-pivot-all-field-title';
/** @hidden */
const PIVOT_FIELD_TITLE_CLASS = 'e-pivot-field-name-title';
/** @hidden */
const PIVOT_FORMULA_TITLE_CLASS = 'e-pivot-formula-title';
/** @hidden */
const OLAP_HIERARCHY_TITLE_CLASS = 'e-olap-hierarchy-title';
/** @hidden */
const PIVOT_FORMAT_TITLE_CLASS = 'e-pivot-format-title';
/** @hidden */
const OLAP_MEMBER_TITLE_CLASS = 'e-olap-member-title';
/** @hidden */
const PIVOT_CONTEXT_MENU_CLASS = 'e-pivot-context-menu';
/** @hidden */
const MENU_DISABLE = 'e-disabled';
/** @hidden */
const MENU_HIDE = 'e-menu-hide';
/** @hidden */
const EMPTY_MEMBER_CLASS = 'e-member-prompt';
/** @hidden */
const CALC_EDIT = 'e-edit';
/** @hidden */
const CALC_EDITED = 'e-edited';
/** @hidden */
const CALC_INFO = 'e-info';
/** @hidden */
const EMPTY_FIELD = 'e-empty-field';
/** @hidden */
const FORMAT_DIALOG = 'e-pivot-formatting-dialog';
/** @hidden */
const FORMAT_CONDITION_BUTTON = 'e-format-condition-button';
/** @hidden */
const FORMAT_NEW = 'e-new-format';
/** @hidden */
const FORMAT_OUTER = 'e-format-outer-div';
/** @hidden */
const FORMAT_INNER = 'e-format-inner-div';
/** @hidden */
const FORMAT_TABLE = 'e-format-table';
/** @hidden */
const FORMAT_VALUE_LABEL = 'e-format-value-label';
/** @hidden */
const FORMAT_LABEL = 'e-format-label';
/** @hidden */
const INPUT = 'e-input';
/** @hidden */
const FORMAT_VALUE1 = 'e-format-value1';
/** @hidden */
const FORMAT_VALUE2 = 'e-format-value2';
/** @hidden */
const FORMAT_VALUE_SPAN = 'e-format-value-span';
/** @hidden */
const FORMAT_FONT_COLOR = 'e-format-font-color';
/** @hidden */
const FORMAT_BACK_COLOR = 'e-format-back-color';
/** @hidden */
const FORMAT_VALUE_PREVIEW = 'e-format-value-preview';
/** @hidden */
const FORMAT_COLOR_PICKER = 'e-format-color-picker';
/** @hidden */
const FORMAT_DELETE_ICON = 'e-format-delete-icon';
/** @hidden */
const FORMAT_DELETE_BUTTON = 'e-format-delete-button';
/** @hidden */
const SELECTED_COLOR = 'e-selected-color';
/** @hidden */
const DIALOG_HEADER = 'e-dlg-header';
/** @hidden */
const FORMAT_APPLY_BUTTON = 'e-format-apply-button';
/** @hidden */
const FORMAT_CANCEL_BUTTON = 'e-format-cancel-button';
/** @hidden */
const FORMAT_ROUND_BUTTON = 'e-small e-round';
/** @hidden */
const VIRTUALTRACK_DIV = 'e-virtualtrack';
/** @hidden */
const MOVABLECONTENT_DIV = 'e-movablecontent';
/** @hidden */
const MOVABLESCROLL_DIV = 'e-movablescrollbar';
/** @hidden */
const MOVABLECHILD_DIV = 'e-movablechild';
/** @hidden */
const FROZENCONTENT_DIV = 'e-frozencontent';
/** @hidden */
const MOVABLEHEADER_DIV = 'e-movableheader';
/** @hidden */

/** @hidden */
const DEFER_APPLY_BUTTON = 'e-defer-apply-button';
/** @hidden */
const DEFER_CANCEL_BUTTON = 'e-defer-cancel-button';
/** @hidden */
const LAYOUT_FOOTER = 'e-layout-footer';
/** @hidden */
const CELL_SELECTED_BGCOLOR = 'e-cellselectionbackground';
/** @hidden */
const SELECTED_BGCOLOR = 'e-selectionbackground';
/** @hidden */
const BUTTON_LAYOUT = 'e-button-layout';
/** @hidden */
const CHECKBOX_LAYOUT = 'e-checkbox-layout';
/** @hidden */
const DEFER_UPDATE_BUTTON = 'e-defer-update-btn';
/** @hidden */

/** @hidden */
const BACK_ICON = 'e-field-list-back-icon';
/** @hidden */
const TITLE_MOBILE_HEADER = 'e-title-mobile-header';
/** @hidden */
const TITLE_MOBILE_CONTENT = 'e-title-mobile-content';
/** @hidden */
const ROW_CELL_CLASS = 'e-rowcell';
/** @hidden */
const CELL_ACTIVE_BGCOLOR = 'e-active';
/** @hidden */
const SPAN_CLICKED = 'e-spanclicked';
/** @hidden */
const ROW_SELECT = 'e-rowselect';
/** @hidden */
const GRID_HEADER = 'e-gridheader';
/** @hidden */

/** @hidden */
const GRID_EXPORT = 'e-export';
/** @hidden */
const PIVOTVIEW_EXPORT = 'e-pivotview-export';
/** @hidden */
const PIVOTVIEW_GRID = 'e-pivotview-grid';
/** @hidden */
const PIVOTVIEW_EXPAND = 'e-pivotview-expand';
/** @hidden */
const PIVOTVIEW_COLLAPSE = 'e-pivotview-collapse';
/** @hidden */
const PIVOTVIEW_GROUP = 'e-pivotview-group';
/** @hidden */
const PIVOTVIEW_UN_GROUP = 'e-pivotview-ungroup';
/** @hidden */
const GRID_PDF_EXPORT = 'e-pivotview-pdf-export';
/** @hidden */
const GRID_EXCEL_EXPORT = 'e-pivotview-excel-export';
/** @hidden */
const GRID_CSV_EXPORT = 'e-pivotview-csv-export';
/** @hidden */
const GRID_PNG_EXPORT = 'e-pivotview-png-export';
/** @hidden */
const GRID_JPEG_EXPORT = 'e-pivotview-jpeg-export';
/** @hidden */
const GRID_SVG_EXPORT = 'e-pivotview-svg-export';
/** @hidden */
const GRID_LOAD = 'e-load-report';
/** @hidden */
const GRID_NEW = 'e-new-report';
/** @hidden */
const GRID_RENAME = 'e-rename-report';
/** @hidden */
const GRID_REMOVE = 'e-remove-report';
/** @hidden */
const GRID_SAVEAS = 'e-saveas-report';
/** @hidden */
const GRID_SAVE = 'e-save-report';
/** @hidden */
const GRID_SUB_TOTAL = 'e-sub-total';
/** @hidden */
const GRID_GRAND_TOTAL = 'e-grand-total';
/** @hidden */
const GRID_FORMATTING = 'e-toolbar-formatting';
/** @hidden */
const GRID_TOOLBAR = 'e-pivot-toolbar';
/** @hidden */
const GRID_REPORT_LABEL = 'e-pivotview-report-label';
/** @hidden */
const GRID_REPORT_INPUT = 'e-pivotview-report-input';
/** @hidden */
const GRID_REPORT_OUTER = 'e-report-outer';
/** @hidden */
const GRID_REPORT_DIALOG = 'e-pivotview-report-dialog';
/** @hidden */
const TOOLBAR_FIELDLIST = 'e-toolbar-fieldlist';
/** @hidden */
const TOOLBAR_GRID = 'e-toolbar-grid';
/** @hidden */
const TOOLBAR_CHART = 'e-toolbar-chart';
/** @hidden */
const REPORT_LIST_DROP = 'e-reportlist-drop';
/** @hidden */
const PIVOTCHART = 'e-pivotchart';
/** @hidden */
const GROUP_CHART_ROW = 'e-group-chart-rows';
/** @hidden */
const GROUP_CHART_COLUMN = 'e-group-chart-columns';
/** @hidden */
const GROUP_CHART_VALUE = 'e-group-chart-values';
/** @hidden */
const GROUP_CHART_MULTI_VALUE = 'e-group-chart-multi-values';
/** @hidden */
const GROUP_CHART_ACCUMULATION_COLUMN = 'e-group-chart-accumulation-column';
/** @hidden */
const GROUP_CHART_FILTER = 'e-group-chart-filters';
/** @hidden */
const GROUP_CHART_VALUE_DROPDOWN_DIV = 'e-group-chart-values-drodown-div';
/** @hidden */
const GROUP_CHART_VALUE_DROPDOWN = 'e-group-chart-values-drodown';
/** @hidden */
const GROUP_CHART_COLUMN_DROPDOWN_DIV = 'e-group-chart-columns-dropdown-div';
/** @hidden */
const GROUP_CHART_COLUMN_DROPDOWN = 'e-group-chart-columns-dropdown';
/** @hidden */
const CHART_GROUPING_BAR_CLASS = 'e-chart-grouping-bar';
/** @hidden */
const PIVOT_DISABLE_ICON = 'e-pivotview-disable-icon';
/** @hidden */
const PIVOT_SELECT_ICON = 'e-pivotview-select-icon';
/** @hidden */
const VALUESHEADER = 'e-valuesheader';
/** @hidden */
const ICON_ASC = 'e-icon-ascending';
/** @hidden */
const ICON_DESC = 'e-icon-descending';
/** @hidden */
const GRID_GROUPING_BAR_CLASS = 'e-pivot-grouping-bar';
/** @hidden */
const MDX_QUERY = 'e-mdx-query';
/** @hidden */
const MDX_QUERY_CONTENT = 'e-mdx-query-content';
/** @hidden */
const GRID_MDX_DIALOG = 'e-pivotview-mdx-dialog';
/** @hidden */
const GRID_MDX = 'e-mdx';
/** @hidden */
const FORMATTING_DIALOG = 'e-pivot-format-dialog';
/** @hidden */
const FORMATTING_DIALOG_OUTER = 'e-pivot-format-dialog-outer';
/** @hidden */
const FORMATTING_VALUE_LABLE = 'e-pivot-format-value-lable';
/** @hidden */
const FORMATTING_VALUE_DROP = 'e-pivot-format-value-drop';
/** @hidden */
const FORMATTING_FORMAT_LABLE = 'e-pivot-format-lable';
/** @hidden */
const FORMATTING_FORMAT_DROP = 'e-pivot-format-drop';
/** @hidden */
const FORMATTING_CUSTOM_LABLE = 'e-pivot-format-custom-lable';
/** @hidden */
const FORMATTING_CUSTOM_TEXT = 'e-pivot-format-custom-text';
/** @hidden */

/** @hidden */

/** @hidden */
const FORMATTING_GROUPING_LABLE = 'e-pivot-format-grouping-lable';
/** @hidden */
const FORMATTING_GROUPING_DROP = 'e-pivot-format-grouping-drop';
/** @hidden */
const FORMATTING_DECIMAL_LABLE = 'e-pivot-format-decimal-lable';
/** @hidden */
const FORMATTING_DECIMAL_DROP = 'e-pivot-format-decimal-drop';
/** @hidden */
const FORMATTING_TOOLBAR = 'e-pivot-format-toolbar';
/** @hidden */
const FORMATTING_TABLE = 'e-pivot-format-table';
/** @hidden */
const FORMATTING_MENU = 'e-pivot-format-menu';
/** @hidden */
const NUMBER_FORMATTING_MENU = 'e-pivot-number-format-menu';
/** @hidden */
const EMPTY_FORMAT = 'e-pivot-conditional-empty-format';
/** @hidden */
const CONDITIONAL_FORMATTING_MENU = 'e-pivot-conditional-format-menu';
/** @hidden */
const PIVOTCHART_INNER = 'e-pivotchart-inner';
/** @hidden */
const PIVOTCHART_TYPE_DIALOG = 'e-pivotchart-type-dialog';
/** @hidden */
const FORMAT_FONT_COLOR_PICKER = 'e-format-font-color-picker';
/** @hidden */
const GROUP_PIVOT_ROW = 'e-group-pivot-rows';
/** @hidden */
const TOOLBAR_MENU = 'e-pivot-toolbar-menu';
/** @hidden */
const DISABLE_FIRST_PAGE = 'e-firstpagedisabled';
/** @hidden */
const DISABLE_PREV_PAGE = 'e-prevpagedisabled';
/** @hidden */
const DISABLE_NEXT_PAGE = 'e-nextpagedisabled';
/** @hidden */
const DISABLE_LAST_PAGE = 'e-lastpagedisabled';
/** @hidden */
const GRID_PAGER = 'e-pivot-pager';
/** @hidden */
const GRID_PAGER_DIV = 'e-pivot-pager-maindiv';
/** @hidden */
const PIVOT_ROW_PAGER_DIV = 'e-pivot-pager-row-maindiv';
/** @hidden */
const PIVOT_COLUMN_PAGER_DIV = 'e-pivot-pager-column-maindiv';
/** @hidden */
const PIVOT_ROW_PAGER_SETTINGS = 'e-pivot-row-pager-settings';
/** @hidden */
const PIVOT_COLUMN_PAGER_SETTINGS = 'e-pivot-column-pager-settings';
/** @hidden */
const PIVOT_PAGER_CONTAINER = 'e-pagercontainer';
/** @hidden */
const PIVOT_V_SEPARATOR = 'e-pivotview-vseparator';
/** @hidden */
const PIVOT_H_SEPARATOR = 'e-pivotview-hseparator';
/** @hidden */
const PIVOT_TEXT_DIV = 'e-pivotview-text-div';
/** @hidden */
const PIVOT_TEXT_DIV_1 = 'e-pivotview-text-div-1';
/** @hidden */
const PIVOT_ROW_SIZE = 'e-pivotview-row-size';
/** @hidden */
const PIVOT_ROW_PAGER_NUMBER = 'e-pivotview-row-pagerNumber';
/** @hidden */
const PIVOT_COLUMN_SIZE = 'e-pivotview-column-size';
/** @hidden */
const PIVOT_COLUMN_PAGER_NUMBER = 'e-pivotview-column-pagerNumber';
/** @hidden */
const PIVOT_ROW_PAGER_STRING = 'e-pivotview-row-pagerString';
/** @hidden */
const PIVOT_COLUMN_PAGER_STRING = 'e-pivotview-column-pagerString';
/** @hidden */
const PIVOT_ROW_OF_STRING = 'e-pivot-row-of-string';
/** @hidden */
const PIVOT_COLUMN_OF_STRING = 'e-pivot-column-of-string';
/** @hidden */
const PIVOT_ROW_DROPDOWN = 'e-pivot-pager-row-dropdown';
/** @hidden */
const PIVOT_COLUMN_DROPDOWN = 'e-pivot-pager-column-dropdown';
/** @hidden */
const PIVOT_ROW_SIZE_LIST = 'e-pivot-row-size-list';
/** @hidden */
const PIVOT_COLUMN_SIZE_LIST = 'e-pivot-column-size-list';
/** @hidden */
const INVERSE = 'e-inverse-view';
/** @hidden */
const COMPACT_VIEW = 'e-compact-view';
/** @hidden */
const PAGE_SIZE_DISABLE = 'e-page-size-disable';
/** @hidden */

/** @hidden */

/** @hidden */

/** @hidden */

/** @hidden */

/** @hidden */

/** @hidden */

/** @hidden */
const PIVOT_ROW_OF_STRING_MAINDIV = 'e-pivot-row-of-string-maindiv';
/** @hidden */
const PIVOT_COLUMN_OF_STRING_MAINDIV = 'e-pivot-column-of-string-maindiv';
/** @hidden */
const PIVOT_PAGE_SIZE_LIST_MAINDIV = 'e-pager-dropdown';
/** @hidden */
const PIVOT_FIRST_ICON_DEFAULT = 'e-first e-icons e-icon-first';
/** @hidden */
const PIVOT_PREV_ICON_DEFAULT = 'e-prev e-icons e-icon-prev';
/** @hidden */
const PIVOT_NEXT_ICON_DEFAULT = 'e-next e-icons e-icon-next';
/** @hidden */
const PIVOT_LAST_ICON_DEFAULT = 'e-last e-icons e-icon-last';
/** @hidden */
const PIVOT_FIRST_ICON_ENABLE = 'e-firstpage e-pager-default';
/** @hidden */
const PIVOT_PREV_ICON_ENABLE = 'e-prevpage e-pager-default';
/** @hidden */
const PIVOT_NEXT_ICON_ENABLE = 'e-nextpage e-pager-default';
/** @hidden */
const PIVOT_LAST_ICON_ENABLE = 'e-lastpage e-pager-default';
/** @hidden */
const GRID_PAGER_TOP = 'e-pivot-pager-top';
/** @hidden */
const GRID_PAGER_BOTTOM = 'e-pivot-pager-bottom';
/** @hidden */
const GRID_PAGER_SINGLE_DIV = 'e-pivot-pager-single-maindiv';
/** @hidden */

/** @hidden */

/** @hidden */

/** @hidden */

/** @hidden */

/** @hidden */

/** @hidden */
const PIVOT_PAGER_NAV_CONTAINER = 'e-pivot-pager-nav-container';
/** @hidden */
const PIVOT_PAGER_INFO_CONTAINER = 'e-pivot-pager-info-container';
/** @hidden */
const PIVOT_CELL_CONTAINER = 'e-pivotcell-container';
/** @hidden */
const PIVOT_FILTER_TAB_CONTAINER = 'e-filter-tab-container';
/** @hidden */
const PIVOT_FILTER_MEMBER_LIMIT = 'e-node-limit';

/**
 * `AggregateMenu` module to create aggregate type popup.
 */
/** @hidden */
class AggregateMenu {
    /**
     * Constructor for the rener action.
     *
     * @param {PivotView | PivotFieldList} parent - It contains the value of parent.
     * @hidden
     */
    constructor(parent) {
        this.menuInfo = [];
        this.stringAggregateTypes = ['Count', 'DistinctCount'];
        this.parent = parent;
    }
    /**
     * Initialize the pivot table rendering
     *
     * @param {MouseEventArgs} args - It contains the args value
     * @param {HTMLElement} parentElement - It contains the value of parentElement
     * @returns {void}
     * @private
     */
    render(args, parentElement) {
        this.parentElement = parentElement;
        this.openContextMenu(args);
    }
    openContextMenu(args) {
        const fieldName = args.target.parentElement.getAttribute('data-uid');
        const fieldInfo = PivotUtil.getFieldInfo(fieldName, this.parent);
        this.buttonElement = args.target.parentElement;
        const isStringField = this.parent.engineModule.fieldList[fieldName].type !== 'number' ? 1 : 0;
        this.summaryTypes = [...this.getMenuItem(isStringField)];
        this.parent.actionObj.actionName = aggregateField;
        this.parent.actionObj.fieldInfo = fieldInfo.fieldItem;
        if (this.parent.actionBeginMethod()) {
            return;
        }
        const eventArgs = {
            cancel: false, fieldName: fieldName, aggregateTypes: this.summaryTypes, displayMenuCount: 7
        };
        const control = this.parent.getModuleName() === 'pivotfieldlist' && this.parent.isPopupView ?
            this.parent.pivotGridModule : this.parent;
        try {
            control.trigger(aggregateMenuOpen, eventArgs, (observedArgs) => {
                if (!observedArgs.cancel) {
                    this.summaryTypes = observedArgs.aggregateTypes;
                    this.createContextMenu(isStringField, observedArgs.displayMenuCount);
                    this.currentMenu = args.target;
                    const pos = this.currentMenu.getBoundingClientRect();
                    if (this.parent.enableRtl) {
                        this.menuInfo[isStringField].open(pos.top + (window.scrollY || document.documentElement.scrollTop), pos.left - 105);
                    }
                    else {
                        this.menuInfo[isStringField].open(pos.top +
                            (window.scrollY || document.documentElement.scrollTop), pos.left);
                    } /* eslint-enable security/detect-non-literal-fs-filename */
                }
            });
        }
        catch (execption) {
            this.parent.actionFailureMethod(execption);
        }
    }
    createContextMenu(isStringField, displayMenuCount) {
        const menuItems = [];
        menuItems[isStringField] = [];
        if (this.menuInfo[isStringField] && !this.menuInfo[isStringField].isDestroyed) {
            this.menuInfo[isStringField].destroy();
        }
        const checkDuplicates = [];
        for (let i = 0; i < this.summaryTypes.length; i++) {
            const key = this.summaryTypes[i];
            if (isStringField) {
                if ((this.stringAggregateTypes.indexOf(key) > -1) && (checkDuplicates.indexOf(key) < 0)) {
                    menuItems[isStringField].push({ text: this.parent.localeObj.getConstant(key), id: this.parent.element.id + 'StringMenu_' + key });
                    checkDuplicates.push(key);
                }
            }
            else {
                if ((this.parent.getAllSummaryType().indexOf(key) > -1) && (checkDuplicates.indexOf(key) < 0)) {
                    menuItems[isStringField].push({ text: this.parent.localeObj.getConstant(key), id: this.parent.element.id + '_' + key });
                    checkDuplicates.push(key);
                }
            }
        }
        if (menuItems[isStringField].length > displayMenuCount) {
            menuItems[isStringField].splice(displayMenuCount);
            menuItems[isStringField].push({
                text: this.parent.localeObj.getConstant('MoreOption'),
                id: this.parent.element.id + '_' + 'MoreOption'
            });
        }
        const menuOptions = {
            items: menuItems[isStringField],
            enableRtl: this.parent.enableRtl,
            locale: this.parent.locale,
            cssClass: this.parent.cssClass,
            beforeOpen: this.beforeMenuOpen.bind(this, isStringField),
            onClose: () => {
                select('#' + this.buttonElement.id, this.parentElement).focus();
            },
            select: this.selectOptionInContextMenu.bind(this)
        };
        let contextMenu = document.getElementById(this.parent.element.id + (isStringField ? 'valueFieldStringContextMenu' : 'valueFieldContextMenu'));
        if (contextMenu !== null) {
            contextMenu.innerHTML = '';
        }
        else {
            contextMenu = createElement('ul', {
                id: this.parent.element.id + (isStringField ? 'valueFieldStringContextMenu' : 'valueFieldContextMenu')
            });
        }
        this.parent.element.appendChild(contextMenu);
        this.menuInfo[isStringField] = new ContextMenu$1(menuOptions);
        this.menuInfo[isStringField].isStringTemplate = true;
        this.menuInfo[isStringField].appendTo(contextMenu);
    }
    getMenuItem(isStringField) {
        const menuItems = [];
        for (let i = 0; i < this.parent.aggregateTypes.length; i++) {
            const key = this.parent.aggregateTypes[i];
            if (isStringField) {
                if ((this.stringAggregateTypes.indexOf(key) > -1) && (menuItems.indexOf(key) === -1)) {
                    menuItems.push(key);
                }
            }
            else {
                if ((this.parent.getAllSummaryType().indexOf(key) > -1) && (menuItems.indexOf(key) === -1)) {
                    menuItems.push(key);
                }
            }
        }
        return menuItems;
    }
    beforeMenuOpen(isString, args) {
        args.element.style.zIndex = (this.menuInfo[isString].element.style.zIndex + 3).toString();
        args.element.style.display = 'inline';
    }
    /**
     * create Value Settings Dialog
     *
     * @param {HTMLElement} target - It represent the target elament.
     * @param {HTMLElement} parentElement - It represent the parentElement.
     * @param {string} type -It represent the type.
     * @returns {void}
     * @hidden */
    createValueSettingsDialog(target, parentElement, type) {
        this.parentElement = parentElement;
        const valueDialog = createElement('div', {
            id: this.parentElement.id + '_ValueDialog',
            className: 'e-value-field-settings',
            attrs: { 'data-field': target.getAttribute('data-uid') ? target.getAttribute('data-uid') : target.getAttribute('data-field') }
        });
        this.parentElement.appendChild(valueDialog);
        this.valueDialog = new Dialog({
            animationSettings: { effect: 'Fade' },
            allowDragging: true,
            header: this.parent.localeObj.getConstant('valueFieldSettings'),
            content: this.createFieldOptions(target, type),
            isModal: true,
            visible: true,
            showCloseIcon: true,
            enableRtl: this.parent.enableRtl,
            locale: this.parent.locale,
            enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
            width: '320px',
            height: 'auto',
            position: { X: 'center', Y: 'center' },
            buttons: [
                {
                    click: this.updateValueSettings.bind(this),
                    buttonModel: { cssClass: OK_BUTTON_CLASS + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''), content: this.parent.localeObj.getConstant('ok'), isPrimary: true }
                },
                {
                    click: () => {
                        this.valueDialog.hide();
                    },
                    buttonModel: { cssClass: CANCEL_BUTTON_CLASS + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''), content: this.parent.localeObj.getConstant('cancel') }
                }
            ],
            closeOnEscape: (this.parent.getModuleName() === 'pivotfieldlist' && this.parent.renderMode === 'Popup') ? false : true,
            target: this.parentElement,
            overlayClick: () => {
                this.removeDialog();
            },
            close: this.removeDialog.bind(this),
            cssClass: this.parent.cssClass
        });
        this.valueDialog.isStringTemplate = true;
        this.valueDialog.appendTo(valueDialog);
        // this.valueDialog.element.querySelector('.e-dlg-header').innerText = this.parent.localeObj.getConstant('valueFieldSettings');
    }
    createFieldOptions(buttonElement, type) {
        const fieldCaption = buttonElement.getAttribute('data-caption');
        let summaryType = (type && type !== 'MoreOption') ? type : buttonElement.getAttribute('data-type');
        let baseField = buttonElement.getAttribute('data-basefield');
        let baseItem = buttonElement.getAttribute('data-baseitem');
        summaryType = (summaryType.toString() !== 'undefined' ? summaryType : 'Sum');
        const summaryDataSource = [];
        const summaryItems = this.parent.aggregateTypes;
        const checkDuplicates = [];
        for (let i = 0; i < summaryItems.length; i++) {
            if (this.parent.getAllSummaryType().indexOf(summaryItems[i]) > -1 &&
                checkDuplicates.indexOf(summaryItems[i]) < 0) {
                summaryDataSource.push({
                    value: summaryItems[i],
                    text: this.parent.localeObj.getConstant(summaryItems[i])
                });
                checkDuplicates.push(summaryItems[i]);
            }
        }
        const baseItemTypes = ['DifferenceFrom', 'PercentageOfDifferenceFrom'];
        const baseFieldTypes = ['DifferenceFrom', 'PercentageOfDifferenceFrom', 'PercentageOfParentTotal'];
        let dataFields = extend([], this.parent.dataSourceSettings.rows, null, true);
        dataFields = dataFields.concat(this.parent.dataSourceSettings.columns);
        const fieldDataSource = [];
        let fieldItemDataSource = [];
        // let summaryDataSource: { [key: string]: Object }[] = [];
        // for (let type of summaryTypes) {
        //     summaryDataSource.push({ value: type, text: type });
        // }
        for (const field of dataFields) {
            const value = field.name;
            const text = (field.caption ? field.caption : field.name);
            fieldDataSource.push({ value: value, text: text });
        }
        if (Object.keys(fieldDataSource).length === 0) {
            fieldDataSource.push({ value: '', text: '' });
            baseField = '';
            fieldItemDataSource = [];
        }
        else {
            baseField = (baseField && (baseField.toString() !== 'undefined' && baseField.toString() !== 'null') ? baseField : fieldDataSource[0].value);
            fieldItemDataSource = Object.keys(this.parent.engineModule.fieldList[(baseField.toString() !== 'undefined' ?
                baseField : fieldDataSource[0].value)].formattedMembers);
        }
        baseItem = (baseItem.toString() !== 'undefined' ? baseItem : fieldItemDataSource[0]);
        const mainDiv = createElement('div', {
            className: 'e-value-field-div-content', id: this.parentElement.id + '_field_div_content',
            attrs: { 'data-type': summaryType, 'data-caption': fieldCaption, 'data-basefield': baseField, 'data-baseitem': baseItem }
        });
        const textWrappper = createElement('div', { className: 'e-field-name-text-container' });
        const filterWrapperDiv1 = createElement('div', { className: 'e-field-option-container' });
        const optionWrapperDiv1 = createElement('div', { className: 'e-type-option-container' });
        const optionWrapperDiv2 = createElement('div', { className: 'e-base-field-option-container' });
        const optionWrapperDiv3 = createElement('div', { className: 'e-base-item-option-container' });
        const texttitle = createElement('div', { className: 'e-field-name-title' });
        texttitle.innerText = this.parent.localeObj.getConstant('sourceName') + ' ';
        const textContent = createElement('div', { className: 'e-field-name-content' });
        textContent.innerText = this.parent.enableHtmlSanitizer ? SanitizeHtmlHelper.sanitize(buttonElement.getAttribute('data-uid') ?
            buttonElement.getAttribute('data-uid') : buttonElement.getAttribute('data-field')) :
            (buttonElement.getAttribute('data-uid') ? buttonElement.getAttribute('data-uid') : buttonElement.getAttribute('data-field'));
        this.buttonElement = this.buttonElement ? this.buttonElement : document.querySelector('.' + textContent.innerText);
        const inputTextDiv1 = createElement('div', {
            className: 'e-type-option-text'
        });
        inputTextDiv1.innerText = this.parent.localeObj.getConstant('sourceCaption');
        const optionTextDiv1 = createElement('div', {
            className: 'e-base-field-option-text'
        });
        optionTextDiv1.innerText = this.parent.localeObj.getConstant('summarizeValuesBy');
        const optionTextDiv2 = createElement('div', {
            className: 'e-base-item-option-text'
        });
        optionTextDiv2.innerText = this.parent.localeObj.getConstant('baseField');
        const optionTextDiv3 = createElement('div', {
            className: 'e-type-option-text'
        });
        optionTextDiv3.innerText = this.parent.localeObj.getConstant('baseItem');
        const inputDiv1 = createElement('div', { className: 'e-caption-input-container' });
        const dropOptionDiv1 = createElement('div', { id: this.parentElement.id + '_type_option' });
        const dropOptionDiv2 = createElement('div', { id: this.parentElement.id + '_base_field_option' });
        const dropOptionDiv3 = createElement('div', { id: this.parentElement.id + '_base_item_option' });
        const inputField1 = createElement('input', {
            id: this.parentElement.id + 'type_input_option',
            className: 'e-caption-input-text',
            attrs: { 'type': 'text' }
        });
        textWrappper.appendChild(texttitle);
        textWrappper.appendChild(textContent);
        inputDiv1.appendChild(inputTextDiv1);
        inputDiv1.appendChild(inputField1);
        optionWrapperDiv1.appendChild(optionTextDiv1);
        optionWrapperDiv2.appendChild(optionTextDiv2);
        optionWrapperDiv3.appendChild(optionTextDiv3);
        optionWrapperDiv1.appendChild(dropOptionDiv1);
        optionWrapperDiv2.appendChild(dropOptionDiv2);
        optionWrapperDiv3.appendChild(dropOptionDiv3);
        filterWrapperDiv1.appendChild(textWrappper);
        filterWrapperDiv1.appendChild(inputDiv1);
        filterWrapperDiv1.appendChild(optionWrapperDiv1);
        filterWrapperDiv1.appendChild(optionWrapperDiv2);
        filterWrapperDiv1.appendChild(optionWrapperDiv3);
        mainDiv.appendChild(filterWrapperDiv1);
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const popupInstance = this;
        const optionWrapper1 = new DropDownList({
            dataSource: summaryDataSource, enableRtl: this.parent.enableRtl, locale: this.parent.locale,
            fields: { value: 'value', text: 'text' },
            value: summaryType,
            // popupWidth: 'auto',
            cssClass: VALUE_OPTIONS_CLASS + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''), width: '100%',
            change: (args) => {
                optionWrapper2.enabled = baseFieldTypes.indexOf(args.value) !== -1 ? true : false;
                optionWrapper3.enabled = baseItemTypes.indexOf(args.value) !== -1 ? true : false;
                if (optionWrapper3.enabled && optionWrapper3.dataSource.length === 1) {
                    optionWrapper3.dataSource = fieldItemDataSource;
                    optionWrapper3.dataBind();
                }
            }
        });
        optionWrapper1.isStringTemplate = true;
        optionWrapper1.appendTo(dropOptionDiv1);
        const optionWrapper2 = new DropDownList({
            dataSource: fieldDataSource, enableRtl: this.parent.enableRtl, locale: this.parent.locale,
            fields: { value: 'value', text: 'text' },
            value: baseField,
            // popupWidth: 'auto',
            enabled: (baseFieldTypes.indexOf(summaryType) !== -1 ? true : false),
            cssClass: VALUE_OPTIONS_CLASS + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''), width: '100%',
            change: (args) => {
                fieldItemDataSource = Object.keys(popupInstance.parent.engineModule.fieldList[args.value].formattedMembers);
                optionWrapper3.dataSource = fieldItemDataSource;
                optionWrapper3.value = fieldItemDataSource[0];
                optionWrapper3.filterBarPlaceholder = popupInstance.parent.localeObj.getConstant('example') + ' ' + fieldItemDataSource[0];
                optionWrapper3.itemData = null; // eslint-disable-line @typescript-eslint/no-explicit-any
                optionWrapper3.dataBind();
            }
        });
        optionWrapper2.isStringTemplate = true;
        optionWrapper2.appendTo(dropOptionDiv2);
        const optionWrapper3 = new DropDownList({
            dataSource: fieldItemDataSource, enableRtl: this.parent.enableRtl, locale: this.parent.locale,
            value: baseItem,
            // popupWidth: 'auto',
            allowFiltering: true,
            filterBarPlaceholder: this.parent.localeObj.getConstant('example') + ' ' + fieldItemDataSource[0],
            enabled: (baseItemTypes.indexOf(summaryType) !== -1 ? true : false),
            cssClass: FILTER_OPERATOR_CLASS + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''), width: '100%'
        });
        optionWrapper3.isStringTemplate = true;
        optionWrapper3.appendTo(dropOptionDiv3);
        const inputObj1 = new MaskedTextBox({
            placeholder: 'Enter field caption',
            // floatLabelType: 'Auto',
            enableRtl: this.parent.enableRtl,
            locale: this.parent.locale,
            value: fieldCaption, width: '100%',
            cssClass: this.parent.cssClass
        });
        inputObj1.isStringTemplate = true;
        inputObj1.appendTo(inputField1);
        return mainDiv;
    }
    selectOptionInContextMenu(menu) {
        if (menu.item.text !== null) {
            const buttonElement = this.currentMenu.parentElement;
            const fieldInfo = PivotUtil.getFieldInfo((buttonElement ?
                buttonElement.getAttribute('data-uid') : ''), this.parent);
            this.parent.actionObj.actionName = aggregateField;
            this.parent.actionObj.fieldInfo = fieldInfo.fieldItem;
            if (this.parent.actionBeginMethod()) {
                return;
            }
            const type = menu.item.id.split('_').pop();
            try {
                if (type === 'MoreOption' || type === 'PercentageOfDifferenceFrom'
                    || type === 'PercentageOfParentTotal' || type === 'DifferenceFrom') {
                    this.createValueSettingsDialog(buttonElement, this.parentElement, type);
                }
                else {
                    const field = buttonElement.getAttribute('data-uid');
                    const valuefields = this.parent.dataSourceSettings.values;
                    const contentElement = buttonElement.querySelector('.' + PIVOT_BUTTON_CONTENT_CLASS);
                    let captionName = menu.item.text + ' ' + this.parent.localeObj.getConstant('of') + ' ' +
                        this.parent.engineModule.fieldList[field].caption;
                    captionName = this.parent.enableHtmlSanitizer ? SanitizeHtmlHelper.sanitize(captionName) : captionName;
                    contentElement.innerText = captionName;
                    contentElement.setAttribute('title', captionName);
                    buttonElement.setAttribute('data-type', type);
                    for (let vCnt = 0; vCnt < this.parent.dataSourceSettings.values.length; vCnt++) {
                        if (this.parent.dataSourceSettings.values[vCnt].name === field) {
                            const dataSourceItem = extend({}, valuefields[vCnt].properties ?
                                valuefields[vCnt].properties :
                                valuefields[vCnt], null, true);
                            dataSourceItem.type = type;
                            this.parent.engineModule.fieldList[field].aggregateType = type;
                            valuefields.splice(vCnt, 1, dataSourceItem);
                            this.parent.lastAggregationInfo = dataSourceItem;
                        }
                    }
                    this.updateDataSource();
                }
            }
            catch (execption) {
                this.parent.actionFailureMethod(execption);
            }
        }
    }
    updateDataSource(isRefreshed) {
        if (!this.parent.allowDeferLayoutUpdate || this.parent.getModuleName() === 'pivotview') {
            this.parent.updateDataSource(isRefreshed);
        }
        else {
            if (this.parent.getModuleName() === 'pivotfieldlist' && this.parent.renderMode === 'Popup') {
                this.parent.pivotGridModule.setProperties({
                    dataSourceSettings: this.parent.dataSourceSettings.properties
                }, true);
                this.parent.pivotGridModule.notify(uiUpdate, this);
                this.parent.pivotGridModule.engineModule = this.parent.engineModule;
            }
            else {
                this.parent.triggerPopulateEvent();
            }
        }
    }
    updateValueSettings() {
        const dialogElement = this.valueDialog.element;
        const captionInstance = getInstance(select('#' + this.parentElement.id + 'type_input_option'), MaskedTextBox);
        const summaryInstance = getInstance(select('#' + this.parentElement.id + '_type_option'), DropDownList);
        const baseFieldInstance = getInstance(select('#' + this.parentElement.id + '_base_field_option'), DropDownList);
        const baseItemInstance = getInstance(select('#' + this.parentElement.id + '_base_item_option'), DropDownList);
        const fieldName = dialogElement.getAttribute('data-field');
        let buttonElement;
        if (this.parentElement.querySelector('.' + PIVOT_BUTTON_CLASS)) {
            buttonElement = this.parentElement.
                querySelector('.' + PIVOT_BUTTON_CLASS + '.' + fieldName.replace(/[^A-Z0-9]/ig, ''));
        }
        if (buttonElement) {
            const contentElement = buttonElement.querySelector('.' + PIVOT_BUTTON_CONTENT_CLASS);
            let captionName = this.parent.localeObj.getConstant(summaryInstance.value) + ' ' +
                this.parent.localeObj.getConstant('of') + ' ' + captionInstance.value;
            captionName = this.parent.enableHtmlSanitizer ? SanitizeHtmlHelper.sanitize(captionName) : captionName;
            contentElement.innerText = captionName;
            contentElement.setAttribute('title', captionName);
            buttonElement.setAttribute('data-type', summaryInstance.value);
            buttonElement.setAttribute('data-caption', captionInstance.value);
            buttonElement.setAttribute('data-basefield', baseFieldInstance.value);
            buttonElement.setAttribute('data-baseitem', baseItemInstance.value);
        }
        let selectedField = PivotUtil.getFieldByName(fieldName, this.parent.dataSourceSettings.values);
        selectedField = selectedField.properties ?
            selectedField.properties : selectedField;
        selectedField.caption = captionInstance.value;
        selectedField.type = summaryInstance.value;
        selectedField.baseField = baseFieldInstance.value;
        selectedField.baseItem = baseItemInstance.value;
        this.valueDialog.close();
        // this.parent.axisFieldModule.render();
        this.parent.lastAggregationInfo = selectedField;
        this.updateDataSource(true);
    }
    removeDialog() {
        if (this.buttonElement && select('#' + this.buttonElement.id, this.parentElement)) {
            select('#' + this.buttonElement.id, this.parentElement).focus();
        }
        if (this.valueDialog && !this.valueDialog.isDestroyed) {
            this.valueDialog.destroy();
        }
        if (document.getElementById(this.parentElement.id + '_ValueDialog')) {
            remove(document.getElementById(this.parentElement.id + '_ValueDialog'));
        }
    }
    /**
     * To destroy the pivot button event listener
     *
     * @returns {void}
     * @hidden
     */
    destroy() {
        if (this.parent.isDestroyed) {
            return;
        }
        if (this.menuInfo) {
            if (this.menuInfo[1] !== undefined && !this.menuInfo[1].isDestroyed) {
                this.menuInfo[1].destroy();
            }
            if (this.menuInfo[0] !== undefined && !this.menuInfo[0].isDestroyed) {
                this.menuInfo[0].destroy();
            }
        }
        else {
            return;
        }
    }
}

/**
 * Module to render PivotGrid control
 */
/** @hidden */
class Render {
    /** Constructor for render module
     *
     * @param {PivotView} parent - Instance of pivot table.
     */
    constructor(parent) {
        /** @hidden */
        this.isAutoFitEnabled = false;
        /** @hidden */
        this.pivotColumns = [];
        /** @hidden */
        this.indentCollection = {};
        this.colPos = 0;
        this.lastSpan = 0;
        this.lvlCollection = {};
        this.hierarchyCollection = {};
        this.lvlPosCollection = {};
        this.hierarchyPosCollection = {};
        this.position = 0;
        this.measurePos = 0;
        this.maxMeasurePos = 0;
        this.hierarchyCount = 0;
        this.actualText = '';
        this.parent = parent;
        this.resColWidth = (this.parent.showGroupingBar && this.parent.groupingBarModule) ? (this.parent.isAdaptive ? 180 : 250) :
            (this.parent.isAdaptive ? 140 : 200);
        this.engine = this.parent.dataType === 'olap' ? this.parent.olapEngineModule : this.parent.engineModule;
        this.gridSettings = this.parent.gridSettings;
        this.formatList = this.getFormatList();
        this.aggMenu = new AggregateMenu(this.parent);
    }
    /** @hidden */
    render(refreshRequired) {
        if (refreshRequired) {
            this.initProperties();
        }
        this.resColWidth = (this.parent.showGroupingBar && this.parent.groupingBarModule) ? (this.parent.isAdaptive ? 180 : 250) :
            (this.parent.isAdaptive ? 140 : 200);
        this.engine = this.parent.dataType === 'olap' ? this.parent.olapEngineModule : this.parent.engineModule;
        this.gridSettings = this.parent.gridSettings;
        this.formatList = this.getFormatList();
        this.parent.gridHeaderCellInfo = [];
        this.parent.gridCellCollection = {};
        this.injectGridModules(this.parent);
        this.rowStartPos = this.getRowStartPos();
        if (this.parent.grid && this.parent.grid.element && this.parent.element.querySelector('.e-grid')) {
            this.parent.notEmpty = true;
            if (!this.engine.isEngineUpdated) {
                this.engine.headerContent = this.frameDataSource('header');
                this.engine.valueContent = this.frameDataSource('value');
            }
            else {
                if (this.parent.enableValueSorting) {
                    this.engine.valueContent = this.frameDataSource('value');
                }
                this.engine.isEngineUpdated = false;
            }
            this.parent.grid.setProperties({
                columns: this.frameStackedHeaders(), dataSource: ((this.parent.dataType === 'olap' && this.parent.dataSourceSettings.url !== '') ? true :
                    (this.parent.dataSourceSettings.dataSource && this.parent.engineModule.data.length > 0 &&
                        this.parent.dataSourceSettings.values.length > 0)) && !this.engine.isEmptyData ? this.engine.valueContent :
                    this.frameDataSource('value')
            }, true);
            if (this.parent.grid.height === 'auto') {
                const mCntHeight = this.parent.element.querySelector('.' + MOVABLECONTENT_DIV).offsetHeight;
                const dataHeight = this.parent.grid.dataSource.length * this.parent.gridSettings.rowHeight;
                if (mCntHeight > 50 && mCntHeight < dataHeight) {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    this.parent.grid.contentModule.setHeightToContent(dataHeight);
                }
            }
            this.parent.grid.notify('datasource-modified', {});
            if (this.parent.isScrolling) {
                this.parent.resizeInfo = {};
            }
            this.parent.grid.refreshColumns();
            if (this.parent.showGroupingBar && this.parent.groupingBarModule &&
                this.parent.element.querySelector('.' + GROUPING_BAR_CLASS)) {
                this.parent.groupingBarModule.setGridRowWidth();
            }
            const e = this.parent.element.querySelector('.e-movablecontent');
            e.querySelector('colGroup').innerHTML =
                this.parent.grid.getHeaderContent().querySelector('.e-movableheader').querySelector('colgroup').innerHTML;
            this.parent.grid.width = this.calculateGridWidth();
            if (!this.gridSettings.allowAutoResizing && this.parent.showGroupingBar && this.parent.groupingBarModule && this.parent.element.querySelector('.' + GROUPING_BAR_CLASS)) {
                this.parent.groupingBarModule.refreshUI();
            }
            if (!this.parent.isScrolling) {
                this.calculateGridHeight(true);
            }
            //this.parent.isScrolling = false;
        }
        else {
            this.parent.element.innerHTML = '';
            this.bindGrid(this.parent, (this.engine.isEmptyData ? true : false));
            this.parent.element.appendChild(createElement('div', { id: this.parent.element.id + '_grid' }));
            this.parent.grid.isStringTemplate = true;
            this.parent.grid.appendTo('#' + this.parent.element.id + '_grid');
        }
        this.parent.grid.on(headerRefreshed, this.refreshHeader, this);
    }
    initProperties() {
        this.rowStartPos = undefined;
        this.maxIndent = undefined;
        this.resColWidth = undefined;
        this.isOverflows = undefined;
        this.indentCollection = {};
        this.formatList = undefined;
        this.colPos = 0;
        this.colGrandPos = undefined;
        this.rowGrandPos = undefined;
        this.lastSpan = 0;
        this.field = undefined;
        this.fieldCaption = undefined;
        this.lvlCollection = {};
        this.hierarchyCollection = {};
        this.lvlPosCollection = {};
        this.hierarchyPosCollection = {};
        this.position = 0;
        this.measurePos = 0;
        this.maxMeasurePos = 0;
        this.hierarchyCount = 0;
        this.actualText = '';
        this.timeOutObj = undefined;
    }
    refreshHeader() {
        if (this.parent.enableVirtualization) {
            const mHdr = this.parent.element.querySelector('.' + MOVABLEHEADER_DIV);
            const mCont = this.parent.element.querySelector('.' + MOVABLECONTENT_DIV);
            const vtr = mCont.querySelector('.' + VIRTUALTRACK_DIV);
            this.parent.virtualHeaderDiv = mHdr.querySelector('.' + VIRTUALTRACK_DIV);
            if (mHdr.querySelector('.' + VIRTUALTRACK_DIV)) {
                remove(mHdr.querySelector('.' + VIRTUALTRACK_DIV));
            }
            else {
                this.parent.virtualHeaderDiv = createElement('div', { className: VIRTUALTRACK_DIV });
            }
            mHdr.appendChild(this.parent.virtualHeaderDiv);
            if (vtr) {
                setStyleAttribute(this.parent.virtualHeaderDiv, { height: 0, width: vtr.style.width });
            }
            if (mHdr.querySelector('.e-table')) {
                setStyleAttribute(mHdr.querySelector('.e-table'), {
                    transform: (mCont.querySelector('.e-table').style.transform).split(',')[0] + ',' + 0 + 'px)'
                });
            }
            const ele = this.parent.isAdaptive ? mCont : mCont.parentElement.parentElement.querySelector('.' + MOVABLESCROLL_DIV);
            mHdr.scrollLeft = ele.scrollLeft;
        }
    }
    /** @hidden */
    bindGrid(parent, isEmpty) {
        this.injectGridModules(parent);
        this.parent.grid = new Grid({
            cssClass: this.parent.cssClass,
            frozenColumns: 1,
            frozenRows: 0,
            enableHover: false,
            dataSource: isEmpty ? this.frameEmptyData() : this.frameDataSource('value'),
            columns: isEmpty ? this.frameEmptyColumns() : this.frameStackedHeaders(),
            height: isEmpty ? 'auto' : this.calculateGridHeight(),
            width: isEmpty ? (this.gridSettings.allowAutoResizing ? this.parent.width : 400) : this.calculateGridWidth(),
            locale: parent.locale,
            enableRtl: parent.enableRtl,
            allowExcelExport: parent.allowExcelExport,
            allowPdfExport: parent.allowPdfExport,
            allowResizing: this.gridSettings.allowResizing,
            allowTextWrap: this.gridSettings.allowTextWrap,
            clipMode: this.gridSettings.clipMode,
            allowReordering: (this.parent.showGroupingBar ? false : this.gridSettings.allowReordering),
            allowSelection: this.gridSettings.allowSelection,
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            contextMenuItems: this.gridSettings.contextMenuItems,
            selectedRowIndex: this.gridSettings.selectedRowIndex,
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            selectionSettings: this.gridSettings.selectionSettings,
            textWrapSettings: this.gridSettings.textWrapSettings,
            printMode: this.gridSettings.printMode,
            rowHeight: this.gridSettings.rowHeight,
            gridLines: this.gridSettings.gridLines,
            contextMenuClick: this.contextMenuClick.bind(this),
            contextMenuOpen: this.contextMenuOpen.bind(this),
            beforeCopy: this.gridSettings.beforeCopy ? this.gridSettings.beforeCopy.bind(this.parent) : undefined,
            beforePrint: this.gridSettings.beforePrint ? this.gridSettings.beforePrint.bind(this.parent) : undefined,
            printComplete: this.gridSettings.printComplete ? this.gridSettings.printComplete.bind(this.parent) : undefined,
            rowSelecting: this.gridSettings.rowSelecting ? this.gridSettings.rowSelecting.bind(this.parent) : undefined,
            rowSelected: this.rowSelected.bind(this),
            rowDeselecting: this.gridSettings.rowDeselecting ? this.gridSettings.rowDeselecting.bind(this.parent) : undefined,
            rowDeselected: this.rowDeselected.bind(this),
            cellSelecting: this.gridSettings.cellSelecting ? this.gridSettings.cellSelecting.bind(this.parent) : undefined,
            cellSelected: this.cellSelected.bind(this),
            cellDeselecting: this.gridSettings.cellDeselecting ? this.gridSettings.cellDeselecting.bind(this.parent) : undefined,
            cellDeselected: this.cellDeselected.bind(this),
            resizeStart: this.gridSettings.resizeStart ? this.gridSettings.resizeStart.bind(this.parent) : undefined,
            columnDragStart: this.gridSettings.columnDragStart ? this.gridSettings.columnDragStart.bind(this) : undefined,
            columnDrag: this.gridSettings.columnDrag ? this.gridSettings.columnDrag.bind(this) : undefined,
            columnDrop: this.gridSettings.columnDrop ? this.gridSettings.columnDrop.bind(this) : undefined,
            beforeExcelExport: this.beforeExcelExport.bind(this),
            resizing: this.setGroupWidth.bind(this),
            resizeStop: this.onResizeStop.bind(this),
            queryCellInfo: this.queryCellInfo.bind(this),
            dataBound: this.dataBound.bind(this),
            headerCellInfo: this.headerCellInfo.bind(this),
            excelHeaderQueryCellInfo: this.excelHeaderQueryCellInfo.bind(this),
            pdfHeaderQueryCellInfo: this.pdfHeaderQueryCellInfo.bind(this),
            excelQueryCellInfo: this.excelQueryCellInfo.bind(this),
            pdfQueryCellInfo: this.pdfQueryCellInfo.bind(this),
            beforePdfExport: this.gridSettings.beforePdfExport ? this.gridSettings.beforePdfExport.bind(this) : undefined,
            pdfExportComplete: this.pdfExportComplete.bind(this),
            excelExportComplete: this.excelExportComplete.bind(this)
        });
        this.parent.grid.on('header-refreshed', this.headerRefreshed.bind(this));
        this.parent.grid.on('export-DataBound', this.excelDataBound.bind(this));
    }
    headerRefreshed() {
        const mHdr = this.parent.element.querySelector('.' + MOVABLEHEADER_DIV);
        if (this.parent.lastGridSettings && Object.keys(this.parent.lastGridSettings).indexOf('allowResizing') > -1 && !isNullOrUndefined(mHdr) && mHdr.querySelector('.e-table') &&
            this.parent.showGroupingBar && this.parent.groupingBarModule && this.parent.element.querySelector('.' + GROUPING_BAR_CLASS)) {
            this.parent.lastGridSettings = undefined;
            this.parent.groupingBarModule.setGridRowWidth();
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    beforeExcelExport(args) {
        if (!isNullOrUndefined(args.gridObject.columns) && !isNullOrUndefined(this.parent.pivotColumns)) {
            args.gridObject.columns[args.gridObject.columns.length - 1].width =
                this.parent.pivotColumns[this.parent.pivotColumns.length - 1].width;
        }
        this.parent.trigger(beforeExcelExport, args);
    }
    rowSelected(args) {
        this.parent.renderModule.selected();
        this.parent.trigger(rowSelected, args);
    }
    rowDeselected(args) {
        this.parent.renderModule.selected();
        this.parent.trigger(rowDeselected, args);
    }
    cellSelected(args) {
        if (this.parent.rowRangeSelection.enable) {
            this.parent.grid.selectionModule.selectRowsByRange(this.parent.rowRangeSelection.startIndex, this.parent.rowRangeSelection.endIndex);
            this.parent.rowRangeSelection.enable = false;
        }
        else {
            this.parent.renderModule.selected();
            this.parent.trigger(selected, args);
        }
    }
    cellSelecting(args) {
        this.parent.trigger(cellSelecting, args);
    }
    cellDeselected(args) {
        this.parent.renderModule.selected();
        this.parent.trigger(cellDeselected, args);
    }
    queryCellInfo(args) {
        this.parent.renderModule.rowCellBoundEvent(args);
    }
    headerCellInfo(args) {
        this.parent.renderModule.columnCellBoundEvent(args);
    }
    excelHeaderQueryCellInfo(args) {
        this.parent.renderModule.excelColumnEvent(args);
    }
    pdfQueryCellInfo(args) {
        this.parent.renderModule.pdfRowEvent(args);
    }
    excelQueryCellInfo(args) {
        this.parent.renderModule.excelRowEvent(args);
    }
    pdfHeaderQueryCellInfo(args) {
        this.parent.renderModule.pdfColumnEvent(args);
    }
    pdfExportComplete(args) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        if (this.parent.lastColumn !== undefined && this.parent.lastColumn.width !== 'auto') {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this.parent.lastColumn.width = 'auto';
            this.parent.lastColumn = undefined;
        }
        const exportCompleteEventArgs = {
            type: 'PDF',
            promise: args.promise
        };
        this.parent.trigger(exportComplete, exportCompleteEventArgs);
    }
    excelExportComplete(args) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        if (this.parent.lastColumn !== undefined && this.parent.lastColumn.width !== 'auto') {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this.parent.lastColumn.width = 'auto';
            this.parent.lastColumn = undefined;
        }
        const exportCompleteEventArgs = {
            type: 'Excel/CSV',
            promise: args.promise
        };
        this.parent.trigger(exportComplete, exportCompleteEventArgs);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    dataBound(args) {
        if (this.parent.cellTemplate) {
            for (const cell of this.parent.gridHeaderCellInfo) {
                if (this.parent.cellTemplate) {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    const element = this.parent.getCellTemplate()(cell, this.parent, 'cellTemplate', this.parent.element.id + '_cellTemplate', null, null, cell.targetCell);
                    if (element && element !== '' && element.length > 0) {
                        if (this.parent.enableHtmlSanitizer) {
                            if (this.parent.isVue || this.parent.isVue3) {
                                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                append(SanitizeHtmlHelper.sanitize(element), cell.targetCell);
                            }
                            else {
                                this.parent.appendHtml(cell.targetCell, SanitizeHtmlHelper.sanitize(element[0].outerHTML));
                            }
                        }
                        else {
                            if (this.parent.isVue || this.parent.isVue3) {
                                append(element, cell.targetCell);
                            }
                            else {
                                this.parent.appendHtml(cell.targetCell, element[0].outerHTML);
                            }
                        }
                    }
                }
            }
            this.parent.gridHeaderCellInfo = [];
        }
        // if ((this.parent.dataSourceSettings.valueAxis === 'row' ||
        //     !(this.parent.dataType === 'pivot' && this.parent.dataSourceSettings.valueAxis === 'column' && this.parent.engineModule && !this.parent.engineModule.isLastHeaderHasMeasures)) &&
        //     this.parent.element.querySelector('.e-firstcell') && !(this.parent.dataSourceSettings.values.length === 1 && this.parent.dataSourceSettings.columns.length > 0)) {
        //     if (this.parent.enableRtl) {
        //         (this.parent.element.querySelector('.e-firstcell') as HTMLElement).style.borderRight = 'none';
        //     } else {
        //         (this.parent.element.querySelector('.e-firstcell') as HTMLElement).style.borderLeft = 'none';
        //     }
        // }
        if (!this.isAutoFitEnabled && this.parent.grid && this.parent.grid.widthService) {
            this.parent.grid.widthService.setWidthToTable();
        }
        if (this.parent.notEmpty) {
            this.calculateGridHeight(true);
        }
        this.parent.isScrolling = false;
        this.setFocusOnLastCell();
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        if (!isNullOrUndefined(this.parent.renderReactTemplates)) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this.parent.renderReactTemplates();
        }
        if (this.parent.isInitial) {
            this.parent.isInitial = false;
            this.parent.refreshData();
        }
        this.parent.notify(contentReady, {});
    }
    setFocusOnLastCell() {
        if (this.parent.keyboardModule && this.parent.keyboardModule.event &&
            this.parent.keyboardModule.event.target.nodeName === 'TD') {
            const gridFocus = this.parent.grid.serviceLocator.getService('focus');
            gridFocus.setFocusedElement(this.parent.keyboardModule.event.target);
            gridFocus.focus(this.parent.keyboardModule.event);
            addClass([this.parent.keyboardModule.event.target], ['e-focused', 'e-focus']);
            this.parent.keyboardModule.event.target.setAttribute('tabindex', '0');
            this.parent.keyboardModule.event = undefined;
        }
    }
    getCellElement(target) {
        let currentElement = closest(target, 'td');
        if (isNullOrUndefined(currentElement)) {
            currentElement = closest(target, 'th');
        }
        return currentElement;
    }
    contextMenuOpen(args) {
        if (args.element && this.parent.cssClass) {
            addClass([args.element.parentElement], this.parent.cssClass);
        }
        for (const item of args.items) {
            const cellTarget = this.parent.lastCellClicked ? this.parent.lastCellClicked :
                (this.parent.isAdaptive ? args.event.target : this.parent.lastCellClicked);
            const elem = this.getCellElement(cellTarget);
            let bool;
            let isGroupElement;
            if (!elem || (elem && Number(elem.getAttribute('index')) === 0 && Number(elem.getAttribute('data-colindex')) === 0)) {
                args.cancel = true;
                return;
            }
            if (elem.classList.contains('e-valuesheader') || elem.classList.contains('e-stot')) {
                bool = true;
            }
            if (this.parent.allowGrouping && this.parent.groupingModule && !this.validateField(elem)) {
                isGroupElement = true;
            }
            const rowIndex = Number(elem.getAttribute('index'));
            const colIndex = Number(elem.getAttribute('data-colindex'));
            const pivotValue1 = this.parent.pivotValues[rowIndex][colIndex];
            const selectedID = item.id;
            switch (selectedID) {
                case this.parent.element.id + '_expand':
                    if (elem.querySelectorAll('.' + EXPAND).length > 0) {
                        if (selectAll('#' + this.parent.element.id + '_expand', args.element)) {
                            select('#' + this.parent.element.id + '_expand', args.element).classList.add(MENU_DISABLE);
                        }
                        if (select('#' + this.parent.element.id + '_expand', args.element).classList.contains(MENU_DISABLE)) {
                            select('#' + this.parent.element.id + '_expand', args.element).classList.remove(MENU_DISABLE);
                        }
                        if (select('#' + this.parent.element.id + '_expand', args.element).classList.contains(MENU_HIDE)) {
                            select('#' + this.parent.element.id + '_expand', args.element).classList.remove(MENU_HIDE);
                            select('#' + this.parent.element.id + '_collapse', args.element).classList.remove(MENU_HIDE);
                        }
                    }
                    else {
                        if (bool) {
                            select('#' + this.parent.element.id + '_expand', args.element).classList.add(MENU_HIDE);
                        }
                        else {
                            select('#' + this.parent.element.id + '_expand', args.element).classList.add(MENU_DISABLE);
                        }
                    }
                    break;
                case this.parent.element.id + '_collapse':
                    if (elem.querySelectorAll('.' + COLLAPSE).length > 0) {
                        if (select('#' + this.parent.element.id + '_expand', args.element)) {
                            select('#' + this.parent.element.id + '_expand', args.element).classList.add(MENU_DISABLE);
                        }
                        if (select('#' + this.parent.element.id + '_collapse', args.element).classList.contains(MENU_DISABLE)) {
                            select('#' + this.parent.element.id + '_collapse', args.element).classList.remove(MENU_DISABLE);
                        }
                        if (select('#' + this.parent.element.id + '_collapse', args.element).classList.contains(MENU_HIDE)) {
                            select('#' + this.parent.element.id + '_collapse', args.element).classList.remove(MENU_HIDE);
                            select('#' + this.parent.element.id + '_expand', args.element).classList.remove(MENU_HIDE);
                        }
                    }
                    else {
                        if (bool) {
                            select('#' + this.parent.element.id + '_collapse', args.element).classList.add(MENU_HIDE);
                        }
                        else {
                            select('#' + this.parent.element.id + '_collapse', args.element).classList.add(MENU_DISABLE);
                        }
                    }
                    break;
                case this.parent.element.id + '_custom_group':
                    if (!isGroupElement && args.items.length === 2) {
                        args.cancel = true;
                    }
                    if (selectAll('#' + this.parent.element.id + '_custom_group', args.element)) {
                        addClass([select('#' + this.parent.element.id + '_custom_group', args.element)], MENU_HIDE);
                    }
                    if (isGroupElement) {
                        if (selectAll('#' + this.parent.element.id + '_custom_group', args.element)) {
                            removeClass([select('#' + this.parent.element.id + '_custom_group', args.element)], MENU_HIDE);
                        }
                    }
                    break;
                case this.parent.element.id + '_custom_ungroup':
                    if (selectAll('#' + this.parent.element.id + '_custom_ungroup', args.element)) {
                        addClass([select('#' + this.parent.element.id + '_custom_ungroup', args.element)], MENU_HIDE);
                    }
                    if (isGroupElement) {
                        let isUngroupOption = false;
                        const fieldName = elem.getAttribute('fieldname');
                        let groupField = PivotUtil.getFieldByName(fieldName, this.parent.dataSourceSettings.groupSettings);
                        if (groupField && groupField.type === 'Custom' || (this.parent.engineModule.fieldList[fieldName].isCustomField && fieldName.indexOf('_custom_group') > -1)) {
                            groupField = PivotUtil.getFieldByName(fieldName.replace('_custom_group', ''), this.parent.dataSourceSettings.groupSettings);
                            if (groupField) {
                                const cell = this.parent.engineModule.pivotValues[Number(elem.getAttribute('index'))][Number(elem.getAttribute('data-colindex'))];
                                const selectedCellsInfo = this.parent.groupingModule.getSelectedCells(cell.axis, fieldName, cell.actualText.toString());
                                selectedCellsInfo.push({ axis: cell.axis, fieldName: fieldName, name: cell.actualText.toString(),
                                    cellInfo: cell });
                                const selectedOptions = this.parent.groupingModule.getSelectedOptions(selectedCellsInfo);
                                for (const customGroup of groupField.customGroups) {
                                    if (selectedOptions.indexOf(customGroup.groupName) > -1) {
                                        isUngroupOption = true;
                                        break;
                                    }
                                }
                            }
                        }
                        else if (groupField && (groupField.type === 'Date' || groupField.type === 'Number') ||
                            (this.parent.engineModule.fieldList[fieldName].isCustomField && fieldName.indexOf('_date_group') > -1)) {
                            isUngroupOption = true;
                        }
                        if (selectAll('#' + this.parent.element.id + '_custom_ungroup', args.element) && isUngroupOption) {
                            removeClass([select('#' + this.parent.element.id + '_custom_ungroup', args.element)], MENU_HIDE);
                        }
                    }
                    break;
                case this.parent.element.id + '_drillthrough':
                    if (!this.parent.allowDrillThrough) {
                        if (select('#' + this.parent.element.id + '_drillthrough', args.element)) {
                            select('#' + this.parent.element.id + '_drillthrough', args.element).classList.add(MENU_DISABLE);
                        }
                    }
                    else if (!(elem.classList.contains('e-summary'))) {
                        if (elem.innerText === '') {
                            if (select('#' + this.parent.element.id + '_drillthrough', args.element)) {
                                select('#' + this.parent.element.id + '_drillthrough', args.element).classList.add(MENU_DISABLE);
                            }
                        }
                    }
                    else {
                        if (select('#' + this.parent.element.id + '_drillthrough', args.element).classList.contains(MENU_DISABLE)) {
                            select('#' + this.parent.element.id + '_drillthrough', args.element).classList.remove(MENU_DISABLE);
                        }
                    }
                    break;
                case this.parent.element.id + '_sortasc':
                    if (!this.parent.enableValueSorting) {
                        if (select('#' + this.parent.element.id + '_sortasc', args.element)) {
                            select('#' + this.parent.element.id + '_sortasc', args.element).classList.add(MENU_DISABLE);
                        }
                    }
                    else if (elem.querySelectorAll('.e-icon-descending').length > 0) {
                        if (select('#' + this.parent.element.id + '_sortdesc', args.element)) {
                            select('#' + this.parent.element.id + '_sortdesc', args.element).classList.add(MENU_DISABLE);
                        }
                        else {
                            select('#' + this.parent.element.id + '_sortdesc', args.element).classList.remove(MENU_DISABLE);
                        }
                        if (select('#' + this.parent.element.id + '_sortasc', args.element).classList.contains(MENU_DISABLE)) {
                            select('#' + this.parent.element.id + '_sortasc', args.element).classList.remove(MENU_DISABLE);
                        }
                    }
                    else if (select('#' + this.parent.element.id + '_sortdesc', args.element).classList.contains(MENU_DISABLE)) {
                        select('#' + this.parent.element.id + '_sortdesc', args.element).classList.remove(MENU_DISABLE);
                    }
                    break;
                case this.parent.element.id + '_sortdesc':
                    if (!this.parent.enableValueSorting) {
                        if (select('#' + this.parent.element.id + '_sortdesc', args.element)) {
                            select('#' + this.parent.element.id + '_sortdesc', args.element).classList.add(MENU_DISABLE);
                        }
                    }
                    else if (elem.querySelectorAll('.e-icon-ascending').length > 0) {
                        if (select('#' + this.parent.element.id + '_sortasc', args.element)) {
                            select('#' + this.parent.element.id + '_sortasc', args.element).classList.add(MENU_DISABLE);
                        }
                        else {
                            select('#' + this.parent.element.id + '_sortasc', args.element).classList.remove(MENU_DISABLE);
                        }
                        if (select('#' + this.parent.element.id + '_sortdesc', args.element).classList.contains(MENU_DISABLE)) {
                            select('#' + this.parent.element.id + '_sortdesc', args.element).classList.remove(MENU_DISABLE);
                        }
                    }
                    else if (select('#' + this.parent.element.id + '_sortasc', args.element).classList.contains(MENU_DISABLE)) {
                        select('#' + this.parent.element.id + '_sortasc', args.element).classList.remove(MENU_DISABLE);
                    }
                    break;
                case this.parent.element.id + '_CalculatedField':
                    if (!this.parent.allowCalculatedField) {
                        select('#' + this.parent.element.id + '_CalculatedField', args.element).classList.add(MENU_DISABLE);
                    }
                    break;
                case this.parent.element.id + '_pdf':
                    if (!this.parent.allowPdfExport) {
                        select('#' + this.parent.element.id + '_pdf', args.element).classList.add(MENU_DISABLE);
                    }
                    break;
                case this.parent.element.id + '_excel':
                    if (!this.parent.allowExcelExport) {
                        select('#' + this.parent.element.id + '_excel', args.element).classList.add(MENU_DISABLE);
                    }
                    break;
                case this.parent.element.id + '_csv':
                    if (!this.parent.allowExcelExport) {
                        select('#' + this.parent.element.id + '_csv', args.element).classList.add(MENU_DISABLE);
                    }
                    break;
                case this.parent.element.id + '_exporting':
                    if ((!this.parent.allowExcelExport) && (!this.parent.allowPdfExport)) {
                        select('#' + this.parent.element.id + '_exporting', args.element).classList.add(MENU_DISABLE);
                    }
                    break;
                case this.parent.element.id + '_aggregate':
                    if ((select('#' + this.parent.element.id + '_aggregate', args.element)) &&
                        (!select('#' + this.parent.element.id + '_aggregate', args.element).classList.contains(MENU_DISABLE))) {
                        select('#' + this.parent.element.id + '_aggregate', args.element).classList.add(MENU_DISABLE);
                    }
                    if ((elem.classList.contains('e-valuesheader') || elem.classList.contains('e-valuescontent') ||
                        (elem.classList.contains('e-stot') && elem.classList.contains('e-rowsheader'))) && this.parent.dataType !== 'olap') {
                        let fieldType;
                        if (!(elem.innerText === '')) {
                            fieldType = this.parent.engineModule.fieldList[pivotValue1.actualText.toString()].type;
                        }
                        const eventArgs = {
                            cancel: false, fieldName: pivotValue1.actualText.toString(),
                            aggregateTypes: [...this.getMenuItem(fieldType)],
                            displayMenuCount: 7
                        };
                        this.parent.trigger(aggregateMenuOpen, eventArgs, (observedArgs) => {
                            if (!observedArgs.cancel && !(elem.innerText === '')) {
                                const menuItem = [];
                                const checkDuplicates = [];
                                for (let i = 0; i < observedArgs.aggregateTypes.length; i++) {
                                    const key = observedArgs.aggregateTypes[i];
                                    if (fieldType !== 'number') {
                                        if ((['Count', 'DistinctCount'].indexOf(key) > -1) && (checkDuplicates.indexOf(key) < 0)) {
                                            menuItem.push({ text: this.parent.localeObj.getConstant(key), id: this.parent.element.id + '_Agg' + key });
                                            checkDuplicates.push(key);
                                        }
                                    }
                                    else {
                                        if ((this.parent.getAllSummaryType().indexOf(key) > -1) && (checkDuplicates.indexOf(key) < 0)) {
                                            menuItem.push({ text: this.parent.localeObj.getConstant(key), id: this.parent.element.id + '_Agg' + key });
                                            checkDuplicates.push(key);
                                        }
                                    }
                                }
                                if (menuItem.length > observedArgs.displayMenuCount) {
                                    menuItem.splice(observedArgs.displayMenuCount);
                                    menuItem.push({
                                        text: this.parent.localeObj.getConstant('MoreOption'),
                                        id: this.parent.element.id + '_Agg' + 'MoreOption'
                                    });
                                }
                                if (menuItem && menuItem.length >= 1) {
                                    item.items = menuItem;
                                    select('#' + this.parent.element.id + '_aggregate', args.element).classList.remove(MENU_DISABLE);
                                }
                            }
                        });
                    }
                    break;
            }
        }
        this.parent.trigger(contextMenuOpen, args);
    }
    getMenuItem(isStringField) {
        const menuItems = [];
        for (let i = 0; i < this.parent.aggregateTypes.length; i++) {
            const key = this.parent.aggregateTypes[i];
            if (isStringField !== 'string') {
                if ((this.parent.getAllSummaryType().indexOf(key) > -1) && (menuItems.indexOf(key) === -1)) {
                    menuItems.push(key);
                }
            }
            else {
                if ((['Count', 'DistinctCount'].indexOf(key) > -1) && (menuItems.indexOf(key) === -1)) {
                    menuItems.push(key);
                }
            }
        }
        return menuItems;
    }
    contextMenuClick(args) {
        // this.parent.gridSettings.contextMenuClick();
        const target = this.parent.lastCellClicked;
        const selected$$1 = args.item.id;
        const event = new MouseEvent('dblclick', {
            'view': window,
            'bubbles': true,
            'cancelable': true
        });
        let exportArgs = {};
        const ele = this.getCellElement(target);
        const rowIndx = Number(ele.getAttribute('index'));
        const colIndx = Number(ele.getAttribute('data-colindex'));
        const pivotValue = this.parent.pivotValues[rowIndx][colIndx];
        let aggregateType;
        if (args.item.id.indexOf(this.parent.element.id + '_Agg') > -1) {
            this.field = this.parent.engineModule.fieldList[pivotValue.actualText.toString()].id;
            this.fieldCaption = this.parent.engineModule.fieldList[pivotValue.actualText.toString()].caption;
            aggregateType = args.item.id.split('_Agg')[1];
        }
        switch (selected$$1) {
            case this.parent.element.id + '_pdf':
                exportArgs = {
                    pdfDoc: undefined,
                    isBlob: false,
                    isMultipleExport: false,
                    pdfExportProperties: { fileName: 'Export.pdf' }
                };
                this.parent.trigger(beforeExport, exportArgs, (observedArgs) => {
                    this.parent.pdfExport(observedArgs.pdfExportProperties, observedArgs.isMultipleExport, observedArgs.pdfDoc, observedArgs.isBlob);
                });
                break;
            case this.parent.element.id + '_excel':
                exportArgs = {
                    isBlob: false,
                    isMultipleExport: false,
                    workbook: undefined,
                    excelExportProperties: { fileName: 'Export.xlsx' }
                };
                this.parent.trigger(beforeExport, exportArgs, (observedArgs) => {
                    this.parent.excelExport(observedArgs.excelExportProperties, observedArgs.isMultipleExport, observedArgs.workbook, observedArgs.isBlob);
                });
                break;
            case this.parent.element.id + '_csv':
                exportArgs = {
                    isBlob: false,
                    workbook: undefined,
                    isMultipleExport: false,
                    excelExportProperties: { fileName: 'Export.csv' }
                };
                this.parent.trigger(beforeExport, exportArgs, (observedArgs) => {
                    this.parent.csvExport(observedArgs.excelExportProperties, observedArgs.isMultipleExport, observedArgs.workbook, observedArgs.isBlob);
                });
                break;
            case this.parent.element.id + '_drillthrough_menu':
                ele.dispatchEvent(event);
                break;
            case this.parent.element.id + '_sortasc':
                this.parent.setProperties({
                    dataSourceSettings: {
                        valueSortSettings: {
                            headerText: pivotValue.valueSort.levelName,
                            headerDelimiter: this.parent.dataSourceSettings.valueSortSettings.headerDelimiter
                        }
                    }
                });
                this.parent.dataSourceSettings.valueSortSettings.sortOrder = 'Ascending';
                break;
            case this.parent.element.id + '_sortdesc':
                this.parent.setProperties({
                    dataSourceSettings: {
                        valueSortSettings: {
                            headerText: pivotValue.valueSort.levelName,
                            headerDelimiter: this.parent.dataSourceSettings.valueSortSettings.headerDelimiter
                        }
                    }
                });
                this.parent.dataSourceSettings.valueSortSettings.sortOrder = 'Descending';
                break;
            case this.parent.element.id + '_expand':
                if (ele.querySelectorAll('.' + EXPAND)) {
                    const exp = ele.querySelectorAll('.' + EXPAND)[0];
                    this.parent.onDrill(exp);
                }
                break;
            case this.parent.element.id + '_collapse':
                if (ele.querySelectorAll('.' + COLLAPSE)) {
                    const colp = ele.querySelectorAll('.' + COLLAPSE)[0];
                    this.parent.onDrill(colp);
                }
                break;
            case this.parent.element.id + '_CalculatedField':
                this.parent.calculatedFieldModule.createCalculatedFieldDialog();
                break;
            case this.parent.element.id + '_AggMoreOption':
            case this.parent.element.id + '_AggDifferenceFrom':
            case this.parent.element.id + '_AggPercentageOfDifferenceFrom':
            case this.parent.element.id + '_AggPercentageOfParentTotal':
                ele.setAttribute('id', this.field);
                ele.setAttribute('data-caption', this.fieldCaption);
                ele.setAttribute('data-field', this.field);
                ele.setAttribute('data-type', this.engine.fieldList[pivotValue.actualText.toString()].aggregateType);
                ele.setAttribute('data-basefield', this.engine.fieldList[pivotValue.actualText.toString()].baseField);
                ele.setAttribute('data-baseItem', this.engine.fieldList[pivotValue.actualText.toString()].baseItem);
                this.aggMenu.createValueSettingsDialog(ele, this.parent.element, aggregateType);
                break;
            case this.parent.element.id + '_Agg' + aggregateType:
                this.updateAggregate(aggregateType);
                break;
            case this.parent.element.id + '_custom_group':
            case this.parent.element.id + '_custom_ungroup':
                if (this.parent.groupingModule) {
                    const args = {
                        target: ele,
                        option: selected$$1,
                        parentElement: this.parent.element
                    };
                    this.parent.notify(initGrouping, args);
                    this.parent.grid.contextMenuModule.contextMenu.close();
                }
                break;
        }
        this.parent.trigger(contextMenuClick, args);
    }
    validateColumnTotalcell(columnIndex) {
        const headerPosKeys = Object.keys(this.engine.headerContent);
        const keysLength = headerPosKeys.length;
        let sumLock = false;
        let fieldName = '';
        for (let pos = keysLength - 1; pos >= 0; pos--) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const cell = this.engine.headerContent[headerPosKeys[pos]][columnIndex];
            if (cell) {
                sumLock = sumLock && fieldName !== '' ? fieldName === cell.valueSort.axis : false;
                fieldName = cell.valueSort.axis ? cell.valueSort.axis.toString() : '';
                if (cell.type === 'sum') {
                    sumLock = true;
                }
                if (sumLock && cell.members && cell.members.length > 0) {
                    return true;
                }
            }
            else {
                return false;
            }
        }
        return false;
    }
    validateField(target) {
        let isValueField = false;
        if (target.classList.contains('e-stot') || target.classList.contains('e-gtot') || target.classList.contains('e-valuescontent') || target.classList.contains('e-valuesheader')) {
            isValueField = true;
        }
        else {
            let fieldName = target.getAttribute('fieldName');
            if (!fieldName || fieldName === '') {
                const rowIndx = Number(target.getAttribute('index'));
                const colIndx = Number(target.getAttribute('data-colindex'));
                fieldName = this.engine.pivotValues[rowIndx][colIndx].actualText;
            }
            const valuefields = this.parent.dataSourceSettings.values;
            for (let valueCnt = 0; valueCnt < valuefields.length; valueCnt++) {
                if (this.parent.dataSourceSettings.values[valueCnt].name === fieldName) {
                    isValueField = true;
                    break;
                }
            }
        }
        return isValueField;
    }
    updateAggregate(aggregate) {
        if (this.parent.getAllSummaryType().indexOf(aggregate) > -1) {
            const valuefields = this.parent.dataSourceSettings.values;
            for (let valueCnt = 0; valueCnt < this.parent.dataSourceSettings.values.length; valueCnt++) {
                if (this.parent.dataSourceSettings.values[valueCnt].name === this.field) {
                    const dataSourceItem = valuefields[valueCnt];
                    dataSourceItem.type = aggregate;
                }
            }
        }
    }
    injectGridModules(parent) {
        Grid.Inject(Freeze);
        if (parent.allowExcelExport) {
            Grid.Inject(ExcelExport);
        }
        if (parent.allowPdfExport) {
            Grid.Inject(PdfExport);
        }
        Grid.Inject(Selection, Reorder, Resize);
        if (this.gridSettings.contextMenuItems) {
            Grid.Inject(ContextMenu);
        }
    }
    /** @hidden */
    updateGridSettings() {
        this.injectGridModules(this.parent);
        this.parent.grid.allowResizing = this.gridSettings.allowResizing;
        this.parent.grid.clipMode = this.gridSettings.clipMode;
        this.parent.grid.allowTextWrap = this.gridSettings.allowTextWrap;
        this.parent.grid.allowReordering = (this.parent.showGroupingBar ? false : this.gridSettings.allowReordering);
        this.parent.grid.allowSelection = this.gridSettings.allowSelection;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.parent.grid.contextMenuItems = this.gridSettings.contextMenuItems;
        this.parent.grid.selectedRowIndex = this.gridSettings.selectedRowIndex;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.parent.grid.selectionSettings = this.gridSettings.selectionSettings;
        this.parent.grid.textWrapSettings = this.gridSettings.textWrapSettings;
        this.parent.grid.printMode = this.gridSettings.printMode;
        this.parent.grid.rowHeight = this.gridSettings.rowHeight;
        this.parent.grid.gridLines = this.gridSettings.gridLines;
        if (this.parent.lastGridSettings) {
            const keys = Object.keys(this.parent.lastGridSettings);
            if (keys.indexOf('height') > -1) {
                this.parent.grid.height = this.gridSettings.height;
            }
            if (keys.indexOf('width') > -1) {
                this.parent.grid.width = this.gridSettings.width;
            }
            this.updatePivotColumns();
            if (keys.indexOf('allowTextWrap') > -1 || keys.indexOf('clipMode') > -1) {
                this.parent.layoutRefresh();
            }
        }
        this.clearColumnSelection();
    }
    updatePivotColumns() {
        const keys = Object.keys(this.parent.lastGridSettings);
        for (let colPos = 0; colPos < this.parent.pivotColumns.length; colPos++) {
            const pivotColumn = this.parent.pivotColumns[colPos];
            for (let keyPos = 0; keyPos < keys.length; keyPos++) {
                const key = keys[keyPos];
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                if (!isNullOrUndefined(this.parent.pivotColumns[colPos][key])) {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    pivotColumn[key] = this.parent.lastGridSettings[key];
                }
            }
        }
        this.parent.fillGridColumns(this.parent.grid.columns);
    }
    clearColumnSelection() {
        removeClass(this.parent.element.querySelectorAll('.' + CELL_ACTIVE_BGCOLOR), [CELL_ACTIVE_BGCOLOR, SELECTED_BGCOLOR]);
    }
    appendValueSortIcon(cell, tCell, rCnt, cCnt, column) {
        if (this.parent.enableValueSorting && this.parent.dataType === 'pivot') {
            const vSort = this.parent.dataSourceSettings.valueSortSettings;
            const len = (cell.type === 'grand sum' &&
                this.parent.dataSourceSettings.values.length === 1 && !this.parent.dataSourceSettings.alwaysShowValueHeader) ? 0 :
                (this.parent.dataSourceSettings.values.length > 1 || this.parent.dataSourceSettings.alwaysShowValueHeader) ?
                    (this.parent.engineModule.headerContent.length - 1) :
                    this.parent.dataSourceSettings.columns.length === 0 ? 0 : (this.parent.engineModule.headerContent.length - 1);
            const lock = (vSort && vSort.headerText) ? cell.valueSort.levelName === vSort.headerText : cCnt === vSort.columnIndex;
            if (vSort !== undefined && lock && (rCnt === len || (rCnt + 1) === len && cell.level > -1 &&
                this.parent.engineModule.headerContent[(rCnt + 1)][cCnt]
                && this.parent.engineModule.headerContent[(rCnt + 1)][cCnt].level === -1)
                && this.parent.dataSourceSettings.valueAxis === 'column') {
                tCell.querySelector('div div').appendChild(createElement('span', {
                    className: (vSort.sortOrder === 'Descending' ?
                        'e-icon-descending e-icons e-descending e-sortfilterdiv e-value-sort-icon' :
                        'e-icon-ascending e-icons e-ascending e-sortfilterdiv e-value-sort-icon') + (cell.hasChild ? ' e-value-sort-align' : ''),
                    styles: column.headerTextAlign === 'Right' ? 'float : left' : ''
                }));
            }
            // return tCell;
        }
        return tCell;
    }
    onResizeStop(args) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const column = args.column.field === '0.formattedText' ? '0.formattedText' : args.column.customAttributes.cell.valueSort.levelName;
        this.parent.resizeInfo[column] = Number(args.column.width.toString().split('px')[0]);
        if (this.parent.enableVirtualization && args.column.field === '0.formattedText') {
            if (this.parent.dataSourceSettings.values.length > 1
                && !isNullOrUndefined(this.parent.grid.columns[this.parent.grid.columns.length - 1].columns)) {
                const gridColumns = this.parent.grid.columns[this.parent.grid.columns.length - 1].columns;
                gridColumns[gridColumns.length - 1].minWidth = this.parent.gridSettings.columnWidth;
            }
            else {
                this.parent.grid.columns[this.parent.grid.columns.length - 1].minWidth =
                    this.parent.gridSettings.columnWidth;
            }
            this.parent.layoutRefresh();
        }
        this.setGroupWidth(args);
        this.calculateGridHeight(true);
        this.parent.grid.hideScroll();
    }
    setGroupWidth(args) {
        if (this.parent.enableVirtualization && args.column.field === '0.formattedText') {
            if (this.parent.showGroupingBar && this.parent.groupingBarModule && this.parent.element.querySelector('.' + GROUPING_BAR_CLASS) && Number(args.column.width.toString().split('px')[0]) < 250) {
                args.cancel = true;
            }
            else {
                this.parent.element.querySelector('.e-frozenscrollbar').style.width = args.column.width.toString().split('px')[0] + 'px';
            }
        }
        if (this.parent.showGroupingBar && this.parent.groupingBarModule &&
            this.parent.element.querySelector('.' + GROUPING_BAR_CLASS)) {
            this.parent.groupingBarModule.refreshUI();
            if (this.parent.element.querySelector('.e-group-row').offsetWidth < 245 && !this.parent.firstColWidth) {
                args.cancel = true;
                const gridColumn = this.parent.grid.columns;
                if (gridColumn && gridColumn.length > 0) {
                    gridColumn[0].width = this.resColWidth;
                }
                this.parent.element.querySelector('.e-frozenheader').querySelector('col').style.width = (this.resColWidth + 'px');
                this.parent.element.querySelector('.e-frozencontent').querySelector('col').style.width = (this.resColWidth + 'px');
            }
            this.parent.element.querySelector('.e-group-rows').style.height = 'auto';
            this.parent.element.querySelector('.e-group-values').style.width =
                this.parent.element.querySelector('.e-group-row').offsetWidth + 'px';
            const firstRowHeight = this.parent.element.querySelector('.e-headercontent').offsetHeight;
            this.parent.element.querySelector('.e-group-rows').style.height = firstRowHeight + 'px';
        }
        if (args.cancel) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const column = args.column.field === '0.formattedText' ? '0.formattedText' : args.column.customAttributes.cell.valueSort.levelName;
            this.parent.resizeInfo[column] = Number(args.column.width.toString().split('px')[0]);
            if (this.parent.enableVirtualization) {
                this.parent.layoutRefresh();
            }
        }
        if (this.parent.enableVirtualization) {
            this.parent.resizedValue = (args.cancel || args.column.field !== '0.formattedText') ? this.parent.resizedValue : Number(args.column.width.toString().split('px')[0]);
        }
        this.parent.trigger(args.e.type === 'touchend' || args.e.type === 'mouseup' ? resizeStop : resizing, args);
    }
    /** @hidden */
    selected() {
        clearTimeout(this.timeOutObj);
        this.timeOutObj = setTimeout(this.onSelect.bind(this), 300);
    }
    onSelect() {
        const pivotArgs = { selectedCellsInfo: [], pivotValues: this.parent.pivotValues, currentCell: null };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const selectedElements = this.parent.element.querySelectorAll('.' + CELL_SELECTED_BGCOLOR + ',.' + SELECTED_BGCOLOR);
        for (const element of selectedElements) {
            const colIndex = Number(element.getAttribute('data-colindex'));
            const rowIndex = Number(element.getAttribute('index'));
            const cell = this.engine.pivotValues[rowIndex][colIndex];
            if (cell) {
                if (cell.axis === 'value') {
                    pivotArgs.selectedCellsInfo.push({
                        currentCell: cell,
                        value: cell.value,
                        columnHeaders: cell.columnHeaders,
                        rowHeaders: cell.rowHeaders,
                        measure: cell.actualText.toString()
                    });
                }
                else if (cell.axis === 'column') {
                    pivotArgs.selectedCellsInfo.push({
                        currentCell: cell,
                        value: cell.formattedText,
                        columnHeaders: cell.valueSort.levelName,
                        rowHeaders: '',
                        measure: ''
                    });
                }
                else {
                    pivotArgs.selectedCellsInfo.push({
                        currentCell: cell,
                        value: cell.formattedText,
                        columnHeaders: '',
                        rowHeaders: cell.valueSort.levelName,
                        measure: ''
                    });
                }
            }
        }
        this.parent.trigger(cellSelected, pivotArgs);
    }
    rowCellBoundEvent(args) {
        let tCell = args.cell;
        if (tCell && (this.parent.notEmpty) && this.engine.headerContent) {
            const customClass = this.parent.hyperlinkSettings.cssClass;
            let cell = args.data[0];
            const isRowFieldsAvail = cell.valueSort && cell.valueSort.levelName === (this.parent.dataSourceSettings.rows.length === 0 && this.parent.dataSourceSettings.valueAxis === 'row' &&
                this.parent.localeObj.getConstant('grandTotal') + (this.parent.dataSourceSettings.valueSortSettings.headerDelimiter) + (cell.formattedText));
            tCell.setAttribute('index', cell.rowIndex ? cell.rowIndex.toString() : '0');
            if (tCell.getAttribute('data-colindex') === '0') {
                if (this.parent.dataType === 'pivot') {
                    const isValueCell = cell.type && cell.type === 'value';
                    tCell.innerText = '';
                    const levelName = cell.valueSort ? cell.valueSort.levelName.toString() : '';
                    const memberPos = cell.actualText ?
                        cell.actualText.toString().split(this.parent.dataSourceSettings.valueSortSettings.headerDelimiter).length : 0;
                    const levelPosition = levelName.split(this.parent.dataSourceSettings.valueSortSettings.headerDelimiter).length -
                        (memberPos ? memberPos - 1 : memberPos);
                    let level = levelPosition ? (levelPosition - 1) : 0;
                    level = cell.isSum ? level - 1 : level;
                    do {
                        if (level > 0) {
                            tCell.appendChild(createElement('span', {
                                className: level === 0 ? '' : NEXTSPAN
                            }));
                        }
                        level--;
                    } while (level > -1);
                    level = levelPosition ? (levelPosition - 1) : 0;
                    this.lastSpan = levelPosition ? this.lastSpan : 0;
                    if (!cell.hasChild && (!isValueCell ? level : 0) > 0) {
                        tCell.appendChild(createElement('span', {
                            className: LASTSPAN
                        }));
                    }
                    let fieldName;
                    if ((this.parent.dataSourceSettings.rows.length > 0 &&
                        (cell.valueSort ? Object.keys(cell.valueSort).length > 0 : true))) {
                        if (isValueCell) {
                            for (const field of this.parent.dataSourceSettings.values) {
                                const name = field.caption ? field.caption : field.name;
                                if (levelName.indexOf(name) > -1) {
                                    fieldName = field.name;
                                    break;
                                }
                            }
                        }
                        else {
                            fieldName = cell.level > -1 && this.parent.dataSourceSettings.rows[cell.level] ?
                                this.parent.dataSourceSettings.rows[cell.level].name : '';
                        }
                        tCell.setAttribute('fieldname', fieldName);
                    }
                }
                else {
                    tCell = this.onOlapRowCellBoundEvent(tCell, cell);
                }
                let localizedText = cell.formattedText;
                if (cell.type) {
                    if (cell.type === 'grand sum') {
                        this.rowGrandPos = cell.rowIndex;
                        tCell.classList.add('e-gtot');
                        const values = this.parent.dataSourceSettings.values;
                        localizedText = isNullOrUndefined(cell.valueSort.axis) ? (this.parent.dataSourceSettings.rows.length === 0 && values.length === 1 && this.parent.dataSourceSettings.valueAxis === 'row') ?
                            this.parent.localeObj.getConstant('total') + ' ' + this.parent.localeObj.getConstant(values[values.length - 1].type) + ' ' +
                                this.parent.localeObj.getConstant('of') + ' ' + (!isNullOrUndefined(values[values.length - 1].caption) ? values[values.length - 1].caption : values[values.length - 1].name) :
                            this.parent.localeObj.getConstant('grandTotal') : cell.formattedText;
                    }
                    else if (cell.valueSort.levelName === (this.parent.localeObj.getConstant('grandTotal') +
                        (this.parent.dataSourceSettings.valueSortSettings.headerDelimiter) + (cell.formattedText))) {
                        tCell.classList.add('e-gtot');
                        localizedText = isRowFieldsAvail ? this.parent.localeObj.getConstant('total') + ' ' + this.parent.localeObj.getConstant(this.parent.engineModule.fieldList[cell.actualText].aggregateType) + ' '
                            + this.parent.localeObj.getConstant('of') + ' ' + cell.formattedText : localizedText;
                    }
                    else if (cell.type === 'sum' && cell.memberType !== 3) {
                        localizedText = cell.formattedText.split('Total')[0] + this.parent.localeObj.getConstant('total');
                    }
                    else {
                        tCell.classList.add('e-stot');
                    }
                }
                tCell.classList.add(ROWSHEADER);
                if (cell.hasChild === true && !cell.isNamedSet) {
                    tCell.appendChild(createElement('div', {
                        className: (cell.isDrilled === true ? COLLAPSE : EXPAND) + ' ' + ICON,
                        attrs: {
                            'title': cell.isDrilled === true ? this.parent.localeObj.getConstant('collapse') :
                                this.parent.localeObj.getConstant('expand')
                        }
                    }));
                }
                tCell.appendChild(createElement('span', {
                    className: CELLVALUE,
                    innerHTML: (this.parent.isRowCellHyperlink || cell.enableHyperlink ? '<a  data-url="' + localizedText + '" class="e-hyperlinkcell ' + customClass + '">' + localizedText + '</a>' : localizedText)
                }));
                const vSort = this.parent.pivotView.dataSourceSettings.valueSortSettings;
                if (this.parent.enableValueSorting) {
                    if (vSort && vSort.headerText && this.parent.dataSourceSettings.valueAxis === 'row' &&
                        this.parent.pivotValues[Number(tCell.getAttribute('index'))][0] &&
                        this.parent.pivotValues[Number(tCell.getAttribute('index'))][0].valueSort.levelName) {
                        if (this.parent.pivotValues[Number(tCell.getAttribute('index'))][0].valueSort.levelName
                            === vSort.headerText) {
                            tCell.appendChild(createElement('span', {
                                className: (vSort.sortOrder === 'Descending' ?
                                    'e-icon-descending e-icons e-descending e-sortfilterdiv e-value-sort-icon' :
                                    'e-icon-ascending e-icons e-ascending e-sortfilterdiv e-value-sort-icon') + (cell.hasChild ? ' e-value-sort-align' : ''),
                                styles: tCell.style.textAlign === 'right' ? 'float: left' : ''
                            }));
                        }
                    }
                }
            }
            else {
                const innerText = tCell.innerText;
                tCell.innerText = '';
                tCell.classList.add(VALUESCONTENT);
                cell = args.data[Number(tCell.getAttribute('data-colindex'))];
                cell = isNullOrUndefined(cell) ? args.column.customAttributes.cell : cell;
                cell.isGrandSum = isRowFieldsAvail ? true : cell.isGrandSum;
                if (cell.isSum) {
                    tCell.classList.add(SUMMARY);
                }
                const isGrandSum = (isNullOrUndefined(cell.isGrandSum) && (!isNullOrUndefined(this.parent.olapEngineModule) && this.parent.olapEngineModule.olapValueAxis === 'column') && this.parent.dataType === 'olap' &&
                    ((this.colGrandPos - this.parent.dataSourceSettings.values.length) < Number(tCell.getAttribute('data-colindex'))));
                if (cell.isGrandSum || (isGrandSum || this.colGrandPos === Number(tCell.getAttribute('data-colindex'))) || this.rowGrandPos === Number(tCell.getAttribute('index'))) {
                    tCell.classList.add('e-gtot');
                }
                else if (this.parent.dataType === 'olap' ? cell.isSum : this.validateColumnTotalcell(cell.colIndex)) {
                    tCell.classList.add('e-colstot');
                }
                if (cell.cssClass) {
                    tCell.classList.add(cell.cssClass);
                }
                tCell.appendChild(createElement('span', {
                    className: CELLVALUE,
                    innerHTML: ((tCell.className.indexOf('e-summary') !== -1 && this.parent.isSummaryCellHyperlink) ||
                        (tCell.className.indexOf('e-summary') === -1 && this.parent.isValueCellHyperlink) || cell.enableHyperlink ?
                        '<a data-url="' + innerText + '" class="e-hyperlinkcell ' + customClass + '">' + innerText + '</a>' : innerText)
                }));
                if (this.parent.gridSettings.allowReordering && !this.parent.showGroupingBar) {
                    tCell.setAttribute('data-colindex', args.column.customAttributes.cell.colIndex.toString());
                }
            }
            if (this.parent.cellTemplate) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const element = this.parent.getCellTemplate()({ targetCell: tCell, cellInfo: cell }, this.parent, 'cellTemplate', this.parent.element.id + '_cellTemplate', null, null, tCell);
                if (element && element !== '' && element.length > 0) {
                    if (this.parent.enableHtmlSanitizer) {
                        if (this.parent.isVue || this.parent.isVue3) {
                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                            append(SanitizeHtmlHelper.sanitize(element), tCell);
                        }
                        else {
                            this.parent.appendHtml(tCell, SanitizeHtmlHelper.sanitize(element[0].outerHTML));
                        }
                    }
                    else {
                        if (this.parent.isVue || this.parent.isVue3) {
                            append(element, tCell);
                        }
                        else {
                            this.parent.appendHtml(tCell, element[0].outerHTML);
                        }
                    }
                }
            }
            this.unWireEvents(tCell);
            this.wireEvents(tCell);
        }
        args.pivotview = this.parent;
        this.parent.trigger(queryCellInfo, args);
    }
    onOlapRowCellBoundEvent(tCell, cell) {
        tCell.innerText = '';
        const rowMeasurePos = this.engine.rowMeasurePos;
        if (this.parent.enableVirtualization) {
            if (cell.ordinal > -1 && this.parent.olapEngineModule.tupRowInfo.length > 0) {
                const tupInfo = this.parent.olapEngineModule.tupRowInfo[cell.ordinal];
                const memberPosition = tupInfo.uNameCollection.indexOf(cell.actualText.toString());
                const cropUName = tupInfo.uNameCollection.substring(0, memberPosition) +
                    (cell.memberType === 3 ? '' : cell.actualText.toString());
                const fieldSep = cropUName.split('::[').map((item) => {
                    return item[0] === '[' ? item : ('[' + item);
                });
                if (cell.memberType === 3 && rowMeasurePos) {
                    fieldSep.push(cell.actualText.toString());
                }
                let nxtIndextCount = -1;
                let lastIndextCount = 0;
                let prevHasChild = false;
                for (let fPos = 0; fPos < fieldSep.length; fPos++) {
                    const fieldMembers = fieldSep[fPos];
                    const membersCount = fieldMembers.split('~~').length;
                    nxtIndextCount += membersCount;
                    const hasChild = tupInfo.typeCollection[fPos] !== '2' ? (this.engine.fieldList[tupInfo.members[fPos].getAttribute('Hierarchy')] && this.engine.fieldList[tupInfo.members[fPos].getAttribute('Hierarchy')].isHierarchy && fPos < this.parent.dataSourceSettings.rows.length - 1 && !this.parent.dataSourceSettings.rows[fPos + 1].isNamedSet && this.parent.dataSourceSettings.rows[fPos + 1].name.indexOf('[Measures]') < 0 && this.engine.fieldList[this.parent.dataSourceSettings.rows[fPos + 1].name] && this.engine.fieldList[this.parent.dataSourceSettings.rows[fPos + 1].name].hasAllMember) ? true : Number(tupInfo.members[fPos].querySelector('CHILDREN_CARDINALITY').textContent) > 0 : false;
                    lastIndextCount += (fPos > 0 && prevHasChild && !hasChild) ? 1 : 0;
                    prevHasChild = hasChild;
                }
                let indent = 0;
                for (let iPos = 0; iPos < nxtIndextCount; iPos++) {
                    tCell.appendChild(createElement('span', {
                        className: NEXTSPAN
                    }));
                    indent++;
                }
                for (let iPos = 0; iPos < lastIndextCount && nxtIndextCount > 0; iPos++) {
                    tCell.appendChild(createElement('span', {
                        className: LASTSPAN
                    }));
                }
                this.indentCollection[cell.rowIndex] = indent;
                this.maxIndent = this.maxIndent > indent ? this.maxIndent : indent;
            }
        }
        else {
            const hierarchyName = cell.hierarchy;
            const levelName = cell.memberType === 3 ? (this.measurePos + '.' + cell.levelUniqueName) : cell.levelUniqueName;
            const hasChild = cell.hasChild;
            let isSubTotalCell = false;
            if (cell.isSum && cell.memberType === 3) {
                const currPos = this.lvlCollection[cell.parentUniqueName].position;
                for (let i = currPos + 1; i < this.position; i++) {
                    delete this.lvlCollection[this.lvlPosCollection[i]];
                    delete this.lvlPosCollection[i];
                }
                this.position = this.position > (currPos + 1) ? (currPos + 1) : this.position;
                isSubTotalCell = true;
                this.measurePos = this.lvlCollection[cell.parentUniqueName].position;
            }
            if (!this.lvlCollection[levelName] && levelName) {
                this.lvlPosCollection[this.position] = levelName;
                this.lvlCollection[levelName] = { position: this.position, hasChild: hasChild };
                this.position++;
            }
            else if (levelName) {
                const currPos = this.lvlCollection[levelName].position;
                for (let pos = currPos + 1; pos < this.position; pos++) {
                    delete this.lvlCollection[this.lvlPosCollection[pos]];
                    delete this.lvlPosCollection[pos];
                }
                this.position = this.position > (currPos + 1) ? (currPos + 1) : this.position;
            }
            if (!this.hierarchyCollection[hierarchyName] && hierarchyName) {
                this.hierarchyPosCollection[this.hierarchyCount] = hierarchyName;
                this.hierarchyCollection[hierarchyName] = {
                    lvlPosition: this.position - 1,
                    hierarchyPOs: this.hierarchyCount
                };
                this.hierarchyCount++;
            }
            else if (hierarchyName) {
                const currPos = this.hierarchyCollection[hierarchyName].hierarchyPOs;
                for (let pos = currPos + 1; pos < this.hierarchyCount; pos++) {
                    delete this.hierarchyCollection[this.hierarchyPosCollection[pos]];
                    delete this.hierarchyPosCollection[pos];
                }
                this.hierarchyCount = this.hierarchyCount > (currPos + 1) ? (currPos + 1) : this.hierarchyCount;
            }
            if (cell.memberType !== 3 && levelName && this.lvlCollection[levelName]) {
                const currHierarchyPos = this.hierarchyCollection[hierarchyName] ?
                    this.hierarchyCollection[hierarchyName].hierarchyPOs : -1;
                this.measurePos = rowMeasurePos <= currHierarchyPos && this.hierarchyPosCollection[rowMeasurePos + 1] ?
                    this.measurePos : this.lvlCollection[levelName].position;
            }
            let currPos = this.lvlCollection[levelName] ? this.lvlCollection[levelName].position : -1;
            currPos = isSubTotalCell ? currPos - 1 : currPos;
            let lvlPos = 0;
            let indent = 0;
            while (lvlPos <= currPos && currPos > 0 && cell.level > -1) {
                const hasChild = this.lvlCollection[this.lvlPosCollection[lvlPos]].hasChild;
                const prevHasChild = lvlPos > 0 ? this.lvlCollection[this.lvlPosCollection[lvlPos - 1]].hasChild : false;
                if (prevHasChild && !hasChild) {
                    tCell.appendChild(createElement('span', {
                        className: LASTSPAN
                    }));
                }
                if (lvlPos !== currPos) {
                    tCell.appendChild(createElement('span', {
                        className: NEXTSPAN
                    }));
                    indent++;
                }
                lvlPos++;
            }
            if (this.parent.dataSourceSettings.grandTotalsPosition === 'Top' && (!isNullOrUndefined(this.parent.olapEngineModule) && this.parent.olapEngineModule.olapValueAxis === 'row') && this.parent.dataType === 'olap' &&
                (cell.valueSort.levelName.toString()).indexOf(this.parent.localeObj.getConstant('grandTotal') + this.parent.dataSourceSettings.valueSortSettings.headerDelimiter) === 0) {
                tCell.appendChild(createElement('span', {
                    className: NEXTSPAN
                }));
            }
            if (cell.memberType === 3 && cell.level === -1 && Object.keys(this.lvlCollection).length > 1) {
                tCell.appendChild(createElement('span', {
                    className: NEXTSPAN
                }));
                indent++;
            }
            this.indentCollection[cell.rowIndex] = indent;
            this.maxIndent = this.maxIndent > indent ? this.maxIndent : indent;
        }
        tCell.setAttribute('fieldname', cell.hierarchy);
        const grandTotal = (this.parent.olapEngineModule.tupRowInfo[cell.ordinal] ?
            (this.parent.olapEngineModule.tupRowInfo[cell.ordinal].measurePosition === 0 ?
                this.parent.olapEngineModule.tupRowInfo[cell.ordinal].allStartPos === 1 :
                this.parent.olapEngineModule.tupRowInfo[cell.ordinal].allStartPos === 0) : false);
        if (grandTotal) {
            tCell.classList.add('e-gtot');
        }
        return tCell;
    }
    columnCellBoundEvent(args) {
        if (args.cell.column && args.cell.column.customAttributes) {
            const cell = args.cell.column.customAttributes.cell;
            let tCell = args.node;
            if (cell) {
                const customClass = this.parent.hyperlinkSettings.cssClass;
                let isValueCell = false;
                for (const field of this.parent.dataSourceSettings.values) {
                    if (field.name === cell.actualText) {
                        isValueCell = true;
                        tCell.setAttribute('fieldname', field.name);
                    }
                }
                if ((cell.level === -1 && !cell.rowSpan) || cell.rowSpan === -1) {
                    args.node.style.display = 'none';
                }
                else if (cell.rowSpan > 1) {
                    args.node.setAttribute('rowspan', cell.rowSpan.toString());
                    args.node.setAttribute('aria-rowspan', cell.rowSpan.toString());
                    if ((cell.rowIndex + cell.rowSpan) === this.engine.headerContent.length) {
                        args.node.style.borderBottomWidth = '0px';
                    }
                }
                args.node.setAttribute('data-colindex', cell.colIndex.toString());
                args.node.setAttribute('index', cell.rowIndex.toString());
                let fieldName;
                if (this.parent.dataType === 'pivot') {
                    if (!isValueCell && !(this.parent.dataSourceSettings.values && this.parent.dataSourceSettings.valueAxis === 'column' &&
                        this.parent.dataSourceSettings.values.length > 1 &&
                        (isValueCell && cell.rowIndex === this.engine.headerContent.length - 1)) && this.parent.dataSourceSettings.columns
                        && this.parent.dataSourceSettings.columns.length > 0) {
                        fieldName = cell.level > -1 && this.parent.dataSourceSettings.columns[cell.level] ?
                            this.parent.dataSourceSettings.columns[cell.level].name : '';
                        tCell.setAttribute('fieldname', fieldName);
                    }
                    if (this.validateColumnTotalcell(cell.colIndex)) {
                        tCell.classList.add('e-colstot');
                    }
                }
                else {
                    tCell = this.onOlapColumnCellBoundEvent(tCell, cell);
                }
                const isColumnFieldsAvail = (this.parent.dataSourceSettings.columns.length === 0 && this.parent.dataSourceSettings.valueAxis === 'column' && cell.valueSort &&
                    cell.valueSort.levelName === (this.parent.localeObj.getConstant('grandTotal') + (this.parent.dataSourceSettings.valueSortSettings.headerDelimiter) + (cell.formattedText)));
                if (cell.type || isColumnFieldsAvail) {
                    tCell.classList.add(cell.type === 'grand sum' ? 'e-gtot' : 'e-stot');
                    if (cell.type === 'grand sum') {
                        this.colGrandPos = cell.colIndex;
                    }
                    else if (cell.type) {
                        tCell.classList.add('e-colstot');
                    }
                    let localizedText = cell.type === 'grand sum' ? (isNullOrUndefined(cell.valueSort.axis) || this.parent.dataType === 'olap' ? this.parent.localeObj.getConstant('grandTotal') :
                        cell.formattedText) : cell.formattedText.split('Total')[0] + this.parent.localeObj.getConstant('total');
                    localizedText = isColumnFieldsAvail && this.parent.engineModule.fieldList ? this.parent.localeObj.getConstant('total') + ' ' + this.parent.localeObj.getConstant(this.parent.engineModule.fieldList[cell.actualText].aggregateType)
                        + ' ' + this.parent.localeObj.getConstant('of') + ' ' + cell.formattedText : localizedText;
                    if (tCell.querySelector('.e-headertext') !== null) {
                        tCell.querySelector('.e-headertext').innerText = localizedText;
                    }
                    else {
                        tCell.querySelector('.e-stackedheadercelldiv').innerText = localizedText;
                    }
                }
                tCell.classList.add(COLUMNSHEADER);
                if (this.parent.isColumnCellHyperlink || cell.enableHyperlink) {
                    if (tCell.querySelector('.e-stackedheadercelldiv')) {
                        const innerText = tCell.querySelector('.e-stackedheadercelldiv').innerText;
                        tCell.querySelector('.e-stackedheadercelldiv').innerHTML =
                            '<a data-url="' + innerText + '" class="e-hyperlinkcell ' + customClass + '">' + innerText + '</a>';
                    }
                    else if (tCell.querySelector('.e-headertext')) {
                        const innerText = tCell.querySelector('.e-headertext').innerText;
                        tCell.querySelector('.e-headertext').innerHTML =
                            '<a data-url="' + innerText + '" class="e-hyperlinkcell ' + customClass + '">' + innerText + '</a>';
                    }
                }
                if (cell.hasChild === true && !cell.isNamedSet) {
                    const hdrdiv = tCell.querySelector('.e-headercelldiv');
                    if (hdrdiv) {
                        hdrdiv.style.height = 'auto';
                        hdrdiv.style.lineHeight = 'normal';
                    }
                    const div = createElement('div', {
                        className: (cell.isDrilled === true ? COLLAPSE : EXPAND) + ' ' + ICON,
                        attrs: {
                            'title': cell.isDrilled === true ? this.parent.localeObj.getConstant('collapse') :
                                this.parent.localeObj.getConstant('expand')
                        }
                    });
                    if (window.navigator.userAgent.indexOf('Edge') > -1 || window.navigator.userAgent.indexOf('Trident') > -1) {
                        tCell.children[0].style.display = 'table';
                    }
                    else {
                        tCell.children[0].style.display = 'block';
                    }
                    this.updateWrapper(tCell, div);
                }
                else {
                    this.updateWrapper(tCell);
                }
                tCell = this.appendValueSortIcon(cell, tCell, cell.rowIndex, cell.colIndex, args.cell.column);
                if (this.parent.cellTemplate) {
                    this.parent.gridHeaderCellInfo.push({ targetCell: tCell });
                }
                const len = this.parent.dataSourceSettings.values.length;
                for (let vCnt = 0; vCnt < len; vCnt++) {
                    if (this.parent.dataSourceSettings.values[vCnt].name === cell.actualText) {
                        if (this.parent.dataType === 'olap') {
                            const grandTotal = (this.parent.olapEngineModule.tupColumnInfo[cell.ordinal] ?
                                (this.parent.olapEngineModule.tupColumnInfo[cell.ordinal].measurePosition === 0 ?
                                    this.parent.olapEngineModule.tupColumnInfo[cell.ordinal].allStartPos === 1 :
                                    this.parent.olapEngineModule.tupColumnInfo[cell.ordinal].allStartPos === 0) : false);
                            if (grandTotal) {
                                tCell.classList.add('e-gtot');
                            }
                        }
                        if (cell.valueSort.levelName === (this.parent.localeObj.getConstant('grandTotal') + (this.parent.dataSourceSettings.valueSortSettings.headerDelimiter) + (cell.formattedText))
                            || cell.valueSort.levelName === ('Grand Total' + (this.parent.dataSourceSettings.valueSortSettings.headerDelimiter) + (cell.formattedText))) {
                            tCell.classList.add('e-gtot');
                        }
                        else {
                            tCell.classList.add(VALUESHEADER);
                        }
                    }
                }
                this.unWireEvents(tCell);
                this.wireEvents(tCell);
            }
        }
        this.parent.trigger(headerCellInfo, args);
    }
    updateWrapper(tCell, div) {
        if (tCell.querySelectorAll('.e-headercelldiv').length > 0 || tCell.querySelectorAll('.e-stackedheadercelldiv').length > 0) {
            const outerDiv = createElement('div', {
                className: PIVOT_CELL_CONTAINER
            });
            const innerDiv = createElement('div', {
                className: (div ? 'e-stackedheadertext' : 'e-headertext') + ' ' + CELLVALUE,
                innerHTML: tCell.querySelectorAll('.e-headercelldiv').length > 0 ? tCell.querySelector('.e-headercelldiv').innerHTML : tCell.querySelector('.e-stackedheadercelldiv').innerHTML
            });
            if (div) {
                outerDiv.append(div);
            }
            outerDiv.append(innerDiv);
            tCell.children[0].innerHTML = '';
            tCell.children[0].append(outerDiv);
        }
        return tCell;
    }
    onOlapColumnCellBoundEvent(tCell, cell) {
        tCell.setAttribute('fieldname', cell.memberType === 3 ? cell.actualText.toString() : cell.hierarchy);
        const prevCell = this.engine.headerContent[cell.rowIndex] ?
            this.engine.headerContent[cell.rowIndex][cell.colIndex - 1] : undefined;
        if (prevCell && prevCell.actualText === cell.actualText && prevCell.type === cell.type &&
            (prevCell.colSpan > 1)) {
            tCell.style.display = 'none';
        }
        else {
            tCell.setAttribute('colspan', cell.colSpan.toString());
            tCell.setAttribute('aria-colspan', cell.colSpan.toString());
        }
        if (cell.rowIndex === (this.engine.headerContent.length - 1) && cell.memberType === 2) {
            tCell.style.display = this.isSpannedCell(this.engine.headerContent.length, cell) ? 'none' : tCell.style.display;
        }
        return tCell;
    }
    isSpannedCell(colLength, currCell) {
        let prevCell = this.engine.headerContent[currCell.rowIndex - 1] ?
            this.engine.headerContent[currCell.rowIndex - 1][currCell.colIndex] : undefined;
        let parentCellSpan;
        let parentCellPos;
        while (prevCell && ((prevCell.memberType === currCell.memberType) || (prevCell.type && currCell.type))) {
            if (prevCell.rowSpan > 0) {
                parentCellSpan = prevCell.rowSpan;
                parentCellPos = prevCell.rowIndex;
            }
            prevCell = this.engine.headerContent[prevCell.rowIndex - 1] ?
                this.engine.headerContent[prevCell.rowIndex - 1][currCell.colIndex] : undefined;
        }
        return (parentCellPos + parentCellSpan) >= colLength;
    }
    onHyperCellClick(e) {
        let cell = e.target.parentElement.parentElement;
        cell = (cell.className.indexOf('e-headercelldiv') > -1 ? cell.parentElement : cell);
        const args = {
            currentCell: cell,
            data: this.engine.pivotValues[Number(cell.getAttribute('index'))][Number(cell.getAttribute('data-colindex'))],
            cancel: true,
            nativeEvent: e
        };
        this.parent.trigger(hyperlinkCellClick, args, (observedArgs) => {
            if (!observedArgs.cancel) {
                args.currentCell = getElement(args.currentCell);
                const url = args.currentCell.getAttribute('data-url') ? (args.currentCell).getAttribute('data-url') :
                    args.currentCell.querySelector('a').getAttribute('data-url');
                window.open(url);
            }
        });
    }
    getRowStartPos() {
        const pivotValues = this.parent.pivotValues;
        let rowPos;
        for (let rCnt = 0; rCnt < (pivotValues ? pivotValues.length : 0); rCnt++) {
            if (pivotValues[rCnt] && pivotValues[rCnt][0] && pivotValues[rCnt][0].axis === 'row') {
                rowPos = rCnt;
                break;
            }
        }
        return rowPos;
    }
    frameDataSource(type) {
        let dataContent = [];
        if (((this.parent.dataType === 'pivot' && this.parent.dataSourceSettings.dataSource && this.parent.engineModule.data.length > 0) || (this.parent.dataType === 'olap' && this.parent.dataSourceSettings.url !== '') ||
            (this.parent.dataSourceSettings.mode === 'Server' && this.parent.dataSourceSettings.url !== '' && this.engine.pivotValues.length > 0)) && this.parent.dataSourceSettings.values.length > 0 && !this.engine.isEmptyData) {
            if ((this.parent.enableValueSorting) || !this.engine.isEngineUpdated) {
                let rowCnt = 0;
                const pivotValues = this.parent.pivotValues;
                const start = type === 'value' ? this.rowStartPos : 0;
                const end = type === 'value' ? (pivotValues ? pivotValues.length : 0) : this.rowStartPos;
                for (let rCnt = start; rCnt < end; rCnt++) {
                    if (pivotValues[rCnt]) {
                        rowCnt = type === 'header' ? rCnt : rowCnt;
                        dataContent[rowCnt] = {};
                        for (let cCnt = 0; cCnt < pivotValues[rCnt].length; cCnt++) {
                            if (pivotValues[rCnt][cCnt]) {
                                dataContent[rowCnt][cCnt] = pivotValues[rCnt][cCnt];
                            }
                        }
                        rowCnt++;
                    }
                }
            }
            else {
                dataContent = type === 'value' ? this.engine.valueContent : this.engine.headerContent;
            }
        }
        else {
            dataContent = this.frameEmptyData();
        }
        return dataContent;
    }
    /** @hidden */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    frameEmptyData() {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const dataContent = [{
                0: { formattedText: this.parent.localeObj.getConstant('grandTotal') },
                1: { formattedText: this.parent.localeObj.getConstant('emptyData') }
            }];
        return dataContent;
    }
    /** @hidden */
    calculateColWidth(colCount) {
        if (!isNullOrUndefined(this.parent.resizedValue)) {
            this.parent.resizedValue = (this.parent.showGroupingBar && this.parent.resizedValue < 250) ? 250 : this.parent.resizedValue;
        }
        this.resColWidth = !isNullOrUndefined(this.parent.resizedValue) ? this.parent.resizedValue : this.resColWidth;
        const offsetWidth = this.parent.element.offsetWidth ? this.parent.element.offsetWidth :
            this.parent.element.getBoundingClientRect().width;
        let parWidth = isNaN(this.parent.width) ? (this.parent.width.toString().indexOf('%') > -1 ?
            ((parseFloat(this.parent.width.toString()) / 100) * offsetWidth) : offsetWidth) :
            Number(this.parent.width);
        parWidth = parWidth - (this.gridSettings.columnWidth > this.resColWidth ? this.gridSettings.columnWidth : this.resColWidth) - 2;
        colCount = colCount - 1;
        this.isOverflows = !((colCount * this.gridSettings.columnWidth) < parWidth);
        const colWidth = (colCount * this.gridSettings.columnWidth) < parWidth ? (parWidth / colCount) : this.gridSettings.columnWidth;
        return (!this.isOverflows && !this.gridSettings.allowAutoResizing) ? this.gridSettings.columnWidth : Math.floor(colWidth);
    }
    /** @hidden */
    resizeColWidth(colCount) {
        if (!isNullOrUndefined(this.parent.resizedValue)) {
            this.parent.resizedValue = (this.parent.showGroupingBar && this.parent.resizedValue < 250) ? 250 : this.parent.resizedValue;
        }
        this.resColWidth = !isNullOrUndefined(this.parent.resizedValue) ? this.parent.resizedValue : this.resColWidth;
        let parWidth = isNaN(this.parent.width) ? (this.parent.width.toString().indexOf('%') > -1 ?
            ((parseFloat(this.parent.width.toString()) / 100) * this.parent.element.offsetWidth) : this.parent.element.offsetWidth) :
            Number(this.parent.width);
        colCount = colCount - 1;
        parWidth = parWidth - (this.gridSettings.columnWidth > this.resColWidth ? this.gridSettings.columnWidth : this.resColWidth) - 2;
        this.isOverflows = !((colCount * this.gridSettings.columnWidth) < parWidth);
        const colWidth = (colCount * this.gridSettings.columnWidth) < parWidth ? (parWidth / colCount) : this.gridSettings.columnWidth;
        return (!this.isOverflows && !this.gridSettings.allowAutoResizing) ? this.gridSettings.columnWidth : Math.floor(colWidth);
    }
    /** @hidden */
    calculateGridWidth() {
        let parWidth = this.parent.width;
        let eleWidth = this.parent.element.getBoundingClientRect().width ?
            this.parent.element.getBoundingClientRect().width : this.parent.element.offsetWidth;
        if (eleWidth === 0) {
            eleWidth = this.parent.element.parentElement.getBoundingClientRect().width ?
                this.parent.element.parentElement.getBoundingClientRect().width : this.parent.element.parentElement.offsetWidth;
        }
        if (this.gridSettings.width === 'auto') {
            if (this.parent.width === 'auto') {
                parWidth = eleWidth;
            }
            else if (this.parent.width.toString().indexOf('%') > -1) {
                parWidth = ((parseFloat(this.parent.width.toString()) / 100) * eleWidth);
            }
        }
        else {
            parWidth = this.gridSettings.width;
        }
        return (!this.gridSettings.allowAutoResizing && parWidth > this.parent.totColWidth) ? this.parent.totColWidth : parWidth;
    }
    /** @hidden */
    calculateGridHeight(elementCreated) {
        let gridHeight = this.parent.height;
        let parHeight = this.parent.getHeightAsNumber();
        if (isNaN(parHeight)) {
            parHeight = parHeight > this.parent.minHeight ? parHeight : this.parent.minHeight;
        }
        if ((this.parent.showToolbar && this.parent.currentView !== 'Chart') || (!this.parent.showToolbar && this.parent.displayOption.view !== 'Chart')) {
            if (this.gridSettings.height === 'auto' && parHeight && this.parent.element.querySelector('.' + GRID_HEADER)) {
                const rowColHeight = this.parent.element.querySelector('.' + GRID_HEADER).offsetHeight;
                const gBarHeight = rowColHeight + (this.parent.element.querySelector('.' + GRID_GROUPING_BAR_CLASS) ?
                    this.parent.element.querySelector('.' + GRID_GROUPING_BAR_CLASS).offsetHeight : 0);
                const toolBarHeight = this.parent.element.querySelector('.' + GRID_TOOLBAR) ? 42 : 0;
                const pagerHeight = this.parent.element.querySelector('.' + GRID_PAGER) ? this.parent.element.querySelector('.' + GRID_PAGER).offsetHeight : 0;
                gridHeight = parHeight - (gBarHeight + toolBarHeight + pagerHeight) - 1;
                gridHeight = gridHeight < 40 ? 40 : gridHeight;
                if (elementCreated) {
                    const tableHeight = this.parent.element.querySelector('.' + FROZENCONTENT_DIV + ' .' + TABLE).offsetHeight;
                    const contentHeight = this.parent.element.querySelector('.' + MOVABLECONTENT_DIV).offsetHeight;
                    const tableWidth = this.parent.element.querySelector('.' + MOVABLECONTENT_DIV + ' .' + TABLE).offsetWidth;
                    const contentWidth = this.parent.element.querySelector('.' + MOVABLECONTENT_DIV).offsetWidth;
                    const horizontalOverflow = contentWidth < tableWidth;
                    //let verticalOverflow: boolean = contentHeight < tableHeight;
                    const commonOverflow = horizontalOverflow && ((gridHeight - tableHeight) < 18) ? true : false;
                    if (gridHeight >= tableHeight && (horizontalOverflow ? gridHeight >= contentHeight : true) &&
                        !commonOverflow) {
                        this.parent.grid.height = 'auto';
                    }
                    else {
                        this.parent.grid.height = gridHeight;
                        this.parent.grid.dataBind();
                    }
                    this.parent.grid.widthService.refreshFrozenScrollbar();
                }
                else {
                    if (gridHeight > (this.engine.valueContent.length * this.gridSettings.rowHeight)) {
                        gridHeight = 'auto';
                    }
                }
            }
            else {
                gridHeight = this.gridSettings.height;
            }
        }
        return gridHeight < this.parent.gridSettings.rowHeight ? this.parent.gridSettings.rowHeight : gridHeight;
    }
    /**
     * It used to frame stacked headers.
     *
     * @returns {ColumnModel[]} - Returns grid columns.
     * @hidden
     */
    frameStackedHeaders() {
        const pivotColumns = this.parent.pivotColumns;
        const gridColumns = this.parent.grid['columnModel'];
        let autoFitApplied = false;
        const refreshColumn = this.parent.toolbarModule && this.parent.toolbarModule.isReportChange ? true : this.parent.actionObj ? ((this.parent.actionObj.actionName === 'Sort value' && this.parent.engineModule.valueAxis === 1) ||
            (this.parent.actionObj.actionName === 'Sort field' && this.parent.actionObj.fieldInfo.axis === 'columns') ||
            (this.parent.pivotFieldListModule && this.parent.pivotFieldListModule.actionObj.actionName === 'Sort field' && this.parent.pivotFieldListModule.actionObj.fieldInfo.axis === 'columns')) : false;
        const singleValueFormat = this.parent.dataSourceSettings.values.length === 1 &&
            !this.parent.dataSourceSettings.alwaysShowValueHeader ?
            this.formatList[this.parent.dataSourceSettings.values[0].name] : undefined;
        this.pivotColumns = [];
        if ((((this.parent.dataType === 'olap' && this.parent.dataSourceSettings.url !== '') ? true : (this.parent.dataSourceSettings.values.length > 0 && this.parent.dataSourceSettings.dataSource && this.parent.engineModule.data.length > 0)) ||
            (this.parent.dataSourceSettings.mode === 'Server' && this.parent.dataSourceSettings.url !== '' && this.engine.pivotValues.length > 0)) && !this.engine.isEmptyData) {
            let headerCnt = this.engine.headerContent.length;
            const headerSplit = [];
            const splitPos = [];
            const colWidth = this.calculateColWidth(this.engine.pivotValues ? this.engine.pivotValues[0].length : 0);
            do {
                const columnModel = [];
                let actualCnt = 0;
                headerCnt--;
                const colField = this.engine.headerContent[headerCnt];
                const colCount = colField ? Object.keys(colField).length : 0;
                if (colField) {
                    for (let cCnt = 0; cCnt < Object.keys(colField).length + (colField[0] ? 0 : 1); cCnt++) {
                        let colSpan = (colField[cCnt] && colField[cCnt].colSpan) ?
                            ((colField[cCnt].memberType !== 3 || headerCnt === 0) ?
                                colField[cCnt].colSpan : headerSplit[cCnt]) : 1;
                        colSpan = this.parent.dataType === 'olap' ? 1 : colSpan;
                        let formattedText = colField[cCnt] ? (colField[cCnt].type === 'grand sum' ?
                            (isNullOrUndefined(colField[cCnt].valueSort.axis) ? this.parent.localeObj.getConstant('grandTotal') :
                                colField[cCnt].formattedText) : (colField[cCnt].type === 'sum' ?
                            colField[cCnt].formattedText.split('Total')[0] + this.parent.localeObj.getConstant('total') :
                            colField[cCnt].formattedText)) : '';
                        formattedText = this.parent.enableHtmlSanitizer ? SanitizeHtmlHelper.sanitize(formattedText) : formattedText;
                        if (headerCnt === this.engine.headerContent.length - 1) {
                            colSpan = 1;
                            autoFitApplied = pivotColumns.length - 1 !== colCount ? false : (!refreshColumn && !this.parent.isEmptyGrid
                                && pivotColumns[actualCnt] && pivotColumns[actualCnt].autoFit);
                            columnModel[actualCnt] = {
                                field: (cCnt + '.formattedText'),
                                headerText: formattedText,
                                customAttributes: { 'cell': colField[cCnt] },
                                width: autoFitApplied ? gridColumns[actualCnt].width : colField[cCnt]
                                    // eslint-disable-next-line @typescript-eslint/no-explicit-any, max-len
                                    ? colField[cCnt].valueSort ? this.setSavedWidth(colField[cCnt].valueSort.levelName, colWidth) : this.resColWidth
                                    : this.resColWidth,
                                minWidth: autoFitApplied && actualCnt === colCount
                                    ? gridColumns[gridColumns.length - 1].minWidth : 30,
                                format: cCnt === 0 ? '' : (isNullOrUndefined(singleValueFormat) ? this.formatList[colField[cCnt].actualText] : singleValueFormat),
                                allowReordering: (this.parent.showGroupingBar ? false : this.parent.gridSettings.allowReordering),
                                allowResizing: this.parent.gridSettings.allowResizing,
                                visible: true,
                                textAlign: this.parent.enableRtl ? 'Left' : 'Right',
                                headerTextAlign: this.parent.enableRtl ? 'Right' : 'Left'
                            };
                        }
                        else if (headerSplit[cCnt]) {
                            colSpan = (colField[cCnt] && colField[cCnt].type === 'grand sum' &&
                                colField[cCnt].memberType === 2) ? 1 : colSpan;
                            let tmpSpan = colSpan;
                            let innerModel = [];
                            let innerPos = cCnt;
                            while (tmpSpan > 0) {
                                if (columnModel[actualCnt]) {
                                    if (!this.pivotColumns[splitPos[innerPos]]) {
                                        break;
                                    }
                                    innerModel.push(this.pivotColumns[splitPos[innerPos]]);
                                }
                                else {
                                    columnModel[actualCnt] = {
                                        headerText: formattedText,
                                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                        field: colField[cCnt] ? colField[cCnt].valueSort.levelName : '',
                                        customAttributes: { 'cell': colField[cCnt] },
                                        width: (autoFitApplied && actualCnt === 0 && !refreshColumn && !this.parent.isEmptyGrid
                                            && pivotColumns[0].autoFit) ? gridColumns[0].width : colField[cCnt] ?
                                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                            this.setSavedWidth(colField[cCnt].valueSort.levelName, colWidth)
                                            : this.resColWidth,
                                        minWidth: 30,
                                        allowReordering: (this.parent.showGroupingBar ? false : this.parent.gridSettings.allowReordering),
                                        allowResizing: this.parent.gridSettings.allowResizing,
                                        visible: true
                                    };
                                    innerModel = [this.pivotColumns[splitPos[innerPos]]];
                                }
                                this.isAutoFitEnabled = this.isAutoFitEnabled ? true : autoFitApplied;
                                tmpSpan = tmpSpan - headerSplit[innerPos];
                                innerPos = innerPos + headerSplit[innerPos];
                            }
                            columnModel[actualCnt].columns = innerModel;
                        }
                        if (columnModel[actualCnt]) {
                            columnModel[actualCnt].clipMode = this.gridSettings.clipMode;
                        }
                        headerSplit[cCnt] = colSpan;
                        splitPos[cCnt] = actualCnt;
                        actualCnt++;
                        cCnt = cCnt + colSpan - 1;
                    }
                }
                this.pivotColumns = columnModel.length > 0 ? columnModel : this.pivotColumns;
            } while (headerCnt > 0);
            this.pivotColumns[0] = {
                field: (0 + '.formattedText'),
                width: (autoFitApplied && !refreshColumn && !this.parent.isEmptyGrid && pivotColumns[0].autoFit)
                    ? gridColumns[0].width : this.resColWidth,
                minWidth: 30,
                headerText: '',
                allowReordering: false,
                allowResizing: this.parent.gridSettings.allowResizing,
                visible: true,
                clipMode: this.parent.gridSettings.clipMode
            };
        }
        else {
            this.pivotColumns = this.frameEmptyColumns();
        }
        if (this.parent.toolbarModule && this.parent.showToolbar) {
            this.parent.toolbarModule.isReportChange = false;
        }
        this.parent.triggerColumnRenderEvent(this.pivotColumns);
        autoFitApplied = this.parent.pivotColumns.length > 0 && this.parent.pivotColumns[this.parent.pivotColumns.length - 1].autoFit;
        if (this.pivotColumns.length > 1 && !autoFitApplied) {
            const lastColumn = this.pivotColumns[this.pivotColumns.length - 1];
            lastColumn.minWidth = lastColumn.width;
            lastColumn.width = 'auto';
            if (lastColumn.columns && lastColumn.columns.length > 0) {
                this.configLastColumnWidth(lastColumn.columns[lastColumn.columns.length - 1]);
            }
        }
        return this.pivotColumns;
    }
    configLastColumnWidth(column) {
        column.minWidth = column.width;
        column.width = 'auto';
        if (column.columns && column.columns.length > 0) {
            this.configLastColumnWidth(column.columns[column.columns.length - 1]);
        }
    }
    /** @hidden */
    setSavedWidth(column, width) {
        if (column === '0.formattedText' && !isNullOrUndefined(this.parent.resizedValue)) {
            width = this.parent.resizedValue;
        }
        else {
            width = this.parent.resizeInfo[column] ? this.parent.resizeInfo[column] : width;
        }
        return width;
    }
    /** @hidden */
    frameEmptyColumns() {
        const columns = [];
        const colWidth = this.calculateColWidth(2);
        columns.push({ field: '0.formattedText', headerText: '', minWidth: 30, width: this.resColWidth });
        columns.push({ field: '1.formattedText', headerText: this.parent.localeObj.getConstant('grandTotal'), minWidth: 30, width: colWidth });
        return columns;
    }
    /** @hidden */
    getFormatList() {
        const formatArray = {};
        for (let vCnt = 0; vCnt < this.parent.dataSourceSettings.values.length; vCnt++) {
            const field = this.parent.dataSourceSettings.values[vCnt];
            let format = 'N';
            if (this.parent.dataType === 'olap') {
                if (this.parent.olapEngineModule.fieldList[field.name] &&
                    !isNullOrUndefined(this.parent.olapEngineModule.fieldList[field.name].formatString)) {
                    const fString = this.parent.olapEngineModule.fieldList[field.name].formatString;
                    format = fString.indexOf('#') > -1 ? fString : (fString[0] + '2');
                }
            }
            else {
                if ((['PercentageOfDifferenceFrom', 'PercentageOfRowTotal', 'PercentageOfColumnTotal', 'PercentageOfGrandTotal', 'PercentageOfParentRowTotal', 'PercentageOfParentColumnTotal', 'PercentageOfParentTotal']).indexOf(field.type) > -1) {
                    format = 'P2';
                }
                else if (['PopulationStDev', 'SampleStDev', 'PopulationVar', 'SampleVar', 'Index'].indexOf(field.type) > -1) {
                    format = undefined;
                }
                if (this.parent.dataSourceSettings.formatSettings.length > 0) {
                    for (let fCnt = 0; fCnt < this.parent.dataSourceSettings.formatSettings.length; fCnt++) {
                        const formatSettings = this.parent.dataSourceSettings.formatSettings[fCnt];
                        if (field.name === formatSettings.name) {
                            format = formatSettings.format;
                            break;
                        }
                        else {
                            continue;
                        }
                    }
                }
            }
            formatArray[field.name] = format;
        }
        return formatArray;
    }
    getValidHeader(args, axis) {
        const values = this.parent.dataSourceSettings.values;
        if (axis === 'row') {
            const cellInfo = args;
            if (this.parent.dataSourceSettings.rows.length === 0 || this.parent.dataSourceSettings.columns.length === 0) {
                if (this.parent.dataSourceSettings.rows.length === 0 && this.parent.dataSourceSettings.valueAxis === 'row' && (this.parent.localeObj.getConstant('grandTotal') +
                    this.parent.dataSourceSettings.valueSortSettings.headerDelimiter + cellInfo.value)
                    === cellInfo.data[0].valueSort.levelName) {
                    return this.parent.localeObj.getConstant('total') + ' ' + this.parent.localeObj.getConstant(this.parent.engineModule.fieldList[cellInfo.value.toString()].aggregateType)
                        + ' ' + this.parent.localeObj.getConstant('of') + ' ' + cellInfo.value.toString();
                }
                else if (values.length === 1 && this.parent.dataSourceSettings.rows.length === 0) {
                    return this.parent.localeObj.getConstant('total') + ' ' + this.parent.localeObj.getConstant(values[values.length - 1].type)
                        + ' ' + this.parent.localeObj.getConstant('of') + ' ' + (!isNullOrUndefined(values[values.length - 1].caption) ? values[values.length - 1].caption : values[values.length - 1].name);
                }
            }
            return cellInfo.value;
        }
        else if (axis === 'column') {
            const cellInfo = args;
            if (this.parent.dataSourceSettings.rows.length === 0 || this.parent.dataSourceSettings.columns.length === 0) {
                if (!isNullOrUndefined(args.gridCell.column.customAttributes) && this.parent.dataSourceSettings.columns.length === 0 && this.parent.dataSourceSettings.valueAxis === 'column' && // eslint-disable-line @typescript-eslint/no-explicit-any
                    (this.parent.localeObj.getConstant('grandTotal') + this.parent.dataSourceSettings.valueSortSettings.headerDelimiter + cellInfo.gridCell.column.customAttributes.cell.formattedText) // eslint-disable-line @typescript-eslint/no-explicit-any
                        === cellInfo.gridCell.column.customAttributes.cell.valueSort.levelName) { // eslint-disable-line @typescript-eslint/no-explicit-any
                    return this.parent.localeObj.getConstant('total') + ' ' + this.parent.localeObj.getConstant(this.parent.engineModule.fieldList[cellInfo
                        .gridCell.column.customAttributes.cell.actualText].aggregateType) + ' ' + this.parent.localeObj.getConstant('of') + ' ' + cellInfo.gridCell.column.customAttributes.cell.formattedText; // eslint-disable-line @typescript-eslint/no-explicit-any
                }
            }
            return (cellInfo.cell).value; // eslint-disable-line @typescript-eslint/no-explicit-any
        }
    }
    excelColumnEvent(args) {
        if (this.parent.dataSourceSettings.columns.length === 0 && this.parent.dataSourceSettings.valueAxis === 'column') {
            (args.cell).value = this.getValidHeader(args, 'column'); // eslint-disable-line @typescript-eslint/no-explicit-any
        }
        if (args.gridCell !== undefined && args.gridCell.column.width === 'auto') { // eslint-disable-line @typescript-eslint/no-explicit-any
            this.parent.lastColumn = args.gridCell.column; // eslint-disable-line @typescript-eslint/no-explicit-any
            args.gridCell.column.width = args.gridCell.column.minWidth; // eslint-disable-line @typescript-eslint/no-explicit-any
        }
        args = this.exportHeaderEvent(args);
        this.parent.trigger(excelHeaderQueryCellInfo, args);
    }
    pdfColumnEvent(args) {
        if (this.parent.dataSourceSettings.columns.length === 0 && this.parent.dataSourceSettings.valueAxis === 'column') {
            (args.cell).value = this.getValidHeader(args, 'column'); // eslint-disable-line @typescript-eslint/no-explicit-any
        }
        if (args.gridCell !== undefined && args.gridCell.column.width === 'auto') { // eslint-disable-line @typescript-eslint/no-explicit-any
            this.parent.lastColumn = args.gridCell.column; // eslint-disable-line @typescript-eslint/no-explicit-any
            args.gridCell.column.width = args.gridCell.column.minWidth; // eslint-disable-line @typescript-eslint/no-explicit-any
        }
        this.parent.trigger(pdfHeaderQueryCellInfo, args);
    }
    excelRowEvent(args) {
        if (args.column.field === '0.formattedText') {
            const cell = args.data[0];
            const isValueCell = cell.type && cell.type === 'value';
            let level = 0;
            if (this.parent.dataType === 'olap') {
                level = this.indentCollection[cell.rowIndex];
            }
            else {
                const levelName = cell.valueSort ? cell.valueSort.levelName.toString() : '';
                const memberPos = cell.actualText ?
                    cell.actualText.toString().split(this.parent.dataSourceSettings.valueSortSettings.headerDelimiter).length : 0;
                const levelPosition = levelName.split(this.parent.dataSourceSettings.valueSortSettings.headerDelimiter).length -
                    (memberPos ? memberPos - 1 : memberPos);
                level = levelPosition ? (levelPosition - 1) : 0;
            }
            this.colPos = 0;
            args.style = { hAlign: 'Left', indent: level * 2 };
            this.lastSpan = isValueCell ? this.lastSpan : level;
        }
        else {
            this.colPos++;
            const pivotValue = args.data[args.column.customAttributes.cell ? args.column.customAttributes.cell.colIndex : this.colPos]; // eslint-disable-line @typescript-eslint/no-explicit-any
            if (isNullOrUndefined(pivotValue.value) || isNullOrUndefined(pivotValue.formattedText) || pivotValue.formattedText === '') {
                args.value = this.parent.exportType === 'Excel' ? null : '';
            }
            else {
                const aggMatrix = this.parent.dataType === 'pivot' && this.parent.engineModule ? this.parent.engineModule.aggregatedValueMatrix : undefined;
                if (aggMatrix && aggMatrix[pivotValue.rowIndex] && aggMatrix[pivotValue.rowIndex][pivotValue.colIndex]) {
                    args.value = aggMatrix[pivotValue.rowIndex][pivotValue.colIndex];
                }
                else {
                    args.value = !isNullOrUndefined(pivotValue.value) ? (pivotValue.formattedText === '#DIV/0!' ? pivotValue.formattedText : pivotValue.value) : pivotValue.formattedText;
                }
            }
        }
        args = this.exportContentEvent(args);
        if (this.parent.dataSourceSettings.rows.length === 0 && this.parent.dataSourceSettings.valueAxis === 'row') {
            args.value = args.column.field === '0.formattedText' ? this.getValidHeader(args, 'row') : args.value;
        }
        this.parent.trigger(excelQueryCellInfo, args);
    }
    pdfRowEvent(args) {
        args = this.exportContentEvent(args);
        if (args.column.field === '0.formattedText') {
            let level = 0;
            const cell = args.data[0];
            const isValueCell = cell.type && cell.type === 'value';
            if (this.parent.dataType === 'olap') {
                level = this.indentCollection[cell.rowIndex];
            }
            else {
                const levelName = cell.valueSort ? cell.valueSort.levelName.toString() : '';
                const memberPos = cell.actualText ?
                    cell.actualText.toString().split(this.parent.dataSourceSettings.valueSortSettings.headerDelimiter).length : 0;
                const levelPosition = levelName.split(this.parent.dataSourceSettings.valueSortSettings.headerDelimiter).length -
                    (memberPos ? memberPos - 1 : memberPos);
                level = levelPosition ? (levelPosition - 1) : 0;
            }
            args.style = { paragraphIndent: level * 10 };
            this.lastSpan = isValueCell ? this.lastSpan : level;
            if (this.parent.dataSourceSettings.rows.length === 0 && this.parent.dataSourceSettings.valueAxis === 'row') {
                args.value = this.getValidHeader(args, 'row');
            }
        }
        this.parent.trigger(pdfQueryCellInfo, args);
    }
    /* eslint-disable @typescript-eslint/no-explicit-any */
    excelDataBound(args) {
        const excelRows = args.excelRows;
        const rowStartPos = Object.keys(this.engine.headerContent).length;
        for (let i = 0; i < rowStartPos; i++) {
            const cells = excelRows[i].cells;
            const tmpCell = [];
            for (let j = 0; j < cells.length; j++) {
                if (cells[j].rowSpan !== -1) {
                    tmpCell.push(cells[j]);
                }
            }
            excelRows[i].cells = tmpCell;
        }
    }
    exportHeaderEvent(args) {
        let rowSpan = 1;
        if (args.gridCell.column.customAttributes) {
            const cell = args.gridCell.column.customAttributes.cell;
            // if (this.actualText !== cell.actualText && cell.colSpan > 1 && cell.level > -1) {
            //     ((args as any).gridCell as any).colSpan = (args.cell as any).colSpan = cell.colSpan > -1 ? cell.colSpan : 1;
            // }
            rowSpan = cell.rowSpan > -1 ? cell.rowSpan : 1;
            if (args.name === 'excelHeaderQueryCellInfo') {
                if (cell.rowSpan > -1) {
                    rowSpan = cell.rowSpan;
                }
                else if (!isNullOrUndefined(cell.type) && cell.level !== 0) {
                    rowSpan = -1;
                    args.cell.rowSpan = -1;
                }
            }
            this.actualText = cell.actualText;
        }
        else {
            rowSpan = Object.keys(this.engine.headerContent).length;
        }
        if (args.cell.rowSpan !== rowSpan && rowSpan > -1) {
            args.cell.rowSpan = rowSpan;
        }
        return args;
    }
    /* eslint-enable @typescript-eslint/no-explicit-any */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    exportContentEvent(args) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const cell = args.data[Number(args.column.field.split('.formattedText')[0])];
        args.value = cell.type === 'grand sum' ? (isNullOrUndefined(cell.valueSort.axis) ?
            this.parent.localeObj.getConstant('grandTotal') : cell.formattedText) : args.value;
        return args;
    }
    unWireEvents(cell) {
        if (cell.querySelector('.e-hyperlinkcell')) {
            EventHandler.remove(cell.querySelector('.e-hyperlinkcell'), this.parent.isAdaptive ? 'touchend' : 'click', this.onHyperCellClick);
        }
        else {
            return;
        }
    }
    wireEvents(cell) {
        if (cell.querySelector('.e-hyperlinkcell')) {
            EventHandler.add(cell.querySelector('.e-hyperlinkcell'), this.parent.isAdaptive ? 'touchend' : 'click', this.onHyperCellClick, this);
        }
        else {
            return;
        }
    }
}

/**
 * Keyboard interaction
 */
/** @hidden */
class CommonKeyboardInteraction {
    /**
     * Constructor
     *
     * @param {PivotCommon} parent - It contains the parent data
     */
    constructor(parent) {
        this.keyConfigs = {
            shiftF: 'shift+F',
            shiftS: 'shift+S',
            shiftE: 'shift+E',
            delete: 'delete',
            enter: 'enter',
            escape: 'escape',
            upArrow: 'upArrow',
            downArrow: 'downArrow',
            altJ: 'alt+J'
        };
        this.parent = parent;
        this.parent.element.tabIndex = this.parent.element.tabIndex === -1 ? 0 : this.parent.element.tabIndex;
        this.keyboardModule = new KeyboardEvents(this.parent.element, {
            keyAction: this.keyActionHandler.bind(this),
            keyConfigs: this.keyConfigs,
            eventName: 'keydown'
        });
    }
    keyActionHandler(e) {
        switch (e.action) {
            case 'shiftF':
                this.processFilter(e);
                break;
            case 'shiftS':
                this.processSort(e);
                break;
            case 'shiftE':
                this.processEdit(e);
                break;
            case 'delete':
                this.processDelete(e);
                break;
            case 'enter':
                this.processEnter(e);
                break;
            case 'escape':
                this.processClose(e);
                break;
            case 'upArrow':
            case 'downArrow':
                this.processFilterNodeSelection(e);
                break;
            case 'altJ':
                this.processComponentFocus(e);
        }
    }
    processComponentFocus(e) {
        if (this.parent.element) {
            this.parent.element.focus();
            e.stopPropagation();
            e.preventDefault();
            return;
        }
    }
    getButtonElement(target) {
        const allPivotButtons = [].slice.call(this.parent.element.querySelectorAll('.' + PIVOT_BUTTON_CLASS));
        for (let i = 0, len = allPivotButtons.length; i < len; i++) {
            if (allPivotButtons[i].getAttribute('data-uid') === target.getAttribute('data-uid')) {
                return allPivotButtons[i];
            }
        }
        return target;
    }
    processEnter(e) {
        const target = e.target;
        if (target && closest(target, '.' + PIVOT_BUTTON_CLASS)) {
            if (target.querySelector('.' + AXISFIELD_ICON_CLASS) && closest(target, '.' + VALUE_AXIS_CLASS)) {
                target.querySelector('.' + AXISFIELD_ICON_CLASS).click();
            }
            else if (target.querySelector('.' + CALC_EDIT)) {
                target.querySelector('.' + CALC_EDIT).click();
            }
            else if (target.querySelector('.' + SORT_CLASS) &&
                !closest(target, '.' + VALUE_AXIS_CLASS) && !closest(target, '.' + AXIS_FILTER_CLASS)) {
                target.querySelector('.' + SORT_CLASS).click();
                this.getButtonElement(target).focus();
            }
            else if (target.querySelector('.' + FILTER_COMMON_CLASS) && !closest(target, '.' + VALUE_AXIS_CLASS)) {
                target.querySelector('.' + FILTER_COMMON_CLASS).click();
            }
            e.preventDefault();
            return;
        }
    }
    processSort(e) {
        const target = e.target;
        if (target && closest(target, '.' + PIVOT_BUTTON_CLASS) && target.querySelector('.' + SORT_CLASS) &&
            !closest(target, '.' + VALUE_AXIS_CLASS) && !closest(target, '.' + AXIS_FILTER_CLASS)) {
            target.querySelector('.' + SORT_CLASS).click();
            this.getButtonElement(target).focus();
            e.preventDefault();
            return;
        }
    }
    processEdit(e) {
        const target = e.target;
        if (target && closest(target, '.' + PIVOT_BUTTON_CLASS) && target.querySelector('.' + CALC_EDIT)) {
            target.querySelector('.' + CALC_EDIT).click();
            e.preventDefault();
            return;
        }
    }
    processFilter(e) {
        const target = e.target;
        if (target && closest(target, '.' + PIVOT_BUTTON_CLASS) && target.querySelector('.' + FILTER_COMMON_CLASS) &&
            !closest(target, '.' + VALUE_AXIS_CLASS)) {
            target.querySelector('.' + FILTER_COMMON_CLASS).click();
            if (this.parent && this.parent.control && this.parent.moduleName === 'pivotview' &&
                this.parent.control.grid && this.parent.control.showGroupingBar &&
                this.parent.control.groupingBarModule && closest(target, '.' + GROUP_ROW_CLASS) &&
                this.parent.filterDialog && this.parent.filterDialog.dialogPopUp &&
                !this.parent.filterDialog.dialogPopUp.isDestroyed && this.parent.filterDialog.dialogPopUp.element) {
                const dialogElement = this.parent.filterDialog.dialogPopUp.element;
                const isExcelFilter = this.parent.filterDialog.allowExcelLikeFilter;
                clearTimeout(this.timeOutObj);
                this.timeOutObj = setTimeout(() => {
                    if (dialogElement && dialogElement.classList.contains('e-popup-open')) {
                        if (isExcelFilter && dialogElement.querySelector('.e-dlg-closeicon-btn')) {
                            dialogElement.querySelector('.e-dlg-closeicon-btn').focus();
                        }
                        else if (dialogElement.querySelector('input')) {
                            dialogElement.querySelector('input').focus();
                        }
                    }
                });
            }
            e.preventDefault();
            return;
        }
    }
    processFilterNodeSelection(e) {
        const target = e.target;
        if (target && closest(target, '.' + SELECT_ALL_CLASS) && e.keyCode === 40) {
            const memberEditorTree = closest(target, '.' + EDITOR_TREE_WRAPPER_CLASS).querySelector('.' + EDITOR_TREE_CONTAINER_CLASS);
            if (memberEditorTree && memberEditorTree.querySelector('li')) {
                const firstLi = memberEditorTree.querySelector('li');
                if (memberEditorTree.querySelector('li#_active')) {
                    removeClass([memberEditorTree.querySelector('li#_active')], ['e-node-focus']);
                    memberEditorTree.querySelector('li#_active').removeAttribute('id');
                }
                firstLi.setAttribute('id', '_active');
                addClass([firstLi], ['e-node-focus']);
                firstLi.focus();
                e.preventDefault();
                return;
            }
        }
        else if (target && closest(target, '.' + EDITOR_TREE_CONTAINER_CLASS) && e.keyCode === 38) {
            const memberEditorTree = closest(target, '.' + EDITOR_TREE_CONTAINER_CLASS);
            if (memberEditorTree.querySelector('li#_active.e-node-focus') && memberEditorTree.querySelector('li') &&
                memberEditorTree.querySelector('li').classList.contains('e-prev-active-node') &&
                memberEditorTree.querySelector('li') === memberEditorTree.querySelector('li#_active.e-node-focus')) {
                removeClass(memberEditorTree.querySelectorAll('li.e-prev-active-node'), 'e-prev-active-node');
                const allMemberEditorTree = closest(target, '.' + EDITOR_TREE_WRAPPER_CLASS).querySelector('.' + SELECT_ALL_CLASS);
                if (allMemberEditorTree && allMemberEditorTree.querySelector('li')) {
                    const firstLi = allMemberEditorTree.querySelector('li');
                    firstLi.setAttribute('id', '_active');
                    addClass([firstLi], ['e-node-focus']);
                    firstLi.focus();
                    e.preventDefault();
                    return;
                }
            }
        }
        else if (target && target.id === this.parent.parentID + '_inputbox') {
            if (e.action === 'upArrow') {
                target.parentElement.querySelector('.e-spin-up').click();
            }
            else if (e.action === 'downArrow') {
                target.parentElement.querySelector('.e-spin-down').click();
            }
        }
    }
    processDelete(e) {
        const target = e.target;
        if (target && closest(target, '.' + PIVOT_BUTTON_CLASS) && target.querySelector('.' + REMOVE_CLASS)) {
            target.querySelector('.' + REMOVE_CLASS).click();
            e.preventDefault();
            return;
        }
    }
    processClose(e) {
        const target = e.target;
        if (target && closest(target, '.e-popup.e-popup-open')) {
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            const dialogInstance = closest(target, '.e-popup.e-popup-open').ej2_instances[0];
            if (dialogInstance && !dialogInstance.closeOnEscape) {
                const button = dialogInstance.element.getAttribute('data-fieldName');
                dialogInstance.hide();
                if (this.parent.element) {
                    const pivotButtons = [].slice.call(this.parent.element.querySelectorAll('.e-pivot-button'));
                    for (const item of pivotButtons) {
                        if (item.getAttribute('data-uid') === button) {
                            item.focus();
                            break;
                        }
                    }
                }
                e.preventDefault();
                return;
            }
        }
    }
    /**
     * To destroy the keyboard module.
     *
     * @returns {void}
     * @private
     */
    destroy() {
        if (this.keyboardModule) {
            this.keyboardModule.destroy();
        }
        else {
            return;
        }
    }
}

/**
 * `EventBase` for active fields action.
 */
/** @hidden */
class EventBase {
    /**
     * Constructor for the dialog action.
     *
     * @param {PivotCommon} parent - It represent the parent.
     * @hidden
     */
    constructor(parent) {
        /** @hidden */
        this.searchListItem = [];
        this.parent = parent;
    }
    /**
     * Updates sorting order for the selected field.
     *
     * @function updateSorting
     * @param  {Event} args - Contains clicked element information to update dataSource.
     * @returns {void}
     * @hidden
     */
    updateSorting(args) {
        if (!(args.target.classList.contains(FILTER_COMMON_CLASS)) &&
            !(args.target.classList.contains(REMOVE_CLASS))) {
            if (this.parent.filterDialog.dialogPopUp) {
                this.parent.filterDialog.dialogPopUp.close();
            }
            const target = args.target;
            let fieldName;
            let checkisDescending;
            let isDescending;
            if (target.id) {
                fieldName = target.getAttribute('data-uid');
                checkisDescending = [].slice.call(target.querySelectorAll('.' + SORT_DESCEND_CLASS));
            }
            else {
                fieldName = target.parentElement.getAttribute('data-uid');
                checkisDescending = [].slice.call(target.parentElement.querySelectorAll('.' + SORT_DESCEND_CLASS));
            }
            if (checkisDescending.length === 0) {
                isDescending = false;
            }
            else {
                isDescending = true;
            }
            //isDescending = (target.querySelectorAll(cls.SORT_DESCEND_CLASS));
            const sortObj = PivotUtil.getFieldByName(fieldName, this.parent.dataSourceSettings.sortSettings);
            const addMembersOrder = this.parent.engineModule && this.parent.engineModule.fieldList[fieldName] &&
                this.parent.engineModule.fieldList[fieldName].membersOrder ?
                [...this.parent.engineModule.fieldList[fieldName].membersOrder] : [];
            if (!isNullOrUndefined(sortObj)) {
                for (let i = 0; i < this.parent.dataSourceSettings.sortSettings.length; i++) {
                    if (this.parent.dataSourceSettings.sortSettings[i].name === fieldName) {
                        this.parent.dataSourceSettings.sortSettings.splice(i, 1);
                        break;
                    }
                }
                const newSortObj = { name: fieldName, order: isDescending ? 'Ascending' : 'Descending', membersOrder: sortObj ? sortObj.membersOrder : addMembersOrder };
                // let newSortObj: ISort = { name: fieldName, order: isNone ? 'Ascending' : isDescending ? 'None' : 'Descending' };
                this.parent.dataSourceSettings.sortSettings.push(newSortObj);
            }
            else {
                const newSortObj = { name: fieldName, order: isDescending ? 'Ascending' : 'Descending', membersOrder: sortObj ? sortObj.membersOrder : addMembersOrder };
                //let newSortObj: ISort = { name: fieldName, order: isNone ? 'Ascending' : isDescending ? 'None' : 'Descending'  };
                this.parent.dataSourceSettings.sortSettings.push(newSortObj);
            }
            this.parent.control.lastSortInfo =
                this.parent.dataSourceSettings.sortSettings[this.parent.dataSourceSettings.sortSettings.length - 1];
            if (isDescending) {
                removeClass([target], SORT_DESCEND_CLASS);
            }
            else {
                addClass([target], SORT_DESCEND_CLASS);
            }
            // if (isDescending) {
            //     removeClass([target], cls.SORT_DESCEND_CLASS);
            //     addClass([target], cls.SORTING);
            // } else if (!isDescending && !isNone) {
            //     addClass([target], cls.SORT_DESCEND_CLASS);
            // } else if (isNone) {
            //     removeClass([target], cls.SORTING);
            // } else if (!isNone) {
            //     removeClass([target], cls.SORT_DESCEND_CLASS);
            //     removeClass([target], cls.SORTING);
            //    //addClass([target], cls.SORT_CLASS);
            // }
        }
    }
    /**
     * Updates sorting order for the selected field.
     *
     * @function updateFiltering
     * @param {Event} args - Contains clicked element information to update dataSource.
     * @returns {void}
     * @hidden
     */
    updateFiltering(args) {
        const target = args.target;
        const fieldName = target.parentElement.getAttribute('data-uid');
        const fieldCaption = target.parentElement.textContent;
        let isInclude = false;
        let filterItems = [];
        let treeData = [];
        if (this.parent.dataSourceSettings.allowMemberFilter) {
            if (this.parent.dataType === 'olap') {
                treeData = this.getOlapData(fieldName, isInclude);
            }
            else {
                const fieldInfo = this.parent.engineModule.fieldList[fieldName];
                let members = PivotUtil.getClonedData(fieldInfo.dateMember);
                const membersInfo = fieldInfo && fieldInfo.membersOrder ?
                    [...fieldInfo.membersOrder] : [];
                let outOfRange;
                if (members[0].actualText === 'Out of Range') {
                    outOfRange = members[0];
                    members.splice(0, 1);
                }
                else if (members[members.length - 1].actualText === 'Out of Range') {
                    outOfRange = members[members.length - 1];
                    members.splice(members.length - 1, 1);
                }
                const sortDetails = {
                    fieldName: fieldName,
                    sortOrder: fieldInfo.sort,
                    members: membersInfo && membersInfo.length > 0 ? membersInfo : Object.keys(members),
                    IsOrderChanged: false
                };
                let isHeaderSortByDefault = false;
                const sortType = fieldInfo && fieldInfo.isAlphanumeric ? true : undefined;
                if (membersInfo && membersInfo.length > 0) {
                    members = PivotUtil.applyCustomSort(sortDetails, members, sortType);
                }
                else {
                    members = PivotUtil.applyHeadersSort(members, sortDetails.sortOrder, sortType);
                    isHeaderSortByDefault = true;
                }
                const filterObj = PivotUtil.getFilterItemByName(fieldName, this.parent.dataSourceSettings.filterSettings);
                if (!isNullOrUndefined(filterObj)) {
                    isInclude = this.isValidFilterItemsAvail(fieldName, filterObj) && filterObj.type === 'Include' ? true : false;
                    filterItems = filterObj.items ? filterObj.items : [];
                }
                if (outOfRange) {
                    if (sortDetails.sortOrder === 'Ascending') {
                        if (members[members.length - 1].actualText === 'Grand Total') {
                            members.splice(members.length - 1, 0, outOfRange);
                        }
                        else {
                            members.splice(members.length, 0, outOfRange);
                        }
                    }
                    else {
                        if (members[0].actualText === 'Grand Total') {
                            members.splice(1, 0, outOfRange);
                        }
                        else {
                            members.splice(0, 0, outOfRange);
                        }
                    }
                }
                if (isHeaderSortByDefault) {
                    const copyOrder = [];
                    for (let m = 0, n = 0; m < members.length; m++) {
                        if (members[m].actualText !== 'Grand Total') {
                            copyOrder[n++] = members[m].actualText;
                        }
                    }
                    sortDetails.members = copyOrder;
                }
                this.parent.control.trigger(onHeadersSort, sortDetails);
                if (sortDetails.IsOrderChanged) {
                    members = PivotUtil.applyCustomSort(sortDetails, members, sortType, true);
                }
                treeData =
                    this.getTreeData(isInclude, members, filterItems, fieldName);
            }
        }
        if (this.parent.filterDialog.dialogPopUp) {
            this.parent.filterDialog.dialogPopUp.close();
        }
        let popupTarget = this.parent.control.filterTargetID;
        if (isNullOrUndefined(popupTarget)) {
            popupTarget = this.parent.moduleName !== 'pivotfieldlist' ?
                this.parent.element : document.getElementById(this.parent.parentID + '_Container');
        }
        this.parent.filterDialog.createFilterDialog(treeData, fieldName, fieldCaption, popupTarget);
    }
    /**
     * Returns boolean by checing the valid filter members from the selected filter settings.
     *
     * @function isValidFilterItemsAvail
     * @param {string} fieldName - Gets filter members for the given field name.
     * @param {IFilter} filterObj - filterObj.
     * @returns {boolean} - boolean.
     * @hidden
     */
    isValidFilterItemsAvail(fieldName, filterObj) {
        let isItemAvail = false;
        const filterTypes = ['Include', 'Exclude'];
        if (filterObj && filterTypes.indexOf(filterObj.type) >= 0) {
            if (filterObj.type === 'Include' && filterObj.items.length === 0) {
                isItemAvail = true;
            }
            else {
                const engineModule = this.parent.engineModule;
                const field = engineModule.fieldList[fieldName];
                const members = (engineModule.formatFields[fieldName] &&
                    (['date', 'dateTime', 'time'].indexOf(engineModule.formatFields[fieldName].type) > -1)) ?
                    field.formattedMembers : field.members;
                for (const item of filterObj.items) {
                    if (members[item]) {
                        isItemAvail = true;
                        break;
                    }
                }
            }
        }
        return isItemAvail;
    }
    getOlapData(fieldName, isInclude) {
        let treeData = [];
        let filterItems = [];
        this.parent.filterDialog.isSearchEnabled = false;
        const updatedTreeData = [];
        const engineModule = this.parent.engineModule;
        const filterObj = PivotUtil.getFilterItemByName(fieldName, this.parent.dataSourceSettings.filterSettings);
        if (engineModule.fieldList[fieldName].filterMembers.length === 0) {
            if (!this.parent.control.loadOnDemandInMemberEditor) {
                engineModule.getMembers(this.parent.dataSourceSettings, fieldName, true);
            }
            else if (filterObj && filterObj.levelCount > 1 && engineModule.fieldList[fieldName].levels.length > 1) {
                engineModule.getFilterMembers(this.parent.dataSourceSettings, fieldName, filterObj.levelCount);
            }
            else {
                engineModule.fieldList[fieldName].levelCount = 1;
                engineModule.getMembers(this.parent.dataSourceSettings, fieldName);
            }
        }
        else {
            engineModule.fieldList[fieldName].currrentMembers = {};
            engineModule.fieldList[fieldName].searchMembers = [];
        }
        const isHierarchy = engineModule.fieldList[fieldName].isHierarchy;
        treeData = engineModule.fieldList[fieldName].filterMembers;
        if (!isNullOrUndefined(filterObj)) {
            isInclude = filterObj.type ? filterObj.type === 'Include' ? true : false : true;
            filterItems = filterObj.items ? filterObj.items : [];
        }
        const filterItemObj = {};
        let dummyfilterItems = {};
        const memberObject = engineModule.fieldList[fieldName].members;
        for (const item of filterItems) {
            filterItemObj[item] = item;
            dummyfilterItems[item] = item;
            if (memberObject[item]) {
                dummyfilterItems = this.getParentNode(fieldName, item, dummyfilterItems);
            }
        }
        treeData = this.getFilteredTreeNodes(fieldName, treeData, dummyfilterItems, updatedTreeData);
        treeData = this.getOlapTreeData(isInclude, PivotUtil.getClonedData(treeData), filterItemObj, fieldName, isHierarchy);
        treeData = this.sortOlapFilterData(treeData, engineModule.fieldList[fieldName].sort);
        return treeData;
    }
    /**
     * Gets sorted filter members for the selected field.
     *
     * @function sortOlapFilterData
     * @param {any} treeData - Gets filter members for the given field name.
     * @param {string} order - It contains the value of order.
     * @returns {any} - It returns the sort Olap Filter Data.
     * @hidden
     */
    sortOlapFilterData(treeData, order) {
        if (treeData.length > 0) {
            let isHeaderSortByDefault = false;
            const members = [];
            for (let i = 0; i < treeData.length; i++) {
                members.push(treeData[i].caption);
            } // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const fieldName = treeData[0].caption !== 'Grand Total' || treeData[0].caption === undefined ? treeData[0].htmlAttributes['data-fieldName'] : treeData[1].htmlAttributes['data-fieldName'];
            const engineModule = this.parent.engineModule;
            const fieldInfo = engineModule.fieldList[fieldName];
            const membersInfo = fieldInfo && fieldInfo.membersOrder ? [...fieldInfo.membersOrder] : [];
            const sortDetails = {
                fieldName: fieldName,
                sortOrder: order,
                members: membersInfo && membersInfo.length > 0 ? membersInfo : members,
                IsOrderChanged: false
            };
            if (membersInfo && membersInfo.length > 0) {
                this.applyFilterCustomSort(treeData, sortDetails);
            }
            else {
                treeData = order === 'Ascending' ?
                    (treeData.sort((a, b) => (a.caption > b.caption) ? 1 :
                        ((b.caption > a.caption) ? -1 : 0))) : order === 'Descending' ?
                    (treeData.sort((a, b) => (a.caption < b.caption) ? 1 :
                        ((b.caption < a.caption) ? -1 : 0))) : treeData;
                isHeaderSortByDefault = true;
            }
            if (isHeaderSortByDefault) {
                const copyOrder = [];
                for (let m = 0, n = 0; m < treeData.length; m++) {
                    if (treeData[m].caption !== 'Grand Total') {
                        copyOrder[n++] = treeData[m].caption;
                    }
                }
                sortDetails.members = copyOrder;
            }
            this.parent.control.trigger(onHeadersSort, sortDetails);
            if (sortDetails.IsOrderChanged) {
                this.applyFilterCustomSort(treeData, sortDetails, true);
            }
        }
        return treeData;
    }
    applyFilterCustomSort(headers, sortDetails, hasMembersOrder) {
        let order = [];
        const updatedMembers = [];
        let grandTotal;
        if (sortDetails.IsOrderChanged) {
            order = sortDetails.members;
        }
        else {
            order = (sortDetails.sortOrder === 'Ascending' || sortDetails.sortOrder === 'None' || sortDetails.sortOrder === undefined) ? [].concat(sortDetails.members) : [].concat(sortDetails.members).reverse();
        }
        if (headers[0].caption === 'Grand Total') {
            grandTotal = headers[0];
            headers.shift();
        }
        for (let i = 0, j = 0; i < headers.length; i++) {
            const sortText = headers[i].caption;
            if (order[j] === sortText) {
                headers.splice(j++, 0, headers[i]);
                headers.splice(++i, 1);
                if (j < order.length) {
                    i = -1;
                }
                else {
                    if (!hasMembersOrder) {
                        updatedMembers.splice(--j, 0, sortText);
                    }
                    break;
                }
            }
            if (i >= 0 && !hasMembersOrder) {
                updatedMembers[i] = headers[i].caption;
            }
        }
        if (!hasMembersOrder) {
            for (let i = updatedMembers.length; i < headers.length; i++) {
                updatedMembers[i] = headers[i].caption;
            }
            if (updatedMembers[updatedMembers.length - 1] === 'Grand Total') {
                updatedMembers.pop();
            }
            sortDetails.members = updatedMembers;
        }
        if (grandTotal) {
            headers.splice(0, 0, grandTotal);
        }
        return headers;
    }
    /**
     * It used to get the parentIds
     *
     * @param {TreeView} treeObj - Specifies the treeview instance.
     * @param {string} id - Specifies the current node id.
     * @param {string[]} parent - Specifies the collection of parent element.
     * @returns {string[]} - Returns parentIds.
     * @hidden
     */
    getParentIDs(treeObj, id, parent) {
        const data = treeObj.fields.dataSource;
        let pid;
        for (const li of data) {
            if (li.id === id) {
                pid = li.pid;
                break;
            }
        }
        if (pid) {
            parent.push(pid);
            this.getParentIDs(treeObj, pid, parent);
        }
        return parent;
    }
    /**
     * It used to get the childIds
     *
     * @param {TreeView} treeObj - Specifies the treeview instance.
     * @param {string} id - Specifies the current node id.
     * @param {string[]} children - Specifies the collection of clid elements.
     * @returns {string[]} - Return childIds.
     * @hidden
     */
    getChildIDs(treeObj, id, children) {
        const data = treeObj.fields.dataSource;
        let cID;
        for (const li of data) {
            if (li.pid === id) {
                cID = li.id;
                break;
            }
        }
        if (cID) {
            children.push(cID);
            this.getParentIDs(treeObj, cID, children);
        }
        return children;
    }
    /**
     * show tree nodes using search text.
     *
     * @param {MaskChangeEventArgs} args -  It cotains the args data.
     * @param {TreeView} treeObj -  It cotains the treeObj data.
     * @param {boolean} isFieldCollection -  It cotains the isFieldCollection data.
     * @param {boolean} isHierarchy -  It cotains the isHierarchy data.
     * @returns {void}
     * @hidden
     */
    searchTreeNodes(args, treeObj, isFieldCollection, isHierarchy) {
        if (isFieldCollection) {
            const searchList = [];
            const nonSearchList = [];
            const list = [].slice.call(treeObj.element.querySelectorAll('li'));
            for (const element of list) {
                if ((element.querySelector('.e-list-text').textContent.toLowerCase()).indexOf(args.value.toLowerCase()) > -1) {
                    searchList.push(element);
                }
                else {
                    nonSearchList.push(element);
                }
            }
            treeObj.enableNodes(searchList);
            removeClass(searchList, ICON_DISABLE);
            treeObj.disableNodes(nonSearchList);
            addClass(nonSearchList, ICON_DISABLE);
            if (searchList.length > 0 && nonSearchList.length > 0) {
                for (const currentNode of searchList) {
                    const id = currentNode.getAttribute('data-uid');
                    const parentIDs = this.getParentIDs(treeObj, id, []);
                    const childIDs = this.getChildIDs(treeObj, id, []);
                    const pNodes = [];
                    if (parentIDs.length > 0) {
                        for (const li of nonSearchList) {
                            if (PivotUtil.inArray(li.getAttribute('data-uid'), parentIDs) !== -1) {
                                pNodes.push(li);
                            }
                        }
                    }
                    if (childIDs.length > 0) {
                        for (const li of nonSearchList) {
                            if (PivotUtil.inArray(li.getAttribute('data-uid'), childIDs) !== -1) {
                                pNodes.push(li);
                            }
                        }
                    }
                    treeObj.enableNodes(pNodes);
                    removeClass(pNodes, ICON_DISABLE);
                }
            }
            if ([].slice.call(treeObj.element.querySelectorAll('li.' + ICON_DISABLE)).length === 0) {
                treeObj.collapseAll();
            }
            else {
                treeObj.expandAll(undefined, undefined, true);
            }
            this.searchListItem = searchList;
        }
        else {
            this.parent.searchTreeItems = [];
            if (this.parent.dataType === 'olap' && !isHierarchy) {
                this.updateOlapSearchTree(args, treeObj, isHierarchy);
            }
            else {
                const searchList = [];
                let memberCount = 0;
                memberCount = 1;
                for (const item of this.parent.currentTreeItems) {
                    if (item.name.toLowerCase().indexOf(args.value.toLowerCase()) > -1) {
                        this.parent.searchTreeItems.push(item);
                        if (memberCount <= this.parent.control.maxNodeLimitInMemberEditor) {
                            searchList.push(item);
                        }
                        memberCount++;
                    }
                }
                memberCount--;
                if (memberCount > this.parent.control.maxNodeLimitInMemberEditor) {
                    this.parent.editorLabelElement.innerText = (memberCount - this.parent.control.maxNodeLimitInMemberEditor) +
                        this.parent.control.localeObj.getConstant('editorDataLimitMsg');
                    this.parent.filterDialog.dialogPopUp.height = (this.parent.filterDialog.allowExcelLikeFilter ? '440px' : '400px');
                    this.parent.isDataOverflow = true;
                }
                else {
                    this.parent.editorLabelElement.innerText = '';
                    this.parent.filterDialog.dialogPopUp.height = (this.parent.filterDialog.allowExcelLikeFilter ? '400px' : '350px');
                    this.parent.isDataOverflow = false;
                }
                this.parent.isDataOverflow = (memberCount > this.parent.control.maxNodeLimitInMemberEditor);
                this.parent.editorLabelElement.parentElement.style.display = this.parent.isDataOverflow ? 'block' : 'none';
                treeObj.fields = { dataSource: searchList, id: 'id', text: 'name', isChecked: 'isSelected', parentID: 'pid' };
                treeObj.dataBind();
            }
        }
    }
    updateOlapSearchTree(args, treeObj, isHierarchy) {
        let treeData = [];
        const filterDialog = this.parent.filterDialog.dialogPopUp.element;
        const fieldName = filterDialog.getAttribute('data-fieldname');
        if (args.value.toLowerCase() === '') {
            this.parent.filterDialog.isSearchEnabled = false;
            this.parent.engineModule.fieldList[fieldName].searchMembers = [];
            // (this.parent.engineModule.fieldList[fieldName as string] as IOlapField).currrentMembers = {};
            const updatedTreeData = [];
            const filterItemObj = {};
            let dummyfilterItems = {};
            const memberObject = this.parent.engineModule.fieldList[fieldName].members;
            const members = Object.keys(memberObject);
            const filterItems = [];
            for (const item of members) {
                if (memberObject[item].isSelected) {
                    if (!(memberObject[item].parent && memberObject[memberObject[item].parent].isSelected)) {
                        filterItems.push(item);
                    }
                }
            }
            for (const item of filterItems) {
                filterItemObj[item] = item;
                dummyfilterItems[item] = item;
                if (memberObject[item]) {
                    dummyfilterItems = this.getParentNode(fieldName, item, dummyfilterItems);
                }
            }
            const searchData = this.parent.engineModule.fieldList[fieldName].filterMembers;
            treeData = this.getFilteredTreeNodes(fieldName, searchData, dummyfilterItems, updatedTreeData);
            treeData = this.getOlapTreeData(true, PivotUtil.getClonedData(treeData), filterItemObj, fieldName, isHierarchy, true);
        }
        else {
            this.parent.filterDialog.isSearchEnabled = true;
            const searchData = this.parent.engineModule.fieldList[fieldName].searchMembers;
            treeData = PivotUtil.getClonedData(searchData);
            treeData = this.getOlapSearchTreeData(true, treeData, fieldName);
        }
        treeObj.fields = { dataSource: treeData, id: 'id', text: 'name', isChecked: 'isSelected', parentID: 'pid' };
        treeObj.dataBind();
    }
    getTreeData(isInclude, members, filterItems, fieldName) {
        this.parent.currentTreeItems = [];
        this.parent.searchTreeItems = [];
        this.parent.currentTreeItemsPos = {};
        this.parent.savedTreeFilterPos = {};
        const engineModule = this.parent.engineModule;
        this.parent.isDateField = engineModule.formatFields[fieldName] &&
            ((['date', 'dateTime', 'time']).indexOf(engineModule.formatFields[fieldName].type) > -1);
        const list = [];
        let memberCount = 1;
        const filterObj = {};
        for (const item of filterItems) {
            filterObj[item] = item;
        }
        const modifiedFieldName = fieldName.replace(/[^a-zA-Z0-9 ]/g, '_');
        for (const member of members) {
            let memberName = engineModule.formatFields[fieldName] ? member.formattedText : member.actualText.toString();
            memberName = this.parent.enableHtmlSanitizer ? SanitizeHtmlHelper.sanitize(memberName) : memberName;
            const actualText = this.parent.enableHtmlSanitizer ?
                SanitizeHtmlHelper.sanitize(member.actualText) : member.actualText;
            const nodeAttr = { 'data-fieldName': fieldName, 'data-memberId': actualText.toString() };
            const obj = {
                id: modifiedFieldName + '_' + memberCount,
                htmlAttributes: nodeAttr,
                actualText: actualText,
                name: memberName,
                isSelected: isInclude ? false : true
            };
            if (filterObj[actualText] !== undefined) {
                obj.isSelected = isInclude ? true : false;
            }
            if (memberCount <= this.parent.control.maxNodeLimitInMemberEditor) {
                list.push(obj);
            }
            if (!obj.isSelected) {
                this.parent.savedTreeFilterPos[memberCount - 1] = memberName;
            }
            this.parent.currentTreeItems.push(obj);
            this.parent.searchTreeItems.push(obj);
            this.parent.currentTreeItemsPos[actualText] = { index: memberCount - 1, isSelected: obj.isSelected };
            memberCount++;
        }
        this.parent.isDataOverflow = ((memberCount - 1) > this.parent.control.maxNodeLimitInMemberEditor);
        return list;
    }
    getOlapTreeData(isInclude, members, filterObj, fieldName, isHierarchy, isSearchRender) {
        const engineModule = this.parent.engineModule;
        const fieldList = engineModule.fieldList[fieldName];
        this.parent.currentTreeItems = [];
        this.parent.searchTreeItems = [];
        this.parent.currentTreeItemsPos = {};
        const list = [];
        let memberCount = 1;
        for (const member of members) {
            const obj = member;
            const memberName = member.id.toString();
            if (!isSearchRender) {
                obj.isSelected = isInclude ? false : true;
            }
            if (filterObj[memberName] !== undefined) {
                obj.isSelected = isInclude ? true : false;
            }
            if (!isSearchRender && member.hasChildren) {
                this.updateChildNodeStates(fieldList.filterMembers, fieldName, member.id, obj.isSelected);
            }
            fieldList.members[memberName].isSelected = obj.isSelected;
            if (fieldList.currrentMembers && fieldList.currrentMembers[memberName]) {
                fieldList.currrentMembers[memberName].isSelected = obj.isSelected;
            }
            if (memberCount <= this.parent.control.maxNodeLimitInMemberEditor && isHierarchy) {
                list.push(obj);
            }
            this.parent.currentTreeItems.push(obj);
            this.parent.searchTreeItems.push(obj);
            this.parent.currentTreeItemsPos[memberName] = { index: memberCount - 1, isSelected: obj.isSelected };
            memberCount++;
        }
        this.parent.isDataOverflow = isHierarchy ? ((memberCount - 1) > this.parent.control.maxNodeLimitInMemberEditor) : false;
        return isHierarchy ? list : members;
    }
    getOlapSearchTreeData(isInclude, members, fieldName) {
        const cMembers = this.parent.engineModule.fieldList[fieldName].members;
        for (const member of members) {
            const memberName = member.id.toString();
            if (cMembers[memberName]) {
                member.isSelected = cMembers[memberName].isSelected;
            }
            this.parent.searchTreeItems.push(member);
        }
        return members;
    }
    /**
     * @param {IOlapField[]} members - members.
     * @param {string} fieldName - fieldName.
     * @param {string} node - node.
     * @param {boolean} state - state.
     * @returns {void}
     * @hidden
     */
    updateChildNodeStates(members, fieldName, node, state) {
        const cMembers = this.parent.engineModule.fieldList[fieldName].members;
        const sMembers = this.parent.engineModule.fieldList[fieldName].currrentMembers;
        for (const member of members) {
            if (member.pid && member.pid.toString() === node) {
                cMembers[member.id].isSelected = state;
                if (sMembers && sMembers[member.id]) {
                    sMembers[member.id].isSelected = state;
                }
                if (member.hasChildren) {
                    this.updateChildNodeStates(members, fieldName, member.id, state);
                }
            }
        }
    }
    /* eslint-disable-next-line */
    /** @hidden */
    getParentNode(fieldName, item, filterObj) {
        const members = this.parent.engineModule.fieldList[fieldName].members;
        if (members[item].parent && item !== members[item].parent) {
            const parentItem = members[item].parent;
            filterObj[parentItem] = parentItem;
            this.getParentNode(fieldName, parentItem, filterObj);
        }
        return filterObj;
    }
    getFilteredTreeNodes(fieldName, members, filterObj, treeData) {
        const parentNodes = [];
        const memberObject = this.parent.engineModule.fieldList[fieldName].members;
        const selectedNodes = filterObj ? Object.keys(filterObj) : [];
        for (const node of selectedNodes) {
            const parent = memberObject[node] ? memberObject[node].parent : undefined;
            if (parent !== undefined && PivotUtil.inArray(parent, parentNodes) === -1) {
                parentNodes.push(parent);
            }
        }
        for (const member of members) {
            if (isNullOrUndefined(member.pid) || PivotUtil.inArray(member.pid, parentNodes) !== -1) {
                treeData.push(member);
                if (isNullOrUndefined(member.pid) && PivotUtil.inArray(member.id, parentNodes) !== -1) {
                    memberObject[member.id].isNodeExpand = true;
                }
                else if (!isNullOrUndefined(member.pid) && PivotUtil.inArray(member.pid, parentNodes) !== -1) {
                    memberObject[member.id].isNodeExpand = false;
                    memberObject[member.pid].isNodeExpand = true;
                }
                else {
                    memberObject[member.id].isNodeExpand = false;
                }
            }
            else {
                memberObject[member.id].isNodeExpand = false;
            }
        }
        return treeData;
    }
}

/**
 * `DialogAction` module is used to handle field list dialog related behaviour.
 *
 */
/** @hidden */
class NodeStateModified {
    /**
     * Constructor for the dialog action.
     *
     * @param {PivotCommon} parent - It represent the parent data.
     * @hidden
     */
    constructor(parent) {
        this.parent = parent;
    }
    /* eslint-disable-next-line */
    /**
     * Updates the dataSource by drag and drop the selected field from either field list or axis table with dropped target position.
     *
     * @function onStateModified
     * @param  {DragEventArgs & DragAndDropEventArgs} args -  Contains both pivot button and field list drag and drop information.
     * @param  {string} fieldName - Defines dropped field name to update dataSource.
     * @returns {void}
     * @hidden
     */
    onStateModified(args, fieldName) {
        let droppedClass = '';
        let nodeDropped = true;
        const target = closest(args.target, '.' + DROPPABLE_CLASS);
        let droppedPosition = -1;
        this.parent.dataSourceUpdate.btnElement = args.element ? args.element.parentElement : undefined;
        if (target) {
            droppedClass = target.classList[1] === ROW_AXIS_CLASS ?
                'rows' : target.classList[1] === COLUMN_AXIS_CLASS ? 'columns' : target.classList[1] === VALUE_AXIS_CLASS ?
                'values' : target.classList[1] === FILTER_AXIS_CLASS ? 'filters' : '';
        }
        if (this.parent.dataType === 'olap' || this.parent.dataType === 'pivot') {
            const actualFieldName = (this.parent.dataType === 'olap' && this.parent.engineModule.fieldList[fieldName] &&
                this.parent.engineModule.fieldList[fieldName].isCalculatedField ?
                this.parent.engineModule.fieldList[fieldName].tag : fieldName);
            if (args.cancel && droppedClass === '') {
                nodeDropped = false;
                return nodeDropped;
            }
            else if ((this.parent.dataSourceUpdate.btnElement &&
                (this.parent.dataSourceUpdate.btnElement.getAttribute('isValue') === 'true' &&
                    (droppedClass === 'filters' || droppedClass === 'values'))) ||
                (this.parent.dataSourceUpdate.btnElement &&
                    (this.parent.dataSourceUpdate.btnElement.getAttribute('isValue') === 'false' &&
                        actualFieldName.toLowerCase().indexOf('[measures].') > -1 && this.parent.dataType === 'olap' &&
                        (droppedClass === 'filters' || droppedClass === 'rows' || droppedClass === 'columns'))) ||
                (this.parent.dataSourceUpdate.btnElement &&
                    (this.parent.dataSourceUpdate.btnElement.getAttribute('isValue') === 'false' && this.parent.dataType === 'olap' &&
                        actualFieldName.toLowerCase().indexOf('[measures].') === -1 &&
                        this.parent.engineModule.fieldList[fieldName] &&
                        this.parent.engineModule.fieldList[fieldName].isNamedSets &&
                        (droppedClass === 'filters' || droppedClass === 'values'))) ||
                (this.parent.dataSourceUpdate.btnElement &&
                    (this.parent.dataSourceUpdate.btnElement.getAttribute('isValue') === 'false' && this.parent.dataType === 'olap' &&
                        actualFieldName.toLowerCase().indexOf('[measures].') === -1 && droppedClass === 'values'))) {
                const title = this.parent.localeObj.getConstant('warning');
                const description = this.parent.localeObj.getConstant('fieldDropErrorAction');
                this.parent.errorDialog.createErrorDialog(title, description);
                nodeDropped = false;
                return nodeDropped;
            }
        }
        else {
            if ((args.cancel && droppedClass === '') ||
                (this.parent.dataSourceUpdate.btnElement && this.parent.dataSourceUpdate.btnElement.getAttribute('isValue') === 'true' &&
                    ((droppedClass === 'filters' || droppedClass === 'values') ||
                        droppedClass.indexOf(this.parent.dataSourceSettings.valueAxis) > -1))) {
                nodeDropped = false;
                return nodeDropped;
            }
        }
        if (droppedClass !== '') {
            if (this.parent.dataType === 'olap' || this.parent.dataType === 'pivot') {
                const actualFieldName = (this.parent.dataType === 'olap' && this.parent.engineModule.fieldList[fieldName] &&
                    this.parent.engineModule.fieldList[fieldName].isCalculatedField ?
                    this.parent.engineModule.fieldList[fieldName].tag : fieldName);
                if ((actualFieldName.toLowerCase().indexOf('[measures].') > -1 && this.parent.dataType === 'olap' &&
                    (droppedClass === 'filters' || droppedClass === 'rows' || droppedClass === 'columns')) ||
                    (this.parent.engineModule.fieldList[fieldName] &&
                        this.parent.engineModule.fieldList[fieldName].isNamedSets && droppedClass === 'filters') ||
                    (this.parent.dataType === 'olap' && droppedClass === 'values' &&
                        actualFieldName.toLowerCase().indexOf('[measures].') === -1)) {
                    const title = this.parent.localeObj.getConstant('warning');
                    const description = this.parent.localeObj.getConstant('fieldDropErrorAction');
                    this.parent.errorDialog.createErrorDialog(title, description);
                    nodeDropped = false;
                    return nodeDropped;
                }
            }
            if (this.parent.dataType === 'pivot' && this.parent.engineModule.fieldList[fieldName] &&
                this.parent.engineModule.fieldList[fieldName].aggregateType === 'CalculatedField' && droppedClass !== 'values') {
                const title = this.parent.localeObj.getConstant('warning');
                const description = this.parent.localeObj.getConstant('dropAction');
                this.parent.errorDialog.createErrorDialog(title, description);
                nodeDropped = false;
                return nodeDropped;
            }
            droppedPosition = this.getButtonPosition(args.target, droppedClass);
        }
        else if (this.parent.engineModule.fieldList[fieldName]) {
            this.parent.engineModule.fieldList[fieldName].isSelected = false;
            if (this.parent.dataType === 'olap') {
                this.parent.engineModule.updateFieldlistData(fieldName);
            }
        }
        nodeDropped = this.parent.dataSourceUpdate.updateDataSource(fieldName, droppedClass, droppedPosition);
        return nodeDropped;
    }
    getButtonPosition(target, droppedClass) {
        let droppedPosition = -1;
        let targetBtn = closest(target, '.' + PIVOT_BUTTON_WRAPPER_CLASS);
        if (!isNullOrUndefined(targetBtn)) {
            targetBtn = targetBtn.querySelector('.' + PIVOT_BUTTON_CLASS);
            const axisPanel = this.parent.element.querySelector('.e-' + droppedClass);
            const pivotButtons = [].slice.call(axisPanel.querySelectorAll('.' + PIVOT_BUTTON_CLASS));
            for (let i = 0, n = pivotButtons.length; i < n; i++) {
                if (pivotButtons[i].id === targetBtn.id) {
                    droppedPosition = i;
                    break;
                }
            }
        }
        return droppedPosition;
    }
}

/**
 * `DataSourceUpdate` module is used to update the dataSource.
 */
/** @hidden */
class DataSourceUpdate {
    /**
     * Constructor for the dialog action.
     *
     * @param {PivotCommon} parent - Instance.
     * @hidden
     */
    constructor(parent) {
        this.parent = parent;
    }
    /**
     * Updates the dataSource by adding the given field along with field dropped position to the dataSource.
     *
     * @function updateDataSource
     * @param  {string} fieldName - Defines dropped field name to update dataSource.
     * @param  {string} droppedClass -  Defines dropped field axis name to update dataSource.
     * @param  {number} droppedPosition - Defines dropped position to the axis based on field position.
     * @returns {void}
     * @hidden
     */
    updateDataSource(fieldName, droppedClass, droppedPosition) {
        let dataSourceItem;
        let draggedClass;
        let draggedPosition = -1;
        let nodeDropped = true;
        const row = this.parent.dataSourceSettings.rows;
        const column = this.parent.dataSourceSettings.columns;
        const value = this.parent.dataSourceSettings.values;
        const filter = this.parent.dataSourceSettings.filters;
        const field = [row, column, value, filter];
        for (let len = 0, lnt = field.length; len < lnt; len++) {
            if (field[len]) {
                for (let i = 0, n = field[len].length; i < n; i++) {
                    if (field[len][i].name === fieldName || (this.parent.dataType === 'olap' &&
                        field[len][i].name.toLowerCase() === '[measures]' && field[len][i].name.toLowerCase() === fieldName)) {
                        draggedClass = len === 0 ? 'rows' : len === 1 ? 'columns' : len === 2 ? 'values' : 'filters';
                        draggedPosition = i;
                    }
                    if (!draggedClass) {
                        draggedClass = 'fieldList';
                    }
                }
            }
        }
        const eventdrop = {
            fieldName: fieldName, dropField: PivotUtil.getFieldInfo(fieldName, this.control).fieldItem,
            dataSourceSettings: PivotUtil.getClonedDataSourceSettings(this.parent.dataSourceSettings),
            dropAxis: droppedClass, dropPosition: droppedPosition, draggedAxis: draggedClass, cancel: false
        };
        const control = this.control.getModuleName() === 'pivotfieldlist' && this.control.isPopupView ?
            this.control.pivotGridModule : this.control;
        control.trigger(fieldDrop, eventdrop, (observedArgs) => {
            if (!observedArgs.cancel) {
                droppedClass = observedArgs.dropAxis;
                droppedPosition = observedArgs.dropPosition;
                fieldName = observedArgs.dropField ? observedArgs.dropField.name : observedArgs.fieldName;
                dataSourceItem = observedArgs.dropField;
                if (this.control && this.btnElement && this.btnElement.getAttribute('isvalue') === 'true') {
                    switch (droppedClass) {
                        case '':
                            this.control.setProperties({ dataSourceSettings: { values: [] } }, true);
                            break;
                        case 'rows':
                            droppedPosition = droppedPosition === this.parent.dataSourceSettings.rows.length ? -1 : droppedPosition;
                            this.control.setProperties({ dataSourceSettings: { valueAxis: 'row', valueIndex: droppedPosition } }, true);
                            break;
                        case 'columns':
                            droppedPosition = droppedPosition === this.parent.dataSourceSettings.columns.length ? -1 : droppedPosition;
                            this.control.setProperties({ dataSourceSettings: { valueAxis: 'column', valueIndex: droppedPosition } }, true);
                            break;
                    }
                }
                else {
                    // dataSourceItem = this.removeFieldFromReport(fieldName.toString());
                    // dataSourceItem = dataSourceItem ? dataSourceItem : this.getNewField(fieldName.toString());
                    this.removeFieldFromReport(fieldName.toString());
                    if (this.parent.dataType === 'pivot' && this.control.showValuesButton && this.parent.dataSourceSettings.values.length > 1) {
                        const dropAxisFields = (this.parent.dataSourceSettings.valueAxis === 'row' &&
                            droppedClass === 'rows') ? this.parent.dataSourceSettings.rows : (this.parent.dataSourceSettings.valueAxis === 'column' && droppedClass === 'columns') ?
                            this.parent.dataSourceSettings.columns : undefined;
                        if (draggedPosition < this.parent.dataSourceSettings.valueIndex && ((this.parent.dataSourceSettings.valueAxis === 'row' &&
                            draggedClass === 'rows') || (this.parent.dataSourceSettings.valueAxis === 'column' && draggedClass === 'columns'))) {
                            this.control.setProperties({
                                dataSourceSettings: { valueIndex: this.parent.dataSourceSettings.valueIndex - 1 }
                            }, true);
                        }
                        if (!isNullOrUndefined(dropAxisFields)) {
                            if (droppedPosition === -1 && this.parent.dataSourceSettings.valueIndex === -1) {
                                this.control.setProperties({
                                    dataSourceSettings: { valueIndex: dropAxisFields.length }
                                }, true);
                            }
                            else if (droppedPosition > -1 && droppedPosition <= this.parent.dataSourceSettings.valueIndex) {
                                this.control.setProperties({
                                    dataSourceSettings: { valueIndex: this.parent.dataSourceSettings.valueIndex + 1 }
                                }, true);
                            }
                            else if (this.parent.dataSourceSettings.valueIndex > -1 &&
                                droppedPosition > this.parent.dataSourceSettings.valueIndex) {
                                droppedPosition = droppedPosition - 1;
                            }
                        }
                    }
                    dataSourceItem = this.getNewField(fieldName.toString(), observedArgs.dropField);
                    if (dataSourceItem.type === 'CalculatedField' && droppedClass !== '') {
                        droppedClass = 'values';
                    }
                }
                if (this.parent.dataType === 'olap') {
                    // dataSourceItem = this.removeFieldFromReport(fieldName.toString());
                    // dataSourceItem = dataSourceItem ? dataSourceItem : this.getNewField(fieldName.toString());
                    this.removeFieldFromReport(fieldName.toString());
                    dataSourceItem = this.getNewField(fieldName.toString(), observedArgs.dropField);
                    if (this.parent.dataSourceSettings.values.length === 0) {
                        this.removeFieldFromReport('[measures]');
                    }
                    if (dataSourceItem.type === 'CalculatedField' && droppedClass !== '') {
                        droppedClass = 'values';
                    }
                }
                if (this.control) {
                    const eventArgs = {
                        fieldName: fieldName, droppedField: dataSourceItem,
                        dataSourceSettings: PivotUtil.getClonedDataSourceSettings(this.parent.dataSourceSettings),
                        droppedAxis: droppedClass, droppedPosition: droppedPosition
                    };
                    control.trigger(onFieldDropped, eventArgs, (droppedArgs) => {
                        dataSourceItem = droppedArgs.droppedField;
                        if (dataSourceItem) {
                            droppedPosition = droppedArgs.droppedPosition;
                            droppedClass = droppedArgs.droppedAxis;
                            switch (droppedClass) {
                                case 'filters':
                                    if (droppedPosition !== -1) {
                                        this.parent.dataSourceSettings.filters.splice(droppedPosition, 0, dataSourceItem);
                                    }
                                    else {
                                        this.parent.dataSourceSettings.filters.push(dataSourceItem);
                                    }
                                    break;
                                case 'rows':
                                    if (droppedPosition !== -1) {
                                        this.parent.dataSourceSettings.rows.splice(droppedPosition, 0, dataSourceItem);
                                    }
                                    else {
                                        this.parent.dataSourceSettings.rows.push(dataSourceItem);
                                    }
                                    break;
                                case 'columns':
                                    if (droppedPosition !== -1) {
                                        this.parent.dataSourceSettings.columns.splice(droppedPosition, 0, dataSourceItem);
                                    }
                                    else {
                                        this.parent.dataSourceSettings.columns.push(dataSourceItem);
                                    }
                                    break;
                                case 'values':
                                    if (droppedPosition !== -1) {
                                        this.parent.dataSourceSettings.values.splice(droppedPosition, 0, dataSourceItem);
                                    }
                                    else {
                                        this.parent.dataSourceSettings.values.push(dataSourceItem);
                                    }
                                    if (this.parent.dataType === 'olap' && !this.parent.engineModule.isMeasureAvail && !(this.parent.dataSourceSettings.values.length > 1)) {
                                        const measureField = {
                                            name: '[Measures]', caption: 'Measures', showRemoveIcon: true, allowDragAndDrop: true
                                        };
                                        const fieldAxis = this.parent.dataSourceSettings.valueAxis === 'row' ?
                                            this.parent.dataSourceSettings.rows : this.parent.dataSourceSettings.columns;
                                        fieldAxis.push(measureField);
                                    }
                                    break;
                            }
                        }
                    });
                }
            }
            else {
                nodeDropped = false;
            }
        });
        return nodeDropped;
    }
    /**
     * Updates the dataSource by removing the given field from the dataSource.
     *
     * @param  {string} fieldName - Defines dropped field name to remove dataSource.
     * @function removeFieldFromReport
     * @returns {void}
     * @hidden
     */
    removeFieldFromReport(fieldName) {
        let dataSourceItem;
        let isDataSource = false;
        const rows = this.parent.dataSourceSettings.rows;
        const columns = this.parent.dataSourceSettings.columns;
        const values = this.parent.dataSourceSettings.values;
        const filters = this.parent.dataSourceSettings.filters;
        const fields = [rows, columns, values, filters];
        const field = this.parent.engineModule.fieldList[fieldName];
        for (let len = 0, lnt = fields.length; len < lnt; len++) {
            if (!isDataSource && fields[len]) {
                for (let i = 0, n = fields[len].length; i < n; i++) {
                    if (fields[len][i].name === fieldName || (this.parent.dataType === 'olap' &&
                        fields[len][i].name.toLowerCase() === '[measures]' && fields[len][i].name.toLowerCase() === fieldName)) {
                        dataSourceItem = fields[len][i].properties ?
                            fields[len][i].properties :
                            fields[len][i];
                        dataSourceItem.type = (field && field.type === 'number') ? dataSourceItem.type :
                            'Count';
                        fields[len].splice(i, 1);
                        if (this.parent.dataType === 'olap') {
                            const engineModule = this.parent.engineModule;
                            if (engineModule && engineModule.fieldList[fieldName]) {
                                engineModule.fieldList[fieldName].currrentMembers = {};
                                engineModule.fieldList[fieldName].searchMembers = [];
                            }
                        }
                        isDataSource = true;
                        break;
                    }
                }
            }
        }
        return dataSourceItem;
    }
    /**
     * Creates new field object given field name from the field list data.
     *
     * @param {string} fieldName - Defines dropped field name to add dataSource.
     * @param {IFieldOptions} fieldItem - Defines dropped field.
     * @function getNewField
     * @returns {IFieldOptions} - It return new field.
     * @hidden
     */
    getNewField(fieldName, fieldItem) {
        let newField;
        if (this.parent.dataType === 'olap') {
            const field = this.parent.engineModule.fieldList[fieldName];
            newField = {
                name: fieldItem ? fieldItem.name : fieldName,
                caption: fieldItem ? fieldItem.caption : field.caption,
                isNamedSet: fieldItem ? fieldItem.isNamedSet : field.isNamedSets,
                isCalculatedField: fieldItem ? fieldItem.isCalculatedField : field.isCalculatedField,
                type: (fieldItem ? (fieldItem.type === undefined ? field.type === 'number' ? 'Sum' :
                    'Count' : fieldItem.type) :
                    (field.aggregateType === undefined ? field.type === 'number' ? 'Sum' :
                        'Count' : field.aggregateType)),
                showFilterIcon: fieldItem ? fieldItem.showFilterIcon : field.showFilterIcon,
                showSortIcon: fieldItem ? fieldItem.showSortIcon : field.showSortIcon,
                showEditIcon: fieldItem ? fieldItem.showEditIcon : field.showEditIcon,
                showRemoveIcon: fieldItem ? fieldItem.showRemoveIcon : field.showRemoveIcon,
                showValueTypeIcon: fieldItem ? fieldItem.showValueTypeIcon : field.showValueTypeIcon,
                allowDragAndDrop: fieldItem ? fieldItem.allowDragAndDrop : field.allowDragAndDrop,
                showSubTotals: fieldItem ? fieldItem.showSubTotals : field.showSubTotals,
                expandAll: fieldItem ? fieldItem.expandAll : field.expandAll
            };
        }
        else {
            const field = this.parent.engineModule.fieldList[fieldName];
            newField = {
                name: fieldItem ? fieldItem.name : fieldName,
                caption: fieldItem ? fieldItem.caption : field.caption,
                type: (fieldItem ? ((fieldItem.type === undefined || fieldItem.type === null) ?
                    field.type === 'number' ? 'Sum' : 'Count' : fieldItem.type) :
                    ((field.aggregateType === undefined || field.aggregateType === null) ?
                        field.type === 'number' ? 'Sum' :
                            'Count' : field.aggregateType)),
                showNoDataItems: fieldItem ? fieldItem.showNoDataItems : field.showNoDataItems,
                baseField: fieldItem ? fieldItem.baseField : field.baseField,
                baseItem: fieldItem ? fieldItem.baseItem : field.baseItem,
                allowDragAndDrop: fieldItem ? fieldItem.allowDragAndDrop : field.allowDragAndDrop,
                showSubTotals: fieldItem ? fieldItem.showSubTotals : field.showSubTotals,
                showFilterIcon: fieldItem ? fieldItem.showFilterIcon : field.showFilterIcon,
                showSortIcon: fieldItem ? fieldItem.showSortIcon : field.showSortIcon,
                showEditIcon: fieldItem ? fieldItem.showEditIcon : field.showEditIcon,
                showRemoveIcon: fieldItem ? fieldItem.showRemoveIcon : field.showRemoveIcon,
                showValueTypeIcon: fieldItem ? fieldItem.showValueTypeIcon : field.showValueTypeIcon,
                expandAll: fieldItem ? fieldItem.expandAll : field.expandAll
            };
        }
        return newField;
    }
}

/**
 * `ErrorDialog` module to create error dialog.
 */
/** @hidden */
class ErrorDialog {
    /**
     * Constructor for the dialog action.
     *
     * @param {PivotCommon} parent - parent.
     * @hidden
     */
    constructor(parent) {
        this.parent = parent;
    }
    /**
     * Creates the error dialog for the unexpected action done.
     *
     * @function createErrorDialog
     * @param {string} title - title.
     * @param {string} description - description.
     * @param {HTMLElement} target - target.
     * @returns {void}
     * @hidden
     */
    createErrorDialog(title, description, target) {
        const errorDialog = createElement('div', {
            id: this.parent.parentID + '_ErrorDialog',
            className: ERROR_DIALOG_CLASS
        });
        this.parent.element.appendChild(errorDialog);
        const zIndex = target ? Number(target.style.zIndex) + 1 : (this.parent.moduleName === 'pivotfieldlist' &&
            this.parent.renderMode === 'Popup' && this.parent.control ? this.parent.control.dialogRenderer.fieldListDialog.zIndex + 1 :
            (this.parent.moduleName === 'pivotfieldlist' && this.parent.renderMode === 'Fixed' && this.parent.control ? 1000002 :
                (this.parent.moduleName === 'pivotview' && this.parent.control ? 1000002 : 1000001)));
        this.errorPopUp = new Dialog({
            animationSettings: { effect: 'Fade' },
            allowDragging: false,
            header: title,
            content: description,
            isModal: true,
            visible: true,
            showCloseIcon: true,
            enableRtl: this.parent.enableRtl,
            enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
            width: 'auto',
            height: 'auto',
            zIndex: zIndex,
            position: { X: 'center', Y: 'center' },
            buttons: [
                {
                    click: this.closeErrorDialog.bind(this),
                    buttonModel: { cssClass: OK_BUTTON_CLASS + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''), content: this.parent.localeObj.getConstant('ok'), isPrimary: true }
                }
            ],
            cssClass: this.parent.cssClass,
            closeOnEscape: true,
            target: document.body,
            close: this.removeErrorDialog.bind(this)
        });
        this.errorPopUp.isStringTemplate = true;
        this.errorPopUp.appendTo(errorDialog);
    }
    closeErrorDialog() {
        this.errorPopUp.close();
    }
    removeErrorDialog() {
        if (this.errorPopUp && !this.errorPopUp.isDestroyed) {
            this.errorPopUp.destroy();
        }
        if (document.getElementById(this.parent.parentID + '_ErrorDialog')) {
            remove(document.getElementById(this.parent.parentID + '_ErrorDialog'));
        }
    }
}

/**
 * `FilterDialog` module to create filter dialog.
 */
/** @hidden */
class FilterDialog {
    /**
     * Constructor for the dialog action.
     *
     * @param {PivotCommon} parent - parent
     * @hidden
     */
    constructor(parent) {
        this.parent = parent;
    }
    /**
     * Creates the member filter dialog for the selected field.
     *
     * @function createFilterDialog
     * @param {any} treeData -treeData.
     * @param {string} fieldName -fieldName.
     * @param {string} fieldCaption -fieldCaption.
     * @param {HTMLElement} target -target.
     * @returns {void}
     * @hidden
     */
    createFilterDialog(treeData, fieldName, fieldCaption, target) {
        const editorDialog = createElement('div', {
            id: this.parent.parentID + '_EditorTreeView',
            className: MEMBER_EDITOR_DIALOG_CLASS + ' ' + (this.parent.dataType === 'olap' ? 'e-olap-editor-dialog' : '') + (this.parent.isDataOverflow ? ' ' + PIVOT_FILTER_MEMBER_LIMIT : ''),
            attrs: { 'data-fieldName': fieldName, 'aria-label': fieldCaption }
        });
        const filterCaption = this.parent.engineModule.fieldList[fieldName].caption;
        const headerTemplate = this.parent.localeObj.getConstant('filter') + ' ' +
            '"' + fieldCaption + '"' + ' ' + this.parent.localeObj.getConstant('by');
        this.filterObject = this.getFilterObject(fieldName);
        this.isSearchEnabled = false;
        this.allowExcelLikeFilter = this.isExcelFilter(fieldName);
        this.parent.element.appendChild(editorDialog);
        this.dialogPopUp = new Dialog({
            animationSettings: { effect: (this.allowExcelLikeFilter ? 'None' : 'Fade') },
            allowDragging: false,
            header: (this.allowExcelLikeFilter ? headerTemplate : filterCaption),
            // content: (this.allowExcelLikeFilter ? '' : this.createTreeView(treeData, fieldCaption, fieldName)),
            content: '',
            isModal: true,
            visible: true,
            showCloseIcon: this.allowExcelLikeFilter ? true : false,
            enableRtl: this.parent.enableRtl,
            enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
            width: '320px',
            height: this.parent.isDataOverflow ? (this.allowExcelLikeFilter ? '440px' : '400px') :
                (this.allowExcelLikeFilter ? '400px' : '350px'),
            position: { X: 'center', Y: 'center' },
            buttons: [
                {
                    buttonModel: {
                        cssClass: 'e-clear-filter-button' + (this.allowExcelLikeFilter ? '' : ' ' + ICON_DISABLE) + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
                        iconCss: 'e-icons e-clear-filter-icon', enableRtl: this.parent.enableRtl,
                        content: this.parent.localeObj.getConstant('clearFilter'), disabled: (this.filterObject ? false : true)
                    }
                },
                {
                    buttonModel: {
                        cssClass: OK_BUTTON_CLASS + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''), content: this.parent.localeObj.getConstant('ok'), isPrimary: true
                    }
                },
                {
                    click: this.closeFilterDialog.bind(this),
                    buttonModel: { cssClass: CANCEL_BUTTON_CLASS + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''), content: this.parent.localeObj.getConstant('cancel') }
                }
            ],
            closeOnEscape: this.parent.renderMode === 'Popup' ? false : true,
            target: target,
            cssClass: this.parent.cssClass,
            close: this.removeFilterDialog.bind(this)
        });
        this.dialogPopUp.isStringTemplate = true;
        this.dialogPopUp.appendTo(editorDialog);
        const filterArgs = {
            cancel: false,
            fieldName: fieldName,
            fieldMembers: this.parent.dataSourceSettings.allowMemberFilter ? treeData : [],
            filterSetting: this.filterObject
        };
        const control = this.parent.moduleName === 'pivotfieldlist' && this.parent.control.isPopupView ?
            this.parent.control.pivotGridModule : this.parent.control;
        control.trigger(memberEditorOpen, filterArgs, (observedArgs) => {
            if (!observedArgs.cancel) {
                treeData = observedArgs.fieldMembers;
                if (this.allowExcelLikeFilter) {
                    this.createTabMenu(treeData, fieldCaption, fieldName);
                    addClass([this.dialogPopUp.element], 'e-excel-filter');
                    this.updateCheckedState();
                }
                else {
                    this.dialogPopUp.content = this.createTreeView(treeData, fieldCaption, fieldName);
                    this.updateCheckedState();
                }
                setStyleAttribute(this.dialogPopUp.element, { 'visibility': 'visible' });
                if (this.allowExcelLikeFilter) {
                    this.dialogPopUp.element.querySelector('.e-dlg-closeicon-btn').focus();
                }
                this.memberTreeView.nodeChecked =
                    this.parent.control.pivotButtonModule.nodeStateModified.bind(this.parent.control.pivotButtonModule);
                this.allMemberSelect.nodeChecked =
                    this.parent.control.pivotButtonModule.nodeStateModified.bind(this.parent.control.pivotButtonModule);
            }
            else {
                this.dialogPopUp.close();
                this.dialogPopUp = undefined;
            }
        });
    }
    createTreeView(treeData, fieldCaption, fieldName) {
        const editorTreeWrapper = createElement('div', {
            id: this.parent.parentID + 'EditorDiv',
            className: EDITOR_TREE_WRAPPER_CLASS + (this.allowExcelLikeFilter ? ' e-excelfilter' : '')
        });
        const levelWrapper = createElement('button', {
            id: this.parent.parentID + '_LevelDiv',
            className: 'e-level-container-class', attrs: { 'type': 'button' }
        });
        const searchWrapper = createElement('div', {
            id: this.parent.parentID + '_SearchDiv', attrs: { 'tabindex': '-1' },
            className: EDITOR_SEARCH_WRAPPER_CLASS
        });
        const filterCaption = this.parent.engineModule.fieldList[fieldName].caption;
        const editorSearch = createElement('input', {
            attrs: { 'type': 'text', className: EDITOR_SEARCH__INPUT_CLASS }
        });
        const nodeLimitText = this.parent.isDataOverflow ?
            ((this.parent.currentTreeItems.length - this.parent.control.maxNodeLimitInMemberEditor) +
                this.parent.control.localeObj.getConstant('editorDataLimitMsg')) : '';
        const labelWrapper = createElement('div', {
            id: this.parent.parentID + '_LabelDiv',
            attrs: { 'tabindex': '-1', 'title': nodeLimitText },
            className: EDITOR_LABEL_WRAPPER_CLASS
        });
        this.parent.editorLabelElement = createElement('label', { className: EDITOR_LABEL_CLASS });
        this.parent.editorLabelElement.innerText = nodeLimitText;
        labelWrapper.style.display = this.parent.isDataOverflow ? 'block' : 'none';
        labelWrapper.appendChild(this.parent.editorLabelElement);
        searchWrapper.appendChild(editorSearch);
        this.createSortOptions(fieldName, searchWrapper, treeData);
        const selectAllWrapper = createElement('div', {
            id: this.parent.parentID + '_AllDiv', attrs: { 'tabindex': '-1' },
            className: SELECT_ALL_WRAPPER_CLASS
        });
        const selectAllContainer = createElement('div', { id: this.parent.parentID + '_SelectAllContainer', className: SELECT_ALL_CLASS });
        const treeOuterDiv = createElement('div', { className: EDITOR_TREE_CONTAINER_CLASS + '-outer-div' });
        const treeViewContainer = createElement('div', { className: EDITOR_TREE_CONTAINER_CLASS });
        const promptDiv = createElement('div', {
            className: EMPTY_MEMBER_CLASS + ' ' + ICON_DISABLE
        });
        promptDiv.innerText = this.parent.localeObj.getConstant('noMatches');
        if (this.parent.dataType === 'olap' && this.parent.control.loadOnDemandInMemberEditor &&
            !this.parent.engineModule.fieldList[fieldName].isHierarchy &&
            !this.parent.engineModule.fieldList[fieldName].isNamedSets) {
            searchWrapper.appendChild(levelWrapper);
            this.createLevelWrapper(levelWrapper, fieldName);
        }
        selectAllWrapper.appendChild(selectAllContainer);
        editorTreeWrapper.appendChild(searchWrapper);
        editorTreeWrapper.appendChild(selectAllWrapper);
        editorTreeWrapper.appendChild(promptDiv);
        this.editorSearch = new MaskedTextBox({
            placeholder: this.parent.localeObj.getConstant('search') + ' ' + '&#8220' + filterCaption + '&#8220',
            enableRtl: this.parent.enableRtl,
            cssClass: EDITOR_SEARCH_CLASS + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
            showClearButton: true,
            change: (e) => {
                if (this.parent.dataType === 'olap') {
                    this.searchOlapTreeView(e, promptDiv);
                }
                else {
                    this.parent.eventBase.searchTreeNodes(e, this.memberTreeView, false);
                    const filterDialog = this.dialogPopUp.element;
                    const liList = [].slice.call(this.memberTreeView.element.querySelectorAll('li'));
                    if (liList.length === 0) {
                        this.allMemberSelect.disableNodes([this.allMemberSelect.element.querySelector('li')]);
                        filterDialog.querySelector('.' + OK_BUTTON_CLASS).setAttribute('disabled', 'disabled');
                        removeClass([promptDiv], ICON_DISABLE);
                    }
                    else {
                        this.allMemberSelect.enableNodes([this.allMemberSelect.element.querySelector('li')]);
                        filterDialog.querySelector('.' + OK_BUTTON_CLASS).removeAttribute('disabled');
                        addClass([promptDiv], ICON_DISABLE);
                    }
                    this.updateCheckedState();
                }
            }
        });
        this.editorSearch.isStringTemplate = true;
        this.editorSearch.appendTo(editorSearch);
        const nodeAttr = { 'data-fieldName': fieldName, 'data-memberId': 'all' };
        const data = [{ id: 'all', name: this.parent.localeObj.getConstant('all'), isSelected: true, htmlAttributes: nodeAttr }];
        this.allMemberSelect = new TreeView({
            fields: { dataSource: data, id: 'id', text: 'name', isChecked: 'isSelected' },
            showCheckBox: true,
            expandOn: 'None',
            enableRtl: this.parent.enableRtl,
            enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
            nodeClicked: this.nodeCheck.bind(this, true),
            keyPress: this.nodeCheck.bind(this, true),
            nodeSelected: (args) => {
                removeClass([args.node], 'e-active');
                args.cancel = true;
            },
            cssClass: this.parent.cssClass
        });
        this.allMemberSelect.isStringTemplate = true;
        if (!isNullOrUndefined(this.parent.currentTreeItems)) {
            for (let i = 0; i < this.parent.currentTreeItems.length; i++) { // eslint-disable-next-line @typescript-eslint/no-explicit-any
                if (this.parent.currentTreeItems[i].id.indexOf('\n') || this.parent.currentTreeItems[i].id.startsWith('\n')) {
                    this.parent.currentTreeItems[i].id = this.parent.currentTreeItems[i].id.replace('\n', ' ');
                }
            }
        }
        this.allMemberSelect.appendTo(selectAllContainer);
        treeOuterDiv.appendChild(treeViewContainer);
        editorTreeWrapper.appendChild(treeOuterDiv);
        this.memberTreeView = new TreeView({
            fields: { dataSource: treeData, id: 'id', text: 'name', isChecked: 'isSelected', parentID: 'pid' },
            showCheckBox: true,
            enableRtl: this.parent.enableRtl,
            enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
            nodeChecking: this.validateTreeNode.bind(this),
            nodeClicked: this.nodeCheck.bind(this, false),
            keyPress: this.nodeCheck.bind(this, false),
            nodeExpanding: this.updateChildNodes.bind(this),
            nodeSelected: (args) => {
                removeClass([args.node], 'e-active');
                args.cancel = true;
            },
            expandOn: 'None',
            cssClass: this.parent.cssClass
        });
        this.memberTreeView.isStringTemplate = true;
        this.memberTreeView.appendTo(treeViewContainer);
        if (this.parent.isDataOverflow && (this.parent.control.maxNodeLimitInMemberEditor < this.parent.currentTreeItems.length)) {
            editorTreeWrapper.appendChild(labelWrapper);
        }
        return editorTreeWrapper;
    }
    createSortOptions(fieldName, target, treeData) {
        if (this.parent.dataType === 'pivot' && treeData && treeData.length > 0) {
            const sortOrder = this.parent.engineModule.fieldList[fieldName].sort;
            const sortWrapper = createElement('div', {
                className: FILTER_SORT_CLASS + ' e-btn-group' + (this.parent.enableRtl ? ' ' + RTL : '') + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
                id: this.parent.element.id + '_Member_Sort'
            });
            this.parent.element.appendChild(sortWrapper);
            const sortAscendElement = createElement('button', {
                className: (sortOrder === 'Ascending' ? SORT_SELECTED_CLASS + ' ' : '') + MEMBER_SORT_CLASS,
                id: this.parent.element.id + '_Sort_Ascend', attrs: { 'type': 'button', 'aria-label': 'button' }
            });
            const sortDescendElement = createElement('button', {
                className: (sortOrder === 'Descending' ? SORT_SELECTED_CLASS + ' ' : '') + MEMBER_SORT_CLASS,
                id: this.parent.element.id + '_Sort_Descend', attrs: { 'type': 'button', 'aria-label': 'button' }
            });
            let sortBtnElement = new Button({
                iconCss: ICON + ' ' + SORT_ASCEND_ICON_CLASS, enableRtl: this.parent.enableRtl, cssClass: this.parent.cssClass, enableHtmlSanitizer: this.parent.enableHtmlSanitizer
            });
            sortBtnElement.appendTo(sortAscendElement);
            sortBtnElement = new Button({
                iconCss: ICON + ' ' + SORT_DESCEND_ICON_CLASS, enableRtl: this.parent.enableRtl, cssClass: this.parent.cssClass, enableHtmlSanitizer: this.parent.enableHtmlSanitizer
            });
            sortBtnElement.appendTo(sortDescendElement);
            sortWrapper.appendChild(sortAscendElement);
            sortWrapper.appendChild(sortDescendElement);
            target.appendChild(sortWrapper);
            this.unWireEvent(sortAscendElement);
            this.unWireEvent(sortDescendElement);
            this.wireEvent(sortAscendElement, fieldName);
            this.wireEvent(sortDescendElement, fieldName);
        }
    }
    createLevelWrapper(levelWrapper, fieldName) {
        const engineModule = this.parent.engineModule;
        const levels = engineModule.fieldList[fieldName].levels;
        const levelCount = engineModule.fieldList[fieldName].levelCount;
        const items = [];
        for (let i = 0, cnt = levels.length; i < cnt; i++) {
            items.push({ id: levels[i].id, text: levels[i].name });
        }
        this.dropMenu = new DropDownButton({
            cssClass: 'e-level-drop e-caret-hide' + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
            items: items, iconCss: 'e-icons e-dropdown-icon',
            disabled: (levelCount === levels.length),
            enableRtl: this.parent.enableRtl,
            enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
            beforeOpen: (args) => {
                const items = [].slice.call(args.element.querySelectorAll('li'));
                const engineModule = this.parent.engineModule;
                const levelCount = engineModule.fieldList[fieldName].levelCount;
                removeClass(items, MENU_DISABLE);
                for (let i = 0, cnt = items.length; i < cnt; i++) {
                    if (i < levelCount) {
                        addClass([items[i]], MENU_DISABLE);
                    }
                }
            },
            select: (args) => {
                const fieldName = this.dialogPopUp.element.getAttribute('data-fieldname');
                const engineModule = this.parent.engineModule;
                let selectedLevel;
                for (let i = 0, cnt = items.length; i < cnt; i++) {
                    if (items[i].id === args.item.id) {
                        selectedLevel = i;
                    }
                }
                engineModule.getFilterMembers(this.parent.dataSourceSettings, fieldName, selectedLevel + 1, false, true);
            },
            close: () => {
                const engineModule = this.parent.engineModule;
                const levels = engineModule.fieldList[fieldName].levels;
                const levelCount = engineModule.fieldList[fieldName].levelCount;
                if (levelCount === levels.length) {
                    this.dropMenu.disabled = true;
                    this.dropMenu.dataBind();
                }
                else {
                    this.dropMenu.disabled = false;
                }
            }
        });
        this.dropMenu.appendTo(levelWrapper);
    }
    searchOlapTreeView(e, promptDiv) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const popupInstance = this;
        clearTimeout(this.timeOutObj);
        this.timeOutObj = setTimeout(function () {
            const engineModule = popupInstance.parent.engineModule;
            const filterDialog = popupInstance.dialogPopUp.element;
            const fieldName = filterDialog.getAttribute('data-fieldname');
            const nodeLimit = popupInstance.parent.control.maxNodeLimitInMemberEditor ?
                popupInstance.parent.control.maxNodeLimitInMemberEditor : 5000;
            if (!engineModule.fieldList[fieldName].isHierarchy) {
                if (popupInstance.dropMenu && e.value !== '') {
                    popupInstance.dropMenu.disabled = true;
                }
                else {
                    popupInstance.dropMenu.disabled = false;
                }
                if (!popupInstance.parent.control.loadOnDemandInMemberEditor) {
                    engineModule.getSearchMembers(popupInstance.parent.dataSourceSettings, fieldName, e.value.toLowerCase(), nodeLimit, true);
                }
                else {
                    const levelCount = engineModule.fieldList[fieldName].levelCount ?
                        engineModule.fieldList[fieldName].levelCount : 1;
                    engineModule.getSearchMembers(popupInstance.parent.dataSourceSettings, fieldName, e.value.toLowerCase(), nodeLimit, false, levelCount);
                }
                popupInstance.parent.eventBase.searchTreeNodes(e, popupInstance.memberTreeView, false, false);
            }
            else {
                popupInstance.parent.eventBase.searchTreeNodes(e, popupInstance.memberTreeView, false, true);
            }
            const liList = [].slice.call(popupInstance.memberTreeView.element.querySelectorAll('li'));
            // for (let element of liList) {
            //     if (element.querySelector('.interaction')) {
            //         setStyleAttribute(element.querySelector('.interaction'), { display: 'none' });
            //     }
            // }
            if (liList.length === 0) {
                popupInstance.allMemberSelect.disableNodes([popupInstance.allMemberSelect.element.querySelector('li')]);
                filterDialog.querySelector('.' + OK_BUTTON_CLASS).setAttribute('disabled', 'disabled');
                removeClass([promptDiv], ICON_DISABLE);
            }
            else {
                popupInstance.allMemberSelect.enableNodes([popupInstance.allMemberSelect.element.querySelector('li')]);
                filterDialog.querySelector('.' + OK_BUTTON_CLASS).removeAttribute('disabled');
                addClass([promptDiv], ICON_DISABLE);
            }
            popupInstance.updateCheckedState();
        }, 500);
    }
    /* eslint-disable @typescript-eslint/no-explicit-any */
    nodeCheck(isAllMember, args) {
        const checkedNode = [args.node];
        const target = args.event.target;
        if (target.classList.contains('e-fullrow') || args.event.key === 'Enter') {
            const memberObj = isAllMember ? this.allMemberSelect : this.memberTreeView;
            const getNodeDetails = memberObj.getNode(args.node);
            if (getNodeDetails.isChecked === 'true') {
                memberObj.uncheckAll(checkedNode);
            }
            else {
                memberObj.checkAll(checkedNode);
            }
        }
        else if (args.event.keyCode === 38 && !isAllMember) {
            removeClass(this.memberTreeView.element.querySelectorAll('li.e-prev-active-node'), 'e-prev-active-node');
            addClass(checkedNode, 'e-prev-active-node');
        }
    } /* eslint-enable @typescript-eslint/no-explicit-any */
    applySorting(fieldName, args) {
        const target = closest(args.target, '.' + MEMBER_SORT_CLASS);
        if (target) {
            const sortElements = [].slice.call(closest(target, '.' + FILTER_SORT_CLASS).querySelectorAll('.' + MEMBER_SORT_CLASS));
            if (target.querySelector('.' + SORT_ASCEND_ICON_CLASS) && !target.classList.contains(SORT_SELECTED_CLASS)) {
                this.updateFilterMembers('Ascending', fieldName);
                addClass([target], SORT_SELECTED_CLASS);
                removeClass([sortElements[1]], SORT_SELECTED_CLASS);
            }
            else if (target.querySelector('.' + SORT_DESCEND_ICON_CLASS) && !target.classList.contains(SORT_SELECTED_CLASS)) {
                this.updateFilterMembers('Descending', fieldName);
                addClass([target], SORT_SELECTED_CLASS);
                removeClass([sortElements[0]], SORT_SELECTED_CLASS);
            }
            else {
                this.updateFilterMembers('None', fieldName);
                removeClass(sortElements, SORT_SELECTED_CLASS);
            }
        }
    }
    updateFilterMembers(order, fieldName) {
        const fieldInfo = this.parent.engineModule.fieldList[fieldName];
        let members = order === 'None' ?
            PivotUtil.getClonedData(fieldInfo.dateMember) :
            [...this.parent.currentTreeItems];
        const sortType = fieldInfo.isAlphanumeric ? true : undefined;
        let isHeaderSortByDefault = false;
        const membersInfo = fieldInfo && fieldInfo.membersOrder ?
            [...fieldInfo.membersOrder] : [];
        const sortDetails = {
            fieldName: fieldName,
            sortOrder: order,
            members: membersInfo && membersInfo.length > 0 ? membersInfo : Object.keys(members),
            IsOrderChanged: false
        };
        if (membersInfo && membersInfo.length > 0) {
            members = PivotUtil.applyCustomSort(sortDetails, members, sortType);
        }
        else {
            members = PivotUtil.applyHeadersSort(members, sortDetails.sortOrder, sortType);
            isHeaderSortByDefault = true;
        }
        const control = this.parent.moduleName === 'pivotfieldlist' && this.parent.control.isPopupView ?
            this.parent.control.pivotGridModule : this.parent.control;
        if (isHeaderSortByDefault) {
            const copyOrder = [];
            for (let m = 0, n = 0; m < members.length; m++) {
                if (members[m].actualText !== 'Grand Total') {
                    copyOrder[n++] = members[m].actualText;
                }
            }
            sortDetails.members = copyOrder;
        }
        control.trigger(onHeadersSort, sortDetails);
        if (sortDetails.IsOrderChanged) {
            members = PivotUtil.applyCustomSort(sortDetails, members, sortType, true);
        }
        this.parent.currentTreeItems = [];
        this.parent.searchTreeItems = [];
        const treeData = [];
        const modifiedFieldName = fieldName.replace(/[^a-zA-Z0-9 ]/g, '_');
        for (let i = 0, lnt = members.length; i < lnt; i++) {
            if (order === 'None') {
                const memberName = (this.parent.isDateField ?
                    members[i].formattedText : members[i].actualText).toString();
                const nodeAttr = { 'data-fieldName': fieldName, 'data-memberId': members[i].actualText.toString() };
                const obj = {
                    id: modifiedFieldName + '_' + (i + 1),
                    htmlAttributes: nodeAttr,
                    actualText: members[i].actualText,
                    name: memberName,
                    isSelected: this.parent.currentTreeItemsPos[members[i].actualText].isSelected
                };
                this.parent.currentTreeItems.push(obj);
                if (this.editorSearch.value !== '') {
                    if (obj.name.toLowerCase().indexOf(this.editorSearch.value.toLowerCase()) > -1) {
                        this.parent.searchTreeItems.push(obj);
                        treeData.push(obj);
                    }
                }
                else {
                    this.parent.searchTreeItems.push(obj);
                    treeData.push(obj);
                }
            }
            else {
                this.parent.currentTreeItems.push(members[i]);
                if (this.editorSearch.value !== '') {
                    if (members[i].name.toLowerCase().indexOf(this.editorSearch.value.toLowerCase()) > -1) {
                        this.parent.searchTreeItems.push(members[i]);
                        treeData.push(members[i]);
                    }
                }
                else {
                    this.parent.searchTreeItems.push(members[i]);
                    treeData.push(members[i]);
                }
            }
            this.parent.currentTreeItemsPos[members[i].actualText].index = i;
        }
        const dataCount = this.memberTreeView.fields.dataSource.length;
        this.memberTreeView.fields = { dataSource: treeData.slice(0, dataCount), id: 'id', text: 'name', isChecked: 'isSelected', parentID: 'pid' };
        this.memberTreeView.dataBind();
    }
    updateChildNodes(args) {
        if (this.parent.dataType === 'olap') {
            const engineModule = this.parent.engineModule;
            const fieldName = args.node.getAttribute('data-fieldname');
            const fieldList = engineModule.fieldList[fieldName];
            let filterItems = [];
            if (fieldList && fieldList.filterMembers.length > 0 && !this.isSearchEnabled &&
                !fieldList.members[args.nodeData.id].isNodeExpand) {
                let childNodes = [];
                for (const item of fieldList.filterMembers) {
                    if (item.pid === args.nodeData.id.toString()) {
                        childNodes.push(item);
                    }
                }
                if (childNodes.length === 0) {
                    fieldList.childMembers = [];
                    engineModule.getChildMembers(this.parent.dataSourceSettings, args.nodeData.id.toString(), fieldName);
                    childNodes = fieldList.childMembers;
                    fieldList.childMembers = [];
                }
                let treeData = PivotUtil.getClonedData(childNodes);
                const curTreeData = this.memberTreeView.fields.dataSource;
                let isInclude = false;
                if (!isNullOrUndefined(this.filterObject)) {
                    isInclude = this.filterObject.type === 'Include' ? true : false;
                    filterItems = this.filterObject.items ? this.filterObject.items : [];
                }
                treeData = this.updateChildData(isInclude, treeData, filterItems, fieldName, args.nodeData);
                treeData = this.parent.eventBase.sortOlapFilterData(treeData, engineModule.fieldList[fieldName].sort);
                for (const node of treeData) {
                    curTreeData.push(node);
                }
                fieldList.members[args.nodeData.id].isNodeExpand = true;
                this.memberTreeView.addNodes(treeData, args.node);
            }
        }
    }
    updateChildData(isInclude, members, filterItems, fieldName, parentNode) {
        let memberCount = Object.keys(this.parent.currentTreeItemsPos).length;
        const fieldList = this.parent.engineModule.fieldList[fieldName];
        const list = [];
        let childMemberCount = 1;
        for (const member of members) {
            const obj = member;
            const memberName = member.id.toString();
            fieldList.members[memberName].isNodeExpand = false;
            member.isSelected = (parentNode.isChecked === 'true');
            if (childMemberCount <= this.parent.control.maxNodeLimitInMemberEditor) {
                list.push(obj);
            }
            this.parent.currentTreeItems.push(obj);
            this.parent.searchTreeItems.push(obj);
            this.parent.currentTreeItemsPos[memberName] = { index: memberCount, isSelected: obj.isSelected };
            memberCount++;
            childMemberCount++;
        }
        this.parent.isDataOverflow = false;
        return list;
    }
    createTabMenu(treeData, fieldCaption, fieldName) {
        const wrapper = createElement('div', {
            id: this.parent.parentID + '_FilterTabContainer',
            className: PIVOT_FILTER_TAB_CONTAINER,
            attrs: {
                'tabindex': '-1'
            }
        });
        this.dialogPopUp.content = wrapper;
        this.dialogPopUp.dataBind();
        const types = ['Label', 'Value', 'Include', 'Exclude'];
        const regx = '((-|\\+)?[0-9]+(\\.[0-9]+)?)+';
        const member = Object.keys(this.parent.engineModule.fieldList[fieldName].members)[0];
        const fieldType = this.parent.engineModule.fieldList[fieldName].type;
        const formatObj = PivotUtil.getFieldByName(fieldName, this.parent.dataSourceSettings.formatSettings);
        const items = [
            {
                header: {
                    text: this.parent.localeObj.getConstant('member'),
                    iconCss: (this.filterObject && types.indexOf(this.filterObject.type) > 1 ? SELECTED_OPTION_ICON_CLASS : '')
                },
                content: this.createTreeView(treeData, fieldCaption, fieldName)
            }
        ];
        for (const type of types) {
            if (((type === 'Label') && this.parent.dataSourceSettings.allowLabelFilter) ||
                (type === 'Value' && this.parent.dataSourceSettings.allowValueFilter)) {
                const filterType = (type === 'Label' && member && ((member).match(regx) &&
                    (member).match(regx)[0].length === (member).length) && fieldType === 'number') ? 'Number' :
                    (type === 'Label' && member && (new Date(member).toString() !== 'Invalid Date') &&
                        ((formatObj && formatObj.type) || (this.filterObject && this.filterObject.type === 'Date'))) ? 'Date' : type;
                const item = {
                    header: {
                        text: (filterType === 'Number' ? this.parent.localeObj.getConstant('label') :
                            this.parent.localeObj.getConstant(filterType.toLowerCase())),
                        iconCss: (this.filterObject && this.filterObject.type === filterType ? SELECTED_OPTION_ICON_CLASS : '')
                    },
                    content: this.createCustomFilter(fieldName, (this.filterObject && this.filterObject.type === filterType ? this.filterObject :
                        undefined), filterType.toLowerCase())
                };
                items.push(item);
            }
        }
        let selectedIndex = (this.filterObject ? (['Label', 'Date', 'Number'].indexOf(this.filterObject.type) >= 0) ?
            1 : this.filterObject.type === 'Value' ?
            (this.parent.dataSourceSettings.allowLabelFilter && this.parent.dataSourceSettings.allowValueFilter) ? 2 : 1 : 0 : 0);
        selectedIndex = (!this.parent.dataSourceSettings.allowMemberFilter && selectedIndex === 0) ? 1 : selectedIndex;
        this.tabObj = new Tab({
            heightAdjustMode: 'Auto',
            items: items,
            height: '100%',
            selectedItem: selectedIndex,
            enableRtl: this.parent.enableRtl,
            enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
            cssClass: this.parent.cssClass
        });
        this.tabObj.isStringTemplate = true;
        this.tabObj.appendTo(wrapper);
        if (!this.parent.dataSourceSettings.allowMemberFilter) {
            this.tabObj.hideTab(0);
        }
        if (selectedIndex > 0) {
            addClass([this.dialogPopUp.element.querySelector('.e-filter-div-content' + '.' + (selectedIndex === 1 && this.parent.dataSourceSettings.allowLabelFilter ? 'e-label-filter' : 'e-value-filter'))], 'e-selected-tab');
        }
    }
    createCustomFilter(fieldName, filterObject, type) {
        const dataSource = [];
        const valueOptions = [];
        const levelOptions = [];
        const measures = this.parent.dataSourceSettings.values;
        let selectedOption = 'DoesNotEquals';
        let selectedValueIndex = 0;
        let selectedLevelIndex = 0;
        const options = {
            label: ['Equals', 'DoesNotEquals', 'BeginWith', 'DoesNotBeginWith', 'EndsWith',
                'DoesNotEndsWith', 'Contains', 'DoesNotContains', 'GreaterThan',
                'GreaterThanOrEqualTo', 'LessThan', 'LessThanOrEqualTo', 'Between', 'NotBetween'],
            date: ['Equals', 'DoesNotEquals', 'Before', 'BeforeOrEqualTo', 'After', 'AfterOrEqualTo',
                'Between', 'NotBetween'],
            value: ['Equals', 'DoesNotEquals', 'GreaterThan', 'GreaterThanOrEqualTo', 'LessThan',
                'LessThanOrEqualTo', 'Between', 'NotBetween']
        };
        const betweenOperators = ['Between', 'NotBetween'];
        const operatorCollection = (type === 'label' ? options.label : type === 'date' ? options.date : options.value);
        for (const operator of operatorCollection) {
            selectedOption = ((filterObject && operator === filterObject.condition) ?
                operatorCollection.indexOf(filterObject.condition) >= 0 ?
                    filterObject.condition : operatorCollection[0] : selectedOption);
            dataSource.push({ value: operator, text: this.parent.localeObj.getConstant(operator) });
        }
        let len = measures.length;
        while (len--) {
            valueOptions.unshift({ value: measures[len].name, text: (measures[len].caption ?
                    measures[len].caption : measures[len].name) });
            selectedValueIndex = filterObject && filterObject.type === 'Value' &&
                filterObject.measure === measures[len].name &&
                filterObject.condition === selectedOption ? len : selectedValueIndex;
        }
        if (this.parent.dataType === 'olap') {
            const engineModule = this.parent.engineModule;
            const levels = engineModule.fieldList[fieldName].levels;
            if (this.parent.engineModule.fieldList[fieldName].isHierarchy) {
                let levelObj;
                const fieldlistData = this.parent.engineModule.fieldListData;
                for (const item of fieldlistData) {
                    if (item && item.pid === fieldName) {
                        levelObj = item;
                        break;
                    }
                }
                levelOptions.push({
                    value: levelObj ? levelObj.id : fieldName,
                    text: levelObj ? levelObj.caption : engineModule.fieldList[fieldName].name
                });
                selectedLevelIndex = 0;
                if (filterObject && filterObject.name === fieldName && filterObject.type.toLowerCase() === type) {
                    levelOptions[levelOptions.length - 1]['iconClass'] = ICON + ' ' + SELECTED_LEVEL_ICON_CLASS;
                }
            }
            else {
                for (let i = 0, cnt = levels.length; i < cnt; i++) {
                    selectedLevelIndex = (filterObject &&
                        filterObject.selectedField === levels[i].id ? i : selectedLevelIndex);
                    levelOptions.push({ value: levels[i].id, text: levels[i].name });
                    for (const field of this.parent.dataSourceSettings.filterSettings) {
                        if (field.name === fieldName && field.selectedField === levels[i].id &&
                            field.type.toLowerCase() === type) {
                            levelOptions[levelOptions.length - 1]['iconClass'] = ICON + ' ' + SELECTED_LEVEL_ICON_CLASS;
                            break;
                        }
                    }
                }
            }
        }
        const mainDiv = createElement('div', {
            className: FILTER_DIV_CONTENT_CLASS + ' e-' + ((['date', 'number']).indexOf(type) >= 0 ? 'label' : type) + '-filter' + (this.parent.isDataOverflow ? ' ' + PIVOT_FILTER_MEMBER_LIMIT : ''),
            id: this.parent.parentID + '_' + type + '_filter_div_content',
            attrs: {
                'data-type': type, 'data-fieldName': fieldName, 'data-operator': selectedOption,
                'data-selectedField': (this.parent.dataType === 'olap' &&
                    levelOptions.length > 0 ? levelOptions[selectedLevelIndex].value.toString() : ''),
                'data-measure': (this.parent.dataSourceSettings.values.length > 0 ?
                    this.parent.dataSourceSettings.values[selectedValueIndex].name : ''),
                'data-value1': (filterObject && selectedOption === filterObject.condition ?
                    filterObject.value1 ? filterObject.value1.toString() : '' : ''),
                'data-value2': (filterObject && selectedOption === filterObject.condition ?
                    filterObject.value2 ? filterObject.value2.toString() : '' : '')
            }
        });
        const textContentdiv = createElement('div', {
            className: FILTER_TEXT_DIV_CLASS
        });
        textContentdiv.innerText = this.parent.localeObj.getConstant(type + 'TextContent');
        const betweenTextContentdiv = createElement('div', {
            className: BETWEEN_TEXT_DIV_CLASS + ' ' +
                (betweenOperators.indexOf(selectedOption) === -1 ? ICON_DISABLE : '')
        });
        betweenTextContentdiv.innerText = this.parent.localeObj.getConstant('And');
        const separatordiv = createElement('div', { className: SEPARATOR_DIV_CLASS });
        const filterWrapperDiv1 = createElement('div', { className: FILTER_OPTION_WRAPPER_1_CLASS });
        const levelWrapperDiv = createElement('div', {
            className: 'e-level-option-container' + ' ' +
                (this.parent.dataType === 'olap' ? '' : ICON_DISABLE)
        });
        const optionWrapperDiv1 = createElement('div', {
            className: 'e-measure-option-container' + ' ' + (((['label', 'date', 'number']).indexOf(type) >= 0) ? ICON_DISABLE : '')
        });
        const optionWrapperDiv2 = createElement('div', { className: 'e-condition-option-container' });
        const filterWrapperDiv2 = createElement('div', { className: FILTER_OPTION_WRAPPER_2_CLASS });
        const levelDropOption = createElement('div', { id: this.parent.parentID + '_' + type + '_level_option_container' });
        const dropOptionDiv1 = createElement('div', { id: this.parent.parentID + '_' + type + '_measure_option_container' });
        const dropOptionDiv2 = createElement('div', { id: this.parent.parentID + '_' + type + '_contition_option_container' });
        const inputDiv1 = createElement('div', { className: FILTER_INPUT_DIV_1_CLASS });
        const inputDiv2 = createElement('div', {
            className: FILTER_INPUT_DIV_2_CLASS + ' ' +
                (betweenOperators.indexOf(selectedOption) === -1 ? ICON_DISABLE : '')
        });
        const inputField1 = createElement('input', {
            id: this.parent.parentID + '_' + type + '_input_option_1', attrs: { 'type': 'text' }
        });
        const inputField2 = createElement('input', {
            id: this.parent.parentID + '_' + type + '_input_option_2', attrs: { 'type': 'text' }
        });
        inputDiv1.appendChild(inputField1);
        inputDiv2.appendChild(inputField2);
        levelWrapperDiv.appendChild(levelDropOption);
        levelWrapperDiv.appendChild(separatordiv.cloneNode(true));
        optionWrapperDiv1.appendChild(dropOptionDiv1);
        optionWrapperDiv1.appendChild(separatordiv);
        optionWrapperDiv2.appendChild(dropOptionDiv2);
        filterWrapperDiv1.appendChild(levelWrapperDiv);
        filterWrapperDiv1.appendChild(optionWrapperDiv1);
        filterWrapperDiv1.appendChild(optionWrapperDiv2);
        filterWrapperDiv2.appendChild(inputDiv1);
        filterWrapperDiv2.appendChild(betweenTextContentdiv);
        filterWrapperDiv2.appendChild(inputDiv2);
        this.createElements(filterObject, betweenOperators, dropOptionDiv1, dropOptionDiv2, inputField1, inputField2, valueOptions, dataSource, selectedValueIndex, selectedOption, type, levelDropOption, levelOptions, selectedLevelIndex);
        mainDiv.appendChild(textContentdiv);
        mainDiv.appendChild(filterWrapperDiv1);
        mainDiv.appendChild(filterWrapperDiv2);
        return mainDiv;
    }
    createElements(filterObj, operators, optionDiv1, optionDiv2, inputDiv1, inputDiv2, vDataSource, oDataSource, valueIndex, option, type, levelDropOption, lDataSource, levelIndex) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const popupInstance = this;
        if (this.parent.dataType === 'olap') {
            const levelWrapper = new DropDownList({
                dataSource: lDataSource, enableRtl: this.parent.enableRtl,
                fields: { value: 'value', text: 'text', iconCss: 'iconClass' },
                index: levelIndex,
                cssClass: LEVEL_OPTIONS_CLASS + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''), width: '100%',
                change: (args) => {
                    const element = popupInstance.dialogPopUp.element.querySelector('.e-selected-tab');
                    const fieldName = element.getAttribute('data-fieldName');
                    const type = element.getAttribute('data-type');
                    if (!isNullOrUndefined(element)) {
                        popupInstance.updateInputValues(element, type, inputDiv1, inputDiv2);
                        setStyleAndAttributes(element, { 'data-selectedField': args.value });
                        let filterObj;
                        for (const field of popupInstance.parent.dataSourceSettings.filterSettings) {
                            if (field.name === fieldName && field.selectedField === args.value) {
                                filterObj = field;
                                break;
                            }
                        }
                        if (filterObj) {
                            if (type === 'value' && filterObj.measure && filterObj.measure !== '') {
                                optionWrapper1.value = filterObj.measure ? filterObj.measure : vDataSource[0].value;
                            }
                            if (filterObj.condition) {
                                optionWrapper.value = filterObj.condition ? filterObj.condition : 'DoesNotEquals';
                            }
                            else {
                                optionWrapper.value = 'DoesNotEquals';
                            }
                            let inputObj1;
                            let inputObj2;
                            if (type === 'value') { /* eslint-disable @typescript-eslint/no-explicit-any */
                                inputObj1 = inputDiv1.ej2_instances[0];
                                inputObj2 = inputDiv2.ej2_instances[0];
                                if (inputObj1) {
                                    inputObj1.value = filterObj.value1 ? parseInt(filterObj.value1, 10) : undefined;
                                }
                                if (inputObj2) {
                                    inputObj2.value = filterObj.value2 ? parseInt(filterObj.value2, 10) : undefined;
                                }
                            }
                            else {
                                inputObj1 = inputDiv1.ej2_instances[0];
                                inputObj2 = inputDiv2.ej2_instances[0];
                                if (inputObj1) { /* eslint-enable @typescript-eslint/no-explicit-any */
                                    inputObj1.value = filterObj.value1 ? filterObj.value1 : '';
                                }
                                if (inputObj2) {
                                    inputObj2.value = filterObj.value2 ? filterObj.value2 : '';
                                }
                            }
                        }
                        popupInstance.updateInputValues(element, type, inputDiv1, inputDiv2);
                    }
                    else {
                        return;
                    }
                }
            });
            levelWrapper.isStringTemplate = true;
            levelWrapper.appendTo(levelDropOption);
        }
        const optionWrapper1 = new DropDownList({
            dataSource: vDataSource, enableRtl: this.parent.enableRtl,
            fields: { value: 'value', text: 'text' }, index: valueIndex,
            cssClass: VALUE_OPTIONS_CLASS + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''), width: '100%',
            change: (args) => {
                const element = popupInstance.dialogPopUp.element.querySelector('.e-selected-tab');
                if (!isNullOrUndefined(element)) {
                    popupInstance.updateInputValues(element, type, inputDiv1, inputDiv2);
                    setStyleAndAttributes(element, { 'data-measure': args.value });
                }
                else {
                    return;
                }
            }
        });
        optionWrapper1.isStringTemplate = true;
        optionWrapper1.appendTo(optionDiv1);
        const optionWrapper = new DropDownList({
            dataSource: oDataSource, enableRtl: this.parent.enableRtl,
            fields: { value: 'value', text: 'text' }, value: option,
            cssClass: FILTER_OPERATOR_CLASS + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''), width: '100%',
            change: (args) => {
                const element = popupInstance.dialogPopUp.element.querySelector('.e-selected-tab');
                if (!isNullOrUndefined(element)) {
                    popupInstance.updateInputValues(element, type, inputDiv1, inputDiv2);
                    const disabledClasses = [BETWEEN_TEXT_DIV_CLASS, FILTER_INPUT_DIV_2_CLASS];
                    for (const className of disabledClasses) {
                        if (operators.indexOf(args.value) >= 0) {
                            removeClass([element.querySelector('.' + className)], ICON_DISABLE);
                        }
                        else {
                            addClass([element.querySelector('.' + className)], ICON_DISABLE);
                        }
                    }
                    setStyleAndAttributes(element, { 'data-operator': args.value });
                }
                else {
                    return;
                }
            }
        });
        optionWrapper.isStringTemplate = true;
        optionWrapper.appendTo(optionDiv2);
        if (type === 'date') {
            const inputObj1 = new DateTimePicker({
                placeholder: this.parent.localeObj.getConstant('chooseDate'),
                enableRtl: this.parent.enableRtl,
                format: 'dd/MM/yyyy hh:mm:ss a',
                showClearButton: true,
                value: (filterObj && option === filterObj.condition ?
                    (typeof (filterObj.value1) === 'string' ? new Date(filterObj.value1) : filterObj.value1) : null),
                change: (e) => {
                    const element = popupInstance.dialogPopUp.element.querySelector('.e-selected-tab');
                    if (!isNullOrUndefined(element)) {
                        setStyleAndAttributes(element, { 'data-value1': e.value, 'data-value2': inputObj2.value });
                    }
                    else {
                        return;
                    }
                },
                width: '100%',
                cssClass: this.parent.cssClass
            });
            const inputObj2 = new DateTimePicker({
                placeholder: this.parent.localeObj.getConstant('chooseDate'),
                enableRtl: this.parent.enableRtl,
                format: 'dd/MM/yyyy hh:mm:ss a',
                showClearButton: true,
                value: (filterObj && option === filterObj.condition ?
                    (typeof (filterObj.value2) === 'string' ? new Date(filterObj.value2) : filterObj.value2) : null),
                change: (e) => {
                    const element = popupInstance.dialogPopUp.element.querySelector('.e-selected-tab');
                    if (!isNullOrUndefined(element)) {
                        setStyleAndAttributes(element, { 'data-value1': inputObj1.value, 'data-value2': e.value });
                    }
                    else {
                        return;
                    }
                },
                width: '100%',
                cssClass: this.parent.cssClass
            });
            inputObj1.isStringTemplate = true;
            inputObj1.appendTo(inputDiv1);
            inputObj2.isStringTemplate = true;
            inputObj2.appendTo(inputDiv2);
        }
        else if (type === 'value') {
            const inputObj1 = new NumericTextBox({
                placeholder: this.parent.localeObj.getConstant('enterValue'),
                enableRtl: this.parent.enableRtl,
                showClearButton: true,
                format: '###.##',
                value: (filterObj && option === filterObj.condition ? parseInt(filterObj.value1, 10) : undefined),
                change: (e) => {
                    const element = popupInstance.dialogPopUp.element.querySelector('.e-selected-tab');
                    if (!isNullOrUndefined(element)) {
                        setStyleAndAttributes(element, {
                            'data-value1': (e.value ? e.value.toString() : '0'),
                            'data-value2': (inputObj2.value ? inputObj2.value.toString() : '0')
                        });
                    }
                    else {
                        return;
                    }
                },
                width: '100%',
                cssClass: this.parent.cssClass
            });
            const inputObj2 = new NumericTextBox({
                placeholder: this.parent.localeObj.getConstant('enterValue'),
                enableRtl: this.parent.enableRtl,
                showClearButton: true,
                format: '###.##',
                value: (filterObj && option === filterObj.condition ? parseInt(filterObj.value2, 10) : undefined),
                change: (e) => {
                    const element = popupInstance.dialogPopUp.element.querySelector('.e-selected-tab');
                    if (!isNullOrUndefined(element)) {
                        setStyleAndAttributes(element, {
                            'data-value1': (inputObj1.value ? inputObj1.value.toString() : '0'),
                            'data-value2': (e.value ? e.value.toString() : '0')
                        });
                    }
                    else {
                        return;
                    }
                },
                width: '100%',
                cssClass: this.parent.cssClass
            });
            inputObj1.isStringTemplate = true;
            inputObj1.appendTo(inputDiv1);
            inputObj2.isStringTemplate = true;
            inputObj2.appendTo(inputDiv2);
        }
        else {
            const inputObj1 = new MaskedTextBox({
                placeholder: this.parent.localeObj.getConstant('enterValue'),
                enableRtl: this.parent.enableRtl,
                showClearButton: true,
                value: (filterObj && option === filterObj.condition ? filterObj.value1 : ''),
                change: (e) => {
                    const element = popupInstance.dialogPopUp.element.querySelector('.e-selected-tab');
                    if (!isNullOrUndefined(element)) {
                        setStyleAndAttributes(element, { 'data-value1': e.value, 'data-value2': inputObj2.value });
                    }
                    else {
                        return;
                    }
                },
                width: '100%',
                cssClass: this.parent.cssClass
            });
            const inputObj2 = new MaskedTextBox({
                placeholder: this.parent.localeObj.getConstant('enterValue'),
                enableRtl: this.parent.enableRtl,
                showClearButton: true,
                value: (filterObj && option === filterObj.condition ? filterObj.value2 : ''),
                change: (e) => {
                    const element = popupInstance.dialogPopUp.element.querySelector('.e-selected-tab');
                    if (!isNullOrUndefined(element)) {
                        setStyleAndAttributes(element, { 'data-value1': inputObj1.value, 'data-value2': e.value });
                    }
                    else {
                        return;
                    }
                },
                width: '100%',
                cssClass: this.parent.cssClass
            });
            inputObj1.isStringTemplate = true;
            inputObj1.appendTo(inputDiv1);
            inputObj2.isStringTemplate = true;
            inputObj2.appendTo(inputDiv2);
        }
    }
    updateInputValues(element, type, inputDiv1, inputDiv2) {
        let value1;
        let value2;
        /* eslint-disable @typescript-eslint/no-explicit-any */
        if (type === 'date') {
            const inputObj1 = inputDiv1.ej2_instances[0];
            const inputObj2 = inputDiv2.ej2_instances[0];
            value1 = !isNullOrUndefined(inputObj1.value) ? inputObj1.value.toString() : '';
            value2 = !isNullOrUndefined(inputObj2.value) ? inputObj2.value.toString() : '';
        }
        else {
            const inputObj1 = inputDiv1.ej2_instances[0];
            const inputObj2 = inputDiv2.ej2_instances[0];
            value1 = inputObj1.value;
            value2 = inputObj2.value;
        }
        /* eslint-enable @typescript-eslint/no-explicit-any */
        setStyleAndAttributes(element, { 'data-value1': value1, 'data-value2': value2 });
    }
    validateTreeNode(e) {
        if (e.node.classList.contains(ICON_DISABLE)) {
            e.cancel = true;
        }
        else {
            return;
        }
    }
    /* eslint-disable-next-line */
    /**
     * Update filter state while Member check/uncheck.
     * @hidden
     */
    updateCheckedState() {
        const filterDialog = this.dialogPopUp.element;
        const list = [].slice.call(this.memberTreeView.element.querySelectorAll('li'));
        const fieldName = filterDialog.getAttribute('data-fieldname');
        const uncheckedNodes = this.getUnCheckedNodes(fieldName);
        const checkedNodes = this.getCheckedNodes(fieldName);
        const firstNode = this.allMemberSelect.element.querySelector('li').querySelector('span.' + CHECK_BOX_FRAME_CLASS);
        if (list.length > 0) {
            if (checkedNodes > 0) {
                if (uncheckedNodes > 0) {
                    removeClass([firstNode], NODE_CHECK_CLASS);
                    addClass([firstNode], NODE_STOP_CLASS);
                }
                else if (uncheckedNodes === 0) {
                    removeClass([firstNode], NODE_STOP_CLASS);
                    addClass([firstNode], NODE_CHECK_CLASS);
                }
                this.dialogPopUp.buttons[0].buttonModel.disabled = false;
                filterDialog.querySelector('.' + OK_BUTTON_CLASS).removeAttribute('disabled');
            }
            else if (uncheckedNodes > 0 && checkedNodes === 0) {
                removeClass([firstNode], [NODE_CHECK_CLASS, NODE_STOP_CLASS]);
                if (this.getCheckedNodes(fieldName) === checkedNodes) {
                    this.dialogPopUp.buttons[0].buttonModel.disabled = true;
                    filterDialog.querySelector('.' + OK_BUTTON_CLASS).setAttribute('disabled', 'disabled');
                }
            }
        }
        else {
            this.dialogPopUp.buttons[0].buttonModel.disabled = true;
            filterDialog.querySelector('.' + OK_BUTTON_CLASS).setAttribute('disabled', 'disabled');
        }
    }
    getCheckedNodes(fieldName) {
        const engineModule = this.parent.engineModule;
        let nodeList = [];
        const checkeNodes = [];
        if (this.parent.dataType === 'olap' && engineModule &&
            !engineModule.fieldList[fieldName].isHierarchy) {
            nodeList = this.memberTreeView.getAllCheckedNodes();
            return nodeList.length;
        }
        else {
            for (const item of this.parent.searchTreeItems) {
                if (item.isSelected) {
                    checkeNodes.push(item);
                }
            }
            return checkeNodes.length;
        }
    }
    getUnCheckedNodes(fieldName) {
        const unCheckeNodes = [];
        let nodeList = [];
        const engineModule = this.parent.engineModule;
        if (this.parent.dataType === 'olap' && engineModule && !engineModule.fieldList[fieldName].isHierarchy) {
            nodeList = this.memberTreeView.getAllCheckedNodes();
            return (this.memberTreeView.fields.dataSource.length - nodeList.length);
        }
        else {
            // unCheckeNodes = this.parent.searchTreeItems.filter((item: { [key: string]: object }) => {
            //     return !item.isSelected;
            // });
            for (const item of this.parent.searchTreeItems) {
                if (!item.isSelected) {
                    unCheckeNodes.push(item);
                }
            }
            return unCheckeNodes.length;
        }
    }
    isExcelFilter(fieldName) {
        let isFilterField = false;
        for (const field of this.parent.dataSourceSettings.filters) {
            if (field.name === fieldName) {
                isFilterField = true;
                break;
            }
        }
        if (!isFilterField && (this.parent.dataSourceSettings.allowLabelFilter || this.parent.dataSourceSettings.allowValueFilter)) {
            return true;
        }
        else {
            return false;
        }
    }
    getFilterObject(fieldName) {
        const filterObj = PivotUtil.getFilterItemByName(fieldName, PivotUtil.cloneFilterSettings(this.parent.dataSourceSettings.filterSettings));
        if (filterObj && (((['Label', 'Date', 'Number'].indexOf(filterObj.type) >= 0) &&
            this.parent.dataSourceSettings.allowLabelFilter) ||
            (filterObj.type === 'Value' && this.parent.dataSourceSettings.allowValueFilter) ||
            (['Include', 'Exclude'].indexOf(filterObj.type) >= 0 &&
                this.parent.eventBase.isValidFilterItemsAvail(fieldName, filterObj)))) {
            return filterObj;
        }
        return undefined;
    }
    wireEvent(element, fieldName) {
        EventHandler.add(element, 'click', this.applySorting.bind(this, fieldName), this);
    }
    unWireEvent(element) {
        EventHandler.remove(element, 'click', this.applySorting);
    }
    /**
     * To close filter dialog.
     *
     * @returns {void}
     * @hidden
     */
    closeFilterDialog() {
        if (this.allowExcelLikeFilter) {
            if (this.tabObj && !this.tabObj.isDestroyed) {
                this.tabObj.destroy();
            }
        }
        if (this.dropMenu && !this.dropMenu.isDestroyed) {
            this.dropMenu.destroy();
        }
        if (this.memberTreeView && !this.memberTreeView.isDestroyed) {
            this.memberTreeView.destroy();
        }
        if (this.allMemberSelect && !this.allMemberSelect.isDestroyed) {
            this.allMemberSelect.destroy();
        }
        if (this.editorSearch && !this.editorSearch.isDestroyed) {
            this.editorSearch.destroy();
        }
        if (document.getElementById(this.parent.parentID + '_LevelDiv-popup')) {
            remove(document.getElementById(this.parent.parentID + '_LevelDiv-popup'));
        }
        this.dialogPopUp.close();
    }
    removeFilterDialog() {
        if (this.dialogPopUp && !this.dialogPopUp.isDestroyed) {
            this.dialogPopUp.destroy();
            setTimeout(this.setFocus.bind(this));
        }
        if (document.getElementById(this.parent.parentID + '_EditorTreeView')) {
            remove(document.getElementById(this.parent.parentID + '_EditorTreeView'));
        }
    }
    setFocus() {
        if (this.parent.control.pivotButtonModule.parentElement) {
            const pivotButtons = [].slice.call(this.parent.control.pivotButtonModule.parentElement.querySelectorAll('.e-pivot-button'));
            for (const item of pivotButtons) {
                if (item.getAttribute('data-uid') === this.parent.control.pivotButtonModule.fieldName) {
                    item.focus();
                    break;
                }
            }
        }
    }
}

/**
 * PivotCommon is used to manipulate the relational or Multi-Dimensional public methods by using their dataSource
 *
 * @hidden
 */
/** @hidden */
class PivotCommon {
    /**
     * Constructor for Pivot Common class.
     *
     * @param  {CommonArgs} control - It contains the value of control.
     * @hidden
     */
    constructor(control) {
        /** @hidden */
        this.currentTreeItems = [];
        /** @hidden */
        this.savedTreeFilterPos = {};
        /** @hidden */
        this.currentTreeItemsPos = {};
        /** @hidden */
        this.searchTreeItems = [];
        /** @hidden */
        this.isDataOverflow = false;
        /** @hidden */
        this.isDateField = false;
        this.element = control.element;
        this.moduleName = control.moduleName;
        this.dataSourceSettings = control.dataSourceSettings;
        this.engineModule = control.pivotEngine;
        this.enableRtl = control.enableRtl;
        this.enableHtmlSanitizer = control.enableHtmlSanitizer;
        this.isAdaptive = control.isAdaptive;
        this.renderMode = control.renderMode;
        this.parentID = control.id;
        this.localeObj = control.localeObj;
        this.dataType = control.dataType;
        this.cssClass = control.cssClass;
        this.nodeStateModified = new NodeStateModified(this);
        this.dataSourceUpdate = new DataSourceUpdate(this);
        this.eventBase = new EventBase(this);
        this.filterDialog = new FilterDialog(this);
        this.errorDialog = new ErrorDialog(this);
        this.keyboardModule = new CommonKeyboardInteraction(this);
        return this;
    }
    /**
     * To destroy the groupingbar.
     *
     * @returns {void}
     * @hidden
     */
    destroy() {
        if (this.keyboardModule) {
            this.keyboardModule.destroy();
            this.keyboardModule = null;
        }
    }
}

/**
 * Module for PivotCommon rendering
 */
/** @hidden */
class Common {
    constructor(parent) {
        this.parent = parent;
        this.parent.commonModule = this;
        this.addEventListener();
    }
    /* eslint-disable-next-line */
    /**
     * For internal use only - Get the module name.
     * @private
     */
    getModuleName() {
        return 'common';
    }
    initiateCommonModule() {
        if (!this.parent.pivotCommon) {
            /* eslint-disable */
            let args = {
                pivotEngine: this.parent.dataType === 'olap' ? this.parent.olapEngineModule : this.parent.engineModule,
                dataSourceSettings: this.parent.dataSourceSettings.properties ?
                    this.parent.dataSourceSettings.properties : this.parent.dataSourceSettings,
                id: this.parent.element.id,
                element: this.parent.element,
                moduleName: this.parent.getModuleName(),
                enableRtl: this.parent.enableRtl,
                enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
                isAdaptive: Browser.isDevice,
                renderMode: 'Popup',
                localeObj: this.parent.localeObj,
                dataType: this.parent.dataType,
                cssClass: this.parent.cssClass
            };
            /* eslint-enable */
            this.parent.pivotCommon = new PivotCommon(args);
        }
        else {
            this.parent.pivotCommon.element = this.parent.element;
            this.parent.pivotCommon.engineModule = this.parent.dataType === 'olap' ?
                this.parent.olapEngineModule : this.parent.engineModule;
            this.parent.pivotCommon.parentID = this.parent.element.id;
            this.parent.pivotCommon.dataSourceSettings = this.parent.dataSourceSettings.properties ?
                this.parent.dataSourceSettings.properties : this.parent.dataSourceSettings;
            this.parent.pivotCommon.moduleName = this.parent.getModuleName();
            this.parent.pivotCommon.enableRtl = this.parent.enableRtl;
            this.parent.pivotCommon.isAdaptive = Browser.isDevice;
            this.parent.pivotCommon.renderMode = 'Popup';
            this.parent.pivotCommon.localeObj = this.parent.localeObj;
            this.parent.pivotCommon.dataType = this.parent.dataType;
            this.parent.pivotCommon.cssClass = this.parent.cssClass;
        }
        this.parent.pivotCommon.control = this.parent;
    }
    /* eslint-disable-next-line */
    /**
     * @hidden
     */
    addEventListener() {
        this.handlers = {
            load: this.initiateCommonModule
        };
        if (this.parent.isDestroyed) {
            return;
        }
        this.parent.on(initialLoad, this.handlers.load, this);
        this.parent.on(uiUpdate, this.handlers.load, this);
    }
    /* eslint-disable-next-line */
    /**
     * @hidden
     */
    removeEventListener() {
        if (this.parent.isDestroyed) {
            return;
        }
        this.parent.off(initialLoad, this.handlers.load);
        this.parent.off(uiUpdate, this.handlers.load);
    }
    /**
     * To destroy the groupingbar
     *
     * @returns {void}
     * @hidden
     */
    destroy() {
        this.removeEventListener();
        if (this.parent.pivotCommon) {
            this.parent.pivotCommon.destroy();
            this.parent.pivotCommon = null;
        }
    }
}

var __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Allows specific fields associated with field information that needs to be displayed in the field axes of pivot table. The following configurations which are applicable are as follows:
 * * `name`: Allows you to set the field name that needs to be displayed in row/column/value/filter axis of pivot table.
 * * `caption`: Allows you to set caption to the specific field. It will be used to display instead of its name in pivot table component's UI.
 * * `type`: Allows to display the values in the pivot table with appropriate aggregations such as sum, product, count, average, etc **Note: It is applicable only for relational data source.**
 * * `axis`: Allows you to set the axis name to the specific field. This will help to display the field in specified axis such as row/column/value/filter axis of pivot table.
 * * `showNoDataItems`: Allows you to display all members items of a specific field to the pivot table,
 * even doesn't have any data in its row/column intersection in data source. **Note: It is applicable only for relational data source.**
 * * `baseField`: Allows you to set the selective field, which used to display the values with either
 *  DifferenceFrom or PercentageOfDifferenceFrom or PercentageOfParentTotal aggregate types. **Note: It is applicable only for relational data source.**
 * * `baseItem`: Allows you to set the selective item of a specific field, which used to display the values with either DifferenceFrom or PercentageOfDifferenceFrom aggregate types.
 * The selective item should be set the from field specified in the baseField property. **Note: It is applicable only for relational data source.**
 * * `showSubTotals`: Allows to show or hide sub-totals to a specific field in row/column axis of the pivot table.
 * * `isNamedSet`: Allows you to set whether the specified field is a named set or not. In general,
 * the named set is a set of dimension members or a set expression (MDX query) to be created as a dimension in the SSAS OLAP cube itself. **Note: It is applicable only for OLAP data source.**
 * * `isCalculatedField`: Allows to set whether the specified field is a calculated field or not.
 * In general, the calculated field is created from the bound data source or using simple formula with basic arithmetic operators in the pivot table. **Note: It is applicable only for OLAP data source.**
 * * `showFilterIcon`: Allows you to show or hide the filter icon of a specific field that used to be displayed on the pivot button of the grouping bar and field list UI.
 * This filter icon is used to filter the members of a specified field at runtime in the pivot table.
 * * `showSortIcon`: Allows you to show or hide the sort icon of a specific field that used to be displayed in the pivot button of the grouping bar and field list UI.
 * This sort icon is used to order members of a specified field either in ascending or descending at runtime.
 * * `showRemoveIcon`: Allows you to show or hide the remove icon of a specific field that used to be displayed in the pivot button of the grouping bar and field list UI.
 * This remove icon is used to remove the specified field during runtime.
 * * `showValueTypeIcon`: Allows you to show or hide the value type icon of a specific field that used to be displayed in the pivot button of the grouping bar and field list UI.
 * This value type icon helps to select the appropriate aggregation type to specified value field at runtime.
 * * `showEditIcon`: Allows you to show or hide the edit icon of a specific field that used to be displayed on the pivot button of the grouping bar and field list UI.
 * This edit icon is used to modify caption, formula, and format of a specified calculated field at runtime that to be displayed in the pivot table.
 * * `allowDragAndDrop`: Allows you to restrict the specific field's pivot button that is used to drag on runtime in the grouping bar and field list UI.
 * This will prevent you from modifying the current report.
 * * `expandAll`: Allows you to either expand or collapse all of the headers in the pivot table for a specific field.
 */
class FieldOptions extends ChildProperty {
}
__decorate$1([
    Property()
], FieldOptions.prototype, "name", void 0);
__decorate$1([
    Property()
], FieldOptions.prototype, "caption", void 0);
__decorate$1([
    Property('Sum')
], FieldOptions.prototype, "type", void 0);
__decorate$1([
    Property()
], FieldOptions.prototype, "axis", void 0);
__decorate$1([
    Property(false)
], FieldOptions.prototype, "showNoDataItems", void 0);
__decorate$1([
    Property()
], FieldOptions.prototype, "baseField", void 0);
__decorate$1([
    Property()
], FieldOptions.prototype, "baseItem", void 0);
__decorate$1([
    Property(true)
], FieldOptions.prototype, "showSubTotals", void 0);
__decorate$1([
    Property(false)
], FieldOptions.prototype, "isNamedSet", void 0);
__decorate$1([
    Property(false)
], FieldOptions.prototype, "isCalculatedField", void 0);
__decorate$1([
    Property(true)
], FieldOptions.prototype, "showFilterIcon", void 0);
__decorate$1([
    Property(true)
], FieldOptions.prototype, "showSortIcon", void 0);
__decorate$1([
    Property(true)
], FieldOptions.prototype, "showRemoveIcon", void 0);
__decorate$1([
    Property(true)
], FieldOptions.prototype, "showValueTypeIcon", void 0);
__decorate$1([
    Property(true)
], FieldOptions.prototype, "showEditIcon", void 0);
__decorate$1([
    Property(true)
], FieldOptions.prototype, "allowDragAndDrop", void 0);
__decorate$1([
    Property()
], FieldOptions.prototype, "dataType", void 0);
__decorate$1([
    Property(false)
], FieldOptions.prototype, "expandAll", void 0);
__decorate$1([
    Property()
], FieldOptions.prototype, "groupName", void 0);
/**
 * Allows specific fields associated with field information that needs to be displayed in the field axes of pivot table. The following configurations which are applicable are as follows:
 * * `name`: Allows you to set the field name that needs to be displayed in row/column/value/filter axis of pivot table.
 * * `caption`: Allows you to set caption to the specific field. It will be used to display instead of its name in pivot table component's UI.
 * * `type`: Allows to display the values in the pivot table with appropriate aggregations such as sum, product, count, average, etc **Note: It is applicable only for relational data source.**
 * * `axis`: Allows you to set the axis name to the specific field. This will help to display the field in specified axis such as row/column/value/filter axis of pivot table.
 * * `showNoDataItems`: Allows you to display all members items of a specific field to the pivot table,
 * even doesn't have any data in its row/column intersection in data source. **Note: It is applicable only for relational data source.**
 * * `baseField`: Allows you to set the selective field, which used to display the values with either
 *  DifferenceFrom or PercentageOfDifferenceFrom or PercentageOfParentTotal aggregate types. **Note: It is applicable only for relational data source.**
 * * `baseItem`: Allows you to set the selective item of a specific field, which used to display the values with either DifferenceFrom or PercentageOfDifferenceFrom aggregate types.
 * The selective item should be set the from field specified in the baseField property. **Note: It is applicable only for relational data source.**
 * * `showSubTotals`: Allows to show or hide sub-totals to a specific field in row/column axis of the pivot table.
 * * `isNamedSet`: Allows you to set whether the specified field is a named set or not. In general,
 * the named set is a set of dimension members or a set expression (MDX query) to be created as a dimension in the SSAS OLAP cube itself. **Note: It is applicable only for OLAP data source.**
 * * `isCalculatedField`: Allows to set whether the specified field is a calculated field or not.
 * In general, the calculated field is created from the bound data source or using simple formula with basic arithmetic operators in the pivot table. **Note: It is applicable only for OLAP data source.**
 * * `showFilterIcon`: Allows you to show or hide the filter icon of a specific field that used to be displayed on the pivot button of the grouping bar and field list UI.
 * This filter icon is used to filter the members of a specified field at runtime in the pivot table.
 * * `showSortIcon`: Allows you to show or hide the sort icon of a specific field that used to be displayed in the pivot button of the grouping bar and field list UI.
 * This sort icon is used to order members of a specified field either in ascending or descending at runtime.
 * * `showRemoveIcon`: Allows you to show or hide the remove icon of a specific field that used to be displayed in the pivot button of the grouping bar and field list UI.
 * This remove icon is used to remove the specified field during runtime.
 * * `showValueTypeIcon`: Allows you to show or hide the value type icon of a specific field that used to be displayed in the pivot button of the grouping bar and field list UI.
 * This value type icon helps to select the appropriate aggregation type to specified value field at runtime.
 * * `showEditIcon`: Allows you to show or hide the edit icon of a specific field that used to be displayed on the pivot button of the grouping bar and field list UI.
 * This edit icon is used to modify caption, formula, and format of a specified calculated field at runtime that to be displayed in the pivot table.
 * * `allowDragAndDrop`: Allows you to restrict the specific field's pivot button that is used to drag on runtime in the grouping bar and field list UI.
 * This will prevent you from modifying the current report.
 * * `expandAll`: Allows you to expand or collapse all of the pivot table's headers for a specific field.
 */
class FieldListFieldOptions extends FieldOptions {
}
/**
 * Allows the style information to customize the pivot table cell appearance.
 */
class Style extends ChildProperty {
}
__decorate$1([
    Property()
], Style.prototype, "backgroundColor", void 0);
__decorate$1([
    Property()
], Style.prototype, "color", void 0);
__decorate$1([
    Property()
], Style.prototype, "fontFamily", void 0);
__decorate$1([
    Property()
], Style.prototype, "fontSize", void 0);
/**
 * Allows specific fields associated with either selective or conditional-based filter members that used to be displayed in the pivot table.
 */
class Filter extends ChildProperty {
}
__decorate$1([
    Property()
], Filter.prototype, "name", void 0);
__decorate$1([
    Property('Include')
], Filter.prototype, "type", void 0);
__decorate$1([
    Property()
], Filter.prototype, "items", void 0);
__decorate$1([
    Property('DoesNotEquals')
], Filter.prototype, "condition", void 0);
__decorate$1([
    Property()
], Filter.prototype, "value1", void 0);
__decorate$1([
    Property()
], Filter.prototype, "value2", void 0);
__decorate$1([
    Property()
], Filter.prototype, "measure", void 0);
__decorate$1([
    Property(1)
], Filter.prototype, "levelCount", void 0);
__decorate$1([
    Property()
], Filter.prototype, "selectedField", void 0);
/**
 * Allows a collection of values fields to change the appearance of the pivot table value cells with different style properties such as background color, font color, font family, and font size based on specific conditions.
 */
class ConditionalFormatSettings extends ChildProperty {
}
__decorate$1([
    Property()
], ConditionalFormatSettings.prototype, "measure", void 0);
__decorate$1([
    Property()
], ConditionalFormatSettings.prototype, "label", void 0);
__decorate$1([
    Property()
], ConditionalFormatSettings.prototype, "conditions", void 0);
__decorate$1([
    Property()
], ConditionalFormatSettings.prototype, "value1", void 0);
__decorate$1([
    Property()
], ConditionalFormatSettings.prototype, "value2", void 0);
__decorate$1([
    Property()
], ConditionalFormatSettings.prototype, "style", void 0);
__decorate$1([
    Property(true)
], ConditionalFormatSettings.prototype, "applyGrandTotals", void 0);
/**
 * Allows specific fields associated with sort settings to order their members either in ascending or descending that used to be displayed in the pivot table.
 */
class Sort extends ChildProperty {
}
__decorate$1([
    Property()
], Sort.prototype, "name", void 0);
__decorate$1([
    Property('Ascending')
], Sort.prototype, "order", void 0);
__decorate$1([
    Property([])
], Sort.prototype, "membersOrder", void 0);
/**
 * Allows specific fields used to display the values with specific format that used to be displayed in the pivot table.
 * For example, to display a specific field with currency formatted values in the pivot table, the set the `format` property to be **C**.
 */
class FormatSettings extends ChildProperty {
}
__decorate$1([
    Property()
], FormatSettings.prototype, "name", void 0);
__decorate$1([
    Property()
], FormatSettings.prototype, "minimumFractionDigits", void 0);
__decorate$1([
    Property()
], FormatSettings.prototype, "maximumFractionDigits", void 0);
__decorate$1([
    Property()
], FormatSettings.prototype, "minimumSignificantDigits", void 0);
__decorate$1([
    Property()
], FormatSettings.prototype, "maximumSignificantDigits", void 0);
__decorate$1([
    Property(true)
], FormatSettings.prototype, "useGrouping", void 0);
__decorate$1([
    Property()
], FormatSettings.prototype, "skeleton", void 0);
__decorate$1([
    Property()
], FormatSettings.prototype, "type", void 0);
__decorate$1([
    Property()
], FormatSettings.prototype, "currency", void 0);
__decorate$1([
    Property()
], FormatSettings.prototype, "minimumIntegerDigits", void 0);
__decorate$1([
    Property()
], FormatSettings.prototype, "format", void 0);
/**
 * Allows specific fields to group their data on the basis of their type.
 * For example, the date type fields can be formatted and displayed based on year, quarter, month, and more. Likewise, the number type fields can be grouped range-wise, such as 1-5, 6-10, etc.
 * You can perform custom group to the string type fields that used to displayed in the pivot table.
 */
class GroupSettings extends ChildProperty {
}
__decorate$1([
    Property()
], GroupSettings.prototype, "name", void 0);
__decorate$1([
    Property()
], GroupSettings.prototype, "groupInterval", void 0);
__decorate$1([
    Property()
], GroupSettings.prototype, "startingAt", void 0);
__decorate$1([
    Property()
], GroupSettings.prototype, "endingAt", void 0);
__decorate$1([
    Property('Date')
], GroupSettings.prototype, "type", void 0);
__decorate$1([
    Property()
], GroupSettings.prototype, "rangeInterval", void 0);
__decorate$1([
    Property()
], GroupSettings.prototype, "caption", void 0);
__decorate$1([
    Property()
], GroupSettings.prototype, "customGroups", void 0);
/**
 * Allows to specify the custom group information of specific field to create custom groups.
 */
class CustomGroups extends ChildProperty {
}
__decorate$1([
    Property()
], CustomGroups.prototype, "groupName", void 0);
__decorate$1([
    Property([])
], CustomGroups.prototype, "items", void 0);
/**
 * Allows options to create new calculated fields from the bound data source or using simple formula with basic arithmetic operators in the pivot table.
 */
class CalculatedFieldSettings extends ChildProperty {
}
__decorate$1([
    Property()
], CalculatedFieldSettings.prototype, "name", void 0);
__decorate$1([
    Property()
], CalculatedFieldSettings.prototype, "formula", void 0);
__decorate$1([
    Property()
], CalculatedFieldSettings.prototype, "hierarchyUniqueName", void 0);
__decorate$1([
    Property()
], CalculatedFieldSettings.prototype, "formatString", void 0);
/**
 * Allows specific fields used to display their the headers to be either expanded or collapsed in the pivot table.
 */
class DrillOptions extends ChildProperty {
}
__decorate$1([
    Property()
], DrillOptions.prototype, "name", void 0);
__decorate$1([
    Property()
], DrillOptions.prototype, "items", void 0);
__decorate$1([
    Property()
], DrillOptions.prototype, "delimiter", void 0);
/**
 * Allows to sort individual value field and its aggregated values either in row or column axis to ascending or descending order.
 */
class ValueSortSettings extends ChildProperty {
}
__decorate$1([
    Property()
], ValueSortSettings.prototype, "headerText", void 0);
__decorate$1([
    Property('.')
], ValueSortSettings.prototype, "headerDelimiter", void 0);
__decorate$1([
    Property('None')
], ValueSortSettings.prototype, "sortOrder", void 0);
__decorate$1([
    Property()
], ValueSortSettings.prototype, "measure", void 0);
/**
 * Allows you to set the credential information to access the specified SSAS cube.
 * > It is applicable only for OLAP data source.
 */
class Authentication extends ChildProperty {
}
__decorate$1([
    Property()
], Authentication.prototype, "userName", void 0);
__decorate$1([
    Property()
], Authentication.prototype, "password", void 0);
/**
 * Allows the following pivot report information such as rows, columns, values, filters, etc., that are used to render the pivot table and field list.
 * * `catalog`: Allows to set the database name of SSAS cube as string type that used to retrieve the data from the specified connection string. **Note: It is applicable only for OLAP data source.**
 * * `cube`: Allows you to set the SSAS cube name as string type that used to retrieve data for pivot table rendering. **Note: It is applicable only for OLAP data source.**
 * * `providerType`: Allows to set the provider type to identify the given connection is either Relational or SSAS to render the pivot table and field list.
 * * `url`: Allows to set the URL as string type, which helps to identify the service endpoint where the data are processed and retrieved to render the pivot table and field list. **Note: It is applicable only for OLAP data source.**
 * * `localeIdentifier`: Allows you to set the specific culture code as number type to render pivot table with desired localization.
 * By default, the pivot table displays with culture code **1033**, which indicates "en-US" locale. **Note: It is applicable only for OLAP data source.**
 * * `dataSource`: Allows you to set the data source as JSON collection to the pivot report either from local or from remote server to the render the pivot that and field list.
 * You can fetch JSON data from remote server by using DataManager. **Note: It is applicable only for relational data source.**
 * * `rows`: Allows specific fields associated with field information that needs to be displayed in row axis of pivot table.
 * * `columns`: Allows specific fields associated with field information that needs to be displayed in column axis of pivot table.
 * * `values`: Allows specific fields associated with field information that needs to be displayed as aggregated numeric values in pivot table.
 * * `filters`: Allows to filter the values in other axis based on the collection of filter fields in pivot table.
 * * `excludeFields`: Allows you to restrict the specific field(s) from displaying it in the field list UI.
 * You may also be unable to render the pivot table with this field(s) by doing so. **Note: It is applicable only for relational data source.**
 * * `expandAll`: Allows you to either expand or collapse all the headers that are displayed in the pivot table.
 * By default, all the headers are collapsed in the pivot table. **Note: It is applicable only for Relational data.**
 * * `valueAxis`: Allows you to set the value fields that to be plotted either in row or column axis in the pivot table.
 * * `filterSettings`: Allows specific fields associated with either selective or conditional-based filter members that used to be displayed in the pivot table.
 * * `sortSettings`: Allows specific fields associated with sort settings to order their members either in ascending or descending that used to be displayed in the pivot table.
 * By default, the data source containing fields are display with Ascending order alone. To use this option, it requires the `enableSorting` property to be **true**.
 * * `enableSorting`: Allows to perform sort operation to order members of a specific fields either in ascending or descending that used to be displayed in the pivot table.
 * * `formatSettings`: Allows specific fields used to display the values with specific format that used to be displayed in the pivot table.
 * For example, to display a specific field with currency formatted values in the pivot table, the set the `format` property to be **C**.
 * * `drilledMembers`: Allows specific fields used to display their the headers to be either expanded or collapsed in the pivot table.
 * * `valueSortSettings`: Allows to sort individual value field and its aggregated values either in row or column axis to ascending or descending order.
 * * `calculatedFieldSettings`: Allows to create new calculated fields from the bound data source or using simple formula with basic arithmetic operators in the pivot table.
 * * `allowMemberFilter`: Allows to perform filter operation based on the selective filter members of the specific fields used to be displayed in the pivot table.
 * * `allowLabelFilter`: Allows to perform filter operation based on the selective headers used to be displayed in the pivot table.
 * * `allowValueFilter`: Allows to perform filter operation based only on value fields and its resultant aggregated values over other fields defined in row and column axes that used to be displayed in the pivot table.
 * * `showSubTotals`: Allows to show or hide sub-totals in both rows and columns axis of the pivot table.
 * * `showRowSubTotals`: Allows to show or hide sub-totals in row axis of the pivot table.
 * * `showColumnSubTotals`: Allows to show or hide sub-totals in column axis of the pivot table.
 * * `showGrandTotals`: Allows to show or hide grand totals in both rows and columns axis of the pivot table.
 * * `showRowGrandTotals`: Allows to show or hide grand totals in row axis of the pivot table.
 * * `showColumnGrandTotals`: Allows to show or hide grand totals in column axis of the pivot table.
 * * `showHeaderWhenEmpty`: Allows the undefined headers to be displayed in the pivot table, when the specific field(s) are not defined in the raw data.
 * For example, if the raw data for the field Country is defined as United Kingdom and State is not defined means, it will be shown as United Kingdom >> Undefined in the header section.
 * * `alwaysShowValueHeader`: Allows to show the value field header always in pivot table, even if it holds a single field in the value field axis.
 * * `conditionalFormatSettings`: Allows a collection of values fields to change the appearance of the pivot table value cells with different style properties such as background color, font color, font family, and font size based on specific conditions.
 * * `emptyCellsTextContent`: Allows to show custom string to the empty value cells that used to display in the pivot table. You can fill empty value cells with any value like 0, -, *, (blank), etc.
 * * `groupSettings`: Allows specific fields to group their data on the basis of their type.
 * For example, the date type fields can be formatted and displayed based on year, quarter, month, and more. Likewise, the number type fields can be grouped range-wise, such as 1-5, 6-10, etc.
 * You can perform custom group to the string type fields that used to displayed in the pivot table.
 * * `showAggregationOnValueField`: Allows the pivot button with specific value field caption along with the aggregation type, to be displayed in the grouping bar and field list UI.
 * For example, if the value field "Sold Amount" is aggregated with Sum, it will be displayed with caption "Sum of Sold Amount" in its pivot button.
 * * `authentication`: Allows you to set the credential information to access the specified SSAS cube. **Note: It is applicable only for OLAP data source**.
 */
class DataSourceSettings extends ChildProperty {
}
__decorate$1([
    Property('Local')
], DataSourceSettings.prototype, "mode", void 0);
__decorate$1([
    Property()
], DataSourceSettings.prototype, "catalog", void 0);
__decorate$1([
    Property()
], DataSourceSettings.prototype, "cube", void 0);
__decorate$1([
    Property()
], DataSourceSettings.prototype, "roles", void 0);
__decorate$1([
    Property('Relational')
], DataSourceSettings.prototype, "providerType", void 0);
__decorate$1([
    Property()
], DataSourceSettings.prototype, "url", void 0);
__decorate$1([
    Property(1033)
], DataSourceSettings.prototype, "localeIdentifier", void 0);
__decorate$1([
    Property()
], DataSourceSettings.prototype, "dataSource", void 0);
__decorate$1([
    Collection([], FieldOptions)
], DataSourceSettings.prototype, "rows", void 0);
__decorate$1([
    Collection([], FieldOptions)
], DataSourceSettings.prototype, "columns", void 0);
__decorate$1([
    Collection([], FieldOptions)
], DataSourceSettings.prototype, "values", void 0);
__decorate$1([
    Collection([], FieldOptions)
], DataSourceSettings.prototype, "filters", void 0);
__decorate$1([
    Collection([], FieldOptions)
], DataSourceSettings.prototype, "fieldMapping", void 0);
__decorate$1([
    Property([])
], DataSourceSettings.prototype, "excludeFields", void 0);
__decorate$1([
    Property(false)
], DataSourceSettings.prototype, "expandAll", void 0);
__decorate$1([
    Property('column')
], DataSourceSettings.prototype, "valueAxis", void 0);
__decorate$1([
    Property(-1)
], DataSourceSettings.prototype, "valueIndex", void 0);
__decorate$1([
    Collection([], Filter)
], DataSourceSettings.prototype, "filterSettings", void 0);
__decorate$1([
    Collection([], Sort)
], DataSourceSettings.prototype, "sortSettings", void 0);
__decorate$1([
    Property(true)
], DataSourceSettings.prototype, "enableSorting", void 0);
__decorate$1([
    Property('JSON')
], DataSourceSettings.prototype, "type", void 0);
__decorate$1([
    Property(true)
], DataSourceSettings.prototype, "allowMemberFilter", void 0);
__decorate$1([
    Property(false)
], DataSourceSettings.prototype, "allowLabelFilter", void 0);
__decorate$1([
    Property(false)
], DataSourceSettings.prototype, "allowValueFilter", void 0);
__decorate$1([
    Property(true)
], DataSourceSettings.prototype, "showSubTotals", void 0);
__decorate$1([
    Property(true)
], DataSourceSettings.prototype, "showRowSubTotals", void 0);
__decorate$1([
    Property(true)
], DataSourceSettings.prototype, "showColumnSubTotals", void 0);
__decorate$1([
    Property('Auto')
], DataSourceSettings.prototype, "subTotalsPosition", void 0);
__decorate$1([
    Property(true)
], DataSourceSettings.prototype, "showGrandTotals", void 0);
__decorate$1([
    Property('Bottom')
], DataSourceSettings.prototype, "grandTotalsPosition", void 0);
__decorate$1([
    Property(true)
], DataSourceSettings.prototype, "showRowGrandTotals", void 0);
__decorate$1([
    Property(true)
], DataSourceSettings.prototype, "showColumnGrandTotals", void 0);
__decorate$1([
    Property(false)
], DataSourceSettings.prototype, "alwaysShowValueHeader", void 0);
__decorate$1([
    Property(true)
], DataSourceSettings.prototype, "showHeaderWhenEmpty", void 0);
__decorate$1([
    Property(true)
], DataSourceSettings.prototype, "showAggregationOnValueField", void 0);
__decorate$1([
    Collection([], FormatSettings)
], DataSourceSettings.prototype, "formatSettings", void 0);
__decorate$1([
    Collection([], DrillOptions)
], DataSourceSettings.prototype, "drilledMembers", void 0);
__decorate$1([
    Complex({}, ValueSortSettings)
], DataSourceSettings.prototype, "valueSortSettings", void 0);
__decorate$1([
    Collection([], CalculatedFieldSettings)
], DataSourceSettings.prototype, "calculatedFieldSettings", void 0);
__decorate$1([
    Collection([], ConditionalFormatSettings)
], DataSourceSettings.prototype, "conditionalFormatSettings", void 0);
__decorate$1([
    Property()
], DataSourceSettings.prototype, "emptyCellsTextContent", void 0);
__decorate$1([
    Collection([], GroupSettings)
], DataSourceSettings.prototype, "groupSettings", void 0);
__decorate$1([
    Complex({}, Authentication)
], DataSourceSettings.prototype, "authentication", void 0);

var __decorate$2 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Interface for a class SelectionSettings
 */
class PivotSelectionSettings extends ChildProperty {
}
__decorate$2([
    Property('Row')
], PivotSelectionSettings.prototype, "mode", void 0);
__decorate$2([
    Property('Flow')
], PivotSelectionSettings.prototype, "cellSelectionMode", void 0);
__decorate$2([
    Property('Single')
], PivotSelectionSettings.prototype, "type", void 0);
__decorate$2([
    Property(false)
], PivotSelectionSettings.prototype, "checkboxOnly", void 0);
__decorate$2([
    Property(false)
], PivotSelectionSettings.prototype, "persistSelection", void 0);
__decorate$2([
    Property('Default')
], PivotSelectionSettings.prototype, "checkboxMode", void 0);
__decorate$2([
    Property(false)
], PivotSelectionSettings.prototype, "enableSimpleMultiRowSelection", void 0);
/**
 *  Represents Pivot widget model class.
 */
class GridSettings extends ChildProperty {
}
__decorate$2([
    Property('auto')
], GridSettings.prototype, "height", void 0);
__decorate$2([
    Property('auto')
], GridSettings.prototype, "width", void 0);
__decorate$2([
    Property('Both')
], GridSettings.prototype, "gridLines", void 0);
__decorate$2([
    Property(false)
], GridSettings.prototype, "allowTextWrap", void 0);
__decorate$2([
    Property(false)
], GridSettings.prototype, "allowReordering", void 0);
__decorate$2([
    Property(true)
], GridSettings.prototype, "allowResizing", void 0);
__decorate$2([
    Property(true)
], GridSettings.prototype, "allowAutoResizing", void 0);
__decorate$2([
    Property(null)
], GridSettings.prototype, "rowHeight", void 0);
__decorate$2([
    Property(110)
], GridSettings.prototype, "columnWidth", void 0);
__decorate$2([
    Property('Ellipsis')
], GridSettings.prototype, "clipMode", void 0);
__decorate$2([
    Property(false)
], GridSettings.prototype, "allowSelection", void 0);
__decorate$2([
    Property(-1)
], GridSettings.prototype, "selectedRowIndex", void 0);
__decorate$2([
    Property({ mode: 'Row', cellSelectionMode: 'Flow', type: 'Single' })
], GridSettings.prototype, "selectionSettings", void 0);
__decorate$2([
    Property({ wrapMode: 'Both' })
], GridSettings.prototype, "textWrapSettings", void 0);
__decorate$2([
    Property('AllPages')
], GridSettings.prototype, "printMode", void 0);
__decorate$2([
    Property()
], GridSettings.prototype, "contextMenuItems", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "beforeCopy", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "printComplete", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "beforePrint", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "beforePdfExport", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "beforeExcelExport", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "contextMenuOpen", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "contextMenuClick", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "queryCellInfo", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "headerCellInfo", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "rowSelecting", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "rowSelected", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "rowDeselecting", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "rowDeselected", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "cellSelecting", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "cellSelected", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "cellDeselecting", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "cellDeselected", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "resizeStart", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "resizing", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "resizeStop", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "pdfHeaderQueryCellInfo", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "pdfQueryCellInfo", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "excelHeaderQueryCellInfo", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "excelQueryCellInfo", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "columnDragStart", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "columnDrag", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "columnDrop", void 0);
__decorate$2([
    Event()
], GridSettings.prototype, "columnRender", void 0);

/**
 * PivotView Keyboard interaction
 */
/** @hidden */
class KeyboardInteraction {
    /**
     * Constructor.
     *
     * @param {PivotView} parent - Instance of pivot table.
     */
    constructor(parent) {
        this.keyConfigs = {
            tab: 'tab',
            shiftTab: 'shift+tab',
            enter: 'enter',
            shiftUp: 'shift+upArrow',
            shiftDown: 'shift+downArrow',
            shiftLeft: 'shift+leftArrow',
            shiftRight: 'shift+rightArrow',
            shiftEnter: 'shift+enter',
            ctrlEnter: 'ctrl+enter',
            upArrow: 'upArrow',
            downArrow: 'downArrow',
            leftArrow: 'leftArrow',
            rightArrow: 'rightArrow',
            escape: 'escape',
            ctrlShiftF: 'ctrl+shift+f'
        };
        this.parent = parent;
        this.event = undefined;
        this.parent.element.tabIndex = this.parent.element.tabIndex === -1 ? 0 : this.parent.element.tabIndex;
        this.pivotViewKeyboardModule = new KeyboardEvents(this.parent.element, {
            keyAction: this.keyActionHandler.bind(this),
            keyConfigs: this.keyConfigs,
            eventName: 'keydown'
        });
    }
    keyActionHandler(e) {
        switch (e.action) {
            case 'tab':
                this.processTab(e);
                break;
            case 'shiftTab':
                this.processShiftTab(e);
                break;
            case 'enter':
            case 'shiftEnter':
            case 'ctrlEnter':
                this.processEnter(e);
                break;
            case 'shiftUp':
            case 'shiftDown':
            case 'shiftLeft':
            case 'shiftRight':
            case 'upArrow':
            case 'downArrow':
            case 'leftArrow':
            case 'rightArrow':
                this.processSelection(e);
                break;
            case 'escape':
                this.clearSelection();
                break;
            case 'ctrlShiftF':
                this.toggleFieldList(e);
                break;
        }
    }
    getNextButton(target) {
        const allPivotButtons = this.allpivotButtons(target);
        removeClass(allPivotButtons, 'e-btn-focused');
        if (this.parent.grid.element.querySelector('.' + PIVOT_BUTTON_CLASS)) {
            const len = allPivotButtons.length;
            for (let i = 0; i < len; i++) {
                if (allPivotButtons[i].getAttribute('data-uid') === target.getAttribute('data-uid')) {
                    return (allPivotButtons[i + 1] ? allPivotButtons[i + 1] : target);
                }
            }
        }
        return target;
    }
    getPrevButton(target) {
        const allPivotButtons = this.allpivotButtons(target);
        removeClass(allPivotButtons, 'e-btn-focused');
        if (this.parent.grid.element.querySelector('.' + PIVOT_BUTTON_CLASS)) {
            const len = allPivotButtons.length;
            for (let i = 0; i < len; i++) {
                if (allPivotButtons[i].getAttribute('data-uid') === target.getAttribute('data-uid')) {
                    return (allPivotButtons[i - 1] ? allPivotButtons[i - 1] : target);
                }
            }
        }
        return target;
    }
    allpivotButtons(target) {
        let buttons = [];
        if (target && this.parent.showGroupingBar) {
            const columnFilterValueGroup = closest(target, '.' + GRID_GROUPING_BAR_CLASS);
            const rowGroup = closest(target, '.' + GROUP_PIVOT_ROW);
            const chartGroup = closest(target, '.' + CHART_GROUPING_BAR_CLASS);
            const tableAxis = target.classList.contains(ROWSHEADER);
            let chartAxis;
            let rowAxis;
            let columnFilterValueAxis;
            if (columnFilterValueGroup !== null) {
                rowAxis = columnFilterValueGroup.classList.contains(GRID_GROUPING_BAR_CLASS);
            }
            else if (rowGroup !== null) {
                columnFilterValueAxis = rowGroup.classList.contains(GROUP_PIVOT_ROW);
            }
            else if (chartGroup !== null) {
                chartAxis = chartGroup.classList.contains(CHART_GROUPING_BAR_CLASS);
            }
            if (rowAxis || columnFilterValueAxis || tableAxis) {
                const groupingbarButton = [].slice.call(this.parent.element.querySelector('.' + GRID_GROUPING_BAR_CLASS).querySelectorAll('.' + PIVOT_BUTTON_CLASS));
                const headerButton = [].slice.call(this.parent.element.querySelector('.' + GROUP_PIVOT_ROW).querySelectorAll('.' + PIVOT_BUTTON_CLASS));
                buttons = groupingbarButton.concat(headerButton);
            }
            else if (chartAxis) {
                buttons = [].slice.call(this.parent.element.querySelector('.' + CHART_GROUPING_BAR_CLASS).querySelectorAll('.' + PIVOT_BUTTON_CLASS));
            }
        }
        return buttons;
    }
    processTab(e) {
        let target = e.target;
        if (target && (closest(target, '.' + PIVOT_BUTTON_CLASS) || target.classList.contains('e-group-row'))) {
            if (this.parent.grid) {
                const gridFocus = this.parent.grid.serviceLocator.getService('focus');
                if (target.classList.contains('e-group-row') && target.querySelector('.e-btn-focused')) {
                    target = target.querySelector('.e-btn-focused');
                }
                else if (target.classList.contains('e-group-row')) {
                    gridFocus.focus();
                    const element = gridFocus.getFocusedElement();
                    addClass([element], ['e-focused', 'e-focus']);
                    element.setAttribute('tabindex', '0');
                    e.preventDefault();
                    return;
                }
                const nextButton = this.getNextButton(target);
                if (nextButton.getAttribute('data-uid') !== target.getAttribute('data-uid')) {
                    if (this.parent.element.querySelector('.e-focused')) {
                        this.parent.element.querySelector('.e-focused').setAttribute('tabindex', '-1');
                        removeClass(this.parent.element.querySelectorAll('.e-focus'), 'e-focus');
                        removeClass(this.parent.element.querySelectorAll('.e-focused'), 'e-focused');
                        gridFocus.setFocusedElement(this.parent.element.querySelector('.e-headercell'));
                        this.parent.element.querySelector('.e-headercell').setAttribute('tabindex', '0');
                    }
                    else {
                        gridFocus.currentInfo.skipAction = true;
                    }
                    addClass([nextButton], 'e-btn-focused');
                    nextButton.focus();
                }
                else {
                    gridFocus.focus();
                    const element = gridFocus.getFocusedElement();
                    addClass([element], ['e-focused', 'e-focus']);
                    element.setAttribute('tabindex', '0');
                }
                e.preventDefault();
                return;
            }
        }
        else if (!this.parent.showGroupingBar && this.parent.showFieldList &&
            target && closest(target, '.' + TOGGLE_FIELD_LIST_CLASS)) {
            if (this.parent.grid) {
                const gridFocus = this.parent.grid.serviceLocator.getService('focus');
                gridFocus.focus();
                const element = gridFocus.getFocusedElement();
                addClass([element], ['e-focused', 'e-focus']);
                element.setAttribute('tabindex', '0');
                e.preventDefault();
                return;
            }
        }
        else if (!this.parent.showGroupingBar && !this.parent.showFieldList &&
            target && closest(target, '.' + PIVOT_VIEW_CLASS) && !closest(target, '.e-popup.e-popup-open')) {
            if (this.parent.grid) {
                const gridElement = closest(target, '.' + PIVOT_VIEW_CLASS);
                const gridFocus = this.parent.grid.serviceLocator.getService('focus');
                const rows = [].slice.call(gridElement.getElementsByTagName('tr'));
                if (target.innerHTML === (rows[rows.length - 1]).lastChild.innerHTML) {
                    gridFocus.currentInfo.skipAction = true;
                }
                else {
                    gridFocus.focus();
                    const element = gridFocus.getFocusedElement();
                    addClass([element], ['e-focused', 'e-focus']);
                    element.setAttribute('tabindex', '0');
                    e.preventDefault();
                    return;
                }
            }
        }
        else if (target && closest(target, '.' + GRID_TOOLBAR) && this.parent.toolbar && this.parent.toolbarModule) {
            clearTimeout(this.timeOutObj);
            this.timeOutObj = setTimeout(() => {
                removeClass(closest(target, '.' + GRID_TOOLBAR).querySelectorAll('.e-menu-item.e-focused'), 'e-focused');
                if (document.activeElement && document.activeElement.classList.contains('e-menu-item')) {
                    addClass([document.activeElement], 'e-focused');
                }
            });
        }
        else if (target.classList.contains('e-numerictextbox')) {
            const gridFocus = this.parent.grid.serviceLocator.getService('focus');
            gridFocus.focus();
            const element = gridFocus.getFocusedElement();
            removeClass([element], ['e-focused', 'e-focus']);
            element.setAttribute('tabindex', '0');
            e.preventDefault();
        }
    }
    processShiftTab(e) {
        let target = e.target;
        if (target && (closest(target, '.' + PIVOT_BUTTON_CLASS) || target.classList.contains('e-group-row'))) {
            if (this.parent.grid) {
                const gridFocus = this.parent.grid.serviceLocator.getService('focus');
                if (target.classList.contains('e-group-row') && target.querySelector('.e-btn-focused')) {
                    target = target.querySelector('.e-btn-focused');
                }
                else if (target.classList.contains('e-group-row')) {
                    target = this.parent.element.querySelector('.e-btn-focused') ? this.parent.element.querySelector('.e-btn-focused') :
                        this.parent.element.querySelector('.' + GRID_GROUPING_BAR_CLASS);
                    const allPivotButtons = this.allpivotButtons(target);
                    if (allPivotButtons.length > 0 && allPivotButtons[allPivotButtons.length - 1]) {
                        gridFocus.currentInfo.skipAction = true;
                        allPivotButtons[allPivotButtons.length - 1].focus();
                        removeClass(allPivotButtons, 'e-btn-focused');
                        addClass([allPivotButtons[allPivotButtons.length - 1]], 'e-btn-focused');
                        e.preventDefault();
                        return;
                    }
                }
                const prevButton = this.getPrevButton(target);
                if (prevButton.getAttribute('data-uid') !== target.getAttribute('data-uid')) {
                    gridFocus.currentInfo.skipAction = true;
                    prevButton.focus();
                    e.preventDefault();
                    return;
                }
            }
        }
        else if (target && this.parent.grid && (target.classList.contains('e-movablefirst') ||
            (target.classList.contains('e-rowsheader') && closest(target, 'tr').getAttribute('data-uid') ===
                this.parent.grid.element.querySelector('.e-frozencontent tr').getAttribute('data-uid')))) {
            const gridFocus = this.parent.grid.serviceLocator.getService('focus');
            if (target.classList.contains('e-movablefirst')) {
                target = (this.parent.element.querySelector('.' + GROUP_ROW_CLASS + ' .e-btn-focused')) ?
                    (this.parent.element.querySelector('.' + GROUP_ROW_CLASS + ' .e-btn-focused')) :
                    (this.parent.element.querySelector('.' + GROUP_ROW_CLASS));
                const element = gridFocus.getFocusedElement();
                removeClass([element], ['e-focused', 'e-focus']);
            }
            const allPivotButtons = this.allpivotButtons(target);
            if (allPivotButtons.length > 0) {
                gridFocus.currentInfo.skipAction = true;
                setTimeout(() => {
                    allPivotButtons[allPivotButtons.length - 1].focus();
                });
                removeClass(allPivotButtons, 'e-btn-focused');
                addClass([allPivotButtons[allPivotButtons.length - 1]], 'e-btn-focused');
                e.preventDefault();
                return;
            }
        }
        else if (target && closest(target, '.' + GRID_TOOLBAR) &&
            this.parent.toolbar && this.parent.toolbarModule) {
            clearTimeout(this.timeOutObj);
            this.timeOutObj = setTimeout(() => {
                removeClass(closest(target, '.' + GRID_TOOLBAR).querySelectorAll('.e-menu-item.e-focused'), 'e-focused');
                if (document.activeElement && document.activeElement.classList.contains('e-menu-item')) {
                    addClass([document.activeElement], 'e-focused');
                }
            });
        }
        else if (target.classList.contains('e-numerictextbox')) {
            const gridFocus = this.parent.grid.serviceLocator.getService('focus');
            gridFocus.focus();
            const element = gridFocus.getFocusedElement();
            removeClass([element], ['e-focused', 'e-focus']);
            element.setAttribute('tabindex', '0');
            e.preventDefault();
        }
    }
    processEnter(e) {
        const target = e.target;
        if (target && closest(target, '.' + GRID_CLASS)) {
            const gridFocus = this.parent.grid.serviceLocator.getService('focus');
            if (e.keyCode === 13 && !e.shiftKey && !e.ctrlKey) {
                if (target.querySelector('.' + ICON)) {
                    this.event = e;
                    target.querySelector('.' + ICON).click();
                    gridFocus.focus();
                    const element = gridFocus.getFocusedElement();
                    addClass([element], ['e-focused', 'e-focus']);
                    element.setAttribute('tabindex', '0');
                }
                else if (target.classList.contains('e-valuescontent')) {
                    target.dispatchEvent(new MouseEvent('dblclick', {
                        'view': window,
                        'bubbles': true,
                        'cancelable': true
                    }));
                    if (target.querySelector('.e-numerictextbox')) {
                        target.click();
                    }
                }
                else if (target.classList.contains('e-numerictextbox')) {
                    gridFocus.focus();
                    const element = gridFocus.getFocusedElement();
                    removeClass([element], ['e-focused', 'e-focus']);
                }
            }
            else if (e.keyCode === 13 && e.shiftKey && !e.ctrlKey) {
                if (this.parent.enableValueSorting) {
                    this.event = e;
                    target.click();
                    gridFocus.focus();
                    const element = gridFocus.getFocusedElement();
                    addClass([element], ['e-focused', 'e-focus']);
                    element.setAttribute('tabindex', '0');
                }
            }
            else if (e.keyCode === 13 && !e.shiftKey && e.ctrlKey) {
                if (this.parent.hyperlinkSettings && target.querySelector('a')) {
                    target.querySelector('a').click();
                }
            }
            e.preventDefault();
            return;
        }
    }
    clearSelection() {
        const control = this.parent;
        removeClass(control.element.querySelectorAll('.' + CELL_SELECTED_BGCOLOR + ',.' + SELECTED_BGCOLOR), [SELECTED_BGCOLOR, CELL_SELECTED_BGCOLOR, CELL_ACTIVE_BGCOLOR]);
        this.parent.renderModule.selected();
    }
    processSelection(e) {
        const target = e.target;
        if (this.parent.grid && this.parent.gridSettings.allowSelection && this.parent.gridSettings.selectionSettings.mode !== 'Row' &&
            !target.classList.contains('e-numerictextbox')) {
            const control = this.parent;
            let colIndex = Number(e.target.getAttribute('data-colindex'));
            let rowIndex = Number(e.target.getAttribute('index'));
            let ele;
            if (target.nodeName === 'TH' || target.nodeName === 'TD') {
                if (e.action === 'shiftUp' || e.action === 'upArrow') {
                    ele = (rowIndex === 0 || colIndex === 0 || (target.nodeName !== 'TH' &&
                        control.renderModule.rowStartPos !== rowIndex)) ? null
                        : this.getParentElement(control, ele, colIndex, rowIndex - 1);
                }
                else if (e.action === 'shiftDown' || e.action === 'downArrow') {
                    ele = control.element.querySelector('th[data-colindex="' + colIndex + '"][index="' + (rowIndex + 1) + '"]');
                }
                else if (e.action === 'shiftLeft' || e.action === 'leftArrow') {
                    ele = e.target.previousSibling;
                }
                else {
                    ele = e.target.nextSibling;
                }
            }
            if (!isNullOrUndefined(ele)) {
                if (control.gridSettings.selectionSettings.mode === 'Both' ? !ele.classList.contains(ROW_CELL_CLASS) : true) {
                    colIndex = Number(ele.getAttribute('data-colindex'));
                    rowIndex = Number(ele.getAttribute('index'));
                    const colSpan = Number(ele.getAttribute('aria-colspan'));
                    control.clearSelection(ele, e, colIndex, rowIndex);
                    const selectArgs = {
                        cancel: false,
                        isCellClick: true,
                        currentCell: ele,
                        data: control.pivotValues[rowIndex][colIndex]
                    };
                    control.trigger(cellSelecting, selectArgs, (observedArgs) => {
                        if (!observedArgs.cancel) {
                            control.applyColumnSelection(e, ele, colIndex, colIndex + (colSpan > 0 ? (colSpan - 1) : 0), rowIndex);
                        }
                    });
                }
                else {
                    control.clearSelection(ele, e, colIndex, rowIndex);
                }
            }
            else {
                if (e.action === 'upArrow') {
                    ele = control.element.querySelector('[data-colindex="' + colIndex + '"][index="' + (rowIndex - 1) + '"]');
                    rowIndex--;
                }
                else if (e.action === 'downArrow') {
                    ele = control.element.querySelector('[data-colindex="' + colIndex + '"][index="' + (rowIndex + 1) + '"]');
                    rowIndex++;
                }
                if (!isNullOrUndefined(ele)) {
                    control.clearSelection(ele, e, colIndex, rowIndex);
                }
            }
        }
        else if (target && (e.keyCode === 37 || e.keyCode === 38) &&
            this.parent && this.parent.showGroupingBar && this.parent.groupingBarModule && !target.classList.contains('e-numerictextbox')) {
            if (this.parent.grid && this.parent.element.querySelector('.e-frozenheader') && this.parent.element.querySelector('.e-frozenheader').querySelectorAll('.e-focus').length > 0) {
                removeClass(this.parent.element.querySelector('.e-frozenheader').querySelectorAll('.e-focus'), 'e-focus');
                removeClass(this.parent.element.querySelector('.e-frozenheader').querySelectorAll('.e-focused'), 'e-focused');
                this.parent.element.querySelector('.e-headercell').setAttribute('tabindex', '-1');
                const gridFocus = this.parent.grid.serviceLocator.getService('focus');
                gridFocus.setFocusedElement(target);
                addClass([target], ['e-focused', 'e-focus']);
                target.setAttribute('tabindex', '0');
                target.focus();
                e.preventDefault();
                return;
            }
        }
        else if (target.classList.contains('e-numerictextbox') && (e.action === 'rightArrow' || e.action === 'leftArrow')) {
            target.click();
        }
    }
    getParentElement(control, ele, colIndex, rowIndex) {
        while (!ele) {
            ele = control.element.querySelector('[data-colindex="' + colIndex + '"][index="' + rowIndex + '"]');
            colIndex--;
        }
        return ele;
    }
    toggleFieldList(e) {
        if (this.parent && !this.parent.isDestroyed && this.parent.showFieldList &&
            this.parent.pivotFieldListModule && !this.parent.pivotFieldListModule.isDestroyed &&
            this.parent.element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS)) {
            if (!this.parent.element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS).classList.contains(ICON_HIDDEN)) {
                this.parent.element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS).click();
                e.preventDefault();
                return;
            }
            else if (this.parent.element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS).classList.contains(ICON_HIDDEN) &&
                this.parent.pivotFieldListModule.dialogRenderer && this.parent.pivotFieldListModule.dialogRenderer.fieldListDialog &&
                !this.parent.pivotFieldListModule.dialogRenderer.fieldListDialog.isDestroyed) {
                this.parent.pivotFieldListModule.dialogRenderer.fieldListDialog.hide();
            }
        }
    }
    /**
     *
     * To destroy the keyboard module.
     *
     * @returns  {void}
     * @private
     */
    destroy() {
        if (this.pivotViewKeyboardModule) {
            this.pivotViewKeyboardModule.destroy();
        }
        else {
            return;
        }
    }
}

/**
 * Module to render Pivot button
 */
/** @hidden */
class PivotContextMenu {
    /**
     * Constructor for render module
     *
     * @param {PivotView | PivotFieldList} parent - parent
     * */
    constructor(parent) {
        this.parent = parent;
        this.parent.contextMenuModule = this;
    }
    /**
     * Initialize the pivot table rendering
     *
     * @returns {void}
     * @private
     */
    render() {
        this.renderContextMenu();
    }
    renderContextMenu() {
        const menuItems = [
            { text: this.parent.localeObj.getConstant('addToFilter'), id: this.parent.element.id + '_Filters' },
            { text: this.parent.localeObj.getConstant('addToRow'), id: this.parent.element.id + '_Rows' },
            { text: this.parent.localeObj.getConstant('addToColumn'), id: this.parent.element.id + '_Columns' },
            { text: this.parent.localeObj.getConstant('addToValue'), id: this.parent.element.id + '_Values' }
        ];
        const menuOptions = {
            cssClass: PIVOT_CONTEXT_MENU_CLASS + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
            items: menuItems,
            enableRtl: this.parent.enableRtl,
            locale: this.parent.locale,
            beforeOpen: this.onBeforeMenuOpen.bind(this),
            select: this.onSelectContextMenu.bind(this)
        };
        const cMenu = createElement('ul', {
            id: this.parent.element.id + '_PivotContextMenu'
        });
        this.parent.element.appendChild(cMenu);
        this.menuObj = new ContextMenu$1(menuOptions);
        this.menuObj.isStringTemplate = true;
        this.menuObj.appendTo(cMenu);
    }
    onBeforeMenuOpen(args) {
        const items = [].slice.call(args.element.querySelectorAll('li'));
        const fieldType = this.parent.dataType === 'olap' ? this.fieldElement.getAttribute('data-type') :
            this.fieldElement.querySelector('.' + PIVOT_BUTTON_CONTENT_CLASS).getAttribute('data-type');
        removeClass(items, MENU_DISABLE);
        if (fieldType === 'CalculatedField' || fieldType === 'isMeasureFieldsAvail') {
            for (const item of items) {
                if (item.textContent !== this.parent.localeObj.getConstant('addToValue')) {
                    addClass([item], MENU_DISABLE);
                }
            }
        }
        else if (fieldType === 'isMeasureAvail') {
            for (const item of items) {
                if (item.textContent !== this.parent.localeObj.getConstant('addToRow') &&
                    item.textContent !== this.parent.localeObj.getConstant('addToColumn')) {
                    addClass([item], MENU_DISABLE);
                }
            }
        }
        else if (this.parent.dataType === 'olap') {
            for (const item of items) {
                if (item.textContent === this.parent.localeObj.getConstant('addToValue')) {
                    addClass([item], MENU_DISABLE);
                    break;
                }
            }
        }
    }
    onSelectContextMenu(menu) {
        if (menu.element.textContent !== null) {
            const fieldName = this.fieldElement.getAttribute('data-uid');
            const dropClass = menu.item.id.replace(this.parent.element.id + '_', '').toLowerCase();
            this.parent.pivotCommon.dataSourceUpdate.control = this.parent.getModuleName() === 'pivotview' ? this.parent :
                (this.parent.pivotGridModule ? this.parent.pivotGridModule : this.parent);
            this.parent.pivotCommon.dataSourceUpdate.btnElement = this.fieldElement;
            this.parent.pivotCommon.dataSourceUpdate.updateDataSource(fieldName, dropClass, -1);
            this.parent.updateDataSource(true);
            this.fieldElement = undefined;
        }
    }
    /**
     * To destroy the pivot button event listener
     *
     * @returns {void}
     * @hidden
     */
    destroy() {
        if (!this.parent.isDestroyed) {
            return;
        }
        if (this.menuObj && !this.menuObj.isDestroyed) {
            this.menuObj.destroy();
            if (select('#' + this.parent.element.id + '_PivotContextMenu', document)) {
                remove(select('#' + this.parent.element.id + '_PivotContextMenu', document));
            }
        }
        else {
            return;
        }
    }
}

/**
 * `VirtualScroll` module is used to handle scrolling behavior.
 */
class VirtualScroll$1 {
    /**
     * Constructor for PivotView scrolling.
     *
     * @param {PivotView} parent - Instance of pivot table.
     * @hidden
     */
    constructor(parent) {
        this.previousValues = { top: 0, left: 0 };
        this.frozenPreviousValues = { top: 0, left: 0 };
        this.eventType = '';
        this.isFireFox = Browser.userAgent.toLowerCase().indexOf('firefox') > -1;
        this.parent = parent;
        this.addInternalEvents();
    }
    /**
     * It returns the Module name.
     *
     * @returns {string} - string.
     * @hidden
     */
    getModuleName() {
        return 'virtualscroll';
    }
    addInternalEvents() {
        this.parent.on(contentReady, this.wireEvents, this);
    }
    wireEvents() {
        this.engineModule = this.parent.dataType === 'pivot' ? this.parent.engineModule : this.parent.olapEngineModule;
        if (this.parent.displayOption.view !== 'Chart') {
            const mCont = this.parent.element.querySelector('.' + MOVABLECONTENT_DIV);
            const fCont = this.parent.element.querySelector('.' + FROZENCONTENT_DIV);
            const mHdr = this.parent.element.querySelector('.' + MOVABLEHEADER_DIV);
            const mScrollBar = mCont.parentElement.parentElement.querySelector('.' + MOVABLESCROLL_DIV);
            EventHandler.clearEvents(mCont);
            EventHandler.clearEvents(fCont);
            if (this.isFireFox) {
                EventHandler.clearEvents(mHdr);
            }
            if (this.engineModule) {
                const ele = this.parent.isAdaptive ? mCont : mCont.parentElement.parentElement.querySelector('.' + MOVABLESCROLL_DIV);
                EventHandler.add(ele, 'scroll touchmove pointermove', this.onHorizondalScroll(mHdr, mCont, fCont), this);
                EventHandler.add(mCont.parentElement, 'scroll wheel touchmove pointermove keyup keydown', this.onVerticalScroll(fCont, mCont), this);
                if (this.isFireFox) {
                    EventHandler.add(mCont, 'mouseup touchend scroll', this.common(mHdr, mCont, fCont), this);
                }
                else {
                    EventHandler.add(mCont.parentElement.parentElement, 'mouseup touchend', this.common(mHdr, mCont, fCont), this);
                }
                EventHandler.add(mScrollBar, 'scroll', this.onCustomScrollbarScroll(mCont, mHdr), this);
                EventHandler.add(mCont, 'scroll', this.onCustomScrollbarScroll(mScrollBar, mHdr), this);
                EventHandler.add(mHdr, 'scroll', this.onCustomScrollbarScroll(mScrollBar, mCont), this);
                // EventHandler.add(fCont.parentElement, 'wheel', this.onWheelScroll(mCont, fCont), this);
                // EventHandler.add(fCont.parentElement, 'touchstart pointerdown', this.setPageXY(), this);
                // EventHandler.add(fCont.parentElement, 'touchmove pointermove', this.onTouchScroll(mHdr, mCont, fCont), this);
                EventHandler.add(mHdr, 'touchstart pointerdown', this.setPageXY(), this);
                EventHandler.add(mHdr, 'touchmove pointermove', this.onTouchScroll(mHdr, mCont, fCont), this);
                EventHandler.add(mCont, 'touchstart pointerdown', this.setPageXY(), this);
                EventHandler.add(mCont, 'touchmove pointermove', this.onTouchScroll(mHdr, mCont, fCont), this);
            }
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this.parent.grid.on('check-scroll-reset', (args) => {
                args.cancel = true;
            });
            this.parent.grid.on('prevent-frozen-scroll-refresh', function (args) {
                args.cancel = true;
            });
            this.parent.grid.isPreventScrollEvent = true;
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onWheelScroll(mCont, fCont) {
        const element = mCont;
        return (e) => {
            const top = element.parentElement.scrollTop + (e.deltaMode === 1 ? e.deltaY * 30 : e.deltaY);
            if (this.frozenPreviousValues.top === top) {
                return;
            }
            e.preventDefault();
            this.frozenPreviousValues.top = top;
            this.eventType = e.type;
        };
    }
    getPointXY(e) {
        const pageXY = { x: 0, y: 0 };
        if (!(e.touches && e.touches.length)) {
            pageXY.x = e.pageX;
            pageXY.y = e.pageY;
        }
        else {
            pageXY.x = e.touches[0].pageX;
            pageXY.y = e.touches[0].pageY;
        }
        return pageXY;
    }
    onCustomScrollbarScroll(mCont, mHdr) {
        const content = mCont;
        const header = mHdr;
        return (e) => {
            const eContent = this.parent.element.querySelector('.' + MOVABLECONTENT_DIV).parentElement;
            if (eContent.querySelector('tbody') === null) {
                return;
            }
            const target = e.target;
            const left = target.scrollLeft;
            if (this.previousValues.left === left || (this.isFireFox && target.classList.contains(MOVABLEHEADER_DIV))) {
                return;
            }
            content.scrollLeft = left;
            header.scrollLeft = left;
            this.previousValues.left = left;
            if (this.parent.isDestroyed) {
                return;
            }
        };
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onTouchScroll(mHdr, mCont, fCont) {
        const element = mCont;
        return (e) => {
            if (e.pointerType === 'mouse') {
                return;
            }
            const pageXY = this.getPointXY(e);
            const top = element.parentElement.scrollTop + (this.pageXY.y - pageXY.y);
            const ele = this.parent.isAdaptive ? mCont : element.parentElement.parentElement.querySelector('.' + MOVABLESCROLL_DIV);
            const left = ele.scrollLeft + (this.pageXY.x - pageXY.x);
            if (this.frozenPreviousValues.left === left || left < 0) {
                return;
            }
            mHdr.scrollLeft = left;
            ele.scrollLeft = left;
            this.pageXY.x = pageXY.x;
            this.frozenPreviousValues.left = left;
            if (this.frozenPreviousValues.top === top || top < 0) {
                return;
            }
            this.pageXY.y = pageXY.y;
            this.frozenPreviousValues.top = top;
            this.eventType = e.type;
        };
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    update(mHdr, mCont, top, left, e) {
        this.parent.isScrolling = true;
        const engine = this.parent.dataType === 'pivot' ? this.parent.engineModule : this.parent.olapEngineModule;
        const args = {
            dataSourceSettings: PivotUtil.getClonedDataSourceSettings(this.parent.dataSourceSettings)
        };
        if (this.parent.pageSettings && engine.pageSettings) {
            if (this.direction === 'vertical') {
                const rowValues = this.parent.dataType === 'pivot' ?
                    (this.parent.dataSourceSettings.valueAxis === 'row' ? this.parent.dataSourceSettings.values.length : 1) : 1;
                const exactSize = (this.parent.pageSettings.rowPageSize * rowValues * this.parent.gridSettings.rowHeight);
                const section = Math.ceil(top / exactSize);
                if ((this.parent.scrollPosObject.vertical === section ||
                    engine.pageSettings.rowPageSize >= engine.rowCount)) {
                    // this.parent.hideWaitingPopup();
                    return;
                }
                this.parent.actionObj.actionName = verticalScroll;
                this.parent.actionBeginMethod();
                this.parent.showWaitingPopup();
                this.parent.scrollPosObject.vertical = section;
                this.parent.pageSettings.currentRowPage = engine.pageSettings.currentRowPage = section > 1 ? section : 1;
                let rowStartPos = 0;
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                this.parent.trigger(enginePopulating, args, (observedArgs) => {
                    if (this.parent.dataType === 'pivot') {
                        if (this.parent.dataSourceSettings.mode === 'Server') {
                            this.parent.getEngine('onScroll', null, null, null, null, null, null);
                        }
                        else {
                            this.parent.engineModule.generateGridData(this.parent.dataSourceSettings, true, this.parent.engineModule.headerCollection);
                            rowStartPos = this.parent.engineModule.rowStartPos;
                        }
                    }
                    else {
                        this.parent.olapEngineModule.scrollPage();
                        rowStartPos = this.parent.olapEngineModule.pageRowStartPos;
                    }
                    this.enginePopulatedEventMethod(engine);
                });
                const exactPage = Math.ceil(rowStartPos / (this.parent.pageSettings.rowPageSize * rowValues));
                const pos = exactSize * exactPage -
                    (engine.rowFirstLvl * rowValues * this.parent.gridSettings.rowHeight);
                this.parent.scrollPosObject.verticalSection = pos;
            }
            else {
                const colValues = this.parent.dataType === 'pivot' ?
                    (this.parent.dataSourceSettings.valueAxis === 'column' ? this.parent.dataSourceSettings.values.length : 1) : 1;
                const exactSize = (this.parent.pageSettings.columnPageSize *
                    colValues * this.parent.gridSettings.columnWidth);
                const section = Math.ceil(left / exactSize);
                if (this.parent.scrollPosObject.horizontal === section) {
                    // this.parent.hideWaitingPopup();
                    return;
                }
                this.parent.actionObj.actionName = horizontalScroll;
                this.parent.actionBeginMethod();
                this.parent.showWaitingPopup();
                const pivot = this.parent;
                pivot.scrollPosObject.horizontal = section;
                this.parent.pageSettings.currentColumnPage = engine.pageSettings.currentColumnPage = section > 1 ? section : 1;
                let colStartPos = 0;
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                this.parent.trigger(enginePopulating, args, (observedArgs) => {
                    if (pivot.dataType === 'pivot') {
                        if (this.parent.dataSourceSettings.mode === 'Server') {
                            this.parent.getEngine('onScroll', null, null, null, null, null, null);
                        }
                        else {
                            pivot.engineModule.generateGridData(pivot.dataSourceSettings, true, pivot.engineModule.headerCollection);
                            colStartPos = pivot.engineModule.colStartPos;
                        }
                    }
                    else {
                        pivot.olapEngineModule.scrollPage();
                        colStartPos = pivot.olapEngineModule.pageColStartPos;
                    }
                    this.enginePopulatedEventMethod(engine);
                });
                const exactPage = Math.ceil(colStartPos / (pivot.pageSettings.columnPageSize * colValues));
                const pos = exactSize * exactPage - (engine.colFirstLvl *
                    colValues * pivot.gridSettings.columnWidth);
                pivot.scrollPosObject.horizontalSection = pos;
            }
            this.parent.actionObj.actionName = this.parent.getActionCompleteName();
            if (this.parent.actionObj.actionName) {
                this.parent.actionCompleteMethod();
            }
        }
    }
    enginePopulatedEventMethod(engine, control) {
        const pivot = control ? control : this.parent;
        const eventArgs = {
            dataSourceSettings: pivot.dataSourceSettings,
            pivotValues: engine.pivotValues
        };
        pivot.trigger(enginePopulated, eventArgs, (observedArgs) => {
            this.parent.pivotValues = observedArgs.pivotValues;
        });
    }
    setPageXY() {
        return (e) => {
            if (e.pointerType === 'mouse') {
                return;
            }
            this.pageXY = this.getPointXY(e);
        };
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    common(mHdr, mCont, fCont) {
        return (e) => {
            const ele = this.parent.isAdaptive ? mCont : mCont.parentElement.parentElement.querySelector('.' + MOVABLESCROLL_DIV);
            this.update(mHdr, mCont, mCont.parentElement.scrollTop * this.parent.verticalScrollScale, ele.scrollLeft * this.parent.horizontalScrollScale, e);
        };
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onHorizondalScroll(mHdr, mCont, fCont) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        let timeOutObj;
        return (e) => {
            const ele = this.parent.isAdaptive ? mCont : mCont.parentElement.parentElement.querySelector('.' + MOVABLESCROLL_DIV);
            let left = ele.scrollLeft * this.parent.horizontalScrollScale;
            if (e.type === 'wheel' || e.type === 'touchmove' || this.eventType === 'wheel' || this.eventType === 'touchmove') {
                clearTimeout(timeOutObj);
                timeOutObj = setTimeout(() => {
                    left = e.type === 'touchmove' ? ele.scrollLeft : left;
                    this.update(mHdr, mCont, mCont.parentElement.scrollTop * this.parent.verticalScrollScale, left, e);
                }, 300);
            }
            if (this.previousValues.left === left) {
                return;
            }
            this.parent.scrollDirection = this.direction = 'horizondal';
            let horiOffset = -((left - this.parent.scrollPosObject.horizontalSection - ele.scrollLeft));
            const vertiOffset = mCont.querySelector('.' + TABLE).style.transform.split(',').length > 1 ?
                mCont.querySelector('.' + TABLE).style.transform.split(',')[1].trim() : '0px)';
            if (ele.scrollLeft < this.parent.scrollerBrowserLimit) {
                setStyleAttribute(mCont.querySelector('.e-table'), {
                    transform: 'translate(' + horiOffset + 'px,' + vertiOffset
                });
                setStyleAttribute(mHdr.querySelector('.e-table'), {
                    transform: 'translate(' + horiOffset + 'px,' + 0 + 'px)'
                });
            }
            let excessMove = this.parent.scrollPosObject.horizontalSection > left ?
                -(this.parent.scrollPosObject.horizontalSection - left) : ((left + mHdr.offsetWidth) -
                (this.parent.scrollPosObject.horizontalSection + mCont.querySelector('.e-table').offsetWidth));
            const notLastPage = Math.ceil(this.parent.scrollPosObject.horizontalSection / this.parent.horizontalScrollScale) <
                this.parent.scrollerBrowserLimit;
            if (this.parent.scrollPosObject.horizontalSection > left ? true : (excessMove > 1 && notLastPage)) {
                //  showSpinner(this.parent.element);
                if (left > mHdr.clientWidth) {
                    if (this.parent.scrollPosObject.left < 1) {
                        this.parent.scrollPosObject.left = mHdr.clientWidth;
                    }
                    this.parent.scrollPosObject.left = this.parent.scrollPosObject.left - 50;
                    excessMove = this.parent.scrollPosObject.horizontalSection > left ?
                        (excessMove - this.parent.scrollPosObject.left) : (excessMove + this.parent.scrollPosObject.left);
                }
                else {
                    excessMove = -this.parent.scrollPosObject.horizontalSection;
                }
                horiOffset = -((left - (this.parent.scrollPosObject.horizontalSection + excessMove) - mCont.parentElement.parentElement.querySelector('.' + MOVABLESCROLL_DIV).scrollLeft));
                let vWidth = (this.parent.gridSettings.columnWidth * this.engineModule.columnCount);
                if (vWidth > this.parent.scrollerBrowserLimit) {
                    this.parent.horizontalScrollScale = vWidth / this.parent.scrollerBrowserLimit;
                    vWidth = this.parent.scrollerBrowserLimit;
                }
                if (horiOffset > vWidth && horiOffset > left) {
                    horiOffset = left;
                    excessMove = 0;
                }
                setStyleAttribute(mCont.querySelector('.e-table'), {
                    transform: 'translate(' + horiOffset + 'px,' + vertiOffset
                });
                setStyleAttribute(mHdr.querySelector('.e-table'), {
                    transform: 'translate(' + horiOffset + 'px,' + 0 + 'px)'
                });
                this.parent.scrollPosObject.horizontalSection = this.parent.scrollPosObject.horizontalSection + excessMove;
            }
            const hScrollPos = (ele.scrollWidth - (ele.scrollLeft + ele.offsetWidth));
            if (hScrollPos <= 0) {
                const virtualDiv = mCont.querySelector('.' + VIRTUALTRACK_DIV);
                virtualDiv.style.display = 'none';
                const mCntScrollPos = (mCont.scrollWidth - (mCont.scrollLeft + mCont.offsetWidth));
                virtualDiv.style.display = '';
                const mCntVScrollPos = (mCont.scrollWidth - (mCont.scrollLeft + mCont.offsetWidth));
                this.parent.scrollPosObject.horizontalSection -= mCntScrollPos > hScrollPos ? mCntScrollPos : -mCntVScrollPos;
                horiOffset = (ele.scrollLeft > this.parent.scrollerBrowserLimit) ?
                    Number(mCont.querySelector('.' + TABLE).style.transform.split(',')[0].split('px')[0].trim()) :
                    -(((ele.scrollLeft * this.parent.horizontalScrollScale) -
                        this.parent.scrollPosObject.horizontalSection - ele.scrollLeft));
                setStyleAttribute(mCont.querySelector('.e-table'), {
                    transform: 'translate(' + horiOffset + 'px,' + vertiOffset
                });
                setStyleAttribute(mHdr.querySelector('.e-table'), {
                    transform: 'translate(' + horiOffset + 'px,' + 0 + 'px)'
                });
            }
            this.previousValues.left = left;
            this.frozenPreviousValues.left = left;
            this.eventType = '';
            mHdr.scrollLeft = ele.scrollLeft;
        };
    }
    onVerticalScroll(fCont, mCont) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        let timeOutObj;
        return (e) => {
            const top = mCont.parentElement.scrollTop * this.parent.verticalScrollScale;
            if (e.type === 'wheel' || e.type === 'touchmove' || this.eventType === 'wheel' || this.eventType === 'touchmove' || e.type === 'keyup' || e.type === 'keydown') {
                const ele = this.parent.isAdaptive ? mCont : mCont.parentElement.parentElement.querySelector('.' + MOVABLESCROLL_DIV);
                clearTimeout(timeOutObj);
                timeOutObj = setTimeout(() => {
                    this.update(null, mCont, mCont.parentElement.scrollTop * this.parent.verticalScrollScale, ele.scrollLeft * this.parent.horizontalScrollScale, e);
                }, 300);
            }
            if (this.previousValues.top === top) {
                return;
            }
            this.parent.scrollDirection = this.direction = 'vertical';
            let vertiOffset = -((top - this.parent.scrollPosObject.verticalSection - mCont.parentElement.scrollTop));
            const horiOffset = mCont.querySelector('.' + TABLE).style.transform.split(',')[0].trim();
            if (vertiOffset > this.parent.virtualDiv.clientHeight) {
                vertiOffset = this.parent.virtualDiv.clientHeight;
            }
            if (mCont.parentElement.scrollTop < this.parent.scrollerBrowserLimit) {
                setStyleAttribute(fCont.querySelector('.e-table'), {
                    transform: 'translate(' + 0 + 'px,' + vertiOffset + 'px)'
                });
                setStyleAttribute(mCont.querySelector('.e-table'), {
                    transform: horiOffset + ',' + vertiOffset + 'px)'
                });
            }
            let excessMove = this.parent.scrollPosObject.verticalSection > top ?
                -(this.parent.scrollPosObject.verticalSection - top) : ((top + fCont.parentElement.clientHeight) -
                (this.parent.scrollPosObject.verticalSection + fCont.querySelector('.e-table').offsetHeight));
            const notLastPage = Math.ceil(this.parent.scrollPosObject.verticalSection / this.parent.verticalScrollScale) <
                this.parent.scrollerBrowserLimit;
            if (this.parent.scrollPosObject.verticalSection > top ? true : (excessMove > 1 && notLastPage)) {
                //  showSpinner(this.parent.element);
                if (top > fCont.parentElement.clientHeight) {
                    if (this.parent.scrollPosObject.top < 1) {
                        this.parent.scrollPosObject.top = fCont.parentElement.clientHeight;
                    }
                    this.parent.scrollPosObject.top = this.parent.scrollPosObject.top - 50;
                    excessMove = this.parent.scrollPosObject.verticalSection > top ?
                        (excessMove - this.parent.scrollPosObject.top) : (excessMove + this.parent.scrollPosObject.top);
                }
                else {
                    excessMove = -this.parent.scrollPosObject.verticalSection;
                }
                const movableTable = this.parent.element.querySelector('.' + MOVABLECONTENT_DIV).querySelector('.e-table');
                vertiOffset = -((top - (this.parent.scrollPosObject.verticalSection + excessMove) - mCont.parentElement.scrollTop));
                let vHeight = (this.parent.gridSettings.rowHeight * this.engineModule.rowCount + 0.1
                    - movableTable.clientHeight);
                if (vHeight > this.parent.scrollerBrowserLimit) {
                    this.parent.verticalScrollScale = vHeight / this.parent.scrollerBrowserLimit;
                    vHeight = this.parent.scrollerBrowserLimit;
                }
                if (vertiOffset > vHeight && vertiOffset > top) {
                    vertiOffset = top;
                    excessMove = 0;
                }
                if (vertiOffset > this.parent.virtualDiv.clientHeight) {
                    vertiOffset = this.parent.virtualDiv.clientHeight;
                }
                setStyleAttribute(fCont.querySelector('.e-table'), {
                    transform: 'translate(' + 0 + 'px,' + vertiOffset + 'px)'
                });
                setStyleAttribute(mCont.querySelector('.e-table'), {
                    transform: horiOffset + ',' + vertiOffset + 'px)'
                });
                this.parent.scrollPosObject.verticalSection = this.parent.scrollPosObject.verticalSection + excessMove;
            }
            this.previousValues.top = top;
            this.frozenPreviousValues.top = top;
            this.eventType = '';
        };
    }
    /**
     * @hidden
     */
    removeInternalEvents() {
        if (this.parent.isDestroyed) {
            return;
        }
        this.parent.off(contentReady, this.wireEvents);
    }
    /**
     * To destroy the virtualscrolling event listener
     *
     * @returns {void}
     * @hidden
     */
    destroy() {
        this.removeInternalEvents();
    }
}

/**
 * `DrillThroughDialog` module to create drill-through dialog.
 */
/** @hidden */
class DrillThroughDialog {
    /**
     * Constructor for the dialog action.
     *
     * @param {PivotView} parent - parent.
     * @hidden
     */
    constructor(parent) {
        /** @hidden */
        this.indexString = [];
        this.clonedData = [];
        this.isUpdated = false;
        this.gridIndexObjects = {};
        this.gridData = [];
        this.formatList = {};
        this.drillKeyConfigs = {
            escape: 'escape'
        };
        this.parent = parent;
        this.engine = this.parent.dataType === 'olap' ? this.parent.olapEngineModule : this.parent.engineModule;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    frameHeaderWithKeys(header) {
        const keys = Object.keys(header);
        let keyPos = 0; // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const framedHeader = {};
        while (keyPos < keys.length) {
            framedHeader[keys[keyPos]] = header[keys[keyPos]];
            keyPos++;
        }
        return framedHeader;
    }
    /**
     * show Drill Through Dialog
     *
     * @param {DrillThroughEventArgs} eventArgs - eventArgs.
     * @returns {void}
     * @hidden */
    showDrillThroughDialog(eventArgs) {
        this.gridData = eventArgs.rawData;
        for (let i = 0; i < eventArgs.rawData.length; i++) {
            this.clonedData.push(this.frameHeaderWithKeys(eventArgs.rawData[i]));
        }
        // let actualText: string = eventArgs.currentCell.actualText.toString();
        try {
            if (this.parent.currentView === 'Table' && this.parent.editSettings.allowInlineEditing &&
                this.parent.editSettings.allowEditing && eventArgs.rawData.length === 1) {
                this.parent.actionObj.actionName = editRecord;
                if (this.parent.actionBeginMethod()) {
                    return;
                }
                this.editCell(eventArgs);
            }
            else {
                this.removeDrillThroughDialog();
                const drillThroughDialog = createElement('div', {
                    id: this.parent.element.id + '_drillthrough',
                    className: DRILLTHROUGH_DIALOG
                });
                this.parent.element.appendChild(drillThroughDialog);
                this.dialogPopUp = new Dialog({
                    animationSettings: { effect: 'Fade' },
                    allowDragging: false,
                    header: this.parent.localeObj.getConstant('details'),
                    content: this.createDrillThroughGrid(eventArgs),
                    cssClass: this.parent.cssClass,
                    beforeOpen: () => {
                        this.drillThroughGrid.setProperties({
                            dataSource: this.parent.editSettings.allowEditing ?
                                this.dataWithPrimarykey(eventArgs) : this.gridData,
                            height: !this.parent.editSettings.allowEditing ? 300 : 220
                        }, false);
                    },
                    beforeClose: () => {
                        if (this.parent.editSettings.allowEditing && this.isUpdated) {
                            if (this.parent.dataSourceSettings.type === 'CSV') {
                                this.updateData(this.drillThroughGrid.dataSource);
                            }
                            const gridIndexObjectsValue = Object.keys(this.gridIndexObjects);
                            const previousPosition = [];
                            for (const value of gridIndexObjectsValue) {
                                previousPosition.push(this.gridIndexObjects[value]);
                            }
                            let count = Object.keys(this.gridIndexObjects).length;
                            const addItems = [];
                            const prevItems = [];
                            let index = 0;
                            for (const item of this.drillThroughGrid.dataSource) {
                                if (isNullOrUndefined(item['__index']) || item['__index'] === '') {
                                    for (const field of this.engine.fields) {
                                        if (isNullOrUndefined(item[field])) {
                                            delete item[field];
                                        }
                                    }
                                    delete item['__index'];
                                    addItems.push(item);
                                }
                                else if (count > 0) {
                                    delete this.gridIndexObjects[item['__index'].toString()];
                                    prevItems.push(item);
                                    count--;
                                }
                                if (this.parent.dataSourceSettings.mode === 'Server') {
                                    if (item['__index']) {
                                        delete item['__index'];
                                    }
                                    if (this.gridData[index]['__index']) {
                                        delete this.gridData[index]['__index'];
                                    }
                                }
                                index++;
                            }
                            count = 0;
                            if (this.parent.dataSourceSettings.mode === 'Server') {
                                const gridIndex = [];
                                let keys = Object.keys(this.gridIndexObjects);
                                for (let len = 0; len < keys.length; len++) {
                                    delete this.parent.drillThroughValue.indexObject[this.gridIndexObjects[keys[len]]];
                                    gridIndex.push({ Key: keys[len], Value: this.gridIndexObjects[keys[len]] });
                                }
                                const indexObject = [];
                                keys = Object.keys(this.parent.drillThroughValue.indexObject);
                                for (let len = 0; len < keys.length; len++) {
                                    indexObject.push({
                                        Key: keys[len], Value: this.parent.drillThroughValue.indexObject[keys[len]]
                                    });
                                }
                                this.parent.getEngine('updateRawData', null, null, null, null, null, null, null, { 'addedData': addItems, 'removedData': gridIndex, 'updatedData': prevItems, indexObject: indexObject });
                            }
                            else {
                                let items = [];
                                const data = this.parent.allowDataCompression
                                    ? this.parent.engineModule.actualData : this.parent.engineModule.data;
                                for (const item of data) {
                                    delete item['__index'];
                                    if (this.gridIndexObjects[count.toString()] === undefined) {
                                        items.push(item);
                                    }
                                    count++;
                                }
                                items = items.concat(addItems);
                                const eventArgs = {
                                    currentData: this.drillThroughGrid.dataSource,
                                    previousData: this.clonedData,
                                    previousPosition: previousPosition,
                                    cancel: false
                                };
                                this.parent.trigger(editCompleted, eventArgs);
                                if (!eventArgs.cancel) {
                                    this.parent.setProperties({ dataSourceSettings: { dataSource: items } }, true);
                                    this.engine.updateGridData(this.parent.dataSourceSettings);
                                    this.parent.pivotValues = this.engine.pivotValues;
                                }
                            }
                            this.parent.actionObj.actionName = recordUpdated;
                            const actionInfo = {
                                editInfo: {
                                    type: this.drillThroughGrid.editSettings.mode, action: 'Update', currentData: this.drillThroughGrid.dataSource,
                                    previousData: this.clonedData, previousPosition: previousPosition
                                }
                            };
                            this.parent.actionObj.actionInfo = actionInfo;
                        }
                        this.isUpdated = false;
                        this.gridIndexObjects = {};
                    },
                    isModal: true,
                    visible: true,
                    showCloseIcon: true,
                    locale: this.parent.locale,
                    enableRtl: this.parent.enableRtl,
                    enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
                    width: this.parent.isAdaptive ? '100%' : '60%',
                    position: { X: 'center', Y: 'center' },
                    closeOnEscape: !this.parent.editSettings.allowEditing,
                    target: document.body,
                    close: this.removeDrillThroughDialog.bind(this)
                });
                this.dialogPopUp.isStringTemplate = true;
                this.dialogPopUp.appendTo(drillThroughDialog);
                // this.dialogPopUp.element.querySelector('.e-dlg-header').innerText = this.parent.localeObj.getConstant('details');
                setStyleAttribute(this.dialogPopUp.element, { 'visibility': 'visible' });
                if (this.parent.editSettings.allowEditing) {
                    this.drillthroughKeyboardModule = new KeyboardEvents(this.dialogPopUp.element, {
                        keyAction: this.drillthroughKeyActionHandler.bind(this),
                        keyConfigs: this.drillKeyConfigs,
                        eventName: 'keydown'
                    });
                }
            }
        }
        catch (execption) {
            this.parent.actionFailureMethod(execption);
        }
    }
    editCell(eventArgs) {
        const gridResize = this.parent.gridSettings.allowResizing;
        const actualText = eventArgs.currentCell.actualText.toString();
        const indexObject = Number(Object.keys(eventArgs.currentCell.indexObject));
        eventArgs.currentTarget.firstElementChild.style.display = 'none';
        const cellValue = Number(eventArgs.rawData[0][actualText]);
        /* eslint-disable @typescript-eslint/no-explicit-any */
        const previousData = this.frameHeaderWithKeys(eventArgs.rawData[eventArgs.rawData.length - 1]);
        const currentData = eventArgs.rawData[eventArgs.rawData.length - 1];
        /* eslint-enable @typescript-eslint/no-explicit-any */
        // if (eventArgs.currentCell.actualText in previousData) {
        //     currentData[eventArgs.currentCell.actualText] = eventArgs.currentCell.actualValue;
        // }
        const actionInfo = {
            editInfo: { type: 'Inline editing', action: 'update', data: this.gridData }
        };
        this.parent.actionObj.actionInfo = actionInfo;
        this.numericTextBox = new NumericTextBox({
            value: cellValue,
            enableRtl: this.parent.enableRtl,
            enabled: true,
            format: '####.##',
            locale: this.parent.locale,
            cssClass: this.parent.cssClass,
            change: () => {
                const textBoxValue = isNullOrUndefined(this.numericTextBox.value) ? 0 : this.numericTextBox.value;
                const indexValue = eventArgs.currentCell.indexObject[indexObject];
                eventArgs.rawData[0][actualText] = textBoxValue;
                this.parent.engineModule.data[indexValue] = eventArgs.rawData[0];
            },
            blur: () => {
                const eventArgs = {
                    currentData: currentData,
                    previousData: previousData,
                    previousPosition: currentData.index,
                    cancel: false
                };
                this.parent.trigger(editCompleted, eventArgs);
                if (!eventArgs.cancel) {
                    this.parent.setProperties({ dataSourceSettings: { dataSource: this.parent.engineModule.data } }, true);
                    this.engine.updateGridData(this.parent.dataSourceSettings);
                    this.parent.pivotValues = this.engine.pivotValues;
                    this.parent.gridSettings.allowResizing = gridResize;
                }
            }
        });
        const textBoxElement = createElement('input', {
            id: this.parent.element.id + '_inputbox'
        });
        eventArgs.currentTarget.appendChild(textBoxElement);
        this.numericTextBox.appendTo(textBoxElement);
        eventArgs.currentCell.value = this.numericTextBox.value;
        this.numericTextBox.focusIn();
        this.parent.gridSettings.allowResizing = false;
    }
    updateData(dataSource) {
        let dataPos = 0;
        const data = this.parent.allowDataCompression ?
            this.parent.engineModule.actualData : this.parent.engineModule.data;
        while (dataPos < dataSource.length) { /* eslint-disable , @typescript-eslint/no-explicit-any */
            const fields = Object.keys(dataSource[dataPos]);
            let keyPos = 0;
            const framedSet = [];
            while (keyPos < fields.length) {
                if (!isNullOrUndefined(this.parent.engineModule.fieldKeys[fields[keyPos]])) {
                    framedSet[this.parent.engineModule.fieldKeys[fields[keyPos]]] =
                        dataSource[dataPos][fields[keyPos]];
                }
                keyPos++;
            }
            data[dataSource[dataPos]['__index']] = framedSet;
            dataPos++;
        } /* eslint-enable , @typescript-eslint/no-explicit-any */
        if (this.parent.allowDataCompression) {
            this.parent.engineModule.actualData = data;
        }
        else {
            this.parent.engineModule.data = data;
        }
    }
    removeDrillThroughDialog() {
        if (this.dialogPopUp && !this.dialogPopUp.isDestroyed) {
            this.parent.actionObj.actionName = drillThroughClosed;
            if (this.parent.actionObj.actionName) {
                this.parent.actionCompleteMethod();
            }
            this.dialogPopUp.destroy();
        }
        const dialogElement = document.getElementById(this.parent.element.id + '_drillthrough');
        if (dialogElement) {
            remove(dialogElement);
        }
        if (document.getElementById(this.parent.element.id + '_drillthroughgrid_ccdlg')) {
            remove(document.getElementById(this.parent.element.id + '_drillthroughgrid_ccdlg'));
        }
    }
    createDrillThroughGrid(eventArgs) {
        const drillThroughBody = createElement('div', { id: this.parent.element.id + '_drillthroughbody', className: DRILLTHROUGH_BODY_CLASS });
        const drillThroughBodyHeader = createElement('div', {
            id: this.parent.element.id +
                '_drillthroughbodyheader', className: DRILLTHROUGH_BODY_HEADER_CONTAINER_CLASS
        });
        if (eventArgs.rowHeaders !== '') {
            drillThroughBodyHeader.innerHTML = '<span class=' +
                DRILLTHROUGH_BODY_HEADER_COMMON_CLASS + '><span class=' + DRILLTHROUGH_BODY_HEADER_CLASS + '>' +
                this.parent.localeObj.getConstant('row') + '</span> : <span class=' +
                DRILLTHROUGH_BODY_HEADER_VALUE_CLASS + '>' + eventArgs.rowHeaders + '</span></span>';
        }
        if (eventArgs.columnHeaders !== '') {
            drillThroughBodyHeader.innerHTML = drillThroughBodyHeader.innerHTML + '<span class=' +
                DRILLTHROUGH_BODY_HEADER_COMMON_CLASS + '><span class=' +
                DRILLTHROUGH_BODY_HEADER_CLASS + '>' + this.parent.localeObj.getConstant('column') +
                '</span> : <span class=' + DRILLTHROUGH_BODY_HEADER_VALUE_CLASS + '>' +
                eventArgs.columnHeaders + '</span></span>';
        }
        if (eventArgs.value !== '') {
            const measure = eventArgs.value.split('(')[0];
            const value = eventArgs.value.split('(')[1].split(')')[0];
            if (value !== '0') {
                drillThroughBodyHeader.innerHTML = drillThroughBodyHeader.innerHTML + '<span class=' +
                    DRILLTHROUGH_BODY_HEADER_COMMON_CLASS + '><span class=' +
                    DRILLTHROUGH_BODY_HEADER_CLASS + '>' +
                    measure + '</span> : <span class=' + DRILLTHROUGH_BODY_HEADER_VALUE_CLASS + '>' + value + '</span></span>';
            }
        }
        let toolbarItems = ['ColumnChooser'];
        if (this.parent.editSettings.allowEditing) {
            if (this.parent.editSettings.allowCommandColumns) {
                toolbarItems = ['ColumnChooser', 'Add'];
            }
            else if (this.parent.editSettings.mode === 'Batch') {
                toolbarItems = ['ColumnChooser', 'Add', 'Delete', 'Update', 'Cancel'];
            }
            else if (this.parent.editSettings.mode === 'Dialog') {
                toolbarItems = ['ColumnChooser', 'Add', 'Edit', 'Delete'];
            }
            else {
                toolbarItems = ['ColumnChooser', 'Add', 'Edit', 'Delete', 'Update', 'Cancel'];
            }
        }
        const drillThroughGrid = createElement('div', { id: this.parent.element.id + '_drillthroughgrid', className: DRILLTHROUGH_GRID_CLASS });
        Grid.Inject(Selection, Reorder, Resize, Toolbar, ColumnChooser);
        this.drillThroughGrid = new Grid({
            cssClass: this.parent.cssClass,
            gridLines: 'Default',
            allowResizing: true,
            allowReordering: true,
            showColumnChooser: true,
            enableHover: false,
            toolbar: toolbarItems,
            columns: eventArgs.gridColumns,
            locale: this.parent.locale,
            enableRtl: this.parent.enableRtl,
            enableVirtualization: !this.parent.editSettings.allowEditing,
            allowPaging: this.parent.editSettings.allowEditing,
            pageSettings: { pageSize: 20 },
            rowHeight: this.parent.gridSettings.rowHeight
        });
        if (this.parent.dataType === 'olap') {
            this.formatData();
        } // eslint-disable-next-line @typescript-eslint/no-this-alias
        const dialogModule = this;
        this.parent.trigger(beginDrillThrough, {
            cellInfo: eventArgs,
            gridObj: this.drillThroughGrid,
            type: 'editing'
        });
        if (this.drillThroughGrid.allowExcelExport) {
            Grid.Inject(ExcelExport);
        }
        if (this.drillThroughGrid.allowPdfExport) {
            Grid.Inject(PdfExport);
        }
        if (this.parent.editSettings.allowEditing) {
            Grid.Inject(Edit, Page);
            try {
                this.drillThroughGrid.editSettings = this.parent.editSettings;
                this.drillThroughGrid.actionBegin = (args) => {
                    const actionName = (args.requestType === 'save') ? saveEditedRecords :
                        (args.requestType === 'add') ? addNewRecord : (args.requestType === 'delete') ?
                            removeRecord : '';
                    this.parent.actionObj.actionName = actionName;
                    if (this.parent.actionObj.actionName) {
                        if (this.parent.actionBeginMethod()) {
                            return;
                        }
                    }
                };
                if (this.parent.editSettings.allowCommandColumns) {
                    this.drillThroughGrid.editSettings.mode = 'Normal';
                    this.drillThroughGrid.editSettings.allowEditOnDblClick = false;
                    Grid.Inject(CommandColumn);
                    this.drillThroughGrid.columns.push({
                        headerText: this.parent.localeObj.getConstant('manageRecords'), width: 160, showInColumnChooser: false,
                        commands: [
                            { type: 'Edit', buttonOption: { iconCss: ' e-icons e-edit', cssClass: 'e-flat' + (this.parent.cssClass ? (' ' + this.parent.cssClass) : '') } },
                            { type: 'Delete', buttonOption: { iconCss: 'e-icons e-delete', cssClass: 'e-flat' + (this.parent.cssClass ? (' ' + this.parent.cssClass) : '') } },
                            { type: 'Save', buttonOption: { iconCss: 'e-icons e-update', cssClass: 'e-flat' + (this.parent.cssClass ? (' ' + this.parent.cssClass) : '') } },
                            { type: 'Cancel', buttonOption: { iconCss: 'e-icons e-cancel-icon', cssClass: 'e-flat' + (this.parent.cssClass ? (' ' + this.parent.cssClass) : '') } }
                        ]
                    });
                }
                else {
                    this.drillThroughGrid.editSettings.allowEditOnDblClick = this.parent.editSettings.allowEditOnDblClick;
                }
                this.drillThroughGrid.columns.push({
                    field: '__index', visible: false, isPrimaryKey: true, type: 'string', showInColumnChooser: false
                });
            }
            catch (execption) {
                this.parent.actionFailureMethod(execption);
            }
            this.drillThroughGrid.actionComplete = (args) => {
                if (args.requestType === 'batchsave' || args.requestType === 'save' || args.requestType === 'delete') {
                    dialogModule.isUpdated = true;
                }
                this.parent.actionObj.actionName = this.parent.getActionCompleteName();
                const actionInfo = {
                    editInfo: { type: this.drillThroughGrid.editSettings.mode, action: args.requestType, data: this.gridData }
                };
                this.parent.actionObj.actionInfo = actionInfo;
                if (this.parent.actionObj.actionName) {
                    this.parent.actionCompleteMethod();
                }
                if ((dialogModule.drillThroughGrid.editSettings.mode === 'Normal' && args.requestType === 'save' &&
                    dialogModule.drillThroughGrid.element.querySelectorAll('.e-tbar-btn:hover').length > 0 &&
                    !dialogModule.parent.editSettings.allowCommandColumns) || args.requestType === 'batchsave') {
                    dialogModule.dialogPopUp.hide();
                }
            };
            this.drillThroughGrid.beforeBatchSave = () => {
                dialogModule.isUpdated = true;
            };
        }
        else {
            Grid.Inject(VirtualScroll);
        }
        document.body.appendChild(drillThroughGrid);
        this.drillThroughGrid.isStringTemplate = true;
        this.drillThroughGrid.appendTo(drillThroughGrid);
        drillThroughBody.appendChild(drillThroughBodyHeader);
        drillThroughBody.appendChild(drillThroughGrid);
        return drillThroughBody;
    }
    /**
     * frame Grid Columns
     *
     * @param {IDataSet[]} rawData - rawData.
     * @returns {ColumnModel[]} - frame Grid Columns
     * @hidden */
    frameGridColumns(rawData) {
        const keys = this.parent.dataType === 'olap' ? rawData[0] ? Object.keys(rawData[0]) : [] :
            Object.keys(this.engine.fieldList);
        const columns = [];
        if (this.parent.dataSourceSettings.formatSettings.length > 0) {
            for (let i = 0; i < this.parent.dataSourceSettings.formatSettings.length; i++) {
                this.formatList[this.parent.dataSourceSettings.formatSettings[i].name] =
                    this.parent.dataSourceSettings.formatSettings[i].format;
            }
        }
        if (this.parent.dataType === 'olap') {
            for (const key of keys) {
                columns.push({
                    field: key.replace(/_x005B_|_x0020_|_x005D_|_x0024_/g, '').replace('].[', '').split('.').reverse().join(''),
                    headerText: key.replace(/_x005B_|_x005D_|_x0024_/g, '').replace(/_x0020_/g, ' ').
                        replace('].[', '').split('.').reverse().join('.'),
                    width: 120,
                    visible: true,
                    validationRules: { required: true },
                    format: !isNullOrUndefined(this.formatList[key]) ? this.formatList[key] : null,
                    type: !isNullOrUndefined(this.formatList[key]) ? null : 'string'
                });
            }
        }
        else {
            for (const key of keys) {
                if (this.engine.fieldList[key].aggregateType !== 'CalculatedField') {
                    let editType = '';
                    const isDateField = ((this.engine.fieldList[key].type === 'date' || this.engine.fieldList[key].type === 'datetime')
                        && (this.isDateFieldExist(key) || (rawData[0] && rawData[0][key] && rawData[0][key].toString().indexOf(' ') === -1))) ? true : false;
                    if (this.engine.fieldList[key].type === 'number') {
                        editType = 'numericedit';
                    }
                    else if (this.engine.fieldList[key].type === 'date' && isDateField) {
                        editType = 'datepickeredit';
                    }
                    else if (this.engine.fieldList[key].type === 'datetime' && isDateField) {
                        editType = 'datetimepickeredit';
                    }
                    else {
                        editType = 'defaultedit';
                    }
                    const caption = this.parent.enableHtmlSanitizer ?
                        SanitizeHtmlHelper.sanitize(this.engine.fieldList[key].caption)
                        : this.engine.fieldList[key].caption;
                    columns.push({
                        field: key,
                        headerText: caption,
                        width: 120,
                        visible: this.engine.fieldList[key].isSelected,
                        validationRules: { required: true },
                        editType: editType,
                        format: !isNullOrUndefined(this.formatList[key]) ? this.formatList[key] : undefined,
                        type: !isNullOrUndefined(this.formatList[key]) ? null : 'string'
                    });
                }
            }
        }
        return columns;
    }
    isDateFieldExist(key) {
        for (let len = 0; len < this.parent.dataSourceSettings.formatSettings.length; len++) {
            if (this.parent.dataSourceSettings.formatSettings[len].name === key &&
                this.parent.dataSourceSettings.formatSettings[len].type.indexOf('date') > -1) {
                return true;
            }
        }
        for (let len = 0; len < this.parent.dataSourceSettings.fieldMapping.length; len++) {
            if (this.parent.dataSourceSettings.fieldMapping[len].name === key &&
                this.parent.dataSourceSettings.fieldMapping[len].dataType &&
                this.parent.dataSourceSettings.fieldMapping[len].dataType.indexOf('date') > -1) {
                return true;
            }
        }
        return false;
    }
    formatData() {
        let index = 0;
        while (index < this.gridData.length) {
            const data = this.gridData[index];
            const keys = Object.keys(this.gridData[index]);
            const newData = {};
            let i = 0;
            while (i < keys.length) {
                const key = keys[i].replace(/_x005B_|_x0020_|_x005D_|_x0024_/g, '').replace('].[', '').split('.').reverse().join('');
                newData[key] = data[keys[i]];
                i++;
            }
            this.gridData[index] = newData;
            index++;
        }
    }
    dataWithPrimarykey(eventArgs) {
        const indexString = this.indexString.length > 0 ? this.indexString : Object.keys(eventArgs.currentCell.indexObject);
        const rawData = this.gridData;
        let count = 0;
        for (const item of rawData) {
            item['__index'] = indexString[count];
            this.gridIndexObjects[indexString[count].toString()] = Number(indexString[count]);
            count++;
        }
        return rawData;
    }
    drillthroughKeyActionHandler(e) {
        switch (e.action) {
            case 'escape':
                this.processClose(e);
                break;
        }
    }
    processClose(e) {
        const target = e.target;
        if (target && closest(target, '.e-popup.e-popup-open')) { /* eslint-disable-next-line , @typescript-eslint/no-explicit-any */
            const dialogInstance = closest(target, '.e-popup.e-popup-open').ej2_instances[0];
            if (dialogInstance && !dialogInstance.closeOnEscape) {
                const button = dialogInstance.element.getAttribute('data-fieldName');
                dialogInstance.hide();
                if (this.parent.element) {
                    const pivotButtons = [].slice.call(this.parent.element.querySelectorAll('.e-pivot-button'));
                    for (const item of pivotButtons) {
                        if (item.getAttribute('data-uid') === button) {
                            item.focus();
                            break;
                        }
                    }
                }
                e.preventDefault();
                return;
            }
        }
    }
    /**
     * To destroy the drillthrough keyboard module.
     *
     * @returns  {void}
     * @hidden
     */
    destroy() {
        if (this.parent.isDestroyed) {
            return;
        }
        if (this.drillthroughKeyboardModule && !this.drillthroughKeyboardModule.isDestroyed) {
            this.drillthroughKeyboardModule.destroy();
            this.drillthroughKeyboardModule = null;
        }
        else {
            return;
        }
    }
}

/**
 * `DrillThrough` module.
 */
class DrillThrough {
    /**
     * Constructor.
     *
     * @param {PivotView} parent - Instance of pivot table.
     * @hidden
     */
    constructor(parent) {
        this.parent = parent;
        this.drillThroughDialog = new DrillThroughDialog(this.parent);
        this.addInternalEvents();
    }
    /**
     * It returns the Module name.
     *
     * @returns {string} - string.
     * @hidden
     */
    getModuleName() {
        return 'drillThrough';
    }
    addInternalEvents() {
        this.parent.on(contentReady, this.wireEvents, this);
    }
    wireEvents() {
        this.unWireEvents();
        EventHandler.add(this.parent.element, 'dblclick', this.mouseClickHandler, this);
    }
    unWireEvents() {
        if (this.parent.isDestroyed) {
            return;
        }
        EventHandler.remove(this.parent.element, 'dblclick', this.mouseClickHandler);
    }
    mouseClickHandler(e) {
        const target = e.target;
        let ele = null;
        if (target.classList.contains('e-stackedheadercelldiv') || target.classList.contains('e-cellvalue') ||
            target.classList.contains('e-headercelldiv')) {
            ele = target.parentElement;
        }
        else if (target.classList.contains('e-headercell') || target.classList.contains('e-rowcell')) {
            ele = target;
        }
        else if (target.classList.contains('e-headertext')) {
            ele = target.parentElement.parentElement;
        }
        if (ele) {
            if (this.parent.allowDrillThrough && ele.classList.contains('e-valuescontent') || this.parent.editSettings.allowEditing) {
                const colIndex = Number(ele.getAttribute('data-colindex'));
                const rowIndex = Number(ele.getAttribute('index'));
                this.executeDrillThrough(this.parent.pivotValues[rowIndex][colIndex], rowIndex, colIndex, ele);
            }
        }
    }
    /** @hidden */
    executeDrillThrough(pivotValue, rowIndex, colIndex, element) {
        this.parent.drillThroughElement = element;
        this.parent.drillThroughValue = pivotValue;
        const engine = this.parent.dataType === 'olap' ? this.parent.olapEngineModule : this.parent.engineModule;
        let valueCaption = '';
        let aggType = '';
        let rawData = [];
        if (pivotValue.rowHeaders !== undefined && pivotValue.columnHeaders !== undefined) {
            if (this.parent.dataType === 'olap') {
                let tupleInfo;
                if (this.parent.dataSourceSettings.valueAxis === 'row') {
                    tupleInfo = engine.tupRowInfo[pivotValue.rowOrdinal];
                }
                else {
                    tupleInfo = engine.tupColumnInfo[pivotValue.colOrdinal];
                }
                const measureName = tupleInfo ?
                    engine.getUniqueName(tupleInfo.measureName) : pivotValue.actualText;
                if (engine.fieldList[measureName] && engine.fieldList[measureName].isCalculatedField) {
                    this.parent.pivotCommon.errorDialog.createErrorDialog(this.parent.localeObj.getConstant('error'), this.parent.localeObj.getConstant('drillError'));
                    return;
                }
                valueCaption = engine.fieldList[measureName || pivotValue.actualText].caption;
                aggType = engine.fieldList[measureName || pivotValue.actualText].aggregateType;
                this.parent.olapEngineModule.getDrillThroughData(pivotValue, this.parent.maxRowsInDrillThrough);
                try {
                    rawData = JSON.parse(engine.gridJSON);
                }
                catch (exception) {
                    this.parent.pivotCommon.errorDialog.createErrorDialog(this.parent.localeObj.getConstant('error'), engine.gridJSON);
                    return;
                }
            }
            else {
                valueCaption = engine.fieldList[pivotValue.actualText.toString()] ?
                    engine.fieldList[pivotValue.actualText.toString()].caption : pivotValue.actualText.toString();
                aggType = engine.fieldList[pivotValue.actualText] ? engine.fieldList[pivotValue.actualText].aggregateType : '';
                if (this.parent.dataSourceSettings.mode === 'Server') {
                    this.parent.getEngine('fetchRawData', null, null, null, null, null, null, { rowIndex: rowIndex, columnIndex: colIndex });
                }
                else {
                    if (this.parent.allowDataCompression) {
                        const indexArray = Object.keys(pivotValue.indexObject);
                        this.drillThroughDialog.indexString = [];
                        for (const cIndex of indexArray) {
                            for (const aIndex of this.parent.engineModule.groupRawIndex[Number(cIndex)]) {
                                rawData.push(this.parent.engineModule.actualData[aIndex]);
                                this.drillThroughDialog.indexString.push(aIndex.toString());
                            }
                        }
                    }
                    else {
                        const indexArray = Object.keys(pivotValue.indexObject);
                        for (const index of indexArray) {
                            rawData.push(this.parent.engineModule.data[Number(index)]);
                        }
                    }
                }
            }
            if (this.parent.dataSourceSettings.mode !== 'Server') {
                this.triggerDialog(valueCaption, aggType, rawData, pivotValue, element);
            }
        }
    }
    getCalcualtedFieldValue(indexArray, rawData) {
        for (let k = 0; k < indexArray.length; k++) {
            const colIndex = {};
            colIndex[indexArray[k]] = indexArray[k];
            for (let i = 0; i < this.parent.dataSourceSettings.calculatedFieldSettings.length; i++) {
                let indexValue;
                for (let j = this.parent.engineModule.fields.length - 1; j >= 0; j--) {
                    if (this.parent.engineModule.fields[j] ===
                        this.parent.dataSourceSettings.calculatedFieldSettings[i].name) {
                        indexValue = j;
                        break;
                    }
                }
                if (!isNullOrUndefined(rawData[k])) {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    const calculatedFeildValue = this.parent.engineModule.getAggregateValue([Number(indexArray[k])], colIndex, indexValue, 'calculatedfield', false);
                    rawData[k][this.parent.dataSourceSettings.calculatedFieldSettings[i].name] = (isNaN(calculatedFeildValue) && isNullOrUndefined(calculatedFeildValue)) ? '#DIV/0!' : calculatedFeildValue;
                }
            }
        }
        return rawData;
    }
    /* eslint-disable @typescript-eslint/no-explicit-any */
    frameData(eventArgs) {
        let keyPos = 0;
        let dataPos = 0;
        const data = [];
        while (dataPos < eventArgs.rawData.length) {
            const framedHeader = {};
            while (keyPos < eventArgs.gridColumns.length) {
                framedHeader[eventArgs.gridColumns[keyPos].field] = this.parent.dataSourceSettings.mode === 'Server' ?
                    eventArgs.rawData[dataPos][this.parent.engineModule.fields.indexOf(eventArgs.gridColumns[keyPos]
                        .field) !== -1 ? this.parent.engineModule.fields.indexOf(eventArgs.gridColumns[keyPos].field) : 0] :
                    eventArgs.rawData[dataPos][this.parent.engineModule.fieldKeys[eventArgs.gridColumns[keyPos]
                        .field]];
                keyPos++;
            }
            data.push(framedHeader);
            dataPos++;
            keyPos = 0;
        }
        eventArgs.rawData = data;
        return eventArgs;
    }
    /** @hidden */
    triggerDialog(valueCaption, aggType, rawData, pivotValue, element) {
        let valuetText = aggType === 'CalculatedField' ? valueCaption.toString() : aggType !== '' ?
            (this.parent.localeObj.getConstant(aggType) + ' ' + this.parent.localeObj.getConstant('of') + ' ' + valueCaption) :
            valueCaption;
        valuetText = this.parent.enableHtmlSanitizer ? SanitizeHtmlHelper.sanitize(valuetText) : valuetText;
        const rowHeaders = this.parent.dataSourceSettings.valueAxis === 'row' ? this.parent.getRowText(Number(element.getAttribute('index')), 0) :
            pivotValue.rowHeaders === '' ? '' : pivotValue.rowHeaders.toString().split(this.parent.dataSourceSettings.valueSortSettings.headerDelimiter).join(' - ');
        let eventArgs = {
            currentTarget: element,
            currentCell: pivotValue,
            rawData: rawData,
            rowHeaders: rowHeaders,
            columnHeaders: pivotValue.columnHeaders === '' ? '' : pivotValue.columnHeaders.toString().split(this.parent.dataSourceSettings.valueSortSettings.headerDelimiter).join(' - '),
            value: valuetText + '(' + pivotValue.formattedText + ')',
            gridColumns: this.drillThroughDialog.frameGridColumns(rawData),
            cancel: false
        };
        if (this.parent.dataSourceSettings.type === 'CSV') {
            eventArgs = this.frameData(eventArgs);
        }
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const drillThrough$$1 = this;
        this.parent.trigger(drillThrough, eventArgs, (observedArgs) => {
            if (!eventArgs.cancel) {
                drillThrough$$1.drillThroughDialog.showDrillThroughDialog(observedArgs);
            }
        });
    }
    /**
     * To destroy the drillthrough module.
     *
     * @returns  {void}
     * @hidden
     */
    destroy() {
        this.unWireEvents();
        if (this.drillThroughDialog) {
            this.drillThroughDialog.destroy();
            this.drillThroughDialog = null;
        }
        else {
            return;
        }
    }
}

class PivotChart {
    constructor() {
        this.headerColl = {};
        this.maxLevel = 0;
        this.columnGroupObject = {};
        this.selectedLegend = 0;
        this.chartSeriesInfo = {};
        this.fieldPosition = [];
        this.measurePos = -1;
        this.measuresNames = {};
        this.accumulationType = ['Pie', 'Pyramid', 'Doughnut', 'Funnel'];
    }
    /**
     * Get component name.
     *
     * @returns {string} - string
     * @private
     */
    getModuleName() {
        return 'pivotChart';
    }
    /**
     * Initialize the pivot chart rendering
     *
     * @param {PivotView} parent - Specifies the pivot table component instance.
     * @param {ChartSettingsModel} chartSettings - Specifies the chart settings.
     * @returns {void}
     * @private
     */
    loadChart(parent, chartSettings) {
        this.parent = parent;
        this.measuresNames = {};
        this.engineModule = this.parent.dataType === 'olap' ? this.parent.olapEngineModule : this.parent.engineModule;
        this.dataSourceSettings = this.parent.dataSourceSettings;
        this.chartSettings = chartSettings;
        const isDataAvail = parent.dataType === 'olap' ?
            (parent.dataSourceSettings.url !== '' && !parent.olapEngineModule.isEmptyData &&
                parent.olapEngineModule.tupColumnInfo.length > 0 && parent.olapEngineModule.tupRowInfo.length > 0 &&
                (!isNullOrUndefined(parent.olapEngineModule.colMeasurePos) || !isNullOrUndefined(parent.olapEngineModule.rowMeasurePos)))
            : this.parent.dataSourceSettings.mode === 'Server' ? (!isNullOrUndefined(parent.dataSourceSettings.url) &&
                parent.dataSourceSettings.url !== '' && parent.dataSourceSettings.values.length > 0 && !parent.engineModule.isEmptyData) :
                (parent.dataSourceSettings.values.length > 0 && parent.dataSourceSettings.dataSource &&
                    parent.dataSourceSettings.dataSource.length > 0 && !parent.engineModule.isEmptyData);
        if (isDataAvail) {
            if (!this.parent.chart && (this.parent.element.querySelector('.e-chart') || this.parent.element.querySelector('.e-accumulationchart'))) {
                remove(select('#' + this.parent.element.id + '_chart', this.parent.element));
            }
            if (this.chartSettings.enableMultipleAxis && this.accumulationType.indexOf(chartSettings.chartSeries.type) < 0 && this.chartSettings.chartSeries.type !== 'Pareto') {
                // eslint-disable-next-line @typescript-eslint/tslint/config
                this.measureList = this.dataSourceSettings.values.map((item) => { return item.name; });
            }
            else {
                this.measureList = [chartSettings.value === '' ? this.dataSourceSettings.values[0].name : chartSettings.value];
            }
            for (const field of this.dataSourceSettings.values) {
                const fieldName = field.name.replace(/[^A-Z0-9]+/ig, '_');
                this.measuresNames[field.name] = fieldName;
                this.measuresNames[fieldName] = field.name;
                if ((this.chartSettings.chartSeries.type === 'Polar' || this.chartSettings.chartSeries.type === 'Radar')) {
                    this.measuresNames[field.caption ? field.caption : field.name] = field.name;
                }
            }
        }
        else if (this.parent.chart) {
            if (this.parent.element.querySelector('.e-chart')) {
                this.parent.chart.series = [];
                this.parent.chart.rows = [];
                this.parent.chart.primaryXAxis.title = '';
                this.parent.chart.primaryYAxis.title = '';
                this.parent.chart.primaryXAxis.multiLevelLabels = [];
                this.parent.chart.primaryYAxis.multiLevelLabels = [];
                if (this.parent.chart.axes.length > 0) {
                    this.parent.chart.axes[0].title = '';
                }
                this.parent.chart.primaryXAxis.zoomFactor = isNullOrUndefined(this.parent.chartSettings.primaryXAxis.zoomFactor)
                    ? 1 : this.parent.chartSettings.primaryXAxis.zoomFactor;
            }
            else if (this.parent.element.querySelector('.e-accumulationchart')) {
                this.parent.chart.series[0].dataSource = [{}];
                this.parent.chart.series[0].dataLabel = {};
            }
            this.parent.chart.refresh();
            return;
        }
        else {
            if (!select('#' + this.parent.element.id + '_chart', this.parent.element)) {
                if (this.parent.displayOption.view === 'Both') {
                    if (this.parent.displayOption.primary === 'Chart') {
                        (this.parent.element.insertBefore((createElement('div', {
                            className: PIVOTCHART, id: this.parent.element.id + '_chart'
                        })), this.parent.element.querySelector('.' + GRID_CLASS)));
                    }
                    else {
                        (this.parent.element.appendChild(createElement('div', {
                            className: PIVOTCHART, id: this.parent.element.id + '_chart'
                        })));
                    }
                }
                else {
                    this.parent.element.appendChild(createElement('div', {
                        className: PIVOTCHART, id: this.parent.element.id + '_chart'
                    }));
                }
                let width = this.parent.width.toString();
                if (this.parent.showToolbar && this.parent.grid) {
                    width = this.parent.getGridWidthAsNumber().toString();
                }
                const height = this.getChartHeight();
                let tmpChart;
                if (this.chartSettings && this.chartSettings.chartSeries &&
                    this.accumulationType.indexOf(this.chartSettings.chartSeries.type) > -1) {
                    tmpChart = new AccumulationChart({ width: width, height: height });
                }
                else {
                    tmpChart = new Chart({ width: width, height: height });
                }
                tmpChart.appendTo('#' + this.parent.element.id + '_chart');
                if (this.parent.showToolbar) {
                    if (this.parent.displayOption.view === 'Both' && this.parent.currentView === 'Chart') {
                        this.parent.grid.element.style.display = 'none';
                    }
                    if (this.parent.currentView !== 'Chart') {
                        select('#' + this.parent.element.id + '_chart', this.parent.element).style.display = 'none';
                    }
                }
            }
            this.parent.notify(contentReady, {});
            return;
        }
        this.columnGroupObject = {};
        this.accEmptyPoint = false;
        const pivotValues = this.engineModule.pivotValues;
        this.currentMeasure = (chartSettings.enableMultipleAxis && this.accumulationType.indexOf(chartSettings.chartSeries.type) < 0 && this.chartSettings.chartSeries.type !== 'Pareto') ? this.measureList[0] :
            (((chartSettings.value === '' || this.dataSourceSettings.values.filter((item) => {
                return item.name === chartSettings.value;
            }).length === 0) && this.dataSourceSettings.values.length > 0) ? this.dataSourceSettings.values[0].name : chartSettings.value);
        const totColIndex = this.getColumnTotalIndex(pivotValues);
        const rKeys = Object.keys(pivotValues);
        let prevLevel;
        let firstLevelUName;
        let levelCollection = {};
        let prevCell;
        let integratedLevel = 0;
        let indexCount = -0.5;
        this.headerColl = {};
        this.maxLevel = 0;
        let levelPos = {};
        let lastHierarchy = '';
        let lastDimension = '';
        let memberCell;
        let drillDimension = '';
        this.chartSeriesInfo = {};
        this.selectedLegend = 0;
        let isDrill = false;
        const measureNames = {};
        let isValidHeader = false;
        const delimiter = this.parent.dataSourceSettings.valueSortSettings.headerDelimiter;
        for (const field of this.dataSourceSettings.values) {
            const fieldName = field.name;
            measureNames[fieldName] = field.caption ? field.caption : fieldName;
            measureNames[field.caption ? field.caption : fieldName] = fieldName;
        }
        if (this.parent.dataType === 'olap') {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            levelPos = this.groupHierarchyWithLevels(pivotValues);
            lastHierarchy = this.fieldPosition[this.fieldPosition.length - 1];
            lastDimension = (this.measurePos === (this.fieldPosition.length - 1) && this.fieldPosition.length > 1) ?
                this.fieldPosition[this.fieldPosition.length - 2] : lastHierarchy;
            drillDimension = lastDimension;
        }
        for (const rKey of rKeys) {
            const rowIndex = Number(rKey);
            if (!isNullOrUndefined(pivotValues[rowIndex])) {
                const header = pivotValues[rowIndex][0];
                const valueSort = header && header.valueSort && !isNullOrUndefined(header.valueSort.levelName) ?
                    header.valueSort.levelName.toString().split(delimiter) : undefined;
                isValidHeader = false;
                if (valueSort && valueSort[0] !== 'Grand Total') {
                    if ((chartSettings.enableMultipleAxis && this.accumulationType.indexOf(chartSettings.chartSeries.type) < 0 && this.chartSettings.chartSeries.type !== 'Pareto') ||
                        valueSort.indexOf(measureNames[this.currentMeasure]) > -1) {
                        isValidHeader = true;
                    }
                    if (!isValidHeader) {
                        for (const levelName of valueSort) {
                            if (measureNames[levelName]) {
                                isValidHeader = true;
                                break;
                            }
                        }
                        isValidHeader = isValidHeader ? false : true;
                    }
                }
                if (header && header.axis === 'row' && (this.dataSourceSettings.rows.length === 0 ? true :
                    (header.type !== 'grand sum' && isValidHeader))) {
                    const firstRowCell = pivotValues[rowIndex][0];
                    if (firstRowCell.isSum) {
                        continue;
                    }
                    const tupInfo = this.parent.dataType === 'olap' ?
                        this.engineModule.tupRowInfo[firstRowCell.ordinal] : undefined;
                    let fieldPos = -1;
                    let currrentLevel = firstRowCell.level;
                    if (this.parent.dataType === 'olap') {
                        isDrill = firstRowCell.hierarchy === '[Measures]' ? isDrill : this.isAttributeDrill(firstRowCell.hierarchy, tupInfo.drillInfo);
                        drillDimension = drillDimension === lastDimension ? lastDimension : (firstRowCell.hierarchy === '[Measures]' || firstRowCell.isNamedSet || (this.engineModule.fieldList[firstRowCell.hierarchy] && !this.engineModule.fieldList[firstRowCell.hierarchy].hasAllMember)) ? lastDimension : drillDimension;
                        fieldPos = tupInfo.drillInfo.length - 1;
                        if (firstRowCell.memberType !== 3 && (tupInfo.measureName ?
                            tupInfo.measureName === this.dataSourceSettings.values[0].name : true)) {
                            firstLevelUName = firstLevelUName === undefined ? firstRowCell.levelUniqueName : firstLevelUName;
                            integratedLevel = firstLevelUName === firstRowCell.levelUniqueName ? 0 : integratedLevel;
                            levelCollection = integratedLevel === 0 ? {} : levelCollection;
                            integratedLevel = (prevCell && firstLevelUName !== firstRowCell.levelUniqueName) ?
                                (prevCell.hierarchy === firstRowCell.hierarchy ?
                                    (integratedLevel + (firstRowCell.level - prevCell.level)) :
                                    (isNullOrUndefined(levelCollection[firstRowCell.levelUniqueName]) ?
                                        (levelPos[firstRowCell.hierarchy].start) :
                                        levelCollection[firstRowCell.levelUniqueName])) : integratedLevel;
                            levelCollection[firstRowCell.levelUniqueName] = integratedLevel;
                            currrentLevel = integratedLevel;
                            indexCount += (prevCell && drillDimension === prevCell.hierarchy && !(prevCell.isDrilled && prevCell.hasChild))
                                ? 1 : 0;
                            drillDimension = isDrill ? firstRowCell.hierarchy : lastDimension;
                            prevLevel = integratedLevel;
                            prevCell = firstRowCell;
                        }
                    }
                    else if (firstRowCell.type !== 'value') {
                        if (!(prevLevel === undefined || prevLevel < currrentLevel)) {
                            indexCount++;
                        }
                        prevLevel = currrentLevel;
                    }
                    this.maxLevel = currrentLevel > this.maxLevel ? currrentLevel : this.maxLevel;
                    const name = this.parent.dataType === 'olap' ? firstRowCell.formattedText :
                        (firstRowCell.actualText ? firstRowCell.actualText.toString() : firstRowCell.formattedText.toString());
                    const values = this.engineModule.fieldList[this.currentMeasure];
                    const text = this.parent.dataSourceSettings.rows.length === 0 ? this.parent.localeObj.getConstant('total') + ' ' + this.parent.localeObj.getConstant(values.aggregateType) + ' ' +
                        this.parent.localeObj.getConstant('of') + ' ' + (!isNullOrUndefined(values.caption) ? values.caption : values.name) : firstRowCell.formattedText ? firstRowCell.formattedText.toString() : name;
                    const caption = (firstRowCell.hasChild && !firstRowCell.isNamedSet) ?
                        ((firstRowCell.isDrilled ? ' - ' : ' + ') + text) : text;
                    const levelName = tupInfo ? tupInfo.uNameCollection : firstRowCell.valueSort.levelName.toString();
                    const cellInfo = {
                        name: name,
                        text: caption,
                        hasChild: firstRowCell.hasChild,
                        isDrilled: firstRowCell.isDrilled,
                        levelName: levelName,
                        level: currrentLevel,
                        fieldName: firstRowCell.valueSort.axis ? firstRowCell.valueSort.axis.toString() : '',
                        rowIndex: rowIndex,
                        colIndex: 0,
                        cell: firstRowCell
                    };
                    if (this.parent.dataType === 'olap' ? firstRowCell.memberType !== 3 : firstRowCell.type !== 'value') {
                        if (this.headerColl[indexCount]) {
                            this.headerColl[indexCount][currrentLevel] = cellInfo;
                        }
                        else {
                            this.headerColl[indexCount] = {};
                            this.headerColl[indexCount][currrentLevel] = cellInfo;
                        }
                    }
                    const rows = pivotValues[rowIndex];
                    const cKeys = Object.keys(rows);
                    let prevMemberCell;
                    if (this.parent.dataType === 'olap') {
                        memberCell = firstRowCell.memberType !== 3 ? firstRowCell : memberCell;
                    }
                    else {
                        memberCell = firstRowCell.type !== 'value' ? firstRowCell : memberCell;
                        if (firstRowCell.type !== 'value') {
                            memberCell = firstRowCell;
                        }
                        else {
                            const valueSort = firstRowCell && firstRowCell.valueSort && firstRowCell.valueSort.levelName &&
                                firstRowCell.valueSort.levelName.toString().split(delimiter);
                            let levelName;
                            if (valueSort && valueSort.length > 0) {
                                valueSort.splice(valueSort.length - 1, 1);
                                levelName = valueSort.join(delimiter);
                            }
                            if ((this.parent.dataSourceSettings.valueIndex <= 0 || this.engineModule.valueAxis &&
                                this.dataSourceSettings.rows.length === this.engineModule.measureIndex) ||
                                isNullOrUndefined(memberCell.valueSort) || (levelName === memberCell.valueSort.levelName)) {
                                // eslint-disable-next-line no-self-assign
                                memberCell = memberCell;
                            }
                            else {
                                let prevIndex = rowIndex;
                                while (prevIndex > -1) {
                                    if (pivotValues[prevIndex] && pivotValues[prevIndex][0] &&
                                        pivotValues[prevIndex][0].valueSort &&
                                        pivotValues[prevIndex][0].valueSort.levelName === levelName) {
                                        memberCell = pivotValues[prevIndex][0];
                                        prevIndex = 0;
                                    }
                                    prevIndex--;
                                }
                            }
                        }
                    }
                    for (const cKey of cKeys) {
                        const cellIndex = Number(cKey);
                        const cell = pivotValues[rowIndex][cellIndex];
                        const measureAllow = isNullOrUndefined(cell.rowHeaders) ? this.dataSourceSettings.rows.length === 0 : true;
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        const actualText = (this.parent.dataType === 'olap' && tupInfo && tupInfo.measureName) ?
                            tupInfo.measureName : cell.actualText;
                        if (!(this.parent.dataType === 'olap' && cell.isGrandSum) && !totColIndex[cell.colIndex] && cell.axis === 'value' && firstRowCell.type !== 'header' &&
                            actualText !== '' && ((chartSettings.enableMultipleAxis && this.accumulationType.indexOf(chartSettings.chartSeries.type) < 0 && this.chartSettings.chartSeries.type !== 'Pareto') ? true : actualText === this.currentMeasure)) {
                            if (isNullOrUndefined(firstRowCell.members)) {
                                firstRowCell.members = [];
                            }
                            if (this.parent.dataType === 'olap' ? ((lastHierarchy === firstRowCell.hierarchy || isDrill) ?
                                ((firstRowCell.memberType === 3 && prevMemberCell) ?
                                    (fieldPos === this.measurePos ? (prevMemberCell.isDrilled && prevMemberCell.hasChild) : true) :
                                    (firstRowCell.isDrilled && firstRowCell.hasChild)) : true)
                                : (((firstRowCell.type === 'value' && prevMemberCell) ?
                                    prevMemberCell.members.length > 0 && prevMemberCell.isDrilled : firstRowCell.members.length > 0
                                    && firstRowCell.isDrilled) || !measureAllow)) {
                                break;
                            }
                            const colHeaders = this.parent.dataType === 'olap' ? cell.columnHeaders.toString().split(/~~|::/).join(' - ')
                                : cell.columnHeaders.toString().split(delimiter).join(' - ');
                            const rowHeaders = this.parent.dataType === 'olap' ? cell.rowHeaders.toString().split(/~~|::/).join(' - ')
                                : cell.rowHeaders.toString().split(delimiter).join(' - ');
                            const columnSeries = colHeaders + ' | ' + actualText;
                            this.chartSeriesInfo[colHeaders] = { uniqueName: colHeaders, caption: cell.hierarchyName && cell.hierarchyName.toString().split(delimiter).join(' - '), colorIndex: [] };
                            this.chartSeriesInfo[this.chartSeriesInfo[colHeaders].caption] =
                                this.chartSeriesInfo[colHeaders];
                            let yValue = (this.parent.dataType === 'pivot' ? (this.engineModule.aggregatedValueMatrix[rowIndex] &&
                                !isNullOrUndefined(this.engineModule.aggregatedValueMatrix[rowIndex][cellIndex])) ?
                                Number(this.engineModule.aggregatedValueMatrix[rowIndex][cellIndex]) :
                                (!isNullOrUndefined(cell.value) ? Number(cell.value) : cell.value) : (!isNullOrUndefined(cell.value)
                                ? Number(cell.value) : cell.value));
                            yValue = yValue === Infinity ? null : yValue;
                            if (yValue === 0) {
                                this.accEmptyPoint = true;
                            }
                            if (this.columnGroupObject[columnSeries]) {
                                this.columnGroupObject[columnSeries].push({
                                    x: this.dataSourceSettings.rows.length === 0 ? firstRowCell.formattedText : rowHeaders,
                                    y: yValue,
                                    rIndex: rowIndex,
                                    cIndex: cellIndex
                                });
                            }
                            else {
                                this.columnGroupObject[columnSeries] = [{
                                        x: this.dataSourceSettings.rows.length === 0 ? firstRowCell.formattedText : rowHeaders,
                                        y: yValue,
                                        rIndex: rowIndex,
                                        cIndex: cellIndex
                                    }];
                            }
                        }
                        prevMemberCell = memberCell;
                    }
                }
            }
        }
        this.refreshChart();
    }
    /**
     * Refreshing chart based on the updated chartSettings.
     *
     * @returns {void}
     * @hidden
     */
    refreshChart() {
        this.chartSeries = [];
        let prevColorIndex = 0;
        const chartSeriesInfo = {};
        const columnKeys = Object.keys(this.columnGroupObject);
        this.persistSettings = JSON.parse(this.parent.getPersistData()).chartSettings;
        const seriesColors = this.persistSettings.palettes && this.persistSettings.palettes.length > 0
            ? this.persistSettings.palettes : getSeriesColor(this.chartSettings.theme);
        const delimiter = this.parent.chartSettings.columnDelimiter ? this.parent.chartSettings.columnDelimiter : '-';
        const columnHeader = (this.parent.chartSettings.columnHeader && this.parent.chartSettings.columnHeader !== '') ?
            this.parent.chartSettings.columnHeader.split(delimiter).join(' - ') : '';
        const chartType = this.chartSettings.chartSeries ? this.chartSettings.chartSeries.type : undefined;
        const fieldWithCaption = {};
        for (let i = 0; i < this.parent.dataSourceSettings.values.length; i++) {
            fieldWithCaption[this.parent.dataSourceSettings.values[i].name] =
                !isNullOrUndefined(this.parent.dataSourceSettings.values[i].caption) ?
                    this.parent.dataSourceSettings.values[i].caption : undefined;
        }
        if (this.accumulationType.indexOf(chartType) > -1 && columnKeys.length > 0) {
            this.currentColumn = (columnKeys.indexOf(columnHeader + ' | ' + this.currentMeasure) > -1 && columnHeader !== undefined) ? columnHeader + ' | ' + this.currentMeasure : columnKeys[0];
            let currentSeries = {};
            currentSeries = this.persistSettings.chartSeries ?
                this.frameChartSeries(this.persistSettings.chartSeries) : currentSeries;
            if ((isNullOrUndefined(currentSeries.palettes) || currentSeries.palettes.length === 0) &&
                !isNullOrUndefined(this.persistSettings.palettes) && this.persistSettings.palettes.length > 0) {
                currentSeries.palettes = this.persistSettings.palettes;
            }
            currentSeries.dataSource = this.columnGroupObject[this.currentColumn];
            currentSeries.xName = 'x';
            currentSeries.yName = 'y';
            if (this.persistSettings.chartSeries && this.persistSettings.chartSeries.dataLabel) { // eslint-disable-next-line @typescript-eslint/no-explicit-any
                currentSeries.dataLabel = this.persistSettings.chartSeries.dataLabel;
                currentSeries.dataLabel.name = 'x';
            }
            else {
                currentSeries.dataLabel = { visible: true, position: 'Outside', name: 'x' };
                this.parent.setProperties({ chartSettings: { chartSeries: { dataLabel: { visible: true, position: 'Outside' } } } }, true);
            }
            if (this.accEmptyPoint && currentSeries.emptyPointSettings) {
                currentSeries.emptyPointSettings.mode = 'Zero';
            }
            else if (this.accEmptyPoint) {
                currentSeries.emptyPointSettings = { mode: 'Zero' };
            }
            currentSeries.name = this.currentColumn;
            if (chartType === 'Doughnut') {
                currentSeries.type = 'Pie';
                currentSeries.innerRadius = this.chartSettings.chartSeries.innerRadius ? this.chartSettings.chartSeries.innerRadius : '40%';
            }
            else if (chartType === 'Pie') {
                currentSeries.innerRadius = this.chartSettings.chartSeries.innerRadius ? this.chartSettings.chartSeries.innerRadius : '0';
            }
            this.chartSeries = this.chartSeries.concat(currentSeries);
        }
        else {
            for (const key of columnKeys) {
                let currentSeries = {};
                currentSeries = this.persistSettings.chartSeries ? this.frameChartSeries(this.persistSettings.chartSeries)
                    : currentSeries;
                /* eslint-disable @typescript-eslint/no-explicit-any */
                if (!isNullOrUndefined(currentSeries.palettes) && currentSeries.palettes.length > 0
                    && (isNullOrUndefined(this.persistSettings.palettes) || this.persistSettings.palettes.length === 0)) {
                    this.chartSettings.palettes = currentSeries.palettes;
                }
                /* eslint-enable @typescript-eslint/no-explicit-any */
                for (let i = 0; i < this.columnGroupObject[key].length; i++) {
                    const values = this.engineModule.fieldList[this.currentMeasure];
                    this.columnGroupObject[key][i].x = (this.parent.dataSourceSettings.rows.length === 0 && !this.chartSettings.showMultiLevelLabels) ? this.parent.localeObj.getConstant('total') + ' ' + this.parent.localeObj.getConstant(values.aggregateType) + ' ' +
                        this.parent.localeObj.getConstant('of') + ' ' + (!isNullOrUndefined(values.caption) ? values.caption : values.name) : this.columnGroupObject[key][i].x === '' ? this.parent.localeObj.getConstant('blank') : this.columnGroupObject[key][i].x;
                }
                currentSeries.dataSource = this.columnGroupObject[key];
                currentSeries.xName = 'x';
                currentSeries.yName = 'y';
                currentSeries.visible = true;
                let multiAxisKey;
                if (this.chartSettings.enableMultipleAxis) {
                    let fieldCaptionName = key.split(' | ')[1];
                    fieldCaptionName = !isNullOrUndefined(fieldWithCaption[fieldCaptionName]) ?
                        fieldWithCaption[fieldCaptionName] : fieldCaptionName;
                    multiAxisKey = key.split(' | ')[0] + ' | ' + fieldCaptionName;
                }
                currentSeries.name = this.chartSettings.enableMultipleAxis ? multiAxisKey : key.split(' | ')[0];
                if (this.chartSettings.showPointColorByMembers && this.chartSettings.enableMultipleAxis) {
                    currentSeries.name = currentSeries.name.split(' |')[0];
                    const seriesName = this.chartSeriesInfo[currentSeries.name].caption;
                    currentSeries.name = seriesName !== undefined && seriesName !== null ? seriesName : currentSeries.name;
                    if (!chartSeriesInfo[currentSeries.name]) {
                        prevColorIndex = seriesColors[prevColorIndex] ? prevColorIndex : 0;
                        chartSeriesInfo[currentSeries.name] = { name: currentSeries.name, color: seriesColors[prevColorIndex] };
                        currentSeries.fill = seriesColors[prevColorIndex++];
                        this.chartSeriesInfo[currentSeries.name].colorIndex.push(this.selectedLegend++);
                    }
                    else {
                        currentSeries.fill = chartSeriesInfo[currentSeries.name].color;
                        this.chartSeriesInfo[currentSeries.name].colorIndex.push(this.selectedLegend++);
                        currentSeries.name = undefined;
                    }
                }
                if (['Radar', 'Polar'].indexOf(chartType) < 0) {
                    const measure = key.split(' | ')[1];
                    currentSeries.tooltipMappingName = this.measuresNames[measure];
                    currentSeries.yAxisName = (this.chartSettings.enableMultipleAxis && this.chartSettings.multipleAxisMode === 'Combined') ?
                        this.measureList.join('_') : this.measuresNames[measure] ? this.measuresNames[measure] : measure;
                }
                if (this.persistSettings.chartSeries && this.persistSettings.chartSeries.emptyPointSettings) {
                    currentSeries.emptyPointSettings = this.persistSettings.chartSeries.emptyPointSettings;
                }
                if (!currentSeries.emptyPointSettings) {
                    currentSeries.emptyPointSettings = { mode: 'Zero' };
                }
                this.chartSeries = this.chartSeries.concat(currentSeries);
            }
        }
        const seriesEvent = { series: this.chartSeries, cancel: false };
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const pivotChart = this;
        this.parent.trigger(chartSeriesCreated, seriesEvent, (observedArgs) => {
            if (!observedArgs.cancel) {
                pivotChart.bindChart();
            }
            else {
                if (pivotChart.element) {
                    remove(pivotChart.element);
                }
                pivotChart.parent.notify(contentReady, {});
            }
        });
    }
    /* eslint-disable @typescript-eslint/no-explicit-any */
    frameObjectWithKeys(series) {
        const keys = Object.keys(series);
        let keyPos = 0;
        const framedSeries = {};
        /* eslint-enable @typescript-eslint/no-explicit-any */
        while (keyPos < keys.length) {
            framedSeries[keys[keyPos]] = series[keys[keyPos]];
            keyPos++;
        }
        return framedSeries;
    }
    /* eslint-disable @typescript-eslint/no-explicit-any */
    frameChartSeries(series) {
        const keys = Object.keys(series);
        let keyPos = 0;
        const framedSeries = {};
        /* eslint-enable @typescript-eslint/no-explicit-any */
        while (keyPos < keys.length) {
            if ((this.accumulationType.indexOf(this.parent.chartSettings.chartSeries.type) > -1 && ['fill', 'dashArray', 'width', 'segmentAxis',
                'drawType', 'isClosed', 'segments', 'stackingGroup', 'marker', 'errorBar', 'trendlines', 'minRadius',
                'splineType', 'maxRadius', 'cardinalSplineTension', 'columnWidth', 'columnSpacing', 'cornerRadius'].indexOf(keys[keyPos]) > -1) ||
                (this.accumulationType.indexOf(this.parent.chartSettings.chartSeries.type) < 0 && ['endAngle', 'explode', 'explodeAll', 'explodeIndex',
                    'explodeOffset', 'gapRatio', 'groupMode', 'groupTo', 'neckHeight', 'neckWidth', 'pyramidMode', 'startAngle',
                    'dataLabel', 'innerRadius'].indexOf(keys[keyPos]) > -1)) {
                keyPos++;
                continue;
            }
            framedSeries[keys[keyPos]] = series[keys[keyPos]];
            keyPos++;
        }
        return framedSeries;
    }
    bindChart() {
        this.parent.showWaitingPopup();
        const currentXAxis = this.configXAxis();
        const currentTooltipSettings = this.configTooltipSettings();
        const currentLegendSettings = this.configLegendSettings();
        const currentZoomSettings = this.configZoomSettings();
        const axesWithRows = this.frameAxesWithRows();
        const type = this.chartSettings.chartSeries.type;
        if (this.parent.displayOption.view === 'Both') {
            this.element = this.parent.displayOption.primary === 'Chart' ?
                (this.parent.element.insertBefore((!this.element ?
                    (createElement('div', {
                        className: PIVOTCHART, id: this.parent.element.id + '_chart'
                    }))
                    : this.element), this.parent.element.querySelector('.' + GRID_CLASS))) :
                (this.parent.element.appendChild(!this.element ? (createElement('div', {
                    className: PIVOTCHART, id: this.parent.element.id + '_chart'
                })) : this.element));
        }
        else if (!this.element) {
            this.element = this.parent.element.appendChild(createElement('div', {
                className: PIVOTCHART, id: this.parent.element.id + '_chart'
            }));
        }
        if (!this.chartElement && this.parent.chartSettings.enableScrollOnMultiAxis && this.parent.chartSettings.enableMultipleAxis && this.chartSettings.chartSeries.type !== 'Pareto') {
            this.parent.element.querySelector('.' + PIVOTCHART).innerHTML = '';
            this.chartElement = this.parent.element.querySelector('.' + PIVOTCHART).appendChild(createElement('div', {
                className: PIVOTCHART_INNER, id: this.parent.element.id + '_chartInner'
            }));
        }
        if (this.parent.element.querySelector('.' + PIVOTCHART_INNER)) {
            this.parent.element.querySelector('.' + PIVOTCHART_INNER).innerHTML = '';
        }
        if (this.parent.showGroupingBar) {
            this.element.style.minWidth = '400px !important';
        }
        else {
            this.element.style.minWidth = '310px !important';
        }
        let width = this.parent.width.toString();
        if (this.parent.showToolbar && this.parent.grid) {
            width = this.parent.getGridWidthAsNumber().toString();
        }
        const height = this.getChartHeight();
        if (this.parent.chartSettings.enableScrollOnMultiAxis && this.parent.chartSettings.enableMultipleAxis &&
            this.accumulationType.indexOf(type) < 0 && this.chartSettings.chartSeries.type !== 'Pareto') {
            this.parent.element.querySelector('.' + PIVOTCHART).style.height =
                (height === 'auto' ? this.getChartAutoHeight() : height) + 'px';
            this.parent.element.querySelector('.' + PIVOTCHART).style.width = width + 'px';
            if (this.parent.chartSettings.chartSeries.type !== 'Polar' && this.parent.chartSettings.chartSeries.type !== 'Radar') {
                this.parent.element.querySelector('.' + PIVOTCHART).style.overflow = 'auto';
                this.parent.element.querySelector('.' + PIVOTCHART).style.overflowX = 'hidden';
            }
        }
        if (this.parent.chart && ((this.parent.chart.getModuleName() === 'accumulationchart' &&
            this.accumulationType.indexOf(type) < 0) || (this.parent.chart.getModuleName() === 'chart' &&
            this.accumulationType.indexOf(type) > -1 && this.chartSettings.chartSeries.type !== 'Pareto'))) {
            this.parent.chart.destroy();
            if (select('#' + this.parent.element.id + '_chart', this.parent.element)) {
                select('#' + this.parent.element.id + '_chart', this.parent.element).innerHTML = '';
                select('#' + this.parent.element.id + '_chart', this.parent.element).appendChild(createElement('div', {
                    className: PIVOTCHART_INNER, id: this.parent.element.id + '_chartInner'
                }));
            }
        }
        if (!(this.parent.chart && this.parent.chart.element && this.parent.element.querySelector('.e-chart') || this.parent.element.querySelector('.e-accumulationchart')) ||
            (this.parent.toolbarModule && this.parent.toolbarModule.isMultiAxisChange)) {
            if (this.parent.toolbarModule && this.parent.toolbarModule.isMultiAxisChange && this.parent.chart) {
                if (!this.parent.chart.isDestroyed) {
                    this.parent.chart.destroy();
                }
                this.parent.chart = undefined;
                select('#' + this.parent.element.id + '_chart', this.parent.element).innerHTML = '';
                select('#' + this.parent.element.id + '_chart', this.parent.element).appendChild(createElement('div', {
                    className: PIVOTCHART_INNER, id: this.parent.element.id + '_chartInner'
                }));
                this.parent.toolbarModule.isMultiAxisChange = false;
            }
            Chart.Inject(ColumnSeries, StackingColumnSeries, RangeColumnSeries, BarSeries, StackingBarSeries, ScatterSeries, BubbleSeries, LineSeries, StepLineSeries, SplineSeries, SplineAreaSeries, MultiColoredLineSeries, PolarSeries, RadarSeries, AreaSeries, RangeAreaSeries, StackingAreaSeries, StepAreaSeries, StackingLineSeries, MultiColoredAreaSeries, ParetoSeries, Legend, Tooltip$1, Category, MultiLevelLabel, ScrollBar, Zoom, Export, Crosshair, Selection$1, StripLine, DataLabel);
            AccumulationChart.Inject(PieSeries, FunnelSeries, PyramidSeries, AccumulationDataLabel, AccumulationLegend, AccumulationTooltip, Export);
            if (this.accumulationType.indexOf(type) > -1) {
                this.parent.chart = new AccumulationChart({
                    series: this.chartSeries.length > 0 ? this.chartSeries : [{}],
                    legendSettings: currentLegendSettings,
                    tooltip: currentTooltipSettings,
                    width: width,
                    height: height.toString(),
                    title: this.chartSettings.title,
                    enableSmartLabels: this.chartSettings.enableSmartLabels,
                    center: this.chartSettings.pieCenter,
                    enableBorderOnMouseMove: this.chartSettings.enableBorderOnMouseMove,
                    highlightMode: this.chartSettings.highlightMode,
                    highlightPattern: this.chartSettings.highlightPattern,
                    titleStyle: this.chartSettings.titleStyle,
                    subTitle: this.chartSettings.subTitle,
                    subTitleStyle: this.chartSettings.subTitleStyle,
                    margin: this.chartSettings.margin,
                    border: this.chartSettings.border,
                    background: this.chartSettings.background,
                    theme: this.chartSettings.theme,
                    selectionMode: this.chartSettings.accumulationSelectionMode,
                    isMultiSelect: this.chartSettings.isMultiSelect,
                    enableExport: this.chartSettings.enableExport,
                    selectedDataIndexes: this.chartSettings.selectedDataIndexes,
                    enableAnimation: this.chartSettings.enableAnimation,
                    useGroupingSeparator: this.chartSettings.useGroupingSeparator,
                    locale: this.parent.locale,
                    enableRtl: this.parent.enableRtl,
                    beforePrint: this.chartSettings.beforePrint ? this.chartSettings.beforePrint.bind(this) : undefined,
                    animationComplete: this.chartSettings.animationComplete ? this.chartSettings.animationComplete.bind(this)
                        : undefined,
                    legendRender: this.chartSettings.legendRender ? this.chartSettings.legendRender.bind(this) : undefined,
                    textRender: this.chartSettings.textRender ? this.chartSettings.textRender.bind(this) : undefined,
                    pointRender: this.chartSettings.pointRender ? this.chartSettings.pointRender.bind(this) : undefined,
                    seriesRender: this.chartSettings.seriesRender ? this.chartSettings.seriesRender.bind(this) : undefined,
                    chartMouseMove: this.chartSettings.chartMouseMove ? this.chartSettings.chartMouseMove.bind(this) : undefined,
                    chartMouseClick: this.chartSettings.chartMouseClick ? this.chartSettings.chartMouseClick.bind(this) : undefined,
                    pointMove: this.chartSettings.pointMove ? this.chartSettings.pointMove.bind(this) : undefined,
                    pointClick: this.pointClick.bind(this),
                    chartMouseLeave: this.chartSettings.chartMouseLeave ? this.chartSettings.chartMouseLeave.bind(this) : undefined,
                    chartMouseDown: this.chartSettings.chartMouseDown ? this.chartSettings.chartMouseDown.bind(this) : undefined,
                    chartMouseUp: this.chartSettings.chartMouseUp ? this.chartSettings.chartMouseUp.bind(this) : undefined,
                    tooltipRender: this.tooltipRender.bind(this),
                    loaded: this.loaded.bind(this),
                    load: this.load.bind(this),
                    resized: this.resized.bind(this)
                });
            }
            else {
                this.parent.chart = new Chart({
                    series: this.chartSeries.length > 0 ? this.chartSeries : [{}],
                    legendSettings: currentLegendSettings,
                    tooltip: currentTooltipSettings,
                    zoomSettings: currentZoomSettings,
                    axes: (type === 'Polar' || type === 'Radar') ? [] : axesWithRows.axes,
                    rows: (type === 'Polar' || type === 'Radar') ? [{}] :
                        (type === 'Bar' || type === 'StackingBar' || type === 'StackingBar100' || type === 'Pareto' &&
                            this.chartSettings.enableMultipleAxis) ? [{ height: '100%' }] : axesWithRows.rows,
                    columns: (type === 'Polar' || type === 'Radar') ? [{}] :
                        (type === 'Bar' || type === 'StackingBar' || type === 'StackingBar100' &&
                            this.chartSettings.enableMultipleAxis) ? axesWithRows.columns : [{ width: '100%' }],
                    primaryYAxis: (type === 'Polar' || type === 'Radar') ? axesWithRows.axes[0] : { visible: false },
                    primaryXAxis: currentXAxis,
                    width: width,
                    height: (this.parent.chartSettings.chartSeries.type !== 'Polar' &&
                        this.parent.chartSettings.chartSeries.type !== 'Radar' && this.parent.chartSettings.enableScrollOnMultiAxis &&
                        this.parent.chartSettings.enableMultipleAxis && this.parent.chartSettings.chartSeries.type !== 'Pareto' && this.parent.dataSourceSettings.values.length > 0) ?
                        Number(height) > (this.parent.dataSourceSettings.values.length * 235) + 100 ? isNaN(Number(height)) ?
                            height.toString() : (Number(height) - 5).toString() :
                            (!isNaN(Number(height)) || this.parent.dataSourceSettings.values.length > 1) ?
                                ((this.parent.dataSourceSettings.values.length * 235) + 100).toString() :
                                height.toString() : height.toString(),
                    title: this.chartSettings.title,
                    titleStyle: this.chartSettings.titleStyle,
                    subTitle: this.chartSettings.subTitle,
                    subTitleStyle: this.chartSettings.subTitleStyle,
                    margin: this.chartSettings.margin,
                    border: this.chartSettings.border,
                    background: this.chartSettings.background,
                    chartArea: this.chartSettings.chartArea,
                    palettes: this.chartSettings.palettes,
                    theme: this.chartSettings.theme,
                    crosshair: this.chartSettings.crosshair,
                    selectionMode: this.chartSettings.selectionMode,
                    isMultiSelect: this.chartSettings.isMultiSelect,
                    enableExport: this.chartSettings.enableExport,
                    selectedDataIndexes: this.chartSettings.selectedDataIndexes,
                    isTransposed: this.chartSettings.isTransposed,
                    enableAnimation: this.chartSettings.enableAnimation,
                    enableCanvas: this.chartSettings.enableCanvas,
                    useGroupingSeparator: this.chartSettings.useGroupingSeparator,
                    description: this.chartSettings.description,
                    tabIndex: this.chartSettings.tabIndex,
                    locale: this.parent.locale,
                    enableRtl: this.parent.enableRtl,
                    enableSideBySidePlacement: this.chartSettings.enableSideBySidePlacement,
                    beforePrint: this.chartSettings.beforePrint ? this.chartSettings.beforePrint.bind(this) : undefined,
                    animationComplete: this.chartSettings.animationComplete ? this.chartSettings.animationComplete.bind(this)
                        : undefined,
                    legendRender: this.chartSettings.legendRender ? this.chartSettings.legendRender.bind(this) : undefined,
                    textRender: this.chartSettings.textRender ? this.chartSettings.textRender.bind(this) : undefined,
                    pointRender: this.chartSettings.pointRender ? this.chartSettings.pointRender.bind(this) : undefined,
                    seriesRender: this.chartSettings.seriesRender ? this.chartSettings.seriesRender.bind(this) : undefined,
                    axisMultiLabelRender: this.chartSettings.multiLevelLabelRender ? this.chartSettings.multiLevelLabelRender.bind(this)
                        : undefined,
                    chartMouseMove: this.chartSettings.chartMouseMove ? this.chartSettings.chartMouseMove.bind(this) : undefined,
                    chartMouseClick: this.chartSettings.chartMouseClick ? this.chartSettings.chartMouseClick.bind(this) : undefined,
                    pointMove: this.chartSettings.pointMove ? this.chartSettings.pointMove.bind(this) : undefined,
                    pointClick: this.pointClick.bind(this),
                    chartMouseLeave: this.chartSettings.chartMouseLeave ? this.chartSettings.chartMouseLeave.bind(this) : undefined,
                    chartMouseDown: this.chartSettings.chartMouseDown ? this.chartSettings.chartMouseDown.bind(this) : undefined,
                    chartMouseUp: this.chartSettings.chartMouseUp ? this.chartSettings.chartMouseUp.bind(this) : undefined,
                    dragComplete: this.chartSettings.dragComplete ? this.chartSettings.dragComplete.bind(this) : undefined,
                    zoomComplete: this.chartSettings.zoomComplete ? this.chartSettings.zoomComplete.bind(this) : undefined,
                    scrollStart: this.chartSettings.scrollStart ? this.chartSettings.scrollStart.bind(this) : undefined,
                    scrollEnd: this.chartSettings.scrollEnd ? this.chartSettings.scrollEnd.bind(this) : undefined,
                    scrollChanged: this.chartSettings.scrollChanged ? this.chartSettings.scrollChanged.bind(this) : undefined,
                    tooltipRender: this.tooltipRender.bind(this),
                    legendClick: this.legendClick.bind(this),
                    loaded: this.loaded.bind(this),
                    load: this.load.bind(this),
                    resized: this.resized.bind(this),
                    axisLabelRender: this.axisLabelRender.bind(this),
                    multiLevelLabelClick: this.multiLevelLabelClick.bind(this)
                });
            }
            this.parent.chart.isStringTemplate = true;
        }
        else {
            this.parent.chart.series = this.chartSeries;
            this.parent.chart.title = this.parent.chartSettings.title;
            this.parent.chart.subTitle = this.parent.chartSettings.subTitle;
            this.parent.chart.background = this.parent.chartSettings.background;
            this.parent.chart.theme = this.parent.chartSettings.theme;
            this.parent.chart.legendSettings = currentLegendSettings;
            this.parent.chart.selectionMode = this.parent.chartSettings.selectionMode;
            this.parent.chart.enableExport = this.parent.chartSettings.enableExport;
            this.parent.chart.isMultiSelect = this.parent.chartSettings.isMultiSelect;
            this.parent.chart.enableAnimation = this.parent.chartSettings.enableAnimation;
            this.parent.chart.useGroupingSeparator = this.parent.chartSettings.useGroupingSeparator;
            this.parent.chart.highlightPattern = this.parent.chartSettings.highlightPattern;
            if (this.accumulationType.indexOf(type) > -1) {
                this.parent.chart.enableBorderOnMouseMove = this.parent.chartSettings.enableBorderOnMouseMove;
                this.parent.chart.highlightMode = this.parent.chartSettings.highlightMode;
                this.parent.chart.enableSmartLabels = this.parent.chartSettings.enableSmartLabels;
            }
            else {
                this.parent.chart.palettes = this.parent.chartSettings.palettes;
                this.parent.chart.isTransposed = this.parent.chartSettings.isTransposed;
                this.parent.chart.enableSideBySidePlacement = this.parent.chartSettings.enableSideBySidePlacement;
                this.parent.chart.tabIndex = this.parent.chartSettings.tabIndex;
                this.parent.chart.description = this.parent.chartSettings.description;
                this.parent.chart.enableCanvas = this.parent.chartSettings.enableCanvas;
            }
            if (type === 'Polar' || type === 'Radar') {
                this.parent.chart.primaryXAxis = currentXAxis;
                this.parent.chart.primaryYAxis.visible = true;
                this.parent.chart.primaryYAxis = axesWithRows.axes[0];
                this.parent.chart.axes = [];
                this.parent.chart.rows = [{}];
            }
            else if ((this.accumulationType.indexOf(type) < 0) && this.parent.chart.getModuleName() === 'chart') {
                this.parent.chart.primaryYAxis.visible = false;
                this.parent.chart.primaryXAxis = currentXAxis;
                this.parent.chart.axes = axesWithRows.axes;
                if (type === 'Bar' || type === 'StackingBar' || type === 'StackingBar100' &&
                    this.chartSettings.enableMultipleAxis) {
                    this.parent.chart.rows = [{ height: '100%' }];
                    this.parent.chart.columns = axesWithRows.columns;
                }
                else if (type === 'Pareto' && this.chartSettings.enableMultipleAxis) {
                    this.parent.chart.rows = [{ height: '100%' }];
                    this.parent.chart.columns = [{ width: '100%' }];
                }
                else {
                    this.parent.chart.rows = axesWithRows.rows;
                    this.parent.chart.columns = [{ width: '100%' }];
                }
            }
            this.parent.chart.refresh();
            if ((this.accumulationType.indexOf(type) > -1) && this.parent.chart.getModuleName() === 'accumulationchart' && (this.parent.dataSourceSettings.rows.length === 0 || this.parent.dataSourceSettings.columns.length === 0)) {
                this.parent.hideWaitingPopup();
                if (this.parent.pivotFieldListModule) {
                    hideSpinner(this.parent.pivotFieldListModule.fieldListSpinnerElement);
                }
            }
        }
        if (this.parent.chartSettings.enableScrollOnMultiAxis && this.parent.chartSettings.enableMultipleAxis) {
            this.parent.chart.appendTo('#' + this.parent.element.id + '_chartInner');
        }
        else {
            this.parent.chart.appendTo('#' + this.parent.element.id + '_chart');
        }
    }
    legendClick(args) {
        if (this.chartSettings.showPointColorByMembers && this.chartSettings.enableMultipleAxis) {
            const colorIndex = this.chartSeriesInfo[args.legendText].colorIndex;
            for (let i = 1; i < colorIndex.length; i++) {
                args.chart.series[colorIndex[i]].visible = !args.chart.series[colorIndex[i]].visible;
            }
        }
        this.parent.trigger(chartLegendClick, args);
    }
    pointClick(args) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const dataSource = args.series.dataSource ? args.series.dataSource : this.parent.chart.series[args.seriesIndex].dataSource;
        if (((['Pie', 'Funnel', 'Doughnut', 'Pyramid', 'Radar', 'Polar'].indexOf(this.parent.chartSettings.chartSeries.type) > -1) || !this.parent.chartSettings.showMultiLevelLabels) && (this.parent.dataType === 'olap' ? true : this.parent.dataSourceSettings.rows.length > 1)) {
            this.pivotIndex = {
                rIndex: dataSource ? dataSource[args.pointIndex].rIndex : undefined,
                cIndex: dataSource ? dataSource[args.pointIndex].cIndex : undefined
            };
            this.creatMenu();
            const pos = this.parent.element.getBoundingClientRect();
            const y = (this.parent.element.querySelector('.e-pivot-toolbar') ?
                this.parent.element.querySelector('.e-pivot-toolbar').clientHeight : 0) +
                (this.parent.element.querySelector('.e-chart-grouping-bar') ?
                    this.parent.element.querySelector('.e-chart-grouping-bar').clientHeight : 0) +
                (window.scrollY || document.documentElement.scrollTop) + pos.top;
            this.accumulationMenu.open(y + args.y, args.x + pos.left + (window.scrollX || document.documentElement.scrollLeft));
        }
        else if ((this.parent.allowDrillThrough || this.parent.editSettings.allowEditing) && this.parent.drillThroughModule) {
            const rIndex = dataSource[args.pointIndex].rIndex;
            const cIndex = dataSource[args.pointIndex].cIndex;
            this.parent.drillThroughModule.executeDrillThrough(this.parent.pivotValues[rIndex][cIndex], rIndex, cIndex);
        }
        this.parent.trigger(chartPointClick, args);
    }
    frameAxesWithRows() {
        let axes = [];
        let rows = [];
        let columns = [];
        const yAxisTitles = [];
        const percentChart = this.persistSettings.chartSeries && (this.persistSettings.chartSeries.type === 'StackingColumn100' ||
            this.persistSettings.chartSeries.type === 'StackingBar100' ||
            this.persistSettings.chartSeries.type === 'StackingArea100' ||
            this.persistSettings.chartSeries.type === 'StackingLine100');
        const percentAggregateTypes = ['PercentageOfGrandTotal', 'PercentageOfColumnTotal', 'PercentageOfRowTotal',
            'PercentageOfDifferenceFrom', 'PercentageOfParentRowTotal', 'PercentageOfParentColumnTotal', 'PercentageOfParentTotal'];
        if (this.chartSettings.enableMultipleAxis) {
            let valCnt = 0;
            const divider = (100 / this.dataSourceSettings.values.length) + '%';
            for (const item of this.dataSourceSettings.values) {
                const measureField = this.engineModule.fieldList[item.name];
                const measureAggregatedName = (this.parent.dataType === 'olap' ? '' : (this.parent.localeObj.getConstant(measureField.aggregateType) + ' ' +
                    this.parent.localeObj.getConstant('of') + ' ')) + measureField.caption;
                // let formatSetting: IFormatSettings = this.dataSourceSettings.formatSettings.filter((itm: IFormatSettings) => {
                //     return itm.name === item.name;
                // })[0];
                yAxisTitles.push(measureAggregatedName);
                let formatSetting;
                for (const field of this.dataSourceSettings.formatSettings) {
                    if (field.name === item.name) {
                        formatSetting = field;
                        break;
                    }
                }
                const format = PivotUtil.inArray(measureField.aggregateType, percentAggregateTypes) !== -1 ? 'P2' : (formatSetting ?
                    (formatSetting.format.toLowerCase().match(/n|p|c/) === null ? 'N' : formatSetting.format) :
                    this.parent.dataType === 'olap' ? this.getFormat(measureField.formatString) : 'N');
                const resFormat = (this.chartSettings.chartSeries.type === 'Polar' || this.chartSettings.chartSeries.type === 'Radar') ? true : false;
                let currentYAxis = {};
                currentYAxis = this.persistSettings.primaryYAxis ?
                    this.frameObjectWithKeys(this.persistSettings.primaryYAxis) : currentYAxis;
                currentYAxis.labelFormat = currentYAxis.labelFormat ?
                    currentYAxis.labelFormat : (percentChart ? '' : (!resFormat ? format : 'N'));
                currentYAxis.title = (this.chartSettings.multipleAxisMode === 'Combined') ? yAxisTitles.join(' - ') :
                    currentYAxis.title ? currentYAxis.title : measureAggregatedName;
                currentYAxis.zoomFactor = isNullOrUndefined(this.chartSettings.primaryYAxis.zoomFactor) ? 1
                    : this.chartSettings.primaryYAxis.zoomFactor;
                currentYAxis.edgeLabelPlacement = this.chartSettings.primaryYAxis.edgeLabelPlacement ?
                    this.chartSettings.primaryYAxis.edgeLabelPlacement : this.persistSettings.primaryYAxis.edgeLabelPlacement;
                if (this.chartSettings.chartSeries.type === 'Bar' || this.chartSettings.chartSeries.type === 'StackingBar' ||
                    this.chartSettings.chartSeries.type === 'StackingBar100') {
                    currentYAxis.plotOffsetRight = currentYAxis.plotOffsetRight ? currentYAxis.plotOffsetRight : 30;
                }
                else {
                    currentYAxis.plotOffsetTop = currentYAxis.plotOffsetTop ? currentYAxis.plotOffsetTop : 30;
                }
                if (!resFormat) {
                    currentYAxis.name = (this.chartSettings.multipleAxisMode === 'Combined') ? this.measureList.join('_') :
                        this.measuresNames[item.name] ? this.measuresNames[item.name] : item.name;
                }
                axes = axes.concat(currentYAxis);
                if (this.chartSettings.multipleAxisMode === 'Combined') {
                    axes = [axes[axes.length - 1]];
                }
                if (this.chartSettings.multipleAxisMode === 'Stacked') {
                    currentYAxis.rowIndex = valCnt;
                    currentYAxis.columnIndex = valCnt;
                    rows.push({ height: divider });
                    columns.push({ width: divider });
                }
                else {
                    currentYAxis.rowIndex = 0;
                    currentYAxis.columnIndex = 0;
                    rows = [{ height: '100%' }];
                    columns = [{ width: '100%' }];
                }
                valCnt++;
            }
        }
        else {
            const measureField = this.engineModule.fieldList[this.currentMeasure];
            const measureAggregatedName = (this.parent.dataType === 'olap' ? '' :
                (this.parent.localeObj.getConstant(measureField.aggregateType) + ' ' +
                    this.parent.localeObj.getConstant('of') + ' ')) + measureField.caption;
            // let formatSetting: IFormatSettings = this.dataSourceSettings.formatSettings.filter((item: IFormatSettings) => {
            //     return item.name === this.currentMeasure;
            // })[0];
            let formatSetting;
            for (const item of this.dataSourceSettings.formatSettings) {
                if (item.name === this.currentMeasure) {
                    formatSetting = item;
                    break;
                }
            }
            let lengthofFormat;
            if (formatSetting) {
                lengthofFormat = formatSetting.format.length;
            }
            let currentYAxis = {};
            const format = PivotUtil.inArray(measureField.aggregateType, percentAggregateTypes) !== -1 ? 'P2' : (formatSetting ?
                (((formatSetting.format.toLowerCase().match(/n[0-10]|p[0-10]|c[0-10]/) === null) || lengthofFormat > 3) ? 'N' : formatSetting.format) :
                this.parent.dataType === 'olap' ? this.getFormat(measureField.formatString) : 'N');
            currentYAxis = this.persistSettings.primaryYAxis ? this.frameObjectWithKeys(this.persistSettings.primaryYAxis) : currentYAxis;
            currentYAxis.zoomFactor = isNullOrUndefined(this.chartSettings.primaryYAxis.zoomFactor) ? 1
                : this.chartSettings.primaryYAxis.zoomFactor;
            currentYAxis.rowIndex = 0;
            currentYAxis.columnIndex = 0;
            currentYAxis.edgeLabelPlacement = this.chartSettings.primaryYAxis.edgeLabelPlacement ?
                this.chartSettings.primaryYAxis.edgeLabelPlacement : this.persistSettings.primaryYAxis.edgeLabelPlacement;
            if (!(this.chartSettings.chartSeries.type === 'Polar' || this.chartSettings.chartSeries.type === 'Radar')) {
                currentYAxis.name = this.measuresNames[this.currentMeasure] ? this.measuresNames[this.currentMeasure] : this.currentMeasure;
            }
            currentYAxis.labelFormat = currentYAxis.labelFormat ? currentYAxis.labelFormat : (percentChart ? '' : format);
            currentYAxis.title = currentYAxis.title ? currentYAxis.title : measureAggregatedName;
            axes = axes.concat(currentYAxis);
            rows.push({ height: '100%' });
            columns.push({ width: '100%' });
        }
        return { axes: axes, rows: rows, columns: columns };
    }
    getFormat(format) {
        if (format === 'Currency') {
            format = 'C';
        }
        else if (format === 'Percent') {
            format = 'P';
        }
        else {
            format = 'N';
        }
        return format;
    }
    /** @hidden */
    getColumnTotalIndex(pivotValues) {
        const colIndexColl = {};
        const rKeys = Object.keys(pivotValues);
        for (const rowIndex of rKeys) {
            const rows = pivotValues[Number(rowIndex)];
            let cKeys;
            if (!isNullOrUndefined(rows)) {
                cKeys = Object.keys(rows);
                for (const cellIndex of cKeys) {
                    const cell = rows[Number(cellIndex)];
                    if (!isNullOrUndefined(cell)) {
                        if (cell.axis !== 'column') {
                            return colIndexColl;
                        }
                        else if ((cell.type === 'sum' || (this.dataSourceSettings.columns.length === 0 ? false : cell.type === 'grand sum'))
                            && cell.rowSpan !== -1) {
                            colIndexColl[cell.colIndex] = cell.colIndex;
                        }
                    }
                }
            }
        }
        return colIndexColl;
    }
    groupHierarchyWithLevels(pivotValues) {
        this.fieldPosition = [];
        const group = {};
        let fieldCount = 0;
        const levelPos = {};
        this.measurePos = this.engineModule.tupRowInfo[0].measurePosition;
        for (let rowPos = 0; rowPos < pivotValues.length; rowPos++) {
            const cell = pivotValues[rowPos][0];
            if (cell && cell.axis === 'row' && cell.type !== 'grand sum') {
                if (isNullOrUndefined(group[cell.hierarchy])) {
                    if (cell.memberType === 3) {
                        if (fieldCount === this.measurePos) {
                            this.fieldPosition[this.measurePos] = cell.hierarchy;
                            group[cell.hierarchy] = { [cell.levelUniqueName]: cell.levelUniqueName };
                        }
                        else {
                            fieldCount--;
                        }
                    }
                    else {
                        this.fieldPosition[fieldCount] = cell.hierarchy;
                        group[cell.hierarchy] = { [cell.levelUniqueName]: cell.levelUniqueName };
                    }
                    fieldCount++;
                }
                else {
                    group[cell.hierarchy][cell.levelUniqueName] = cell.levelUniqueName;
                }
            }
        }
        let lastEnd = -1;
        for (let pos = 0; pos < this.fieldPosition.length; pos++) {
            if (this.measurePos !== pos) {
                levelPos[this.fieldPosition[pos]] = {
                    start: (lastEnd + 1),
                    end: (lastEnd + Object.keys(group[this.fieldPosition[pos]]).length)
                };
                lastEnd = levelPos[this.fieldPosition[pos]].end;
            }
        }
        return levelPos;
    }
    frameMultiLevelLabels() {
        const startKeys = Object.keys(this.headerColl);
        let parentHeaders = this.headerColl[-0.5];
        for (const startKey of startKeys) {
            const sKey = Number(startKey);
            const headers = this.headerColl[sKey];
            let levelPos = 0;
            let isAvail = false;
            while (levelPos <= this.maxLevel) {
                if (!isAvail) {
                    if (!headers[levelPos]) {
                        headers[levelPos] = parentHeaders[levelPos];
                    }
                    else {
                        isAvail = true;
                    }
                }
                else if (!headers[levelPos]) {
                    headers[levelPos] = {
                        name: headers[levelPos - 1].name,
                        // text: headers[levelPos - 1].text,
                        text: '',
                        hasChild: headers[levelPos - 1].hasChild,
                        isDrilled: headers[levelPos - 1].isDrilled,
                        levelName: headers[levelPos - 1].levelName,
                        level: headers[levelPos - 1].level,
                        fieldName: headers[levelPos - 1].fieldName,
                        rowIndex: headers[levelPos - 1].rowIndex,
                        colIndex: headers[levelPos - 1].colIndex,
                        span: -1
                    };
                    // headers[levelPos - 1].span = 0;
                }
                levelPos++;
            }
            parentHeaders = this.headerColl[sKey];
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const gRows = {};
        for (const startKey of startKeys) {
            const sKey = Number(startKey);
            const headers = this.headerColl[sKey];
            const lKeys = Object.keys(headers);
            for (const levelKey of lKeys) {
                const lKey = Number(levelKey);
                if (gRows[lKey]) {
                    const len = gRows[lKey].length;
                    if (headers[lKey].levelName === parentHeaders[lKey].levelName) {
                        gRows[lKey][len - 1].end = gRows[lKey][len - 1].end + 1;
                    }
                    else {
                        gRows[lKey].push({
                            start: sKey, end: sKey + 1, text: headers[lKey].text,
                            type: (headers[lKey].span === -1 ? 'WithoutTopandBottomBorder' : 'WithoutTopBorder'),
                            customAttributes: headers[lKey]
                        });
                    }
                }
                else {
                    gRows[lKey] = [{
                            start: sKey, end: sKey + 1, text: headers[lKey].text,
                            type: (headers[lKey].span === -1 ? 'WithoutTopandBottomBorder' : 'WithoutTopBorder'),
                            customAttributes: headers[lKey]
                        }];
                }
            }
            parentHeaders = headers;
        }
        const levellength = Object.keys(gRows).length;
        const multiLevelLabels = [];
        for (let level = levellength - 1; level > -1; level--) {
            multiLevelLabels.push({ categories: gRows[level], border: { width: 1 }, overflow: 'Trim' });
        }
        return multiLevelLabels;
    }
    getZoomFactor() {
        this.calculatedWidth = this.getCalulatedWidth();
        const seriesLength = (this.chartSeries.length * 10) > 120 ? (this.chartSeries.length * 10) : 120;
        let zoomFactor = this.chartSeries.length > 0 ?
            (this.calculatedWidth / (Object.keys(this.chartSeries[0].dataSource).length * seriesLength)) : 1;
        zoomFactor = (zoomFactor < 1 && zoomFactor > 0) ? zoomFactor : 1;
        return zoomFactor;
    }
    /** @hidden */
    getCalulatedWidth() {
        if (!isNaN(Number(this.parent.width))) {
            this.calculatedWidth = Number(this.parent.width);
        }
        else if (this.parent.width.indexOf('%') > -1) {
            this.calculatedWidth = this.parent.element.clientWidth * (parseFloat(this.parent.width) / 100);
        }
        else if (this.parent.width.indexOf('px') > -1) {
            this.calculatedWidth = Number(this.parent.width.toString().split('px')[0]);
        }
        else {
            this.calculatedWidth = this.parent.element.clientWidth;
        }
        return this.calculatedWidth;
    }
    configTooltipSettings() {
        const tooltip = this.persistSettings.tooltip ? this.persistSettings.tooltip : // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this.chartSettings.tooltip;
        tooltip.enable = tooltip.enable === undefined ? true : tooltip.enable;
        if (tooltip.enable && tooltip.template) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this.templateFn = this.parent.templateParser(tooltip.template);
        }
        if (this.parent.tooltipTemplate) { // eslint-disable-next-line @typescript-eslint/no-explicit-any
            tooltip.template = tooltip.template ? tooltip.template : this.parent.tooltipTemplate;
        }
        tooltip.header = tooltip.header ? tooltip.header : '';
        tooltip.enableMarker = tooltip.enableMarker === undefined ? true : tooltip.enableMarker;
        return tooltip;
    }
    configLegendSettings() {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const legendSettings = {};
        if (this.chartSettings.legendSettings) {
            let keyPos = 0;
            const keys = Object.keys(this.chartSettings.legendSettings);
            while (keyPos < keys.length) {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                legendSettings[keys[keyPos]] = this.chartSettings.legendSettings[keys[keyPos]];
                keyPos++;
            }
        }
        legendSettings.visible = legendSettings.visible !== false;
        legendSettings.padding = legendSettings.padding ? legendSettings.padding : 25;
        legendSettings.shapePadding = legendSettings.shapePadding ? legendSettings.shapePadding : 10;
        return legendSettings;
    }
    configXAxis() {
        let currentXAxis = {};
        currentXAxis = this.persistSettings.primaryXAxis ? this.frameObjectWithKeys(this.persistSettings.primaryXAxis) : currentXAxis;
        currentXAxis.valueType = 'Category';
        currentXAxis.labelIntersectAction = currentXAxis.labelIntersectAction ? currentXAxis.labelIntersectAction : 'Rotate45';
        currentXAxis.title = currentXAxis.title ? currentXAxis.title :
            this.dataSourceSettings.rows.map((args) => {
                return args.caption || args.name;
            }).join(' / ');
        currentXAxis.zoomFactor = isNullOrUndefined(this.parent.chartSettings.primaryXAxis.zoomFactor) ? this.getZoomFactor()
            : this.parent.chartSettings.primaryXAxis.zoomFactor;
        if (!this.parent.chartSettings.zoomSettings.enableScrollbar) {
            currentXAxis.zoomFactor = 1;
        }
        if (this.chartSettings.showMultiLevelLabels && this.chartSettings.chartSeries.type !== 'Pareto') {
            currentXAxis.multiLevelLabels = this.frameMultiLevelLabels();
            currentXAxis.border = { width: 1, type: 'WithoutTopandBottomBorder' };
            currentXAxis.majorTickLines = { width: 0, height: -10 };
        }
        else {
            currentXAxis.multiLevelLabels = [];
            currentXAxis.border = { width: 1, type: 'Rectangle' };
            currentXAxis.majorTickLines = { width: 0, height: 5 };
        }
        return currentXAxis;
    }
    configZoomSettings() {
        const zoomSettings = this.chartSettings.zoomSettings;
        zoomSettings.enableSelectionZooming = zoomSettings.enableSelectionZooming === undefined ? true :
            zoomSettings.enableSelectionZooming;
        zoomSettings.enableScrollbar = zoomSettings.enableScrollbar === undefined ? true : zoomSettings.enableScrollbar;
        return zoomSettings;
    }
    tooltipRender(args) {
        const measure = (this.chartSettings.enableMultipleAxis && this.chartSettings.multipleAxisMode === 'Combined' &&
            this.accumulationType.indexOf(this.chartSettings.chartSeries.type) < 0 && this.chartSettings.chartSeries.type !== 'Radar' &&
            this.chartSettings.chartSeries.type !== 'Polar') ? args.series.tooltipMappingName :
            args.series.yAxisName ? (args.series.yAxisName.split('_CumulativeAxis')[0]) :
                ((this.chartSettings.enableMultipleAxis && this.accumulationType.indexOf(this.chartSettings.chartSeries.type) < 0 &&
                    this.chartSettings.chartSeries.type !== 'Pareto') ? args.series.name ? args.series.name.split(' | ')[1] :
                    args.data.seriesName ? args.data.seriesName.split(' | ')[1] : this.currentMeasure : this.measuresNames[this.currentMeasure] ?
                    this.measuresNames[this.currentMeasure] : this.currentMeasure);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const dataSource = args.series.dataSource ? args.series.dataSource
            : this.parent.chart.series[args.data.seriesIndex].dataSource;
        const rowIndex = dataSource ? dataSource[args.data.pointIndex].rIndex : undefined;
        const colIndex = dataSource ? dataSource[args.data.pointIndex].cIndex : undefined;
        const measureField = this.engineModule.fieldList[this.measuresNames[measure]
            ? this.measuresNames[measure] : measure];
        const aggregateType = this.parent.dataType === 'olap' ? '' : this.parent.localeObj.getConstant(measureField.aggregateType);
        const measureAggregatedName = (this.parent.dataType === 'olap' ? '' : aggregateType + ' ' +
            this.parent.localeObj.getConstant('of') + ' ') + measureField.caption;
        const formattedText = this.engineModule.pivotValues[rowIndex][colIndex].formattedText;
        const formatField = this.engineModule.formatFields[measureField.id];
        const valueFormat = this.engineModule.getFormattedValue(args.point.y, measureField.id, formattedText);
        const formattedValue = (formatField && formatField.format && formatField.format.toLowerCase().match(/n|p|c/) !== null &&
            this.chartSettings.useGroupingSeparator) ? this.parent.dataType === 'olap' ?
            valueFormat.toString() : valueFormat.formattedText :
            formattedText;
        const text = this.parent.pivotValues[rowIndex][colIndex].columnHeaders;
        const columnText = !isNullOrUndefined(text) ? this.parent.dataType === 'olap' ? this.chartSeriesInfo[text.toString().split(/~~|::/).join(' - ')].uniqueName :
            this.chartSeriesInfo[text.toString().split(this.parent.dataSourceSettings.valueSortSettings.headerDelimiter).join(' - ')].uniqueName : undefined;
        /* eslint-disable @typescript-eslint/no-explicit-any */
        const rowText = args.point.x;
        if (this.parent.tooltipTemplate && this.parent.getTooltipTemplate() !== undefined || this.chartSettings.tooltip.template) {
            const rowFields = dataSource ? this.parent.getHeaderField(rowIndex, colIndex, 'row') : '';
            const columnFields = dataSource ? this.parent.getHeaderField(rowIndex, colIndex, 'Column') : '';
            const templateVariable = {
                rowHeaders: rowText,
                columnHeaders: columnText,
                aggregateType: aggregateType,
                value: formattedValue,
                valueField: measureField.caption,
                rowFields: rowFields,
                columnFields: columnFields
            };
            /* eslint-enable @typescript-eslint/no-explicit-any */
            let template;
            if (this.parent.chartSettings && this.parent.chartSettings.tooltip &&
                this.parent.chartSettings.tooltip.enable && this.parent.chartSettings.tooltip.template) {
                template = this.tooltipTemplateFn()(templateVariable, this, 'tooltipTemplate', this.element.id + '1tooltipTemplate')[0].outerHTML;
            }
            else {
                template = this.parent.getTooltipTemplate()(templateVariable, this, 'tooltipTemplate', this.element.id + 'tooltipTemplate')[0].outerHTML;
            }
            args.template = template;
        }
        else {
            args.text = measureAggregatedName + ': ' + formattedValue +
                (this.dataSourceSettings.columns.length === 0 ? '' :
                    (' <br/>' + this.parent.localeObj.getConstant('column') + ': ' + columnText)) +
                (this.dataSourceSettings.rows.length === 0 ? '' :
                    (' <br/>' + this.parent.localeObj.getConstant('row') + ': ' + rowText));
            this.parent.trigger(chartTooltipRender, args);
        }
    }
    tooltipTemplateFn() {
        return this.templateFn;
    }
    loaded(args) {
        this.parent.isChartLoaded = true;
        const width = this.parent.grid ? this.parent.getGridWidthAsNumber().toString() : this.parent.getWidthAsNumber().toString();
        if (this.parent.chart && this.parent.showGroupingBar && this.parent.groupingBarModule &&
            this.parent.showFieldList && this.parent.currentView === 'Chart') {
            this.parent.groupingBarModule.alignIcon();
        }
        if (this.chartSettings.showMultiLevelLabels) {
            const multilabelAxisName = PivotUtil.inArray(this.chartSettings.chartSeries.type, ['Bar', 'StackingBar', 'StackingBar100']) > -1 ?
                '_chartYAxisMultiLevelLabel0' : '_chartXAxisMultiLevelLabel0';
            if (!isNullOrUndefined(select('#' + this.parent.element.id + multilabelAxisName, this.parent.element))) {
                this.parent.element.querySelector('#' + this.parent.element.id + multilabelAxisName).setAttribute('cursor', 'pointer');
            }
        }
        if (this.parent.chartSettings.enableScrollOnMultiAxis && this.parent.chartSettings.enableMultipleAxis) {
            if (['Pie', 'Funnel', 'Pyramid', 'Doughnut', 'Radar', 'Polar', 'Pareto'].indexOf(this.parent.chartSettings.chartSeries.type) >= 0) {
                this.parent.element.querySelector('.' + PIVOTCHART).style.overflow = 'visible';
            }
            else {
                this.parent.element.querySelector('.' + PIVOTCHART).style.overflow = 'auto';
                this.parent.element.querySelector('.' + PIVOTCHART).style.overflowX = 'hidden';
            }
            this.parent.element.querySelector('.' + PIVOTCHART).style.width = width + 'px';
        }
        this.updateView();
        this.parent.notify(contentReady, {});
        this.parent.trigger(chartLoaded, args);
        if ((this.parent.dataSourceSettings.mode === 'Server' && this.parent.isServerWaitingPopup) || this.parent.dataSourceSettings.mode === 'Local') {
            this.parent.hideWaitingPopup();
        }
    }
    /** @hidden */
    updateView() {
        if (this.parent.grid && this.parent.chart && this.parent.showToolbar) {
            if (this.parent.currentView === 'Table') {
                this.parent.grid.element.style.display = '';
                this.parent.chart.element.style.display = 'none';
                if (this.parent.showGroupingBar && this.parent.groupingBarModule &&
                    this.parent.element.querySelector('.e-pivot-grouping-bar') &&
                    this.parent.element.querySelector('.e-chart-grouping-bar')) {
                    const groupingTable = this.parent.element.querySelector('.e-pivot-grouping-bar');
                    groupingTable.style.display = '';
                    if (groupingTable && groupingTable.querySelector('.' + ALL_FIELDS_PANEL_CLASS) && this.parent.groupingBarModule.gridPanel != null &&
                        !this.parent.groupingBarModule.gridPanel.isDestroyed) {
                        this.parent.groupingBarModule.gridPanel.refreshOverflow();
                    }
                    this.parent.element.querySelector('.e-chart-grouping-bar').style.display = 'none';
                }
                if (this.parent.chartSettings.enableMultipleAxis && this.parent.chartSettings.enableScrollOnMultiAxis) {
                    this.parent.element.querySelector('.e-pivotchart').style.display = 'none';
                }
            }
            else {
                this.parent.grid.element.style.display = 'none';
                this.parent.chart.element.style.display = '';
                if (this.parent.showGroupingBar && this.parent.groupingBarModule &&
                    this.parent.element.querySelector('.e-pivot-grouping-bar') &&
                    this.parent.element.querySelector('.e-chart-grouping-bar')) {
                    this.parent.element.querySelector('.e-pivot-grouping-bar').style.display = 'none';
                    const groupingChartTable = this.parent.element.querySelector('.e-chart-grouping-bar');
                    groupingChartTable.style.display = '';
                    if (groupingChartTable && groupingChartTable.querySelector('.' + ALL_FIELDS_PANEL_CLASS) &&
                        this.parent.groupingBarModule.chartPanel != null && !this.parent.groupingBarModule.chartPanel.isDestroyed) {
                        this.parent.groupingBarModule.chartPanel.refreshOverflow();
                    }
                }
                if (this.parent.chartSettings.enableMultipleAxis && this.parent.chartSettings.enableScrollOnMultiAxis) {
                    this.parent.element.querySelector('.e-pivotchart').style.display = '';
                }
            }
        }
    }
    creatMenu() {
        if (this.accumulationMenu && !this.accumulationMenu.isDestroyed) {
            this.accumulationMenu.destroy();
        }
        const items = ((this.parent.allowDrillThrough || this.parent.editSettings.allowEditing)
            && this.parent.drillThroughModule) ? ['expand', 'collapse', 'drillThrough', 'exit'] :
            ['expand', 'collapse', 'exit'];
        const option = [];
        for (let i = 0; i < items.length; i++) {
            option.push({
                id: this.parent.element.id + '_DrillMenuChart_' + items[i],
                text: this.parent.localeObj.getConstant(items[i]),
                items: []
            });
        }
        const getString = this.getMenuItems();
        const expand = [];
        const collapse = [];
        for (let i = 0; i < getString.length; i++) {
            if (getString[i].type === 'expand') {
                expand.push({ id: this.element.id + 'drillExpand_' + getString[i].key, text: getString[i].value });
            }
            else {
                collapse.push({ id: this.element.id + 'drillCollapse_' + getString[i].key, text: getString[i].value });
            }
        }
        if (expand.length > 0) {
            option[0].items = expand;
        }
        if (collapse.length > 0) {
            option[1].items = collapse;
        }
        const menuOptions = {
            cssClass: this.parent.element.id + '_accumulationChart' + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
            items: option,
            enableRtl: this.parent.enableRtl,
            beforeOpen: this.drillMenuOpen.bind(this),
            select: this.drillMenuSelect.bind(this),
            locale: this.parent.locale
        };
        this.accumulationMenu = new ContextMenu$1(menuOptions);
        let contextMenu;
        if (select('#' + this.parent.element.id + '_accumulationChart', this.parent.element)) {
            contextMenu = select('#' + this.parent.element.id + '_accumulationChart', this.parent.element);
            contextMenu.innerHTML = '';
        }
        else {
            contextMenu = createElement('ul', {
                id: this.parent.element.id + '_accumulationChart'
            });
            this.parent.element.appendChild(contextMenu);
        }
        this.accumulationMenu.isStringTemplate = true;
        this.accumulationMenu.appendTo(contextMenu);
    }
    drillMenuOpen(args) {
        if (args.items[0] && args.items[0].text === this.parent.localeObj.getConstant('expand') &&
            args.items[0].items && args.items[0].items.length === 0) {
            this.accumulationMenu.enableItems([this.parent.localeObj.getConstant('expand')], false);
        }
        if (args.items[1] && args.items[1].text === this.parent.localeObj.getConstant('collapse') &&
            args.items[1].items && args.items[1].items.length === 0) {
            this.accumulationMenu.enableItems([this.parent.localeObj.getConstant('collapse')], false);
        }
    }
    getMenuItems() {
        let rowIndex = this.pivotIndex.rIndex;
        const menuItem = [];
        const pivotValues = this.engineModule.pivotValues;
        let levelCol = [];
        let pivotValue = pivotValues[rowIndex][this.pivotIndex.cIndex];
        // let hierarchy: string = pivotValues[rowIndex][0].hierarchy;
        let level = (!pivotValues[rowIndex][0].isNamedSet && pivotValues[rowIndex][0].hasChild) ?
            pivotValues[rowIndex][0].level : undefined;
        const levels = this.parent.dataType === 'olap' ? pivotValue.rowHeaders.toString().split(/~~|::/)
            : pivotValue.rowHeaders.toString().split(this.engineModule.valueSortSettings.headerDelimiter);
        while (pivotValues[rowIndex][0]) {
            pivotValue = pivotValues[rowIndex][0];
            if ((levels.length !== 0) && (levels.indexOf(pivotValue.formattedText.toString()) === (levels.length - 1))) {
                if (pivotValue.hasChild && !pivotValue.isNamedSet && levelCol.indexOf(pivotValue.level) < 0 &&
                    (level ? level >= pivotValue.level : (level === 0 ? (pivotValue.level === 0) : true))) {
                    if (!(pivotValue.isDrilled && pivotValue.hasChild)) {
                        menuItem.push({
                            key: rowIndex,
                            type: 'expand',
                            value: pivotValue.formattedText
                        });
                    }
                    else {
                        menuItem.push({
                            key: rowIndex,
                            type: 'collapse',
                            value: pivotValue.formattedText
                        });
                    }
                    levelCol.push(pivotValue.level);
                    level = level ? (level - 1) : (pivotValue.level - 1);
                }
                const index = levels.indexOf(pivotValue.formattedText.toString());
                levels.splice(index, 1);
            }
            if (pivotValue.level === 0 && pivotValue.hasChild && !pivotValue.isNamedSet) {
                level = undefined;
                levelCol = [];
            }
            rowIndex--;
        }
        return menuItem;
    }
    drillMenuSelect(args) {
        const pivotValues = (this.parent.dataType === 'olap' ?
            this.parent.olapEngineModule.pivotValues : this.parent.engineModule.pivotValues);
        const option = (args.element.id).split('_DrillMenuChart_')[1];
        if (args.element.id.indexOf(this.element.id + 'drill') === 0) {
            const type = args.element.id.split(this.element.id + 'drill')[1].indexOf('Expand') >= 0 ? 'drillExpand' : 'drillCollapse';
            const rowIndex = Number(args.element.id.split(this.element.id + type + '_')[1]);
            const pivotValue = pivotValues[rowIndex][0];
            const name = this.parent.dataType === 'olap' ? pivotValue.formattedText :
                (pivotValue.actualText ? pivotValue.actualText.toString() : pivotValue.formattedText.toString());
            const text = pivotValue.formattedText ? pivotValue.formattedText.toString() : name;
            const caption = (pivotValue.hasChild && !pivotValue.isNamedSet) ?
                ((pivotValue.isDrilled ? ' - ' : ' + ') + text) : text;
            const tupInfo = this.parent.dataType === 'olap' ?
                this.engineModule.tupRowInfo[pivotValue.ordinal] : undefined;
            const levelName = tupInfo ? tupInfo.uNameCollection : pivotValue.valueSort.levelName.toString();
            const customAttributes = {
                fieldName: pivotValue.valueSort.axis,
                level: pivotValue.level,
                hasChild: pivotValue.hasChild,
                levelName: levelName,
                name: name,
                text: caption,
                rowIndex: rowIndex,
                colIndex: 0,
                isDrilled: pivotValue.isDrilled,
                cell: pivotValue
            };
            if (this.parent.dataType === 'olap') {
                this.parent.onDrill(undefined, customAttributes);
            }
            else {
                this.onDrill({ customAttributes });
            }
        }
        else if (option === 'drillThrough') {
            this.parent.drillThroughModule.executeDrillThrough(pivotValues[this.pivotIndex.rIndex][this.pivotIndex.cIndex], this.pivotIndex.rIndex, this.pivotIndex.rIndex);
        }
        else if (option === 'exit') {
            this.accumulationMenu.close();
        }
    }
    /**
     * @returns {string} - string.
     * @hidden
     */
    getChartHeight() {
        let height;
        let offSetHeight;
        if (isNullOrUndefined(this.parent.getHeightAsNumber())) {
            height = 'auto';
        }
        else {
            const offSetVal = this.parent.showToolbar ? 6 : 5;
            height = (this.parent.getHeightAsNumber() - offSetVal).toString();
            offSetHeight = this.parent.getHeightAsNumber() - offSetVal;
        }
        if (!isNullOrUndefined(this.parent.getHeightAsNumber())) {
            let isNone = false;
            if (this.parent.element.querySelector('.e-chart-grouping-bar') !== null && this.parent.element.querySelector('.e-chart-grouping-bar').style.display.toLowerCase() === 'none') {
                isNone = true;
                this.parent.element.querySelector('.e-chart-grouping-bar').style.display = 'block';
            }
            if (this.parent.showToolbar && this.parent.showGroupingBar) {
                height = (offSetHeight - (this.parent.element.querySelector('.e-pivot-toolbar') ?
                    this.parent.element.querySelector('.e-pivot-toolbar').clientHeight : 42) -
                    (this.parent.element.querySelector('.e-chart-grouping-bar') ?
                        this.parent.element.querySelector('.e-chart-grouping-bar').clientHeight : 62)).toString();
            }
            else if (this.parent.showToolbar) {
                height = (offSetHeight - (this.parent.element.querySelector('.e-pivot-toolbar') ?
                    this.parent.element.querySelector('.e-pivot-toolbar').clientHeight : 42)).toString();
            }
            else if (this.parent.showGroupingBar) {
                height = (offSetHeight - (this.parent.element.querySelector('.e-chart-grouping-bar') ?
                    this.parent.element.querySelector('.e-chart-grouping-bar').clientHeight : 62)).toString();
            }
            else if ((this.parent.chart && parseInt(this.parent.chart.height, 10) < 200) || offSetHeight < 200) {
                height = '200';
            }
            if (isNone) {
                this.parent.element.querySelector('.e-chart-grouping-bar').style.display = 'none';
            }
        }
        else {
            height = 'auto';
        }
        return height;
    }
    getChartAutoHeight() {
        let height = this.parent.element.offsetHeight < this.parent.minHeight ? this.parent.minHeight :
            this.parent.element.offsetHeight;
        if (this.parent.showToolbar && this.parent.showGroupingBar) {
            height = height - (this.parent.element.querySelector('.e-pivot-toolbar') ?
                this.parent.element.querySelector('.e-pivot-toolbar').clientHeight : 42) -
                (this.parent.element.querySelector('.e-chart-grouping-bar') ?
                    this.parent.element.querySelector('.e-chart-grouping-bar').clientHeight : 62);
        }
        else if (this.parent.showToolbar) {
            height = height - (this.parent.element.querySelector('.e-pivot-toolbar') ?
                this.parent.element.querySelector('.e-pivot-toolbar').clientHeight : 42);
        }
        else if (this.parent.showGroupingBar) {
            height = height - (this.parent.element.querySelector('.e-chart-grouping-bar') ?
                this.parent.element.querySelector('.e-chart-grouping-bar').clientHeight : 62);
        }
        return height;
    }
    axisLabelRender(args) {
        if (this.chartSettings.showMultiLevelLabels && this.chartSettings.chartSeries.type !== 'Pareto') {
            if (args.axis.name === 'primaryXAxis') {
                args.text = '';
            }
        }
        if (args.axis.name !== 'primaryXAxis') {
            const formatField = this.engineModule.formatFields[(this.chartSettings.enableMultipleAxis &&
                this.chartSettings.multipleAxisMode === 'Combined') ? this.currentMeasure : args.axis.name];
            const valueFormat = this.engineModule.getFormattedValue(args.value, (this.chartSettings.enableMultipleAxis &&
                this.chartSettings.multipleAxisMode === 'Combined') ? this.currentMeasure : args.axis.name, args.text);
            const formattedValue = ((formatField && formatField.format && formatField.format.toLowerCase().match(/n|p|c/) !== null &&
                this.chartSettings.useGroupingSeparator) ? this.parent.dataType === 'olap' ? valueFormat.toString() :
                valueFormat.formattedText : args.value.toString());
            args.text = formattedValue;
        }
        this.parent.trigger(chartAxisLabelRender, args);
    }
    multiLevelLabelClick(args) {
        /* eslint-disable @typescript-eslint/no-explicit-any */
        const eventArgs = {
            axis: args.axis,
            text: args.text,
            cell: !isNullOrUndefined(args.customAttributes) ? args.customAttributes.cell : undefined,
            cancel: false
        };
        this.parent.trigger(multiLevelLabelClick, eventArgs);
        if (!eventArgs.cancel && args.customAttributes && args.customAttributes.hasChild &&
            !args.customAttributes.cell.isNamedSet) {
            /* eslint-enable @typescript-eslint/no-explicit-any */
            if (this.parent.dataType === 'olap') {
                this.parent.onDrill(undefined, args.customAttributes);
            }
            else {
                this.onDrill(args);
            }
        }
    }
    /* eslint-disable @typescript-eslint/no-explicit-any */
    /**
     * It helped to drills the row or columns.
     *
     * @param {IMultiLevelLabelClickEventArgs | any} args - It contains the drillInfo.
     * @returns {void}
     * @hidden
     */
    onDrill(args) {
        const labelInfo = args.customAttributes;
        /* eslint-enable @typescript-eslint/no-explicit-any */
        let delimiter = (this.dataSourceSettings.drilledMembers[0] && this.dataSourceSettings.drilledMembers[0].delimiter) ?
            this.dataSourceSettings.drilledMembers[0].delimiter : '**';
        const fieldName = labelInfo.fieldName;
        const currentCell = this.engineModule.pivotValues[labelInfo.rowIndex][labelInfo.colIndex];
        let memberUqName = currentCell.valueSort.levelName.
            split(this.engineModule.valueSortSettings.headerDelimiter).join(delimiter);
        let fieldAvail = false;
        if (this.dataSourceSettings.drilledMembers.length === 0) {
            this.parent.setProperties({
                dataSourceSettings: { drilledMembers: [{ name: fieldName, items: [memberUqName], delimiter: delimiter }] }
            }, true);
        }
        else {
            for (let fCnt = 0; fCnt < this.dataSourceSettings.drilledMembers.length; fCnt++) {
                const field = this.dataSourceSettings.drilledMembers[fCnt];
                memberUqName = memberUqName.split(delimiter).join(field.delimiter ? field.delimiter : delimiter);
                delimiter = field.delimiter = field.delimiter ? field.delimiter : delimiter;
                if (field.name === fieldName) {
                    fieldAvail = true;
                    const memIndex = field.items.indexOf(memberUqName);
                    if (memIndex > -1) {
                        field.items.splice(memIndex, 1);
                    }
                    else {
                        field.items.push(memberUqName);
                    }
                }
                else {
                    continue;
                }
            }
            if (!fieldAvail) {
                this.dataSourceSettings.drilledMembers.push({ name: fieldName, items: [memberUqName], delimiter: delimiter });
            }
        }
        this.parent.showWaitingPopup();
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const pivot = this;
        //setTimeout(() => {
        const drilledItem = {
            fieldName: fieldName, memberName: memberUqName, delimiter: delimiter,
            axis: 'row',
            action: labelInfo.isDrilled ? 'up' : 'down',
            currentCell: currentCell
        };
        const drillArgs = {
            drillInfo: drilledItem,
            pivotview: pivot.parent
        };
        pivot.parent.trigger(drill, drillArgs);
        const enginePopulatingEventArgs = {
            dataSourceSettings: PivotUtil.getClonedDataSourceSettings(this.parent.dataSourceSettings)
        };
        this.parent.trigger(enginePopulating, enginePopulatingEventArgs);
        this.parent.setProperties({ dataSourceSettings: enginePopulatingEventArgs.dataSourceSettings }, true);
        if (pivot.parent.enableVirtualization || pivot.parent.enablePaging) {
            if (pivot.parent.dataSourceSettings.mode === 'Server') {
                pivot.parent.getEngine('onDrill', drilledItem, null, null, null, null, null);
            }
            else {
                pivot.engineModule.drilledMembers = pivot.dataSourceSettings.drilledMembers;
                pivot.engineModule.onDrill(drilledItem);
            }
        }
        else if (pivot.parent.dataSourceSettings.mode === 'Server') {
            pivot.parent.getEngine('onDrill', drilledItem, null, null, null, null, null);
        }
        else {
            pivot.engineModule.generateGridData(pivot.dataSourceSettings, true);
        }
        pivot.parent.allowServerDataBinding = false;
        pivot.parent.setProperties({ pivotValues: pivot.engineModule.pivotValues }, true);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        delete pivot.parent.bulkChanges.pivotValues;
        pivot.parent.allowServerDataBinding = true;
        const eventArgs = {
            dataSourceSettings: PivotUtil.getClonedDataSourceSettings(this.parent.dataSourceSettings),
            pivotValues: this.parent.pivotValues
        };
        this.parent.trigger(enginePopulated, eventArgs);
        pivot.engineModule.pivotValues = eventArgs.pivotValues;
        pivot.parent.renderPivotGrid();
        //});
    }
    isAttributeDrill(hierarchy, drillInfo) {
        let isDrill = false;
        for (let i = 0; i < this.dataSourceSettings.drilledMembers.length; i++) {
            if (this.dataSourceSettings.drilledMembers[i].name === hierarchy) {
                for (let j = 0; j < this.dataSourceSettings.drilledMembers[i].items.length; j++) {
                    const drillItems = this.dataSourceSettings.drilledMembers[i].items[j]
                        .split(this.dataSourceSettings.drilledMembers[i].delimiter);
                    let levelName = '';
                    for (let k = 0; k < drillItems.length; k++) {
                        if (drillInfo[k] && drillInfo[k].uName) {
                            levelName = levelName + (levelName === '' ? '' : this.dataSourceSettings.drilledMembers[i].delimiter) +
                                (drillInfo[k].uName.indexOf('[Measures]') > -1 ? '[Measures]' : drillInfo[k].uName);
                        }
                    }
                    if (levelName === this.dataSourceSettings.drilledMembers[i].items[j]) {
                        isDrill = true;
                        break;
                    }
                }
            }
        }
        return isDrill;
    }
    load(args) {
        if (args.chart.zoomModule) {
            args.chart.zoomModule.isZoomed = true;
        }
        this.parent.trigger(chartLoad, args);
    }
    resized(args) {
        if (this.accumulationType.indexOf(this.chartSettings.chartSeries.type) < 0) {
            args.chart.primaryXAxis.zoomFactor = isNullOrUndefined(this.parent.chartSettings.primaryXAxis.zoomFactor)
                ? this.getZoomFactor() : this.parent.chartSettings.primaryXAxis.zoomFactor;
            if (!this.parent.chartSettings.zoomSettings.enableScrollbar) {
                args.chart.primaryXAxis.zoomFactor = isNullOrUndefined(this.parent.chartSettings.primaryXAxis.zoomFactor)
                    ? 1 : this.parent.chartSettings.primaryXAxis.zoomFactor;
            }
        }
        this.parent.trigger(chartResized, args);
    }
    /** @hidden */
    getResizedChartHeight() {
        const height = ['Pie', 'Funnel', 'Pyramid', 'Doughnut', 'Radar', 'Polar', 'Pareto'].indexOf(this.parent.chartSettings.chartSeries.type) < 0 &&
            this.parent.chartSettings.enableScrollOnMultiAxis && this.parent.chartSettings.enableMultipleAxis &&
            this.parent.dataSourceSettings.values.length > 0 ? Number(this.parent.chart.height) >
            (this.parent.dataSourceSettings.values.length * 235) + 100 ? isNaN(Number(this.getChartHeight())) ?
            this.getChartHeight().toString() : (Number(this.getChartHeight()) - 5).toString() :
            (!isNaN(Number(this.getChartHeight())) || this.parent.dataSourceSettings.values.length > 1) ?
                ((this.parent.dataSourceSettings.values.length * 235) + 100).toString() : this.getChartHeight().toString()
            : this.getChartHeight().toString();
        return height;
    }
    /**
     * To destroy the chart module
     *
     * @returns {void}
     * @hidden
     */
    destroy() {
        if (this.parent && this.parent.isDestroyed) {
            return;
        }
        if (this.engineModule && !this.parent.destroyEngine) {
            this.engineModule.fieldList = {};
            this.engineModule = {};
        }
        if (this.chartSeries) {
            this.chartSeries = null;
        }
        if (this.columnGroupObject) {
            this.columnGroupObject = null;
        }
        if (this.chartSeriesInfo) {
            this.chartSeriesInfo = {};
            this.selectedLegend = null;
        }
        if (this.chartSettings) {
            this.chartSettings = null;
        }
        if (this.dataSourceSettings) {
            this.dataSourceSettings = null;
        }
        if (this.accumulationMenu && !this.accumulationMenu.isDestroyed) {
            this.accumulationMenu.destroy();
            this.accumulationMenu = null;
        }
        if (this.parent && this.parent.chart && !this.parent.chart.isDestroyed) {
            this.parent.chart.destroy();
            this.parent.chart = null;
        }
        else {
            return;
        }
    }
}

/**
 * Base export
 */
/** @hidden */

/**
 * Specifies Chart Themes
 */
var Theme;
(function (Theme) {
    /** @private */
    Theme.axisLabelFont = {
        size: '12px',
        fontWeight: 'Normal',
        color: null,
        fontStyle: 'Normal',
        fontFamily: 'Segoe UI'
    };
    /** @private */
    Theme.axisTitleFont = {
        size: '14px',
        fontWeight: 'Normal',
        color: null,
        fontStyle: 'Normal',
        fontFamily: 'Segoe UI'
    };
    /** @private */
    Theme.chartTitleFont = {
        size: '15px',
        fontWeight: '500',
        color: null,
        fontStyle: 'Normal',
        fontFamily: 'Segoe UI'
    };
    /** @private */
    Theme.chartSubTitleFont = {
        size: '11px',
        fontWeight: '500',
        color: null,
        fontStyle: 'Normal',
        fontFamily: 'Segoe UI'
    };
    /** @private */
    Theme.crosshairLabelFont = {
        size: '13px',
        fontWeight: 'Normal',
        color: null,
        fontStyle: 'Normal',
        fontFamily: 'Segoe UI'
    };
    /** @private */
    Theme.tooltipLabelFont = {
        size: '13px',
        fontWeight: 'Normal',
        color: null,
        fontStyle: 'Normal',
        fontFamily: 'Segoe UI'
    };
    /** @private */
    Theme.legendLabelFont = {
        size: '13px',
        fontWeight: 'Normal',
        color: null,
        fontStyle: 'Normal',
        fontFamily: 'Segoe UI'
    };
    /** @private */
    Theme.stripLineLabelFont = {
        size: '12px',
        fontWeight: 'Regular',
        color: '#353535',
        fontStyle: 'Normal',
        fontFamily: 'Segoe UI'
    };
    /** @private */
    Theme.stockEventFont = {
        size: '13px',
        fontWeight: 'Normal',
        color: null,
        fontStyle: 'Normal',
        fontFamily: 'Segoe UI'
    };
})(Theme || (Theme = {}));

var __decorate$3 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Allows to configure the animation behavior for chart series such as animation duration and delay.
 */
class Animation extends ChildProperty {
}
__decorate$3([
    Property(true)
], Animation.prototype, "enable", void 0);
__decorate$3([
    Property(1000)
], Animation.prototype, "duration", void 0);
__decorate$3([
    Property(0)
], Animation.prototype, "delay", void 0);
/**
 * Allows to customize specific region for line type series with a variety of means such as value, color, pattern of dashes.
 */
class ChartSegment extends ChildProperty {
}
__decorate$3([
    Property(null)
], ChartSegment.prototype, "value", void 0);
__decorate$3([
    Property(null)
], ChartSegment.prototype, "color", void 0);
__decorate$3([
    Property('0')
], ChartSegment.prototype, "dashArray", void 0);
/**
 * Allows to customize the appearance of the text in the chart such as font style, font size, font weight, font color, font family, text alignment, opacity, text overflow.
 */
class Font extends ChildProperty {
}
__decorate$3([
    Property('Normal')
], Font.prototype, "fontStyle", void 0);
__decorate$3([
    Property('16px')
], Font.prototype, "size", void 0);
__decorate$3([
    Property('Normal')
], Font.prototype, "fontWeight", void 0);
__decorate$3([
    Property('')
], Font.prototype, "color", void 0);
__decorate$3([
    Property('Center')
], Font.prototype, "textAlignment", void 0);
__decorate$3([
    Property('Segoe UI')
], Font.prototype, "fontFamily", void 0);
__decorate$3([
    Property(1)
], Font.prototype, "opacity", void 0);
__decorate$3([
    Property('Trim')
], Font.prototype, "textOverflow", void 0);
/**
 * Allow options to customize the left, right, top and bottom margins of the pivot chart.
 */
class Margin extends ChildProperty {
}
__decorate$3([
    Property(10)
], Margin.prototype, "left", void 0);
__decorate$3([
    Property(10)
], Margin.prototype, "right", void 0);
__decorate$3([
    Property(10)
], Margin.prototype, "top", void 0);
__decorate$3([
    Property(10)
], Margin.prototype, "bottom", void 0);
/**
 * Allow options to customize the border of the chart such as color and border size in the pivot chart.
 * For example, to display the chart border color as red, set the properties `color` to either **"red"**
 * or **"#FF0000"** or **"rgba(255,0,0,1.0)"** and `width` to **0.5**.
 */
class Border extends ChildProperty {
}
__decorate$3([
    Property('')
], Border.prototype, "color", void 0);
__decorate$3([
    Property(1)
], Border.prototype, "width", void 0);
/**
 * Allows to configure the position of the marker such as top and left in the chart.
 */
class Offset extends ChildProperty {
}
__decorate$3([
    Property(0)
], Offset.prototype, "x", void 0);
__decorate$3([
    Property(0)
], Offset.prototype, "y", void 0);
/**
 * Allows you to highlight a specific point of the series while rendering the pivot chart.
 * For example, to highlight first point in the first series, set the properties series to 0 and points to 1. To use this option, it requires the property `selectionMode` to be **Point** or **Series**.
 *
 * @public
 */
class Indexes extends ChildProperty {
}
__decorate$3([
    Property(0)
], Indexes.prototype, "series", void 0);
__decorate$3([
    Property(0)
], Indexes.prototype, "point", void 0);
/**
 * Allow options to customize the chart area with a variety of settings such as background color, border, opacity and background image in the pivot chart.
 * For example, to change the of the pivot chart's background, set the property `opacity` to **0.5**.
 */
class ChartArea extends ChildProperty {
}
__decorate$3([
    Complex({}, Border)
], ChartArea.prototype, "border", void 0);
__decorate$3([
    Property('transparent')
], ChartArea.prototype, "background", void 0);
__decorate$3([
    Property(1)
], ChartArea.prototype, "opacity", void 0);
__decorate$3([
    Property(null)
], ChartArea.prototype, "backgroundImage", void 0);
/**
 * Allow options to customize the crosshair line with different settings such as color and width of the line,
 * line types that are shown horizontally and vertically to indicate the value of the axis at the mouse hover or touch position in the pivot chart.
 */
class CrosshairSettings extends ChildProperty {
}
__decorate$3([
    Property(false)
], CrosshairSettings.prototype, "enable", void 0);
__decorate$3([
    Property('')
], CrosshairSettings.prototype, "dashArray", void 0);
__decorate$3([
    Complex({ color: null, width: 1 }, Border)
], CrosshairSettings.prototype, "line", void 0);
__decorate$3([
    Property('Both')
], CrosshairSettings.prototype, "lineType", void 0);
/**
 * Allows to configure the data label with different settings such as name, fill color, opacity, rotation angle, border, margins, etc in the chart.
 */
class DataLabelSettings extends ChildProperty {
}
__decorate$3([
    Property(false)
], DataLabelSettings.prototype, "visible", void 0);
__decorate$3([
    Property(null)
], DataLabelSettings.prototype, "name", void 0);
__decorate$3([
    Property('transparent')
], DataLabelSettings.prototype, "fill", void 0);
__decorate$3([
    Property(1)
], DataLabelSettings.prototype, "opacity", void 0);
__decorate$3([
    Property(0)
], DataLabelSettings.prototype, "angle", void 0);
__decorate$3([
    Property(false)
], DataLabelSettings.prototype, "enableRotation", void 0);
__decorate$3([
    Property('Auto')
], DataLabelSettings.prototype, "position", void 0);
__decorate$3([
    Property(5)
], DataLabelSettings.prototype, "rx", void 0);
__decorate$3([
    Property(5)
], DataLabelSettings.prototype, "ry", void 0);
__decorate$3([
    Property('Center')
], DataLabelSettings.prototype, "alignment", void 0);
__decorate$3([
    Complex({ width: null, color: null }, Border)
], DataLabelSettings.prototype, "border", void 0);
__decorate$3([
    Complex({ left: 5, right: 5, top: 5, bottom: 5 }, Margin)
], DataLabelSettings.prototype, "margin", void 0);
__decorate$3([
    Complex({ size: '11px', color: '', fontStyle: 'Normal', fontWeight: 'Normal', fontFamily: 'Segoe UI' }, Font)
], DataLabelSettings.prototype, "font", void 0);
__decorate$3([
    Property(null)
], DataLabelSettings.prototype, "template", void 0);
/**
 * Allow options to customize the pie, funnel, doughnut and pyramid chart data label connector.
 */
class PivotChartConnectorStyle extends ChildProperty {
}
__decorate$3([
    Property('Line')
], PivotChartConnectorStyle.prototype, "type", void 0);
__decorate$3([
    Property(null)
], PivotChartConnectorStyle.prototype, "color", void 0);
__decorate$3([
    Property(1)
], PivotChartConnectorStyle.prototype, "width", void 0);
__decorate$3([
    Property(null)
], PivotChartConnectorStyle.prototype, "length", void 0);
__decorate$3([
    Property('')
], PivotChartConnectorStyle.prototype, "dashArray", void 0);
/**
 * Allow options to customize the pie, funnel, doughnut and pyramid chart data label connector.
 */
class PivotChartDataLabel extends ChildProperty {
}
__decorate$3([
    Property(true)
], PivotChartDataLabel.prototype, "visible", void 0);
__decorate$3([
    Complex({ width: null, color: null }, Border)
], PivotChartDataLabel.prototype, "border", void 0);
__decorate$3([
    Complex({ size: '11px', color: '', fontStyle: 'Normal', fontWeight: 'Normal', fontFamily: 'Segoe UI' }, Font)
], PivotChartDataLabel.prototype, "font", void 0);
__decorate$3([
    Property('transparent')
], PivotChartDataLabel.prototype, "fill", void 0);
__decorate$3([
    Property(0)
], PivotChartDataLabel.prototype, "angle", void 0);
__decorate$3([
    Property(false)
], PivotChartDataLabel.prototype, "enableRotation", void 0);
__decorate$3([
    Property('Outside')
], PivotChartDataLabel.prototype, "position", void 0);
__decorate$3([
    Property(5)
], PivotChartDataLabel.prototype, "rx", void 0);
__decorate$3([
    Property(5)
], PivotChartDataLabel.prototype, "ry", void 0);
__decorate$3([
    Property(null)
], PivotChartDataLabel.prototype, "template", void 0);
__decorate$3([
    Complex({}, PivotChartConnectorStyle)
], PivotChartDataLabel.prototype, "connectorStyle", void 0);
/**
 *  Allows to configure the marker of the series such as shape, width, height, border, position, fill color, opacity, data label etc in the chart
 */
class MarkerSettings extends ChildProperty {
}
__decorate$3([
    Property(false)
], MarkerSettings.prototype, "visible", void 0);
__decorate$3([
    Property('Circle')
], MarkerSettings.prototype, "shape", void 0);
__decorate$3([
    Property('')
], MarkerSettings.prototype, "imageUrl", void 0);
__decorate$3([
    Property(5)
], MarkerSettings.prototype, "width", void 0);
__decorate$3([
    Property(5)
], MarkerSettings.prototype, "height", void 0);
__decorate$3([
    Complex({ width: 2, color: null }, Border)
], MarkerSettings.prototype, "border", void 0);
__decorate$3([
    Complex({ x: 0, y: 0 }, Offset)
], MarkerSettings.prototype, "offset", void 0);
__decorate$3([
    Property(null)
], MarkerSettings.prototype, "fill", void 0);
__decorate$3([
    Property(1)
], MarkerSettings.prototype, "opacity", void 0);
__decorate$3([
    Complex({}, DataLabelSettings)
], MarkerSettings.prototype, "dataLabel", void 0);
/**
 * Allows to configure the error bar cap settings such as cap width, length, color, opacity.
 */
class ErrorBarCapSettings extends ChildProperty {
}
__decorate$3([
    Property(1)
], ErrorBarCapSettings.prototype, "width", void 0);
__decorate$3([
    Property(10)
], ErrorBarCapSettings.prototype, "length", void 0);
__decorate$3([
    Property(null)
], ErrorBarCapSettings.prototype, "color", void 0);
__decorate$3([
    Property(1)
], ErrorBarCapSettings.prototype, "opacity", void 0);
/**
 * Allows options for customize the error bar chart with different settings such as type, direction, mode, color, width, etc.
 *
 * @public
 */
class ErrorBarSettings extends ChildProperty {
}
__decorate$3([
    Property(false)
], ErrorBarSettings.prototype, "visible", void 0);
__decorate$3([
    Property('Fixed')
], ErrorBarSettings.prototype, "type", void 0);
__decorate$3([
    Property('Both')
], ErrorBarSettings.prototype, "direction", void 0);
__decorate$3([
    Property('Vertical')
], ErrorBarSettings.prototype, "mode", void 0);
__decorate$3([
    Property(1)
], ErrorBarSettings.prototype, "verticalError", void 0);
__decorate$3([
    Property(null)
], ErrorBarSettings.prototype, "color", void 0);
__decorate$3([
    Property(1)
], ErrorBarSettings.prototype, "width", void 0);
__decorate$3([
    Property(1)
], ErrorBarSettings.prototype, "horizontalError", void 0);
__decorate$3([
    Property(3)
], ErrorBarSettings.prototype, "verticalNegativeError", void 0);
__decorate$3([
    Property(3)
], ErrorBarSettings.prototype, "verticalPositiveError", void 0);
__decorate$3([
    Property(1)
], ErrorBarSettings.prototype, "horizontalNegativeError", void 0);
__decorate$3([
    Property(1)
], ErrorBarSettings.prototype, "horizontalPositiveError", void 0);
__decorate$3([
    Complex(null, ErrorBarCapSettings)
], ErrorBarSettings.prototype, "errorBarCap", void 0);
/**
 * Allows to configure the trendlines of the chart such as name, period, type, tooltip, marker, animation, color, legend shape, etc.
 */
class Trendline extends ChildProperty {
}
__decorate$3([
    Property('')
], Trendline.prototype, "name", void 0);
__decorate$3([
    Property('0')
], Trendline.prototype, "dashArray", void 0);
__decorate$3([
    Property(true)
], Trendline.prototype, "visible", void 0);
__decorate$3([
    Property(2)
], Trendline.prototype, "period", void 0);
__decorate$3([
    Property('Linear')
], Trendline.prototype, "type", void 0);
__decorate$3([
    Property(0)
], Trendline.prototype, "backwardForecast", void 0);
__decorate$3([
    Property(0)
], Trendline.prototype, "forwardForecast", void 0);
__decorate$3([
    Property(2)
], Trendline.prototype, "polynomialOrder", void 0);
__decorate$3([
    Complex({}, MarkerSettings)
], Trendline.prototype, "marker", void 0);
__decorate$3([
    Property(true)
], Trendline.prototype, "enableTooltip", void 0);
__decorate$3([
    Complex({}, Animation)
], Trendline.prototype, "animation", void 0);
__decorate$3([
    Property('')
], Trendline.prototype, "fill", void 0);
__decorate$3([
    Property(1)
], Trendline.prototype, "width", void 0);
__decorate$3([
    Property(null)
], Trendline.prototype, "intercept", void 0);
__decorate$3([
    Property('SeriesType')
], Trendline.prototype, "legendShape", void 0);
/**
 * Allows to configure the empty points with a variety of means such as fill color, border and mode in the chart.
 */
class EmptyPointSettings extends ChildProperty {
}
__decorate$3([
    Property(null)
], EmptyPointSettings.prototype, "fill", void 0);
__decorate$3([
    Complex({ color: 'transparent', width: 0 }, Border)
], EmptyPointSettings.prototype, "border", void 0);
__decorate$3([
    Property('Zero')
], EmptyPointSettings.prototype, "mode", void 0);
/**
 * Allows to customize the rounded corners of the column series in the chart.
 */
class CornerRadius extends ChildProperty {
}
__decorate$3([
    Property(0)
], CornerRadius.prototype, "topLeft", void 0);
__decorate$3([
    Property(0)
], CornerRadius.prototype, "topRight", void 0);
__decorate$3([
    Property(0)
], CornerRadius.prototype, "bottomLeft", void 0);
__decorate$3([
    Property(0)
], CornerRadius.prototype, "bottomRight", void 0);
/**
 * Allows to configure the crosshair tooltip with text style and fill color in the chart.
 */
class CrosshairTooltip extends ChildProperty {
}
__decorate$3([
    Property(false)
], CrosshairTooltip.prototype, "enable", void 0);
__decorate$3([
    Property(null)
], CrosshairTooltip.prototype, "fill", void 0);
__decorate$3([
    Complex(Theme.crosshairLabelFont, Font)
], CrosshairTooltip.prototype, "textStyle", void 0);
/**
 * Allows to configure the strip line properties such as line position, size, color, size type, border, text and opacity in the chart.
 */
class StripLineSettings extends ChildProperty {
}
__decorate$3([
    Property(true)
], StripLineSettings.prototype, "visible", void 0);
__decorate$3([
    Property(false)
], StripLineSettings.prototype, "startFromAxis", void 0);
__decorate$3([
    Property(null)
], StripLineSettings.prototype, "start", void 0);
__decorate$3([
    Property(null)
], StripLineSettings.prototype, "end", void 0);
__decorate$3([
    Property(null)
], StripLineSettings.prototype, "size", void 0);
__decorate$3([
    Property('#808080')
], StripLineSettings.prototype, "color", void 0);
__decorate$3([
    Property(null)
], StripLineSettings.prototype, "dashArray", void 0);
__decorate$3([
    Property('Auto')
], StripLineSettings.prototype, "sizeType", void 0);
__decorate$3([
    Property(false)
], StripLineSettings.prototype, "isRepeat", void 0);
__decorate$3([
    Property(null)
], StripLineSettings.prototype, "repeatEvery", void 0);
__decorate$3([
    Property(null)
], StripLineSettings.prototype, "repeatUntil", void 0);
__decorate$3([
    Property(false)
], StripLineSettings.prototype, "isSegmented", void 0);
__decorate$3([
    Property(null)
], StripLineSettings.prototype, "segmentStart", void 0);
__decorate$3([
    Property(null)
], StripLineSettings.prototype, "segmentEnd", void 0);
__decorate$3([
    Property(null)
], StripLineSettings.prototype, "segmentAxisName", void 0);
__decorate$3([
    Complex({ color: 'transparent', width: 1 }, Border)
], StripLineSettings.prototype, "border", void 0);
__decorate$3([
    Property('')
], StripLineSettings.prototype, "text", void 0);
__decorate$3([
    Property(null)
], StripLineSettings.prototype, "rotation", void 0);
__decorate$3([
    Property('Middle')
], StripLineSettings.prototype, "horizontalAlignment", void 0);
__decorate$3([
    Property('Middle')
], StripLineSettings.prototype, "verticalAlignment", void 0);
__decorate$3([
    Complex(Theme.stripLineLabelFont, Font)
], StripLineSettings.prototype, "textStyle", void 0);
__decorate$3([
    Property('Behind')
], StripLineSettings.prototype, "zIndex", void 0);
__decorate$3([
    Property(1)
], StripLineSettings.prototype, "opacity", void 0);
/**
 * Allows to customize the label border with a variety of means such as label color, width and label type in the chart.
 */
class LabelBorder extends ChildProperty {
}
__decorate$3([
    Property('')
], LabelBorder.prototype, "color", void 0);
__decorate$3([
    Property(1)
], LabelBorder.prototype, "width", void 0);
__decorate$3([
    Property('Rectangle')
], LabelBorder.prototype, "type", void 0);
/**
 * Allows to configure the major grid lines such as line width, color and dashArray in the `axis`.
 */
class MajorGridLines extends ChildProperty {
}
__decorate$3([
    Property(1)
], MajorGridLines.prototype, "width", void 0);
__decorate$3([
    Property('')
], MajorGridLines.prototype, "dashArray", void 0);
__decorate$3([
    Property(null)
], MajorGridLines.prototype, "color", void 0);
/**
 * Allows to configure the minor grid lines such as line width, dashArray and color in the `axis`.
 */
class MinorGridLines extends ChildProperty {
}
__decorate$3([
    Property(0.7)
], MinorGridLines.prototype, "width", void 0);
__decorate$3([
    Property('')
], MinorGridLines.prototype, "dashArray", void 0);
__decorate$3([
    Property(null)
], MinorGridLines.prototype, "color", void 0);
/**
 * Allows to configure the axis line such as line width, dashArray and color in a chart.
 */
class AxisLine extends ChildProperty {
}
__decorate$3([
    Property(1)
], AxisLine.prototype, "width", void 0);
__decorate$3([
    Property('')
], AxisLine.prototype, "dashArray", void 0);
__decorate$3([
    Property(null)
], AxisLine.prototype, "color", void 0);
/**
 * Allows to configure the major tick lines such as width, height and color in the chart.
 */
class MajorTickLines extends ChildProperty {
}
__decorate$3([
    Property(1)
], MajorTickLines.prototype, "width", void 0);
__decorate$3([
    Property(5)
], MajorTickLines.prototype, "height", void 0);
__decorate$3([
    Property(null)
], MajorTickLines.prototype, "color", void 0);
/**
 * Allows to configure the minor tick lines such as width, height and color in the chart.
 */
class MinorTickLines extends ChildProperty {
}
__decorate$3([
    Property(0.7)
], MinorTickLines.prototype, "width", void 0);
__decorate$3([
    Property(5)
], MinorTickLines.prototype, "height", void 0);
__decorate$3([
    Property(null)
], MinorTickLines.prototype, "color", void 0);
/**
 * Allows to configure the position of the legend such as top and left in the chart.
 */
class ChartLocation extends ChildProperty {
}
__decorate$3([
    Property(0)
], ChartLocation.prototype, "x", void 0);
__decorate$3([
    Property(0)
], ChartLocation.prototype, "y", void 0);
/**
 * Allow options to customize the border of the chart series such as color and border size in the pivot chart.
 * For example, to display the chart series border color as red, set the properties `color` to either **"red"** or **"#FF0000"** or **"rgba(255,0,0,1.0)"** and `width` to **0.5**.
 */
class PivotChartSeriesBorder {
}
__decorate$3([
    Property('')
], PivotChartSeriesBorder.prototype, "color", void 0);
__decorate$3([
    Property(1)
], PivotChartSeriesBorder.prototype, "width", void 0);
/**
 * Allows to configure the animation behavior for chart series such as animation duration and delay.
 */
class PivotChartSeriesAnimation {
}
__decorate$3([
    Property(true)
], PivotChartSeriesAnimation.prototype, "enable", void 0);
__decorate$3([
    Property(1000)
], PivotChartSeriesAnimation.prototype, "duration", void 0);
__decorate$3([
    Property(0)
], PivotChartSeriesAnimation.prototype, "delay", void 0);
/**
 * Allows to customize specific region for line type series with a variety of means such as value, color, pattern of dashes.
 */
class PivotChartSeriesSegment {
}
__decorate$3([
    Property(null)
], PivotChartSeriesSegment.prototype, "value", void 0);
__decorate$3([
    Property(null)
], PivotChartSeriesSegment.prototype, "color", void 0);
__decorate$3([
    Property('0')
], PivotChartSeriesSegment.prototype, "dashArray", void 0);
/**
 *  Allows to configure the marker of the series such as shape, width, height, border, position, fill color, opacity, data label etc in the chart
 */
class PivotChartSeriesMarkerSettings {
}
__decorate$3([
    Property(false)
], PivotChartSeriesMarkerSettings.prototype, "visible", void 0);
__decorate$3([
    Property('Circle')
], PivotChartSeriesMarkerSettings.prototype, "shape", void 0);
__decorate$3([
    Property('')
], PivotChartSeriesMarkerSettings.prototype, "imageUrl", void 0);
__decorate$3([
    Property(5)
], PivotChartSeriesMarkerSettings.prototype, "height", void 0);
__decorate$3([
    Property(5)
], PivotChartSeriesMarkerSettings.prototype, "width", void 0);
__decorate$3([
    Complex({ width: 2, color: null }, Border)
], PivotChartSeriesMarkerSettings.prototype, "border", void 0);
__decorate$3([
    Property(null)
], PivotChartSeriesMarkerSettings.prototype, "fill", void 0);
__decorate$3([
    Property(1)
], PivotChartSeriesMarkerSettings.prototype, "opacity", void 0);
__decorate$3([
    Complex({}, DataLabelSettings)
], PivotChartSeriesMarkerSettings.prototype, "dataLabel", void 0);
/**
 * Allows options for customize the error bar chart series with different settings such as type, direction, mode, color, width, etc.
 */
class PivotChartSeriesErrorSettings {
}
__decorate$3([
    Property(false)
], PivotChartSeriesErrorSettings.prototype, "visible", void 0);
__decorate$3([
    Property('Fixed')
], PivotChartSeriesErrorSettings.prototype, "type", void 0);
__decorate$3([
    Property('Both')
], PivotChartSeriesErrorSettings.prototype, "direction", void 0);
__decorate$3([
    Property('Vertical')
], PivotChartSeriesErrorSettings.prototype, "mode", void 0);
__decorate$3([
    Property(null)
], PivotChartSeriesErrorSettings.prototype, "color", void 0);
__decorate$3([
    Property(1)
], PivotChartSeriesErrorSettings.prototype, "verticalError", void 0);
__decorate$3([
    Property(1)
], PivotChartSeriesErrorSettings.prototype, "width", void 0);
__decorate$3([
    Property(1)
], PivotChartSeriesErrorSettings.prototype, "horizontalError", void 0);
__decorate$3([
    Property(3)
], PivotChartSeriesErrorSettings.prototype, "verticalPositiveError", void 0);
__decorate$3([
    Property(3)
], PivotChartSeriesErrorSettings.prototype, "verticalNegativeError", void 0);
__decorate$3([
    Property(1)
], PivotChartSeriesErrorSettings.prototype, "horizontalPositiveError", void 0);
__decorate$3([
    Property(1)
], PivotChartSeriesErrorSettings.prototype, "horizontalNegativeError", void 0);
__decorate$3([
    Complex(null, ErrorBarCapSettings)
], PivotChartSeriesErrorSettings.prototype, "errorBarCap", void 0);
/**
 * Allows to configure the trendlines of the chart series such as name, period, type, tooltip, marker, animation, color, legend shape, etc.
 */
class PivotChartSeriesTrendline {
}
__decorate$3([
    Property('')
], PivotChartSeriesTrendline.prototype, "name", void 0);
__decorate$3([
    Property('Linear')
], PivotChartSeriesTrendline.prototype, "type", void 0);
__decorate$3([
    Property(2)
], PivotChartSeriesTrendline.prototype, "period", void 0);
__decorate$3([
    Property(2)
], PivotChartSeriesTrendline.prototype, "polynomialOrder", void 0);
__decorate$3([
    Property(0)
], PivotChartSeriesTrendline.prototype, "backwardForecast", void 0);
__decorate$3([
    Property(0)
], PivotChartSeriesTrendline.prototype, "forwardForecast", void 0);
__decorate$3([
    Complex({}, Animation)
], PivotChartSeriesTrendline.prototype, "animation", void 0);
__decorate$3([
    Complex({}, MarkerSettings)
], PivotChartSeriesTrendline.prototype, "marker", void 0);
__decorate$3([
    Property(true)
], PivotChartSeriesTrendline.prototype, "enableTooltip", void 0);
__decorate$3([
    Property(null)
], PivotChartSeriesTrendline.prototype, "intercept", void 0);
__decorate$3([
    Property('')
], PivotChartSeriesTrendline.prototype, "fill", void 0);
__decorate$3([
    Property(1)
], PivotChartSeriesTrendline.prototype, "width", void 0);
__decorate$3([
    Property('SeriesType')
], PivotChartSeriesTrendline.prototype, "legendShape", void 0);
/**
 * Allows to configure the empty points with a variety of means such as fill color, border and mode in the chart.
 */
class PivotChartSeriesEmptyPointSettings {
}
__decorate$3([
    Property(null)
], PivotChartSeriesEmptyPointSettings.prototype, "fill", void 0);
__decorate$3([
    Complex({ color: 'transparent', width: 0 }, Border)
], PivotChartSeriesEmptyPointSettings.prototype, "border", void 0);
__decorate$3([
    Property('Zero')
], PivotChartSeriesEmptyPointSettings.prototype, "mode", void 0);
/**
 * Allows to customize the rounded corners of the column series in the chart.
 */
class PivotChartSeriesCornerRadius {
}
__decorate$3([
    Property(0)
], PivotChartSeriesCornerRadius.prototype, "topLeft", void 0);
__decorate$3([
    Property(0)
], PivotChartSeriesCornerRadius.prototype, "topRight", void 0);
__decorate$3([
    Property(0)
], PivotChartSeriesCornerRadius.prototype, "bottomLeft", void 0);
__decorate$3([
    Property(0)
], PivotChartSeriesCornerRadius.prototype, "bottomRight", void 0);
/**
 * Allows to customize the appearance of the text in the chart such as font style, font size, font weight, font color, font family, text alignment, opacity, text overflow.
 */
class PivotChartAxisFont {
}
__decorate$3([
    Property('Normal')
], PivotChartAxisFont.prototype, "fontStyle", void 0);
__decorate$3([
    Property('16px')
], PivotChartAxisFont.prototype, "size", void 0);
__decorate$3([
    Property('Normal')
], PivotChartAxisFont.prototype, "fontWeight", void 0);
__decorate$3([
    Property('')
], PivotChartAxisFont.prototype, "color", void 0);
__decorate$3([
    Property('Center')
], PivotChartAxisFont.prototype, "textAlignment", void 0);
__decorate$3([
    Property('Segoe UI')
], PivotChartAxisFont.prototype, "fontFamily", void 0);
__decorate$3([
    Property(1)
], PivotChartAxisFont.prototype, "opacity", void 0);
__decorate$3([
    Property('Trim')
], PivotChartAxisFont.prototype, "textOverflow", void 0);
/**
 * Allows to configure the crosshair tooltip with text style and fill color in the chart.
 */
class PivotChartAxisCrosshairTooltip {
}
__decorate$3([
    Property(false)
], PivotChartAxisCrosshairTooltip.prototype, "enable", void 0);
__decorate$3([
    Property(null)
], PivotChartAxisCrosshairTooltip.prototype, "fill", void 0);
__decorate$3([
    Complex(Theme.crosshairLabelFont, Font)
], PivotChartAxisCrosshairTooltip.prototype, "textStyle", void 0);
/**
 * Allows to configure the major tick lines such as width, height and color in the chart.
 */
class PivotChartAxisMajorTickLines {
}
__decorate$3([
    Property(1)
], PivotChartAxisMajorTickLines.prototype, "width", void 0);
__decorate$3([
    Property(5)
], PivotChartAxisMajorTickLines.prototype, "height", void 0);
__decorate$3([
    Property(null)
], PivotChartAxisMajorTickLines.prototype, "color", void 0);
/**
 * Allows to configure the major grid lines such as line width, color and dashArray in the `axis`.
 */
class PivotChartAxisMajorGridLines {
}
__decorate$3([
    Property(1)
], PivotChartAxisMajorGridLines.prototype, "width", void 0);
__decorate$3([
    Property('')
], PivotChartAxisMajorGridLines.prototype, "dashArray", void 0);
__decorate$3([
    Property(null)
], PivotChartAxisMajorGridLines.prototype, "color", void 0);
/**
 * Allows to configure the minor tick lines such as width, height and color in the chart.
 */
class PivotChartAxisMinorTickLines {
}
__decorate$3([
    Property(0.7)
], PivotChartAxisMinorTickLines.prototype, "width", void 0);
__decorate$3([
    Property(5)
], PivotChartAxisMinorTickLines.prototype, "height", void 0);
__decorate$3([
    Property(null)
], PivotChartAxisMinorTickLines.prototype, "color", void 0);
/**
 * Allows to configure the minor grid lines such as line width, dashArray and color in the `axis`.
 */
class PivotChartAxisMinorGridLines {
}
__decorate$3([
    Property(0.7)
], PivotChartAxisMinorGridLines.prototype, "width", void 0);
__decorate$3([
    Property('')
], PivotChartAxisMinorGridLines.prototype, "dashArray", void 0);
__decorate$3([
    Property(null)
], PivotChartAxisMinorGridLines.prototype, "color", void 0);
/**
 * Allows to configure the axis line such as line width, dashArray and color in a chart.
 */
class PivotChartAxisAxisLine {
}
__decorate$3([
    Property(1)
], PivotChartAxisAxisLine.prototype, "width", void 0);
__decorate$3([
    Property('')
], PivotChartAxisAxisLine.prototype, "dashArray", void 0);
__decorate$3([
    Property(null)
], PivotChartAxisAxisLine.prototype, "color", void 0);
/**
 * Allows to configure the strip line properties such as line position, size, color, size type, border, text and opacity in the chart.
 */
class PivotChartAxisStripLineSettings {
}
__decorate$3([
    Property(true)
], PivotChartAxisStripLineSettings.prototype, "visible", void 0);
__decorate$3([
    Property(false)
], PivotChartAxisStripLineSettings.prototype, "startFromAxis", void 0);
__decorate$3([
    Property(null)
], PivotChartAxisStripLineSettings.prototype, "start", void 0);
__decorate$3([
    Property(null)
], PivotChartAxisStripLineSettings.prototype, "end", void 0);
__decorate$3([
    Property(null)
], PivotChartAxisStripLineSettings.prototype, "size", void 0);
__decorate$3([
    Property('#808080')
], PivotChartAxisStripLineSettings.prototype, "color", void 0);
__decorate$3([
    Property(null)
], PivotChartAxisStripLineSettings.prototype, "dashArray", void 0);
__decorate$3([
    Property('Auto')
], PivotChartAxisStripLineSettings.prototype, "sizeType", void 0);
__decorate$3([
    Property(false)
], PivotChartAxisStripLineSettings.prototype, "isRepeat", void 0);
__decorate$3([
    Property(null)
], PivotChartAxisStripLineSettings.prototype, "repeatEvery", void 0);
__decorate$3([
    Property(null)
], PivotChartAxisStripLineSettings.prototype, "repeatUntil", void 0);
__decorate$3([
    Property(false)
], PivotChartAxisStripLineSettings.prototype, "isSegmented", void 0);
__decorate$3([
    Property(null)
], PivotChartAxisStripLineSettings.prototype, "segmentStart", void 0);
__decorate$3([
    Property(null)
], PivotChartAxisStripLineSettings.prototype, "segmentEnd", void 0);
__decorate$3([
    Property(null)
], PivotChartAxisStripLineSettings.prototype, "segmentAxisName", void 0);
__decorate$3([
    Complex({ color: 'transparent', width: 1 }, Border)
], PivotChartAxisStripLineSettings.prototype, "border", void 0);
__decorate$3([
    Property('')
], PivotChartAxisStripLineSettings.prototype, "text", void 0);
__decorate$3([
    Property(null)
], PivotChartAxisStripLineSettings.prototype, "rotation", void 0);
__decorate$3([
    Property('Middle')
], PivotChartAxisStripLineSettings.prototype, "horizontalAlignment", void 0);
__decorate$3([
    Property('Middle')
], PivotChartAxisStripLineSettings.prototype, "verticalAlignment", void 0);
__decorate$3([
    Complex(Theme.stripLineLabelFont, Font)
], PivotChartAxisStripLineSettings.prototype, "textStyle", void 0);
__decorate$3([
    Property('Behind')
], PivotChartAxisStripLineSettings.prototype, "zIndex", void 0);
__decorate$3([
    Property(1)
], PivotChartAxisStripLineSettings.prototype, "opacity", void 0);
/**
 * Allows to customize the label border with a variety of means such as label color, width and label type in the chart.
 */
class PivotChartAxisLabelBorder {
}
__decorate$3([
    Property('')
], PivotChartAxisLabelBorder.prototype, "color", void 0);
__decorate$3([
    Property(1)
], PivotChartAxisLabelBorder.prototype, "width", void 0);
__decorate$3([
    Property('Rectangle')
], PivotChartAxisLabelBorder.prototype, "type", void 0);
/**
 * Allow options to customize the chart area with a variety of settings such as background color, border, opacity and background image in the pivot chart.
 * For example, to change the of the pivot chart's background, set the property `opacity` to **0.5**.
 */
class PivotChartSettingsChartArea {
}
__decorate$3([
    Complex({}, Border)
], PivotChartSettingsChartArea.prototype, "border", void 0);
__decorate$3([
    Property('transparent')
], PivotChartSettingsChartArea.prototype, "background", void 0);
__decorate$3([
    Property(1)
], PivotChartSettingsChartArea.prototype, "opacity", void 0);
/**
 * Allow options to customize the crosshair line with different settings such as color and width of the line,
 * line types that are shown horizontally and vertically to indicate the value of the axis at the mouse hover or touch position in the pivot chart.
 */
class PivotChartSettingsCrosshairSettings {
}
__decorate$3([
    Property(false)
], PivotChartSettingsCrosshairSettings.prototype, "enable", void 0);
__decorate$3([
    Property('')
], PivotChartSettingsCrosshairSettings.prototype, "dashArray", void 0);
__decorate$3([
    Complex({ color: null, width: 1 }, Border)
], PivotChartSettingsCrosshairSettings.prototype, "line", void 0);
__decorate$3([
    Property('Both')
], PivotChartSettingsCrosshairSettings.prototype, "lineType", void 0);
/**
 * Allow options for customizing legends with different properties such as legend visibility,
 * height, width, position, legend padding, alignment, textStyle, border, margin, background, opacity, description, tabIndex in the pivot chart.
 */
class PivotChartSettingsLegendSettings {
}
__decorate$3([
    Property(true)
], PivotChartSettingsLegendSettings.prototype, "visible", void 0);
__decorate$3([
    Property(null)
], PivotChartSettingsLegendSettings.prototype, "height", void 0);
__decorate$3([
    Property(null)
], PivotChartSettingsLegendSettings.prototype, "width", void 0);
__decorate$3([
    Complex({ x: 0, y: 0 }, ChartLocation)
], PivotChartSettingsLegendSettings.prototype, "location", void 0);
__decorate$3([
    Property('Auto')
], PivotChartSettingsLegendSettings.prototype, "position", void 0);
__decorate$3([
    Property(8)
], PivotChartSettingsLegendSettings.prototype, "padding", void 0);
__decorate$3([
    Property('Center')
], PivotChartSettingsLegendSettings.prototype, "alignment", void 0);
__decorate$3([
    Complex(Theme.legendLabelFont, Font)
], PivotChartSettingsLegendSettings.prototype, "textStyle", void 0);
__decorate$3([
    Property(10)
], PivotChartSettingsLegendSettings.prototype, "shapeHeight", void 0);
__decorate$3([
    Property(10)
], PivotChartSettingsLegendSettings.prototype, "shapeWidth", void 0);
__decorate$3([
    Complex({}, Border)
], PivotChartSettingsLegendSettings.prototype, "border", void 0);
__decorate$3([
    Complex({ left: 0, right: 0, top: 0, bottom: 0 }, Margin)
], PivotChartSettingsLegendSettings.prototype, "margin", void 0);
__decorate$3([
    Property(5)
], PivotChartSettingsLegendSettings.prototype, "shapePadding", void 0);
__decorate$3([
    Property('transparent')
], PivotChartSettingsLegendSettings.prototype, "background", void 0);
__decorate$3([
    Property(1)
], PivotChartSettingsLegendSettings.prototype, "opacity", void 0);
__decorate$3([
    Property(true)
], PivotChartSettingsLegendSettings.prototype, "toggleVisibility", void 0);
__decorate$3([
    Property(null)
], PivotChartSettingsLegendSettings.prototype, "description", void 0);
__decorate$3([
    Property(3)
], PivotChartSettingsLegendSettings.prototype, "tabIndex", void 0);
/**
 * Allows you to highlight a specific point of the series while rendering the pivot chart.
 * For example, to highlight first point in the first series, set the properties series to 0 and points to 1. To use this option, it requires the property `selectionMode` to be **Point** or **Series**.
 */
class PivotChartSettingsIndexes {
}
__decorate$3([
    Property(0)
], PivotChartSettingsIndexes.prototype, "series", void 0);
__decorate$3([
    Property(0)
], PivotChartSettingsIndexes.prototype, "point", void 0);
/**
 * Allow options to customize the left, right, top and bottom margins of the pivot chart.
 */
class PivotChartSettingsMargin {
}
__decorate$3([
    Property(10)
], PivotChartSettingsMargin.prototype, "left", void 0);
__decorate$3([
    Property(10)
], PivotChartSettingsMargin.prototype, "right", void 0);
__decorate$3([
    Property(10)
], PivotChartSettingsMargin.prototype, "top", void 0);
__decorate$3([
    Property(10)
], PivotChartSettingsMargin.prototype, "bottom", void 0);
/**
 * Allow options to customize the chart series with different settings such as fill color, animation of the series,
 * series width, border, visibility of the series, opacity, chart series types, marker, tooltip, trendlines, etc., in the pivot chart.
 * For example, to display the line type pivot chart, set the property `type` to **Line**.
 */
class PivotSeries extends ChildProperty {
}
__decorate$3([
    Property(null)
], PivotSeries.prototype, "fill", void 0);
__decorate$3([
    Property(null)
], PivotSeries.prototype, "endAngle", void 0);
__decorate$3([
    Property(false)
], PivotSeries.prototype, "explode", void 0);
__decorate$3([
    Property(false)
], PivotSeries.prototype, "explodeAll", void 0);
__decorate$3([
    Property(null)
], PivotSeries.prototype, "explodeIndex", void 0);
__decorate$3([
    Property(null)
], PivotSeries.prototype, "innerRadius", void 0);
__decorate$3([
    Property('30%')
], PivotSeries.prototype, "explodeOffset", void 0);
__decorate$3([
    Property(0)
], PivotSeries.prototype, "gapRatio", void 0);
__decorate$3([
    Property('Value')
], PivotSeries.prototype, "groupMode", void 0);
__decorate$3([
    Property(null)
], PivotSeries.prototype, "groupTo", void 0);
__decorate$3([
    Property('20%')
], PivotSeries.prototype, "neckHeight", void 0);
__decorate$3([
    Property('20%')
], PivotSeries.prototype, "neckWidth", void 0);
__decorate$3([
    Property('Linear')
], PivotSeries.prototype, "pyramidMode", void 0);
__decorate$3([
    Property([])
], PivotSeries.prototype, "palettes", void 0);
__decorate$3([
    Property(0)
], PivotSeries.prototype, "startAngle", void 0);
__decorate$3([
    Complex(null, Animation)
], PivotSeries.prototype, "animation", void 0);
__decorate$3([
    Complex(null, PivotChartDataLabel)
], PivotSeries.prototype, "dataLabel", void 0);
__decorate$3([
    Property('0')
], PivotSeries.prototype, "dashArray", void 0);
__decorate$3([
    Property(1)
], PivotSeries.prototype, "width", void 0);
__decorate$3([
    Property('X')
], PivotSeries.prototype, "segmentAxis", void 0);
__decorate$3([
    Property('Line')
], PivotSeries.prototype, "drawType", void 0);
__decorate$3([
    Property(true)
], PivotSeries.prototype, "isClosed", void 0);
__decorate$3([
    Collection([], ChartSegment)
], PivotSeries.prototype, "segments", void 0);
__decorate$3([
    Property('')
], PivotSeries.prototype, "stackingGroup", void 0);
__decorate$3([
    Complex({ color: 'transparent', width: 0 }, Border)
], PivotSeries.prototype, "border", void 0);
__decorate$3([
    Property(true)
], PivotSeries.prototype, "visible", void 0);
__decorate$3([
    Property(1)
], PivotSeries.prototype, "opacity", void 0);
__decorate$3([
    Property('Line')
], PivotSeries.prototype, "type", void 0);
__decorate$3([
    Complex(null, MarkerSettings)
], PivotSeries.prototype, "marker", void 0);
__decorate$3([
    Complex(null, ErrorBarSettings)
], PivotSeries.prototype, "errorBar", void 0);
__decorate$3([
    Property(true)
], PivotSeries.prototype, "enableTooltip", void 0);
__decorate$3([
    Collection([], Trendline)
], PivotSeries.prototype, "trendlines", void 0);
__decorate$3([
    Property('')
], PivotSeries.prototype, "tooltipMappingName", void 0);
__decorate$3([
    Property('SeriesType')
], PivotSeries.prototype, "legendShape", void 0);
__decorate$3([
    Property(1)
], PivotSeries.prototype, "minRadius", void 0);
__decorate$3([
    Property(null)
], PivotSeries.prototype, "selectionStyle", void 0);
__decorate$3([
    Property('Natural')
], PivotSeries.prototype, "splineType", void 0);
__decorate$3([
    Property(3)
], PivotSeries.prototype, "maxRadius", void 0);
__decorate$3([
    Property(0.5)
], PivotSeries.prototype, "cardinalSplineTension", void 0);
__decorate$3([
    Property(null)
], PivotSeries.prototype, "columnWidth", void 0);
__decorate$3([
    Complex(null, EmptyPointSettings)
], PivotSeries.prototype, "emptyPointSettings", void 0);
__decorate$3([
    Complex(null, CornerRadius)
], PivotSeries.prototype, "cornerRadius", void 0);
__decorate$3([
    Property(0)
], PivotSeries.prototype, "columnSpacing", void 0);
/**
 * Allow options to customize the axis with different properties such as labelIntersectAction, labelStyle, title,
 * description, crosshairTooltip, labelFormat, titleStyle, plotOffset, edgeLabelPlacement, labelPlacement, tickPosition, opposedPosition, minor and
 * major grid lines, minor and major tick lines, border, etc. in the pivot chart.
 */
class PivotAxis extends ChildProperty {
}
__decorate$3([
    Property('Rotate45')
], PivotAxis.prototype, "labelIntersectAction", void 0);
__decorate$3([
    Complex(Theme.axisLabelFont, Font)
], PivotAxis.prototype, "labelStyle", void 0);
__decorate$3([
    Property('')
], PivotAxis.prototype, "title", void 0);
__decorate$3([
    Property(null)
], PivotAxis.prototype, "zoomFactor", void 0);
__decorate$3([
    Complex({}, CrosshairTooltip)
], PivotAxis.prototype, "crosshairTooltip", void 0);
__decorate$3([
    Property('')
], PivotAxis.prototype, "labelFormat", void 0);
__decorate$3([
    Complex(Theme.axisTitleFont, Font)
], PivotAxis.prototype, "titleStyle", void 0);
__decorate$3([
    Property(false)
], PivotAxis.prototype, "isIndexed", void 0);
__decorate$3([
    Property(0)
], PivotAxis.prototype, "plotOffset", void 0);
__decorate$3([
    Property('Shift')
], PivotAxis.prototype, "edgeLabelPlacement", void 0);
__decorate$3([
    Property('BetweenTicks')
], PivotAxis.prototype, "labelPlacement", void 0);
__decorate$3([
    Property('Outside')
], PivotAxis.prototype, "tickPosition", void 0);
__decorate$3([
    Property(false)
], PivotAxis.prototype, "opposedPosition", void 0);
__decorate$3([
    Property(true)
], PivotAxis.prototype, "visible", void 0);
__decorate$3([
    Property('Outside')
], PivotAxis.prototype, "labelPosition", void 0);
__decorate$3([
    Property(0)
], PivotAxis.prototype, "labelRotation", void 0);
__decorate$3([
    Property(0)
], PivotAxis.prototype, "minorTicksPerInterval", void 0);
__decorate$3([
    Property(null)
], PivotAxis.prototype, "maximum", void 0);
__decorate$3([
    Property(null)
], PivotAxis.prototype, "minimum", void 0);
__decorate$3([
    Property(34)
], PivotAxis.prototype, "maximumLabelWidth", void 0);
__decorate$3([
    Property(null)
], PivotAxis.prototype, "interval", void 0);
__decorate$3([
    Complex({}, MajorTickLines)
], PivotAxis.prototype, "majorTickLines", void 0);
__decorate$3([
    Property(false)
], PivotAxis.prototype, "enableTrim", void 0);
__decorate$3([
    Complex({}, MajorGridLines)
], PivotAxis.prototype, "majorGridLines", void 0);
__decorate$3([
    Complex({}, MinorTickLines)
], PivotAxis.prototype, "minorTickLines", void 0);
__decorate$3([
    Complex({}, AxisLine)
], PivotAxis.prototype, "lineStyle", void 0);
__decorate$3([
    Complex({}, MinorGridLines)
], PivotAxis.prototype, "minorGridLines", void 0);
__decorate$3([
    Property(false)
], PivotAxis.prototype, "isInversed", void 0);
__decorate$3([
    Property(null)
], PivotAxis.prototype, "description", void 0);
__decorate$3([
    Property(0)
], PivotAxis.prototype, "startAngle", void 0);
__decorate$3([
    Property(100)
], PivotAxis.prototype, "coefficient", void 0);
__decorate$3([
    Collection([], StripLineSettings)
], PivotAxis.prototype, "stripLines", void 0);
__decorate$3([
    Property(2)
], PivotAxis.prototype, "tabIndex", void 0);
__decorate$3([
    Complex({ color: null, width: 0, type: 'Rectangle' }, LabelBorder)
], PivotAxis.prototype, "border", void 0);
/**
 * Allow options to customize the tooltip of the pivot chart with different properties such as visibility of the tooltip, enableMarker, fill color, opacity, header for tooltip,
 * format, textStyle, template, border, enableAnimation.
 */
class PivotTooltipSettings extends ChildProperty {
}
__decorate$3([
    Property(false)
], PivotTooltipSettings.prototype, "enableMarker", void 0);
__decorate$3([
    Property(true)
], PivotTooltipSettings.prototype, "enable", void 0);
__decorate$3([
    Property(null)
], PivotTooltipSettings.prototype, "fill", void 0);
__decorate$3([
    Property(false)
], PivotTooltipSettings.prototype, "shared", void 0);
__decorate$3([
    Property(0.75)
], PivotTooltipSettings.prototype, "opacity", void 0);
__decorate$3([
    Property(null)
], PivotTooltipSettings.prototype, "header", void 0);
__decorate$3([
    Property(null)
], PivotTooltipSettings.prototype, "format", void 0);
__decorate$3([
    Complex(Theme.tooltipLabelFont, Font)
], PivotTooltipSettings.prototype, "textStyle", void 0);
__decorate$3([
    Property(null)
], PivotTooltipSettings.prototype, "template", void 0);
__decorate$3([
    Complex({ color: '#cccccc', width: 0.5 }, Border)
], PivotTooltipSettings.prototype, "border", void 0);
__decorate$3([
    Property(true)
], PivotTooltipSettings.prototype, "enableAnimation", void 0);
/**
 * Allow options to customize the center of the pivot pie series chart.
 */
class PivotPieChartCenter extends ChildProperty {
}
__decorate$3([
    Property('50%')
], PivotPieChartCenter.prototype, "x", void 0);
__decorate$3([
    Property('50%')
], PivotPieChartCenter.prototype, "y", void 0);
/**
 * Allow options to customize the pivot chart zooming with different properties such as enablePinchZooming, enableSelectionZooming,
 * enableDeferredZooming, enableMouseWheelZooming, zoom modes, toolbarItems, enableScrollbar and enablePan.
 */
class PivotZoomSettings extends ChildProperty {
}
__decorate$3([
    Property(false)
], PivotZoomSettings.prototype, "enablePinchZooming", void 0);
__decorate$3([
    Property(true)
], PivotZoomSettings.prototype, "enableSelectionZooming", void 0);
__decorate$3([
    Property(false)
], PivotZoomSettings.prototype, "enableDeferredZooming", void 0);
__decorate$3([
    Property(false)
], PivotZoomSettings.prototype, "enableMouseWheelZooming", void 0);
__decorate$3([
    Property('XY')
], PivotZoomSettings.prototype, "mode", void 0);
__decorate$3([
    Property(['Zoom', 'ZoomIn', 'ZoomOut', 'Pan', 'Reset'])
], PivotZoomSettings.prototype, "toolbarItems", void 0);
__decorate$3([
    Property(true)
], PivotZoomSettings.prototype, "enableScrollbar", void 0);
__decorate$3([
    Property(false)
], PivotZoomSettings.prototype, "enablePan", void 0);
/**
 * Allows a set of options to customize a pivot chart with a variety of settings, such as chart series, chart area, axis labels, legends, border, crosshairs, theme, title, tooltip, zooming, etc.
 * The following options are available to customize the pivot chart.
 * * `background`: Allows you to change the background color of the chart series in the pivot chart.
 * For example, to display the chart series with background color as red, set the property `background` to either **"red"** or **"#FF0000"** or **"rgba(255,0,0,1.0)"**.
 * * `border`: Allow options to customize the border of the chart series such as color and border size in the pivot chart.
 * For example, to display the chart series border color as red, set the properties `color` to either **"red"** or **"#FF0000"** or **"rgba(255,0,0,1.0)"** and `width` to **0.5**.
 * * `chartArea`: Allow options to customize the chart area with a variety of settings such as background color, border, opacity and background image in the pivot chart.
 * For example, to change the of the pivot chart's background, set the property `opacity` to **0.5**.
 * * `chartSeries`: Allow options to customize the chart series with different settings such as fill color, animation of the series,
 * series width, border, visibility of the series, opacity, chart series types, marker, tooltip, trendlines, etc., in the pivot chart.
 * For example, to display the line type pivot chart, set the property `type` to **Line**.
 * * `crosshair`: Allow options to customize the crosshair line with different settings such as color and width of the line,
 * line types that are shown horizontally and vertically to indicate the value of the axis at the mouse hover or touch position in the pivot chart.
 * * `description`: Allows you to add a description of the pivot chart.
 * * `enableAnimation`: Allows you to enable/disable the tooltip animation while performing the mouse move from one point to another in the pivot chart.
 * * `enableCanvas`: Allows you to render the pivot chart in canvas mode.
 * * `enableExport`: Allows the pivot chart to be exported to either **PDF** or **PNG** or **JPEG** or **SVG** filter formats.
 * * `enableMultipleAxis`: Allows you to draw the pivot chart with multiple value fields as separate chart area.
 * * `enableSideBySidePlacement`: Allows you to draw points of the column type pivot chart series as side by side.
 * * `isMultiSelect`: Allows you to perform multiple selection in the pivot chart. To enable this option, it requires the property `selectionMode` to be **Point** or **Series** or **Cluster**.
 * * `isTransposed`: Allows you to render the pivot chart in a transposed manner or not.
 * * `legendSettings`: Allow options for customizing legends with different properties such as legend visibility,
 * height, width, position, legend padding, alignment, textStyle, border, margin, background, opacity, description, tabIndex in the pivot chart.
 * * `margin`: Allow options to customize the left, right, top and bottom margins of the pivot chart.
 * * `palettes`: Allows you to draw the chart series points with custom color in the pivot chart.
 * * `primaryXAxis`: Allow options to customize the horizontal(row) axis with different properties such as labelIntersectAction, labelStyle, title,
 * description, crosshairTooltip, labelFormat, titleStyle, plotOffset, edgeLabelPlacement, labelPlacement, tickPosition, opposedPosition, minor and
 * major grid lines, minor and major tick lines, border, etc. in the pivot chart.
 * * `primaryYAxis`: Allow options to customize the vertical(value) axis with different properties such as labelIntersectAction, labelStyle,
 * title, description, crosshairTooltip, labelFormat, titleStyle, plotOffset, edgeLabelPlacement, labelPlacement, tickPosition, opposedPosition, minor and
 * major grid lines, minor and major tick lines, border, etc. in the pivot chart.
 * * `selectedDataIndexes`: Allows you to highlight a specific point of the series while rendering the pivot chart.
 * For example, to highlight first point in the first series, set the properties series to 0 and points to 1. To use this option, it requires the property `selectionMode` to be **Point** or **Series**.
 * * `selectionMode`: Allow options for customizing the selection mode to be done either by a specific series or point or cluster or by dragging it to the pivot chart.
 * For example, to highlight a specific point in a specific series of the pivot chart, set the property `selectionMode` to **Point**.
 * * `showMultiLevelLabels`: Allows you to display the multi-level label feature in the pivot chart. This multi-level labels used to perform drill operation in the pivot chart.
 * * `subTitle`: Allows you to add the subtitle to the pivot chart.
 * * `subTitleStyle`: Allow options to customize the subtitle in the pivot chart with different properties such as fontStyle, font size, fontWeight, font color, testAlignment, fontFamily, opacity, textOverflow.
 * * `tabIndex`: Allows you to highlight specific legends by clicking the mouse or by interacting with the keyboard in the pivot chart.
 * * `theme`: Allows you to draw a pivot chart with either material, fabric, bootstrap, highcontrast light, material dark, fabric dark, highcontrast, bootstrap dark, bootstrap4 theme.
 * * `title`: Allows you to add title to the pivot chart.
 * * `titleStyle`: Allow options to customize the title in the pivot chart with different properties such as fontStyle, font size, fontWeight, font color, testAlignment, fontFamily, opacity, textOverflow.
 * * `tooltip`: Allow options to customize the tooltip of the pivot chart with different properties such as visibility of the tooltip, enableMarker, fill color, opacity, header for tooltip,
 * format, textStyle, template, border, enableAnimation.
 * * `useGroupingSeparator`: Allows the group separator to be shown to the values in the pivot chart.
 * * `value`: Allows you to draw a pivot chart with a specific value field during initial loading.
 * * `zoomSettings`: Allow options to customize the pivot chart zooming with different properties such as enablePinchZooming, enableSelectionZooming,
 * enableDeferredZooming, enableMouseWheelZooming, zoom modes, toolbarItems, enableScrollbar and enablePan.
 */
class ChartSettings extends ChildProperty {
}
__decorate$3([
    Complex({}, PivotSeries)
], ChartSettings.prototype, "chartSeries", void 0);
__decorate$3([
    Complex({}, PivotAxis)
], ChartSettings.prototype, "primaryXAxis", void 0);
__decorate$3([
    Complex({}, PivotAxis)
], ChartSettings.prototype, "primaryYAxis", void 0);
__decorate$3([
    Property('')
], ChartSettings.prototype, "value", void 0);
__decorate$3([
    Property('')
], ChartSettings.prototype, "columnHeader", void 0);
__decorate$3([
    Property('-')
], ChartSettings.prototype, "columnDelimiter", void 0);
__decorate$3([
    Property(false)
], ChartSettings.prototype, "enableMultipleAxis", void 0);
__decorate$3([
    Property('Stacked')
], ChartSettings.prototype, "multipleAxisMode", void 0);
__decorate$3([
    Property(false)
], ChartSettings.prototype, "enableScrollOnMultiAxis", void 0);
__decorate$3([
    Property(false)
], ChartSettings.prototype, "showMemberSeries", void 0);
__decorate$3([
    Property(false)
], ChartSettings.prototype, "showPointColorByMembers", void 0);
__decorate$3([
    Complex(Theme.chartTitleFont, Font)
], ChartSettings.prototype, "titleStyle", void 0);
__decorate$3([
    Property('')
], ChartSettings.prototype, "title", void 0);
__decorate$3([
    Complex(Theme.chartSubTitleFont, Font)
], ChartSettings.prototype, "subTitleStyle", void 0);
__decorate$3([
    Property('')
], ChartSettings.prototype, "subTitle", void 0);
__decorate$3([
    Complex({ color: '#DDDDDD', width: 0 }, Border)
], ChartSettings.prototype, "border", void 0);
__decorate$3([
    Complex({}, Margin)
], ChartSettings.prototype, "margin", void 0);
__decorate$3([
    Complex({ border: { color: null, width: 0.5 }, background: 'transparent' }, ChartArea)
], ChartSettings.prototype, "chartArea", void 0);
__decorate$3([
    Property(null)
], ChartSettings.prototype, "background", void 0);
__decorate$3([
    Property('Material')
], ChartSettings.prototype, "theme", void 0);
__decorate$3([
    Property([])
], ChartSettings.prototype, "palettes", void 0);
__decorate$3([
    Complex({}, CrosshairSettings)
], ChartSettings.prototype, "crosshair", void 0);
__decorate$3([
    Complex({}, PivotTooltipSettings)
], ChartSettings.prototype, "tooltip", void 0);
__decorate$3([
    Complex(null, PivotPieChartCenter)
], ChartSettings.prototype, "pieCenter", void 0);
__decorate$3([
    Complex({}, PivotZoomSettings)
], ChartSettings.prototype, "zoomSettings", void 0);
__decorate$3([
    Property()
], ChartSettings.prototype, "legendSettings", void 0);
__decorate$3([
    Property('None')
], ChartSettings.prototype, "selectionMode", void 0);
__decorate$3([
    Property('None')
], ChartSettings.prototype, "accumulationSelectionMode", void 0);
__decorate$3([
    Property(true)
], ChartSettings.prototype, "enableSmartLabels", void 0);
__decorate$3([
    Property(true)
], ChartSettings.prototype, "enableBorderOnMouseMove", void 0);
__decorate$3([
    Property('None')
], ChartSettings.prototype, "highlightMode", void 0);
__decorate$3([
    Property('None')
], ChartSettings.prototype, "highlightPattern", void 0);
__decorate$3([
    Property(true)
], ChartSettings.prototype, "enableExport", void 0);
__decorate$3([
    Property(false)
], ChartSettings.prototype, "isMultiSelect", void 0);
__decorate$3([
    Collection([], Indexes)
], ChartSettings.prototype, "selectedDataIndexes", void 0);
__decorate$3([
    Property(true)
], ChartSettings.prototype, "enableAnimation", void 0);
__decorate$3([
    Property(false)
], ChartSettings.prototype, "enableCanvas", void 0);
__decorate$3([
    Property(true)
], ChartSettings.prototype, "useGroupingSeparator", void 0);
__decorate$3([
    Property(false)
], ChartSettings.prototype, "isTransposed", void 0);
__decorate$3([
    Property(1)
], ChartSettings.prototype, "tabIndex", void 0);
__decorate$3([
    Property(null)
], ChartSettings.prototype, "description", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "resized", void 0);
__decorate$3([
    Property(true)
], ChartSettings.prototype, "enableSideBySidePlacement", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "loaded", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "beforePrint", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "animationComplete", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "load", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "textRender", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "legendRender", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "seriesRender", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "multiLevelLabelRender", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "pointRender", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "tooltipRender", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "legendClick", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "axisLabelRender", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "multiLevelLabelClick", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "chartMouseClick", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "chartMouseMove", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "pointMove", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "pointClick", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "chartMouseDown", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "chartMouseLeave", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "dragComplete", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "chartMouseUp", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "scrollStart", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "zoomComplete", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "scrollChanged", void 0);
__decorate$3([
    Event()
], ChartSettings.prototype, "scrollEnd", void 0);
__decorate$3([
    Property(true)
], ChartSettings.prototype, "showMultiLevelLabels", void 0);

/**
 * This is a file to create MDX query for the provided OLAP datasource
 *
 * @hidden
 */
/** @hidden */
class MDXQuery {
    /* eslint-disable @typescript-eslint/no-explicit-any */
    static getCellSets(dataSourceSettings, olapEngine, refPaging, drillInfo, isQueryUpdate) {
        this.engine = olapEngine;
        this.isMondrian = olapEngine.isMondrian;
        this.isMeasureAvail = olapEngine.isMeasureAvail;
        this.isPaging = olapEngine.isPaging;
        this.pageSettings = olapEngine.pageSettings;
        this.rows = olapEngine.rows;
        this.columns = olapEngine.columns;
        this.values = olapEngine.values;
        this.filters = olapEngine.filters;
        this.allowLabelFilter = olapEngine.allowLabelFilter;
        this.allowValueFilter = olapEngine.allowValueFilter;
        this.valueSortSettings = dataSourceSettings.valueSortSettings ? dataSourceSettings.valueSortSettings : undefined;
        this.drilledMembers = olapEngine.updateDrilledItems(dataSourceSettings.drilledMembers);
        this.calculatedFieldSettings = olapEngine.calculatedFieldSettings;
        this.valueAxis = dataSourceSettings.valueAxis === 'row' ? 'rows' : 'columns';
        if (drillInfo) {
            drillInfo.axis = drillInfo.axis === 'row' ? 'rows' : 'columns';
        }
        this.filterMembers = extend({}, olapEngine.filterMembers, null, true);
        this.fieldDataObj = olapEngine.fieldListObj;
        this.fieldList = olapEngine.fieldList;
        this.cellSetInfo = '\nDIMENSION PROPERTIES PARENT_UNIQUE_NAME, HIERARCHY_UNIQUE_NAME, CHILDREN_CARDINALITY, MEMBER_TYPE, MEMBER_VALUE';
        const measureQuery = this.getMeasuresQuery(this.values);
        let rowQuery = this.getDimensionsQuery(this.rows, measureQuery, 'rows', drillInfo).replace(/\&/g, '&amp;'); /* eslint-disable-line */
        let columnQuery = this.getDimensionsQuery(this.columns, measureQuery, 'columns', drillInfo).replace(/\&/g, '&amp;'); /* eslint-disable-line */
        if (this.isPaging && refPaging && this.pageSettings !== undefined) {
            const pagingQuery = this.getPagingQuery(rowQuery, columnQuery);
            rowQuery = pagingQuery.rowQuery;
            columnQuery = pagingQuery.columnQuery;
        }
        else if (this.isPaging && !refPaging && this.pageSettings !== undefined) {
            const pagingQuery = this.getPagingCountQuery(rowQuery, columnQuery);
            rowQuery = pagingQuery.rowQuery;
            columnQuery = pagingQuery.columnQuery;
        }
        rowQuery = (rowQuery.length > 0 ? rowQuery + (this.isPaging && !refPaging ? '' : this.cellSetInfo + ' ON ROWS') : '');
        columnQuery = (columnQuery.length > 0 ? columnQuery + (this.isPaging && !refPaging ? '' : this.cellSetInfo + ' ON COLUMNS') : '');
        const slicerQuery = this.getSlicersQuery(this.filters, 'filters').replace(/\&/g, '&amp;'); /* eslint-disable-line */
        const filterQuery = this.getfilterQuery(this.filterMembers, dataSourceSettings.cube).replace(/\&/g, '&amp;').replace(/\>/g, '&gt;').replace(/\</g, '&lt;'); /* eslint-disable-line */
        const caclQuery = this.getCalculatedFieldQuery(this.calculatedFieldSettings).replace(/\&/g, '&amp;'); /* eslint-disable-line */
        const query = this.frameMDXQuery(rowQuery, columnQuery, slicerQuery, filterQuery, caclQuery, refPaging);
        const args = {
            catalog: dataSourceSettings.catalog,
            cube: dataSourceSettings.cube,
            url: dataSourceSettings.url,
            request: query,
            LCID: dataSourceSettings.localeIdentifier.toString(),
            roles: dataSourceSettings.roles
        };
        olapEngine.mdxQuery = query.replace(/\&amp;/g, '&').replace(/\&gt;/g, '>').replace(/\&lt;/g, '<').replace(/%280/g, '\"'); /* eslint-disable-line */
        // console.log(olapEngine.mdxQuery);
        if (drillInfo) {
            drillInfo.axis = drillInfo.axis === 'rows' ? 'row' : 'column';
        }
        if (!isQueryUpdate) {
            this.getTableCellData(args, (this.isPaging && !refPaging ? this.engine.generatePagingData.bind(this.engine) :
                this.engine.generateEngine.bind(this.engine)), drillInfo ? { action: drillInfo.action, drillInfo: drillInfo } : {
                dataSourceSettings: dataSourceSettings, action: 'loadTableElements'
            });
        }
    }
    static getTableCellData(args, successMethod, customArgs) {
        const connectionString = this.engine.getConnectionInfo(args.url, args.LCID);
        const soapMessage = '<Envelope xmlns="http://schemas.xmlsoap.org/soap/envelope/"> <Header></Header> <Body> <Execute xmlns="urn:schemas-microsoft-com:xml-analysis"> <Command> <Statement>' +
            args.request + '</Statement> </Command> <Properties> <PropertyList> <Catalog>' +
            args.catalog + '</Catalog> <LocaleIdentifier>' + connectionString.LCID +
            '</LocaleIdentifier>' + (args.roles ? '<Roles>' + args.roles + '</Roles>' : '') + '</PropertyList> </Properties></Execute> </Body> </Envelope>';
        this.engine.doAjaxPost('POST', connectionString.url, soapMessage, successMethod, customArgs);
    }
    static frameMDXQuery(rowQuery, columnQuery, slicerQuery, filterQuery, caclQuery, refPaging) {
        let query = ((this.isPaging && !refPaging) ? caclQuery !== '' ? '' : '\nWITH' : '\nSelect ');
        if (columnQuery.length > 0) {
            query = query + columnQuery;
        }
        if (rowQuery.length > 0) {
            query = query + (columnQuery.length > 0 ? this.isPaging && !refPaging ? '' : ', ' : '') + rowQuery;
        }
        query = caclQuery + query + (this.isPaging && !refPaging ? '\nMEMBER [Measures].[3d268ce0-664d-4092-b9cb-fece97175006] AS Count([e16a30d0-2174-4874-8dae-a5085a75a3e2]) ' +
            'MEMBER [Measures].[8d7fe8c1-f09f-410e-b9ba-eaab75a1fc3e] AS Count ([d1876d2b-e50e-4547-85fe-5b8ed9d629de])' +
            '\nSELECT { [Measures].[3d268ce0-664d-4092-b9cb-fece97175006] , [Measures].[8d7fe8c1-f09f-410e-b9ba-eaab75a1fc3e] } ON AXIS(0)' : '') +
            filterQuery + slicerQuery + '\nCELL PROPERTIES VALUE, FORMAT_STRING, FORMATTED_VALUE\n';
        return query;
    }
    static getPagingQuery(rowQuery, columnQuery) {
        // let colCurrentPage: number = (Math.ceil(this.engine.columnCount / this.pageSettings.columnPageSize) < this.pageSettings.currentColumnPage || this.pageSettings.currentColumnPage === 0) ? ((Math.ceil(this.engine.columnCount / this.pageSettings.columnPageSize) < this.pageSettings.currentColumnPage && this.engine.columnCount > 0) ? Math.ceil(this.engine.columnCount / this.pageSettings.columnPageSize) : this.pageSettings.currentColumnPage) : this.pageSettings.currentColumnPage;
        // let rowCurrentPage: number = (Math.ceil(this.engine.rowCount / this.pageSettings.rowPageSize) < this.pageSettings.currentRowPage || this.pageSettings.currentRowPage === 0) ? ((Math.ceil(this.engine.rowCount / this.pageSettings.rowPageSize) < this.pageSettings.currentRowPage && this.engine.rowCount > 0) ? Math.ceil(this.engine.rowCount / this.pageSettings.rowPageSize) : this.pageSettings.rowPageSize) : this.pageSettings.currentRowPage;
        rowQuery = rowQuery.replace('NON EMPTY ( ', '').slice(0, -1);
        columnQuery = columnQuery.replace('NON EMPTY ( ', '').slice(0, -1);
        const rowQueryCpy = rowQuery;
        // let axisQuery: pagingQuery = {
        //     rowQuery: rowQuery !== '' ? ('\nSUBSET ({ ' + (this.isMondrian ? '' : 'NONEMPTY') + ' (' + rowQuery + (!this.isMondrian && columnQuery !== '' ? ',' + columnQuery : '') + ')},' + (((rowCurrentPage === 0 ? 1 : rowCurrentPage) - 1) * (this.pageSettings.rowPageSize)) + ',' + this.pageSettings.rowPageSize + ')') : '',
        //     columnQuery: columnQuery !== '' ? ('\nSUBSET ({ ' + (this.isMondrian ? '' : 'NONEMPTY') + ' (' + columnQuery + (!this.isMondrian && rowQueryCpy !== '' ? ',' + rowQueryCpy : '') + ')},' + (((colCurrentPage === 0 ? 1 : colCurrentPage) - 1) * (this.pageSettings.columnPageSize)) + ',' + this.pageSettings.columnPageSize + ')') : ''
        // }
        let calRowPage = (this.pageSettings.currentRowPage - 1) * this.pageSettings.rowPageSize;
        let calColPage = (this.pageSettings.currentColumnPage - 1) * this.pageSettings.columnPageSize;
        const calRowSize = this.pageSettings.rowPageSize * 3;
        const calColumnSize = this.pageSettings.columnPageSize * 3;
        calRowPage = (this.engine.rowCount < (calRowPage + calRowSize)) ?
            (this.engine.rowCount > calRowSize ? (this.engine.rowCount - calRowSize) : 0) : calRowPage;
        this.engine.pageRowStartPos = calRowPage;
        calColPage = (this.engine.columnCount < (calColPage + calColumnSize)) ?
            (this.engine.columnCount > calColumnSize ? (this.engine.columnCount - calColumnSize) : 0) : calColPage;
        this.engine.pageColStartPos = calColPage;
        const axisQuery = {
            rowQuery: rowQuery !== '' ? ('\nSUBSET ({ ' + (this.isMondrian ? '' : 'NONEMPTY') + ' (' + rowQuery + (!this.isMondrian && columnQuery !== '' ? ',' + columnQuery : '') + ')},' + (calRowPage) + ',' + calRowSize + ')') : '',
            columnQuery: columnQuery !== '' ? ('\nSUBSET ({ ' + (this.isMondrian ? '' : 'NONEMPTY') + ' (' + columnQuery + (!this.isMondrian && rowQueryCpy !== '' ? ',' + rowQueryCpy : '') + ')},' + (calColPage) + ',' + calColumnSize + ')') : ''
        };
        return axisQuery;
    }
    static getPagingCountQuery(rowQuery, columnQuery) {
        rowQuery = rowQuery.replace('NON EMPTY ( ', '').slice(0, -1);
        columnQuery = columnQuery.replace('NON EMPTY ( ', '').slice(0, -1);
        const rowQueryCpy = rowQuery;
        const axisQuery = {
            rowQuery: rowQuery !== '' ? ('\SET [d1876d2b-e50e-4547-85fe-5b8ed9d629de] as ' + (this.isMondrian ? '' : 'NONEMPTY') + ' (' + rowQuery + (!this.isMondrian && columnQuery !== '' ? ',' + columnQuery : '') + ')\n') : '',
            columnQuery: columnQuery !== '' ? ('\nSET [e16a30d0-2174-4874-8dae-a5085a75a3e2] as ' + (this.isMondrian ? '' : 'NONEMPTY') + ' (' + columnQuery + (!this.isMondrian && rowQueryCpy !== '' ? ',' + rowQueryCpy : '') + ')\n') : ''
        };
        return axisQuery;
    }
    static getDimensionsQuery(dimensions, measureQuery, axis, drillInfo) {
        let query = '';
        if (dimensions.length > 0) {
            query = '\nNON EMPTY ( ' + (this.drilledMembers.length > 0 ? 'HIERARCHIZE ({' : '');
            let i = 0;
            while (i < dimensions.length) {
                let hierarchy = '';
                if (i === 0) {
                    if (dimensions[i].name.toLowerCase() === '[measures]') {
                        if (measureQuery !== '') {
                            query = query + measureQuery;
                        }
                    }
                    else {
                        hierarchy = '({' + this.getDimensionQuery(dimensions[i], axis) + '})';
                        query = query + hierarchy;
                    }
                }
                else {
                    if (dimensions[i].name.toLowerCase() === '[measures]') {
                        if (measureQuery !== '') {
                            query = query + ' * ' + measureQuery;
                        }
                    }
                    else {
                        hierarchy = '({' + this.getDimensionQuery(dimensions[i], axis) + '})';
                        query = query + ' * ' + hierarchy;
                    }
                }
                i++;
            }
            const drillQueryObj = this.getDrillQuery(dimensions, measureQuery, axis, drillInfo);
            query = (drillInfo && drillInfo.axis === axis ? '\nNON EMPTY ( ' + (this.drilledMembers.length > 0 ? 'HIERARCHIZE ({' : '') + drillQueryObj.query : query + (drillQueryObj.query !== '' ? ',' : '') + drillQueryObj.query);
            const drillQuery = this.getAttributeDrillQuery(dimensions, measureQuery, axis, drillInfo);
            query = (this.valueAxis !== axis ? this.updateValueSortQuery(query, this.valueSortSettings) : query) +
                (this.isPaging ? ((drillQuery !== '' ? '-' : '') + drillQuery) : '') + (this.drilledMembers.length > 0 ? '})' : '') + (!this.isPaging ? ((drillQuery !== '' ? '-' : '') + drillQuery) : '') + ')';
        }
        return query;
    }
    static getAttributeDrillQuery(dimensions, measureQuery, axis, drillInfo) {
        let query = '';
        let drilledMembers = [];
        if (drillInfo && drillInfo.axis === axis && drillInfo.action.toLowerCase() === 'down') {
            drilledMembers = [{ name: drillInfo.fieldName, items: [drillInfo.memberName], delimiter: '~~' }];
        }
        else {
            drilledMembers = this.drilledMembers;
        }
        const measurePos = axis === this.valueAxis ? this.getMeasurePos(axis) : 0;
        for (const field of drilledMembers) {
            const isHierarchy = this.engine.fieldList[field.name] ? this.engine.fieldList[field.name].isHierarchy : false;
            if (isHierarchy) {
                for (const item of field.items) {
                    const drillQuery = [];
                    const drillInfo = item.split(field.delimiter ? field.delimiter : '~~');
                    const result = this.getDrillLevel(dimensions, drillInfo);
                    const fieldPosition = this.getDimensionPos(axis, field.name);
                    let index = dimensions.length - (measurePos > fieldPosition ? 1 : 0);
                    const isExist = this.isPaging ? this.isAttributeMemberExist(field.name, item.split(field.delimiter ? field.delimiter : '~~'), field.delimiter, drillInfo, axis) : false;
                    while (result.level > 0 && result.isDrill && (fieldPosition + 1) !== measurePos && !isExist) {
                        let levelQuery = [];
                        let i = 0;
                        while (i < dimensions.length) {
                            if (dimensions[i].name.toLowerCase() === '[measures]') {
                                if (measureQuery !== '') {
                                    levelQuery.push(drillInfo[i] ? '({{' + drillInfo[i] + '}})' : '(' + measureQuery + ')');
                                }
                            }
                            else if (drillInfo[i] && (drillInfo[i].indexOf(dimensions[i].name) !== -1 ||
                                (dimensions[i].isNamedSet && this.fieldList[dimensions[i].name] && drillInfo[i].indexOf(this.fieldList[dimensions[i].name].pid.split('Sets_')[1]) !== -1))) {
                                levelQuery.push(this.getHierarchyQuery(drillInfo[i], false, false, false, result.level, true));
                            }
                            else if (!drillInfo[i] && dimensions[i]) {
                                levelQuery.push(this.getHierarchyQuery(dimensions[i].name, ((this.isPaging && result.level === 2)
                                    || (!this.isPaging && index > i) ? true : false), dimensions[i].isNamedSet, dimensions[i].isCalculatedField, result.level, false));
                            }
                            else {
                                levelQuery = [];
                                break;
                            }
                            i++;
                        }
                        if (levelQuery.length > 0) {
                            drillQuery.push('(' + levelQuery.join('*') + ')');
                        }
                        result.level--;
                        index--;
                    }
                    if (drillQuery.length > 0) {
                        query = query + (query !== '' ? '-' : '') + drillQuery.join(this.isPaging ? '+' : '-');
                    }
                }
            }
        }
        return query;
    }
    static getDimensionPos(axis, field) {
        let position = 0;
        const dimensions = axis === 'rows' ? this.rows : this.columns;
        for (let i = 0; i < dimensions.length; i++) {
            if (dimensions[i].name === field) {
                position = i;
                break;
            }
        }
        return position;
    }
    static getMeasurePos(axis) {
        let position = 0;
        const dimensions = axis === 'rows' ? this.rows : this.columns;
        for (let i = 0; i < dimensions.length; i++) {
            if (dimensions[i].name.indexOf('[Measures]') === 0) {
                position = i;
                break;
            }
        }
        return position;
    }
    static getDrillLevel(dimensions, drillInfo) {
        let level = dimensions.length;
        let isDrill = false;
        let i = 0;
        while (i < dimensions.length) {
            if (drillInfo[i] && drillInfo[i].indexOf(dimensions[i].name) !== -1) {
                level -= 1;
                if (dimensions[i + 1] && !(dimensions[i + 1].isNamedSet || dimensions[i + 1].name.indexOf('[Measures]') === 0 || (this.fieldList[dimensions[i + 1].name] && !this.fieldList[dimensions[i + 1].name].hasAllMember))) {
                    isDrill = true;
                }
            }
            else if (dimensions[i].isNamedSet || dimensions[i].name.indexOf('[Measures]') === 0 || (this.fieldList[dimensions[i].name] && !this.fieldList[dimensions[i].name].hasAllMember)) {
                level -= 1;
            }
            i++;
        }
        return { level: this.isPaging ? 2 : level, isDrill: isDrill };
    }
    static getHierarchyQuery(name, isChildren, isNamedSet, isCalculatedField, level, isDrill) {
        name = isCalculatedField ? this.fieldList[name].tag : name;
        return ((this.fieldList[name] && !this.fieldList[name].hasAllMember && !isNamedSet && !isCalculatedField) ? '((' + name + ').levels(0).AllMembers)' : (isNamedSet || isCalculatedField) ? ('({' + name + '})') : this.isPaging ? ('({' + name) + (isChildren ? '.CHILDREN})' : (!isDrill && level === 1) ? '.[All]})' : '})') : ('({DrilldownLevel({' + name + (isChildren ? '.CHILDREN' : '') + '},,,INCLUDE_CALC_MEMBERS' + ')})'));
    }
    static isAttributeMemberExist(hierarchy, item, delimiter, drillInfo, axis) {
        item.splice(drillInfo.length - 1, 1);
        let isAvailable = false;
        if (item.join(delimiter) !== '' && !(this.isPaging && item.length === 1 && item.join(delimiter) === '[Measures]') && this.engine.fieldList[hierarchy] && this.engine.fieldList[hierarchy].hasAllMember) {
            const hierarchyPosition = this.getDimensionPos(axis, hierarchy);
            for (let i = 0; i < this.drilledMembers.length; i++) {
                if (hierarchy !== this.drilledMembers[i].name) {
                    const isHierarchy = this.engine.fieldList[this.drilledMembers[i].name] ?
                        this.engine.fieldList[this.drilledMembers[i].name].isHierarchy : false;
                    if (isHierarchy) {
                        const fieldPosition = this.getDimensionPos(axis, this.drilledMembers[i].name);
                        for (let j = 0; j < this.drilledMembers[i].items.length; j++) {
                            const result = this.getDrillLevel(axis === 'rows' ? this.rows : this.columns, this.drilledMembers[i].items[j].split(this.drilledMembers[i].delimiter ? this.drilledMembers[i].delimiter : '~~'));
                            if ((this.isPaging ? (fieldPosition < hierarchyPosition && result.isDrill) : true) &&
                                (this.drilledMembers[i].items[j].indexOf(item.join(delimiter)) === 0 ||
                                    item.join(delimiter).indexOf(this.drilledMembers[i].items[j]) === 0)) {
                                isAvailable = true;
                                break;
                            }
                        }
                    }
                }
            }
        }
        return isAvailable;
    }
    static getDrillQuery(dimensions, measureQuery, axis, drillInfo) {
        let query = '';
        const rawDrillQuery = [];
        let drilledMembers = [];
        let isOnDemandDrill = false;
        let onDemandDrillQuery = '';
        if (drillInfo && drillInfo.axis === axis && drillInfo.action.toLowerCase() === 'down') {
            isOnDemandDrill = true;
            drilledMembers = [{ name: drillInfo.fieldName, items: [drillInfo.memberName], delimiter: '~~' }];
        }
        else {
            drilledMembers = this.drilledMembers;
        }
        for (const field of drilledMembers) {
            const isHierarchy = this.engine.fieldList[field.name] ? this.engine.fieldList[field.name].isHierarchy : false;
            if (!isHierarchy) {
                for (const item of field.items) {
                    let drillQuery = [];
                    let rawQuery = [];
                    let i = 0;
                    const drillInfo = item.split(field.delimiter ? field.delimiter : '~~');
                    const isExist = this.isAttributeMemberExist(field.name, item.split(field.delimiter ? field.delimiter : '~~'), (field.delimiter ? field.delimiter : '~~'), drillInfo, axis);
                    while (i < dimensions.length && !isExist) {
                        if (drillInfo[i] && drillInfo[i].indexOf(dimensions[i].name) !== -1) {
                            if (drillInfo[drillInfo.length - 1].indexOf(dimensions[i].name) !== -1) {
                                if (isOnDemandDrill) {
                                    onDemandDrillQuery = onDemandDrillQuery + (onDemandDrillQuery !== '' ? ' * ' : '') + '({' + drillInfo[i] + '.CHILDREN})';
                                }
                                else {
                                    drillQuery.push('(' + drillInfo[i] + '.CHILDREN)');
                                    rawQuery.push('(' + drillInfo[i] + ')');
                                }
                            }
                            else {
                                if (drillInfo[i].toLowerCase() === '[measures]' && measureQuery !== '') {
                                    if (isOnDemandDrill) {
                                        onDemandDrillQuery = onDemandDrillQuery + (onDemandDrillQuery !== '' ? ' * ' : '') + '(' + measureQuery + ')';
                                    }
                                    else {
                                        drillQuery.push('(' + measureQuery + ')');
                                        rawQuery.push('(' + measureQuery + ')');
                                    }
                                }
                                else if (drillInfo[i].toLowerCase().indexOf('[measures]') !== -1) {
                                    if (isOnDemandDrill) {
                                        onDemandDrillQuery = onDemandDrillQuery + (onDemandDrillQuery !== '' ? ' * ' : '') + '({' + drillInfo[i] + '})';
                                    }
                                    else {
                                        drillQuery.push('({' + drillInfo[i] + '})');
                                        rawQuery.push('({' + drillInfo[i] + '})');
                                    }
                                }
                                else {
                                    if (isOnDemandDrill) {
                                        onDemandDrillQuery = onDemandDrillQuery + (onDemandDrillQuery !== '' ? ' * ' : '') + '({' + drillInfo[i] + '})';
                                    }
                                    else {
                                        drillQuery.push('(' + drillInfo[i] + ')');
                                        rawQuery.push('(' + drillInfo[i] + ')');
                                    }
                                }
                            }
                        }
                        else if (!drillInfo[i] && dimensions[i]) {
                            if (dimensions[i].name.toLowerCase() === '[measures]' && measureQuery !== '') {
                                if (isOnDemandDrill) {
                                    onDemandDrillQuery = onDemandDrillQuery + (onDemandDrillQuery !== '' ? ' * ' : '') + '(' + measureQuery + ')';
                                }
                                else {
                                    drillQuery.push('(' + measureQuery + ')');
                                    rawQuery.push('(' + measureQuery + ')');
                                }
                            }
                            else {
                                if (isOnDemandDrill) {
                                    onDemandDrillQuery = onDemandDrillQuery + (onDemandDrillQuery !== '' ? ' * ' : '') + '({' + this.getDimensionQuery(dimensions[i], axis) + '})';
                                }
                                else {
                                    drillQuery.push('(' + this.getDimensionQuery(dimensions[i], axis) + ')');
                                    rawQuery.push('(' + this.getDimensionQuery(dimensions[i], axis) + ')');
                                }
                            }
                        }
                        else {
                            drillQuery = [];
                            break;
                        }
                        i++;
                    }
                    if (drillQuery.length > 0 && drillQuery.length < drillInfo.length) {
                        drillQuery = [];
                        rawQuery = [];
                    }
                    // query = query + (query !== '' && drillQuery.length > 0 ? ',' : '') + (drillQuery.length > 0 ? '(' + drillQuery.toString().replace(/\&/g, "&amp;") + ')' : '');
                    query = query + (query !== '' && drillQuery.length > 0 ? ',' : '') + (drillQuery.length > 0 ? '(' + drillQuery.toString() + ')' : '');
                    if (rawQuery.length > 0) {
                        rawDrillQuery.push(('(' + rawQuery.toString() + ')'));
                    }
                }
            }
        }
        // return (isOnDemandDrill ? onDemandDrillQuery.replace(/\&/g, "&amp;") : query);
        const queryCollection = {
            query: (isOnDemandDrill ? onDemandDrillQuery : query),
            collection: (isOnDemandDrill ? [onDemandDrillQuery] : rawDrillQuery)
        };
        return queryCollection;
    }
    static updateValueSortQuery(query, valueSortSettings) {
        if (valueSortSettings && valueSortSettings.measure && valueSortSettings.measure !== '') {
            const heirarchize = (this.drilledMembers.length > 0 ? 'HIERARCHIZE ({' : '');
            const measure = (this.fieldList[valueSortSettings.measure].isCalculatedField ?
                this.fieldList[valueSortSettings.measure].tag : valueSortSettings.measure);
            switch (valueSortSettings.sortOrder) {
                case 'Ascending':
                    query = query.replace('NON EMPTY ( ' + heirarchize, 'NON EMPTY ( ' + heirarchize + ' ORDER ({');
                    query = query + '},(' + measure + '), ASC)';
                    // query = query + '},(' + valueSortSettings.measure + '), ' +
                    //     (valueSortSettings.preserveHierarchy ? 'BASC' : 'ASC') + ')';
                    break;
                case 'Descending':
                    query = query.replace('NON EMPTY ( ' + heirarchize, 'NON EMPTY ( ' + heirarchize + ' ORDER ({');
                    query = query + '},(' + measure + '), DESC)';
                    // query = query + '},(' + valueSortSettings.measure + '), ' +
                    //     (valueSortSettings.preserveHierarchy ? 'BDESC' : 'DESC') + ')';
                    break;
            }
        }
        return query;
    }
    static getSlicersQuery(slicers, axis) {
        let query = '';
        let dataFields = extend([], this.rows, null, true);
        dataFields = dataFields.concat(this.columns);
        if (slicers.length > 0) {
            let i = 0;
            while (i < slicers.length) {
                const isCol = dataFields.filter((field) => {
                    const colUqName = this.getDimensionUniqueName(field.name);
                    const slicerUqName = this.getDimensionUniqueName(slicers[i].name);
                    let isMatch = false;
                    isMatch = colUqName === slicerUqName &&
                        !(this.isMondrian && slicerUqName === '' && colUqName === '');
                    return (isMatch);
                }).length > 0;
                if (!isCol) {
                    if (slicers[i].name !== undefined && !this.filterMembers[slicers[i].name]) {
                        query = query + (query !== '' ? ' * ' : '') + '{' + this.getDimensionQuery(slicers[i], axis) + '}';
                    }
                    else if (this.filterMembers[slicers[i].name]) {
                        query = query + (query !== '' ? ' * ' : '') + '{' + (this.filterMembers[slicers[i].name].toString()) + '}';
                    }
                }
                i++;
            }
            query = query === '' ? '' : '\nWHERE (' + query.replace(/DrilldownLevel/g, '') + ')';
        }
        return query;
    }
    static getDimensionQuery(dimension, axis) {
        let query = '';
        const name = dimension.isCalculatedField ? this.fieldList[dimension.name].tag : dimension.name;
        const hasAllMember = this.fieldList[dimension.name].hasAllMember;
        if (!hasAllMember && !dimension.isNamedSet && !dimension.isCalculatedField) {
            query = '((' + name + ').levels(0).AllMembers)';
        }
        else {
            query = (dimension.isNamedSet || dimension.isCalculatedField ? '{' + name + '}' : this.isPaging ? name + '.CHILDREN' :
                'DrilldownLevel({' + name + '}' + ((axis === 'rows' || axis === 'columns') ? ',,,INCLUDE_CALC_MEMBERS' : '') + ')');
        }
        return query;
    }
    static getDimensionUniqueName(headerText) {
        const hierarchyNode = this.fieldDataObj.hierarchy;
        const curElement = [];
        if (hierarchyNode) {
            // let curElement: IOlapField[] = hierarchyNode.filter((item: IOlapField) => {
            //     return (item.id.toLowerCase() === headerText.toLowerCase());
            // });
            for (const item of hierarchyNode) {
                if (item.id.toLowerCase() === headerText.toLowerCase()) {
                    curElement.push(item);
                }
            }
            return (curElement.length > 0 ? curElement[0].pid : '');
        }
        else {
            return headerText.split('.')[0];
        }
    }
    static getMeasuresQuery(measures) {
        let query = '';
        if (measures.length > 0) {
            query = '{{';
            let values = '';
            for (const measure of measures) {
                const name = (measure.isCalculatedField ? this.fieldList[measure.name].tag : measure.name);
                if (values.length > 0) {
                    values = values + ', ' + name;
                }
                else {
                    values = name;
                }
            }
            query = query + values + '}}';
        }
        return query;
    }
    static getfilterQuery(filters, cube) {
        let query = '\nFROM [' + cube + ']';
        let filterQuery = '\nFROM( SELECT (';
        const advancedFilters = [];
        const advancedFilterQuery = [];
        const rowFilter = [];
        const columnFilter = [];
        for (const field of this.rows) {
            if (filters[field.name] && filters[field.name].length > 0) {
                if (typeof filters[field.name][0] === 'string') {
                    rowFilter.push(filters[field.name]);
                }
                else {
                    filters[field.name][1] = filters[field.name][0].type;
                    advancedFilters.push(filters[field.name]);
                    delete filters[field.name];
                }
            }
        }
        for (const field of this.columns) {
            if (filters[field.name] && filters[field.name].length > 0) {
                if (typeof filters[field.name][0] === 'string') {
                    columnFilter.push(filters[field.name]);
                }
                else { // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    const filter = filters[field.name];
                    filter[1] = filter[0].type;
                    advancedFilters.push(filters[field.name]);
                    delete filters[field.name];
                }
            }
        }
        for (const field of this.filters) {
            let isFound = false;
            for (const column of this.columns) {
                if (!isFound && this.getDimensionUniqueName(column.name) === this.getDimensionUniqueName(field.name)) {
                    if (filters[field.name]) {
                        columnFilter.push(filters[field.name]);
                        isFound = true;
                    }
                }
            }
            if (!isFound) {
                for (const row of this.rows) {
                    if (!isFound && this.getDimensionUniqueName(row.name) === this.getDimensionUniqueName(field.name)) {
                        if (filters[field.name]) {
                            rowFilter.push(filters[field.name]);
                            isFound = true;
                        }
                    }
                }
            }
        }
        if ((this.allowLabelFilter || this.allowValueFilter) && advancedFilters.length > 0) {
            const axes = ['Value', 'Label'];
            for (const axis of axes) {
                for (const filterItems of advancedFilters) {
                    if (filterItems && filterItems.length === 2 &&
                        typeof filterItems[1] === 'string' && filterItems[1] === axis) {
                        advancedFilterQuery.push(this.getAdvancedFilterQuery(filterItems[0], filterQuery, 'COLUMNS'));
                    }
                }
            }
        }
        for (let i = 0, cnt = columnFilter.length; i < cnt; i++) {
            filterQuery = i === 0 ? filterQuery + '{' + columnFilter[i].toString() + '}' : filterQuery + ',{' + columnFilter[i].toString() + '}';
        }
        if (columnFilter.length > 0) {
            filterQuery = (rowFilter.length > 0) ? filterQuery + ' ) ON COLUMNS ' + ',(' : filterQuery + ' ) ON COLUMNS';
        }
        for (let i = 0, cnt = rowFilter.length; i < cnt; i++) {
            filterQuery = (i > 0) ? filterQuery + ',{' + rowFilter[i].toString() + '}' : filterQuery + '{' + rowFilter[i].toString() + '}';
        }
        filterQuery = (columnFilter.length > 0 && rowFilter.length > 0) ?
            filterQuery = filterQuery + ') ON ROWS ' : (columnFilter.length === 0 && rowFilter.length > 0) ?
            filterQuery + ') ON COLUMNS ' : filterQuery;
        let updatedFilterQuery = '';
        if (advancedFilterQuery.length > 0) {
            updatedFilterQuery = advancedFilterQuery.join(' ') + ' ' +
                ((columnFilter.length > 0 || rowFilter.length > 0) ? filterQuery : '') + ' '
                + query + Array(advancedFilterQuery.length + 1 +
                ((columnFilter.length > 0 || rowFilter.length > 0) ? 1 : 0)).join(')');
        }
        query = (columnFilter.length === 0 && rowFilter.length === 0) ? query : filterQuery + query + ')';
        return (updatedFilterQuery.length > 0) ? updatedFilterQuery : query;
    }
    static getAdvancedFilterQuery(filterItem, query, currentAxis) {
        const filterQuery = '\nFROM (SELECT Filter(' + filterItem.selectedField + '.AllMembers, ' +
            this.getAdvancedFilterCondtions(filterItem.name, filterItem.condition, filterItem.value1, filterItem.value2, filterItem.type, filterItem.measure) +
            ')) on ' + currentAxis;
        return filterQuery;
    }
    static getAdvancedFilterCondtions(fieldName, filterOperator, value1, value2, filterType, measures) {
        let advancedFilterQuery = '';
        switch (filterOperator) {
            case 'Equals': /* eslint-disable no-useless-escape */
                advancedFilterQuery = '(' + (filterType !== 'Value' ? (fieldName + '.CurrentMember.member_caption =\"' + value1 + '\"') : (measures + ' = ' + value1));
                break;
            case 'DoesNotEquals':
                advancedFilterQuery = '(' + (filterType !== 'Value' ? (fieldName + '.CurrentMember.member_caption <>\"' + value1 + '\"') : (measures + ' <>' + value1));
                break;
            case 'Contains':
                advancedFilterQuery = '( InStr (1,' + fieldName + '.CurrentMember.member_caption,\"' + value1 + '\") >0';
                break;
            case 'DoesNotContains':
                advancedFilterQuery = '( InStr (1,' + fieldName + '.CurrentMember.member_caption,\"' + value1 + '\")=0';
                break;
            case 'BeginWith':
                advancedFilterQuery = '( Left (' + fieldName + '.CurrentMember.member_caption,' + value1.length + ')=\"' + value1 + '\"';
                break;
            case 'DoesNotBeginWith':
                advancedFilterQuery = '( Left (' + fieldName + '.CurrentMember.member_caption,' + value1.length + ') <>\"' + value1 + '\"';
                break;
            case 'EndsWith':
                advancedFilterQuery = '( Right (' + fieldName + '.CurrentMember.member_caption,' + value1.length + ')=\"' + value1 + '\"';
                break;
            case 'DoesNotEndsWith':
                advancedFilterQuery = '( Right (' + fieldName + '.CurrentMember.member_caption,' + value1.length + ') <>\"' + value1 + '\"';
                break;
            case 'GreaterThan':
                advancedFilterQuery = '(' + (filterType !== 'Value' ? (fieldName + '.CurrentMember.member_caption >\"' + value1 + '\"') : (measures + ' >' + value1 + ''));
                break;
            case 'GreaterThanOrEqualTo':
                advancedFilterQuery = '(' + (filterType !== 'Value' ? (fieldName + '.CurrentMember.member_caption >=\"' + value1 + '\"') : (measures + ' >=' + value1 + ''));
                break;
            case 'LessThan':
                advancedFilterQuery = '(' + (filterType !== 'Value' ? (fieldName + '.CurrentMember.member_caption <\"' + value1 + '\"') : (measures + ' <' + value1 + ''));
                break;
            case 'LessThanOrEqualTo':
                advancedFilterQuery = '(' + (filterType !== 'Value' ? (fieldName + '.CurrentMember.member_caption <=\"' + value1 + '\"') : (measures + ' <=' + value1 + ''));
                break;
            case 'Between':
                advancedFilterQuery = '(' + (filterType !== 'Value' ? (fieldName + '.CurrentMember.member_caption >=\"' + value1 + '\"AND ' + fieldName + '.CurrentMember.member_caption <=\"' + value2 + '\"') : (measures + ' >=' + value1 + ' AND ' + measures + ' <=' + value2));
                break;
            case 'NotBetween':
                advancedFilterQuery = '(' + (filterType !== 'Value' ? (fieldName + '.CurrentMember.member_caption >=\"' + value1 + '\"OR ' + fieldName + '.CurrentMember.member_caption <=\"' + value2 + '\"') : (measures + ' >=' + value1 + ' OR ' + measures + ' <=' + value2));
                break;
            default:
                advancedFilterQuery = '( InStr (1,' + fieldName + '.CurrentMember.member_caption,\"' + value1 + '\") >0';
                break;
        } /* eslint-enable no-useless-escape */
        return advancedFilterQuery;
    }
    static getCalculatedFieldQuery(calcMembers) {
        let calcQuery = '';
        if (calcMembers.length > 0) {
            calcQuery = '\nWITH';
            for (const member of calcMembers) {
                const prefixName = (member.formula.indexOf('Measure') > -1 ? '[Measures].' : member.hierarchyUniqueName + '.');
                const aliasName = prefixName + '[' + member.name + ']';
                const formatString = (!isNullOrUndefined(member.formatString) ? member.formatString : null); // eslint-disable-next-line no-useless-escape
                calcQuery += ('\nMEMBER ' + aliasName + 'as (' + member.formula + ') ' + (!isNullOrUndefined(formatString) ? ', FORMAT_STRING =\"' + formatString.trim() + '\"' : ''));
            }
        }
        return calcQuery;
    }
}

/**
 * OlapEngine is used to manipulate the olap or Multi-Dimensional data as pivoting values.
 */
/** @hidden */
class OlapEngine {
    constructor() {
        /** @hidden */
        this.fieldList = {};
        /** @hidden */
        this.columnCount = 0;
        /** @hidden */
        this.rowCount = 0;
        /** @hidden */
        this.colFirstLvl = 0;
        /** @hidden */
        this.rowFirstLvl = 0;
        /** @hidden */
        this.pageColStartPos = 0;
        /** @hidden */
        this.enableSort = false;
        /** @hidden */
        this.enableValueSorting = false;
        /** @hidden */
        this.dataFields = {};
        /** @hidden */
        this.formatFields = {};
        /** @hidden */
        this.filterMembers = {};
        /** @hidden */
        this.drilledSets = {};
        this.aggregatedValueMatrix = [];
        this.mappingFields = {}; /* eslint-disable security/detect-unsafe-regex */
        this.customRegex = /^(('[^']+'|''|[^*#@0,.])*)(\*.)?((([0#,]*[0,]*[0#]*)(\.[0#]*)?)|([#,]*@+#*))(E\+?0+)?(('[^']+'|''|[^*#@0,.E])*)$/;
        this.formatRegex = /(^[ncpae]{1})([0-1]?[0-9]|20)?$/i; /* eslint-enable security/detect-unsafe-regex */
        /** @hidden */
        this.pivotValues = [];
        /** @hidden */
        this.valueContent = [];
        /** @hidden */
        this.headerContent = [];
        /** @hidden */
        this.rowStartPos = 0;
        /** @hidden */
        this.pageRowStartPos = 0;
        /** @hidden */
        this.tupColumnInfo = [];
        /** @hidden */
        this.tupRowInfo = [];
        /** @hidden */
        this.gridJSON = '';
        /** @hidden */
        this.namedSetsPosition = {};
        this.colDepth = 0;
        this.totalCollection = [];
        this.parentObjCollection = {};
        this.curDrillEndPos = -1;
        this.headerGrouping = {};
        this.lastLevel = [];
        this.showRowSubTotals = true;
        this.showColumnSubTotals = true;
        this.hideRowTotalsObject = {};
        this.hideColumnTotalsObject = {};
        this.sortObject = {};
        this.isColDrill = false;
    }
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
    renderEngine(dataSourceSettings, customProperties, onHeadersSort) {
        this.isEmptyData = false;
        this.getHeaderSortInfo = onHeadersSort;
        this.mdxQuery = '';
        this.isMeasureAvail = false;
        this.allowMemberFilter = false;
        this.allowLabelFilter = false;
        this.allowValueFilter = false;
        this.isMondrian = false;
        this.aggregatedValueMatrix = [];
        this.measureReportItems = [];
        this.calcChildMembers = [];
        this.selectedItems = [];
        this.savedFieldList = undefined;
        this.savedFieldListData = undefined;
        this.formatFields = {};
        this.filterMembers = {};
        this.dataFields = {};
        this.valueAxis = '';
        this.columnCount = 0;
        this.rowCount = 0;
        this.colFirstLvl = 0;
        this.rowFirstLvl = 0;
        this.pageColStartPos = 0;
        this.enableValueSorting = false;
        this.sortObject = {};
        this.globalize = new Internationalization(); // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.locale = this.globalize.getCulture();
        this.localeObj = customProperties ? customProperties.localeObj : undefined;
        this.enableValueSorting = customProperties ? customProperties.enableValueSorting : false;
        if (dataSourceSettings.url) {
            // this.isMondrian = (dataSourceSettings.providerType === 'mondrian');
            this.dataSourceSettings = dataSourceSettings;
            this.valueAxis = dataSourceSettings.valueAxis === 'row' ? 'row' : 'column';
            this.getAxisFields();
            this.formats = dataSourceSettings.formatSettings ? dataSourceSettings.formatSettings : [];
            this.enableSort = dataSourceSettings.enableSorting === undefined ? true : dataSourceSettings.enableSorting;
            this.valueSortSettings = dataSourceSettings.valueSortSettings ? dataSourceSettings.valueSortSettings : undefined;
            this.filterSettings = dataSourceSettings.filterSettings ? dataSourceSettings.filterSettings : [];
            this.sortSettings = dataSourceSettings.sortSettings ? dataSourceSettings.sortSettings : [];
            this.allowMemberFilter = dataSourceSettings.allowMemberFilter ? true : false;
            this.allowLabelFilter = dataSourceSettings.allowLabelFilter ? true : false;
            this.allowValueFilter = dataSourceSettings.allowValueFilter ? true : false;
            this.drilledMembers = dataSourceSettings.drilledMembers ? this.updateDrilledItems(dataSourceSettings.drilledMembers) : [];
            this.calculatedFieldSettings = dataSourceSettings.calculatedFieldSettings ? dataSourceSettings.calculatedFieldSettings : [];
            this.emptyCellTextContent = dataSourceSettings.emptyCellsTextContent ? dataSourceSettings.emptyCellsTextContent : '';
            this.pageSettings = customProperties ? (customProperties.pageSettings ? customProperties.pageSettings : this.pageSettings)
                : undefined;
            this.isPaging = this.pageSettings && (customProperties.enablePaging || customProperties.enableVirtualization) ? true : false;
            this.frameSortObject();
            this.getFormattedFields(this.formats);
            this.savedFieldList = customProperties ? customProperties.savedFieldList : undefined;
            this.savedFieldListData = customProperties ? customProperties.savedFieldListData : undefined;
            this.fieldListData = [];
            this.fieldListObj = {};
            this.setNamedSetsPosition();
            if (!(this.savedFieldList && this.savedFieldListData)) {
                this.getFieldList(dataSourceSettings);
            }
            else {
                this.updateFieldlist(true);
            }
            this.loadCalculatedMemberElements(this.calculatedFieldSettings);
            this.measureReportItems = [];
            // this.updateAllMembers(dataSourceSettings, this.filters);
            this.updateFilterItems(this.filterSettings);
            this.generateGridData(dataSourceSettings);
        }
    }
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
    generateGridData(dataSourceSettings, action) {
        const refPaging = (action && action === 'navPaging' &&
            this.isPaging && this.pageSettings !== undefined ? true : false);
        if (this.rows.length > 0 || this.columns.length > 0 || this.values.length > 0 || this.filters.length > 0) {
            MDXQuery.getCellSets(dataSourceSettings, this, refPaging);
        }
        else {
            MDXQuery.getCellSets(dataSourceSettings, this, true, undefined, true);
            this.generateEngine(undefined, undefined, { dataSourceSettings: dataSourceSettings, action: 'loadTableElements' });
        }
    }
    generatePagingData(xmlDoc, request, customArgs) {
        const xmlaCellSet = [].slice.call(xmlDoc.querySelectorAll('Axes, CellData'));
        // this.rowCount =
        //     (xmlaCellSet.length > 0 && [].slice.call(xmlaCellSet[0].querySelectorAll('Axis[name|="Axis1"] Tuple')).length > 0 ?
        //         [].slice.call(xmlaCellSet[0].querySelectorAll('Axis[name|="Axis1"] Tuple')).length : 0);
        // this.columnCount =
        //     (xmlaCellSet.length > 0 && [].slice.call(xmlaCellSet[0].querySelectorAll('Axis[name|="Axis0"] Tuple')).length > 0 ?
        //         [].slice.call(xmlaCellSet[0].querySelectorAll('Axis[name|="Axis0"] Tuple')).length : 0);
        const countCells = xmlaCellSet[1] ? xmlaCellSet[1].querySelectorAll('FmtValue') : null;
        if (countCells && countCells.length > 0) {
            this.columnCount = Number(countCells[0].textContent);
            this.rowCount = Number(countCells[1].textContent);
        }
        const dataSourceSettings = customArgs.dataSourceSettings;
        MDXQuery.getCellSets(dataSourceSettings, this, true);
    }
    scrollPage() {
        MDXQuery.getCellSets(this.dataSourceSettings, this, true);
    }
    generateEngine(xmlDoc, request, customArgs) {
        if (customArgs.action !== 'down') {
            this.pivotValues = [];
            this.valueContent = [];
            this.headerContent = [];
            this.colDepth = 0;
            this.tupColumnInfo = [];
            this.tupRowInfo = [];
            this.colMeasures = {};
            this.colMeasurePos = undefined;
            this.rowMeasurePos = undefined;
            this.rowStartPos = -1;
        }
        this.xmlDoc = xmlDoc ? xmlDoc.cloneNode(true) : undefined;
        this.request = request;
        this.customArgs = customArgs;
        this.totalCollection = [];
        this.parentObjCollection = {};
        this.curDrillEndPos = -1;
        this.onDemandDrillEngine = [];
        this.getSubTotalsVisibility();
        this.xmlaCellSet = xmlDoc ? xmlDoc.querySelectorAll('Axes, CellData') : undefined;
        let columnTuples = this.xmlaCellSet && this.xmlaCellSet.length > 0 ?
            [].slice.call(this.xmlaCellSet[0].querySelectorAll('Axis[name|="Axis0"] Tuple')) : [];
        let rowTuples = this.xmlaCellSet && this.xmlaCellSet.length > 0 ?
            [].slice.call(this.xmlaCellSet[0].querySelectorAll('Axis[name|="Axis1"] Tuple')) : [];
        let valCollection = this.xmlaCellSet && this.xmlaCellSet.length > 1 ?
            [].slice.call(this.xmlaCellSet[1].querySelectorAll('Cell')) : [];
        if (this.drilledMembers.length > 0) {
            // let st1: number = new Date().getTime();
            const measureInfo = this.getMeasureInfo();
            let orderedInfo;
            orderedInfo = this.frameMeasureOrder(measureInfo, 'column', columnTuples, valCollection, columnTuples.length);
            columnTuples = orderedInfo.orderedHeaderTuples;
            valCollection = orderedInfo.orderedValueTuples;
            orderedInfo = this.frameMeasureOrder(measureInfo, 'row', rowTuples, valCollection, columnTuples.length);
            rowTuples = orderedInfo.orderedHeaderTuples;
            valCollection = orderedInfo.orderedValueTuples;
            // let st2: number = (new Date().getTime() - st1) / 1000;
            // console.log('over-all:' + st2);
        }
        if (customArgs.action === 'down') {
            this.updateTupCollection(customArgs.drillInfo.axis === 'row' ? rowTuples.length : columnTuples.length);
        }
        if (customArgs.action === 'down' ? customArgs.drillInfo.axis === 'column' : true) {
            this.olapValueAxis = isNullOrUndefined(this.getValueAxis(undefined, undefined)) ? 'column' : 'row';
            this.frameColumnHeader(columnTuples);
            if (!this.isPaging) {
                this.performColumnSorting();
            }
        }
        if (customArgs.action === 'down' ? customArgs.drillInfo.axis === 'row' : true) {
            this.frameRowHeader(rowTuples);
            if (!this.isPaging) {
                this.performRowSorting();
            }
        }
        this.frameValues(valCollection, columnTuples.length);
        this.performColumnSpanning();
        if (!this.isPaging && this.enableSort) {
            for (let i = 0; i < this.headerContent.length; i++) {
                this.headerContent[i] = this.pivotValues[i];
            }
        }
        this.isEngineUpdated = true;
        this.isEmptyData = columnTuples.length === 0;
        //this.append(columnTuples.length);
    }
    getSubTotalsVisibility() {
        this.showRowSubTotals = this.dataSourceSettings.showRowSubTotals && this.dataSourceSettings.showSubTotals;
        this.showColumnSubTotals = this.dataSourceSettings.showColumnSubTotals && this.dataSourceSettings.showSubTotals;
        this.showSubTotalsAtTop = this.showColumnSubTotals && this.dataSourceSettings.subTotalsPosition === 'Top';
        this.showSubTotalsAtBottom = this.showRowSubTotals && this.dataSourceSettings.subTotalsPosition === 'Bottom';
        this.hideRowTotalsObject = {};
        this.hideColumnTotalsObject = {};
        let axisCount = 1;
        do {
            if (axisCount === 1) {
                if (this.showColumnSubTotals) {
                    for (let cCnt = 0; cCnt < this.dataSourceSettings.columns.length; cCnt++) {
                        if (this.dataSourceSettings.columns[cCnt].showSubTotals === false) {
                            this.hideColumnTotalsObject[this.dataSourceSettings.columns[cCnt].name] = cCnt;
                        }
                    }
                }
            }
            else {
                if (this.showRowSubTotals) {
                    for (let rCnt = 0; rCnt < this.dataSourceSettings.rows.length; rCnt++) {
                        if (this.dataSourceSettings.rows[rCnt].showSubTotals === false) {
                            this.hideRowTotalsObject[this.dataSourceSettings.rows[rCnt].name] = rCnt;
                        }
                    }
                }
            }
            axisCount++;
        } while (axisCount < 3);
    }
    frameRowHeader(tuples) {
        this.headerGrouping = {};
        this.lastLevel = [];
        let isGrandTotalAdd = true;
        let position = this.pivotValues.length;
        let pivotValues = [];
        let valueContent = [];
        if (this.customArgs.action !== 'down') {
            pivotValues = this.pivotValues;
            valueContent = this.valueContent;
        }
        else {
            position = this.customArgs.drillInfo.currentCell.rowIndex + 1;
        }
        this.rowStartPos = this.rowStartPos > 0 ? this.rowStartPos : position;
        let tupPos = 0;
        let lastAllStartPos;
        let lastAllCount;
        const prevUNArray = [];
        const allType = {};
        const rowMembers = [];
        let availAllMember = false;
        let withoutAllStartPos = -1;
        let withoutAllEndPos = -1;
        const minLevel = [];
        let gTotals = [{
                axis: 'row',
                colIndex: 0,
                formattedText: 'Grand Total',
                hasChild: false,
                level: -1,
                rowIndex: 0,
                index: [],
                type: 'grand sum',
                ordinal: 0,
                colSpan: 1,
                rowSpan: 1,
                memberType: 2,
                isDrilled: false,
                valueSort: { 'Grand Total': 1, levelName: 'Grand Total' }
            }];
        let maxLevel = [];
        let measurePos;
        const newTupPosition = (this.customArgs.drillInfo && this.customArgs.drillInfo.axis === 'row') ?
            (this.customArgs.drillInfo.currentCell.ordinal + 1) : 0;
        while (tupPos < tuples.length) {
            const members = tuples[tupPos].querySelectorAll('Member');
            maxLevel = this.frameTupCollection(members, maxLevel, (tupPos + newTupPosition), this.tupRowInfo, this.showRowSubTotals, this.hideRowTotalsObject, 'row');
            tupPos++;
        }
        tupPos = 0;
        let prevTupInfo;
        let tuplesLength = tuples.length;
        if (this.customArgs.action === 'down') {
            const ordinal = this.customArgs.drillInfo.currentCell.ordinal + 1;
            tupPos = ordinal;
            tuplesLength += ordinal;
            lastAllCount = this.tupRowInfo[ordinal - 1].allCount;
            lastAllStartPos = this.tupRowInfo[ordinal - 1].allStartPos;
            prevTupInfo = this.tupRowInfo[ordinal - 1];
        }
        const startTupPos = tupPos;
        const pagingAllowFlag = true;
        let lastMesPos = 0;
        let isGrandTotalTop = false;
        const subTotals = [];
        while (tupPos < tuplesLength && pagingAllowFlag) {
            const members = tuples[this.customArgs.action === 'down' ?
                (tupPos - (this.customArgs.drillInfo.currentCell.ordinal + 1)) : tupPos].querySelectorAll('Member');
            let memPos = 0;
            let prevParent;
            const allCount = this.tupRowInfo[tupPos].allCount;
            const allStartPos = this.tupRowInfo[tupPos].allStartPos;
            const measure = this.tupRowInfo[tupPos].measure;
            const typeColl = this.tupRowInfo[tupPos].typeCollection;
            // let drillInfo: IDrillInfo[] = this.tupRowInfo[tupPos].drillInfo;
            const drillStartPos = this.tupRowInfo[tupPos].drillStartPos;
            const startDrillUniquename = this.tupRowInfo[tupPos].startDrillUniquename;
            // let drillEndPos: number = this.tupRowInfo[tupPos].drillEndPos;
            // let levelColl: number[] = this.tupRowInfo[tupPos].levelCollection;
            if (tupPos === 0 || tupPos === startTupPos) {
                const firstTupMembers = this.customArgs.action === 'down' ? this.tupRowInfo[0].members : members;
                while (memPos < firstTupMembers.length) {
                    if (firstTupMembers[memPos].querySelector('MEMBER_TYPE').textContent === '1' &&
                        Number(firstTupMembers[memPos].querySelector('LNum').textContent) === 0) {
                        minLevel[memPos] = 0;
                    }
                    else {
                        minLevel[memPos] = Number(firstTupMembers[memPos].querySelector('LNum').textContent);
                    }
                    // if (firstTupMembers[memPos].querySelector('MEMBER_TYPE').textContent === '1' &&
                    //   (this.isPaging || Number(firstTupMembers[memPos].querySelector('LNum').textContent) === 0)) {
                    if (firstTupMembers[memPos].querySelector('MEMBER_TYPE').textContent === '1') {
                        allType[memPos] = 0;
                        withoutAllStartPos = withoutAllStartPos === -1 ? memPos : withoutAllStartPos;
                        withoutAllEndPos = memPos;
                    }
                    else {
                        allType[memPos] = 1;
                        availAllMember = firstTupMembers[memPos].querySelector('MEMBER_TYPE').textContent === '3' ? availAllMember : true;
                    }
                    memPos++;
                }
                measurePos = typeColl.indexOf('3');
            }
            memPos = 0;
            if (tupPos === 0 && (members.length > (allCount + (measure ? 1 : 0)) || (members.length === 1 && measure))) {
                gTotals.pop();
            }
            if ((tupPos === 0 && this.isPaging) ? gTotals.length === 0 :
                (!availAllMember || allCount === lastAllCount || allStartPos !== lastAllStartPos || (members.length === 1 && measure))) {
                const attrDrill = this.checkAttributeDrill(this.tupRowInfo[tupPos].drillInfo, 'rows');
                let drillAllow = drillStartPos > -1 ? (allCount > 0 ? (attrDrill || allStartPos > drillStartPos) : true) : true;
                drillAllow = (prevTupInfo && drillAllow && drillStartPos > -1) ?
                    (prevTupInfo.startDrillUniquename !== startDrillUniquename ? true :
                        ((withoutAllEndPos > prevTupInfo.measurePosition ? false :
                            prevTupInfo.measureName !== this.tupRowInfo[tupPos].measureName) &&
                            (allStartPos === (drillStartPos + 1) ||
                                this.tupRowInfo[tupPos].measurePosition === (drillStartPos + 1))))
                    : drillAllow;
                const withoutAllAllow = (withoutAllStartPos > -1 && allCount > 0) ?
                    (attrDrill || allStartPos > withoutAllEndPos) : true;
                isGrandTotalTop = this.dataSourceSettings.grandTotalsPosition === 'Top' && this.olapRowValueIndex === 0 &&
                    this.olapValueAxis === 'row'
                    && this.dataSourceSettings.showGrandTotals && this.dataSourceSettings.showRowGrandTotals &&
                    (this.olapValueAxis === 'row' ? this.dataSourceSettings.rows.length > 1 : true);
                if (isGrandTotalTop && gTotals.length === 1) {
                    gTotals = this.frameGrandTotalValues(tuples, gTotals, typeColl, measurePos);
                }
                if (members.length === allCount + (measure ? 1 : 0) && measure && !isGrandTotalTop) {
                    const levelName = 'Grand Total.' + members[measurePos].querySelector('Caption').textContent;
                    const formattedText = (typeColl[measurePos] === '3' &&
                        this.dataFields[this.getUniqueName(members[measurePos].querySelector('UName').textContent)] &&
                        this.dataFields[this.getUniqueName(members[measurePos].querySelector('UName').textContent)].caption) ?
                        this.dataFields[this.getUniqueName(members[measurePos].querySelector('UName').textContent)].caption :
                        members[measurePos].querySelector('Caption').textContent;
                    gTotals = this.frameGrandTotalAxisSet(gTotals, this.getUniqueName(members[measurePos].querySelector('UName').textContent), formattedText, position, tupPos, Number(typeColl[measurePos]), members[measurePos].querySelector('PARENT_UNIQUE_NAME') ?
                        members[measurePos].querySelector('PARENT_UNIQUE_NAME').textContent : undefined, members[measurePos].querySelector('LName').textContent, members[measurePos].getAttribute('Hierarchy'), {
                        levelName: levelName, axis: members[measurePos].getAttribute('Hierarchy')
                    });
                    gTotals[gTotals.length - 1].valueSort['Grand Total.' +
                        members[measurePos].querySelector('Caption').textContent] = 1;
                }
                else if (!(allStartPos === 0 || (measurePos === 0 && allStartPos === 1)) && drillAllow && withoutAllAllow) {
                    if (this.dataSourceSettings.grandTotalsPosition === 'Top' && isGrandTotalAdd && this.dataSourceSettings.showGrandTotals &&
                        (this.olapValueAxis === 'row' ? this.dataSourceSettings.rows.length > 1 : true)) {
                        this.insertRowGrandTotal(gTotals, valueContent, pivotValues, tuples, position);
                        position = this.pivotValues.length;
                        isGrandTotalAdd = false;
                    }
                    prevTupInfo = this.tupRowInfo[tupPos];
                    let lastPos = position;
                    let lastMemPos = memPos;
                    prevParent = {};
                    let withoutAllDrilled = false;
                    while (memPos < members.length && pagingAllowFlag) {
                        const member = members[memPos];
                        if (member.querySelector('UName').textContent !== prevUNArray[memPos] && typeColl[memPos] !== '2'
                            && ((Object.keys(prevParent).length > 0 ? (prevParent.isDrilled &&
                                !this.fieldList[prevParent.hierarchy].isHierarchy) : withoutAllDrilled) ?
                                (typeColl[memPos] === '3' && (allType[memPos - 1] && allType[memPos + 1] !== 0)) : true)) {
                            const lvl = Number(member.querySelector('LNum').textContent) -
                                ((allType[memPos] && typeColl[memPos] !== '3') ? 1 : minLevel[memPos]);
                            const isNamedSet = this.namedSetsPosition['row'][memPos] ? true : false;
                            const uniqueName = this.getUniqueName(member.querySelector('UName').textContent);
                            const depth = this.getDepth(this.tupRowInfo[tupPos], uniqueName, Number(typeColl[memPos]));
                            const levelName = this.getCaptionCollectionWithMeasure(this.tupRowInfo[tupPos]);
                            if (this.showSubTotalsAtBottom && position > this.rowStartPos) {
                                lastPos = position = this.insertRowSubTotal(pivotValues, valueContent, subTotals, position, lvl, levelName);
                            }
                            if (!(this.isPaging && pivotValues[lastMesPos][0] &&
                                this.fieldList[pivotValues[lastMesPos][0].hierarchy] &&
                                this.fieldList[pivotValues[lastMesPos][0].hierarchy].isHierarchy &&
                                pivotValues[lastMesPos][0].hasChild &&
                                !pivotValues[lastMesPos][0].isDrilled &&
                                !this.rows[memPos].isNamedSet && (this.rows[memPos].name.indexOf('[Measures]') === 0 ||
                                (this.fieldList[member.getAttribute('Hierarchy')] &&
                                    (this.fieldList[member.getAttribute('Hierarchy')].isHierarchy ||
                                        this.fieldList[member.getAttribute('Hierarchy')].hasAllMember))) &&
                                pivotValues[lastMesPos][0].depth < depth)) {
                                pivotValues[position] = [{
                                        axis: 'row',
                                        actualText: uniqueName,
                                        colIndex: 0,
                                        formattedText: (typeColl[memPos] === '3' && this.dataFields[uniqueName] &&
                                            this.dataFields[uniqueName].caption) ? this.dataFields[uniqueName].caption :
                                            member.querySelector('Caption').textContent,
                                        hasChild: (this.fieldList[member.getAttribute('Hierarchy')] &&
                                            this.fieldList[member.getAttribute('Hierarchy')].isHierarchy && memPos < this.rows.length - 1 &&
                                            !this.rows[memPos + 1].isNamedSet && this.rows[memPos + 1].name.indexOf('[Measures]') < 0 &&
                                            this.fieldList[this.rows[memPos + 1].name] &&
                                            this.fieldList[this.rows[memPos + 1].name].hasAllMember) ? true :
                                            Number(member.querySelector('CHILDREN_CARDINALITY').textContent) > 0 ? true : false,
                                        level: lvl,
                                        depth: depth,
                                        rowIndex: position,
                                        index: [],
                                        ordinal: tupPos,
                                        type: 'header',
                                        colSpan: 1,
                                        rowSpan: 1,
                                        memberType: Number(typeColl[memPos]),
                                        isDrilled: (this.fieldList[member.getAttribute('Hierarchy')] &&
                                            this.fieldList[member.getAttribute('Hierarchy')].isHierarchy &&
                                            !this.isAttributeDrill(member.getAttribute('Hierarchy'), this.tupRowInfo[tupPos].drillInfo, 'rows')) ? true :
                                            this.tupRowInfo[tupPos].drillInfo[memPos].isDrilled,
                                        parentUniqueName: member.querySelector('PARENT_UNIQUE_NAME') ?
                                            member.querySelector('PARENT_UNIQUE_NAME').textContent : undefined,
                                        levelUniqueName: member.querySelector('LName').textContent,
                                        hierarchy: member.getAttribute('Hierarchy'),
                                        isNamedSet: isNamedSet,
                                        valueSort: { levelName: '', axis: member.getAttribute('Hierarchy') }
                                    }];
                                prevParent = typeColl[memPos] !== '3' ? pivotValues[position][0] : prevParent;
                                if (!prevParent) {
                                    rowMembers.push(member.querySelector('Caption').textContent);
                                }
                                pivotValues[position][0].valueSort.levelName = levelName;
                                pivotValues[position][0].valueSort[levelName] = 1;
                                valueContent[position - this.rowStartPos] = {};
                                valueContent[position - this.rowStartPos][0] = pivotValues[position][0];
                                if (measure && measurePos > memPos) {
                                    prevUNArray[measurePos] = '';
                                }
                                for (let pos = memPos + 1; pos < members.length; pos++) {
                                    prevUNArray[pos] = '';
                                }
                                prevUNArray[memPos] = member.querySelector('UName').textContent;
                                lastMesPos = Number(typeColl[memPos]) !== 3 ? position : lastMesPos;
                                position++;
                                lastMemPos = memPos;
                            }
                        }
                        else if (typeColl[memPos] === '2') {
                            lastMemPos = memPos;
                        }
                        else {
                            if (this.tupRowInfo[tupPos].drillInfo[memPos].isDrilled &&
                                allType[memPos] === 0) {
                                withoutAllDrilled = true;
                            }
                        }
                        if (this.tupRowInfo[tupPos].drillInfo[memPos].isDrilled &&
                            this.tupRowInfo[tupPos].showTotals) {
                            this.tupRowInfo[tupPos].showTotals = !this.showRowSubTotals ? false :
                                this.hideRowTotalsObject[this.tupRowInfo[tupPos].drillInfo[memPos].hierarchy] ===
                                    undefined;
                        }
                        memPos++;
                    }
                    if (lastPos < position && lastMemPos >= (members.length - 1)) {
                        pivotValues[position - 1][0].ordinal = tupPos;
                        if (pivotValues[position - 1][0].type === 'header') {
                            delete pivotValues[position - 1][0].type;
                        }
                    }
                }
                lastAllCount = allCount;
                lastAllStartPos = allStartPos;
            }
            tupPos++;
        }
        if (this.showSubTotalsAtBottom && subTotals.length > 0) {
            subTotals.reverse();
            subTotals.forEach((axis) => {
                pivotValues[position] = [axis];
                valueContent[position - this.rowStartPos] = {};
                valueContent[position - this.rowStartPos][0] = pivotValues[position][0];
                position++;
            });
        }
        if (!(this.dataSourceSettings.grandTotalsPosition === 'Top') || (this.olapValueAxis === 'row' &&
            this.dataSourceSettings.rows.length === 1 && this.dataSourceSettings.grandTotalsPosition === 'Top') ||
            this.dataSourceSettings.rows.length === 0) {
            this.insertRowGrandTotal(gTotals, valueContent, pivotValues, tuples, position);
        }
    }
    insertRowSubTotal(pivotValues, valueContent, subTotals, position, lvl, levelName) {
        const prevRowParent = PivotUtil.frameHeaderWithKeys(pivotValues[position - 1][0]);
        if (prevRowParent.level < lvl && prevRowParent.type !== 'grand sum' && (prevRowParent.isDrilled ||
            prevRowParent.memberType === 3)) {
            if (prevRowParent.memberType === 3) {
                const valueCells = [];
                let index = 1;
                while (pivotValues[position - index][0].memberType === 3) {
                    valueCells[valueCells.length] = pivotValues[position - index][0];
                    index++;
                }
                if (pivotValues[position - index][0].isDrilled && valueCells.length !== 0) {
                    for (let i = 0, axislength = valueCells.length; i < axislength; i++) {
                        valueCells[i].formattedText =
                            pivotValues[position - index][0].formattedText + ' ' + valueCells[i].formattedText;
                        valueCells[i].isSum = true;
                        valueCells[i].type = 'sum';
                        valueCells[i].parentUniqueName = pivotValues[position - index][0].levelUniqueName;
                        subTotals[subTotals.length] = valueCells[i];
                    }
                    index--;
                    position -= index;
                }
            }
            else {
                prevRowParent.hasChild = false;
                prevRowParent.isDrilled = false;
                prevRowParent.isSum = true;
                prevRowParent.type = 'sum';
                prevRowParent.formattedText = prevRowParent.formattedText + ' Total';
                subTotals[Object.keys(subTotals).length] = prevRowParent;
            }
        }
        if (subTotals.length > 0) {
            let j = subTotals.length - 1;
            let subTotalLevel = subTotals[j].valueSort.levelName.split('.').length;
            const nextLevels = levelName.split('.').length;
            while (subTotalLevel >= nextLevels) {
                pivotValues[position] = [subTotals[j]];
                valueContent[position - this.rowStartPos] = {};
                valueContent[position - this.rowStartPos][0] = pivotValues[position][0];
                position++;
                subTotals.splice(subTotals.length - 1, 1);
                if (Object.keys(subTotals).length > 0) {
                    j--;
                    subTotalLevel = subTotals[j].valueSort.levelName.split('.').length;
                }
                else {
                    break;
                }
            }
        }
        return position;
    }
    insertRowGrandTotal(gTotals, valueContent, pivotValues, tuples, position) {
        if (gTotals.length > 1 && gTotals[0].memberType !== 3) {
            gTotals[0].ordinal = -1;
        }
        // if (!(this.dataSourceSettings.showGrandTotals && this.dataSourceSettings.showRowGrandTotals)) {
        //     for (let totPos: number = 0; totPos < gTotals.length; totPos++) {
        //         if (this.tupRowInfo[gTotals[totPos].ordinal]) {
        //             this.tupRowInfo[gTotals[totPos].ordinal].showTotals = false;
        //         }
        //     }
        // }
        if (this.customArgs.action !== 'down') {
            if (this.dataSourceSettings.showGrandTotals && this.dataSourceSettings.showRowGrandTotals) {
                for (let totPos = 0; totPos < gTotals.length; totPos++) {
                    gTotals[totPos].rowIndex = position;
                    pivotValues[position] = [gTotals[totPos]];
                    valueContent[position - this.rowStartPos] = {};
                    valueContent[position - this.rowStartPos][0] = pivotValues[position][0];
                    position++;
                }
            }
        }
        else {
            this.updateRowEngine(pivotValues, valueContent, tuples.length);
            this.onDemandDrillEngine = pivotValues;
        }
        return gTotals;
    }
    getValueAxis(valueAxis, valueIndex) {
        this.olapValueAxis = valueAxis;
        this.olapRowValueIndex = valueIndex;
        for (let i = 0; i < this.dataSourceSettings.rows.length; i++) {
            if (this.dataSourceSettings.rows[i].name === '[Measures]') {
                this.olapValueAxis = 'row';
                this.olapRowValueIndex = i;
                break;
            }
        }
        return this.olapValueAxis;
    }
    frameGrandTotalAxisSet(gTotals, actualText, formattedText, rowIndex, ordinal, memberType, parentUniqueName, levelUniqueName, hierarchy, valueSort) {
        gTotals.push({
            axis: 'row',
            actualText: actualText,
            colIndex: 0,
            formattedText: formattedText,
            hasChild: false,
            level: -1,
            rowIndex: rowIndex,
            index: [],
            ordinal: ordinal,
            colSpan: 1,
            rowSpan: 1,
            memberType: memberType,
            isDrilled: false,
            parentUniqueName: parentUniqueName,
            levelUniqueName: levelUniqueName,
            hierarchy: hierarchy,
            valueSort: valueSort
        });
        return gTotals;
    }
    getDepth(tupInfo, uniqueName, memberType) {
        const memberPosition = tupInfo.uNameCollection.indexOf(uniqueName);
        const cropUName = tupInfo.uNameCollection.substring(0, memberPosition) +
            (memberType === 3 ? '' : uniqueName);
        const fieldSep = cropUName.split('::[').map((item) => {
            return item[0] === '[' ? item : ('[' + item);
        });
        if (memberType === 3 && this.rowMeasurePos === fieldSep.length) {
            fieldSep.push(uniqueName);
        }
        let nxtIndextCount = -1;
        for (let fPos = 0; fPos < fieldSep.length; fPos++) {
            const fieldMembers = fieldSep[fPos];
            const membersCount = fieldMembers.split('~~').length;
            nxtIndextCount += membersCount;
        }
        return nxtIndextCount;
    }
    checkAttributeDrill(drillInfo, axis) {
        let isDrill = false;
        for (let i = 0; i < drillInfo.length; i++) {
            isDrill = this.isAttributeDrill(drillInfo[i].hierarchy, drillInfo, axis);
            if (isDrill) {
                break;
            }
        }
        return isDrill;
    }
    frameTupCollection(members, maxLevel, tupPos, tupInfo, showSubTotals, hideTotalsObject, axis) {
        let memPos = 0;
        let allCount = 0;
        let allStartPos;
        let measure;
        let measureName;
        let measurePosition;
        const typeColl = [];
        const levelColl = [];
        const drillState = [];
        let uNameCollection = '';
        let captionCollection = '';
        let showTotals = true;
        let hideFieldPos = -1;
        while (memPos < members.length) {
            const member = members[memPos];
            const memberlevel = Number(member.querySelector('LNum').textContent);
            const memberUName = member.querySelector('UName').textContent; /* eslint-disable @typescript-eslint/no-explicit-any */
            if (Number(member.querySelector('MEMBER_TYPE').textContent) > 3) {
                member.querySelector('MEMBER_TYPE').textContent = memberUName.indexOf('[Measures]') === 0 ? '3' : '1';
            }
            const memberType = memberUName.indexOf('[Measures]') === 0 ? '3' :
                (Number(member.querySelector('MEMBER_TYPE').textContent) > 3 ? '1' : member.querySelector('MEMBER_TYPE').textContent);
            let memberCaption = member.querySelector('Caption').textContent; /* eslint-enable @typescript-eslint/no-explicit-any */
            if (this.fieldList[memberCaption] && this.fieldList[memberCaption].type === 'CalculatedField') {
                memberCaption = this.fieldList[memberCaption].caption;
                member.querySelector('Caption').textContent = memberCaption;
            }
            const hierarchy = member.getAttribute('Hierarchy');
            const parentUName = member.querySelector('PARENT_UNIQUE_NAME') ?
                member.querySelector('PARENT_UNIQUE_NAME').textContent : '';
            if (memberType === '2') {
                if (!this.isPaging) {
                    allCount++;
                }
                allStartPos = isNullOrUndefined(allStartPos) ? memPos : allStartPos;
            }
            else if (memberType === '3') {
                measure = member;
                measureName = memberUName;
                measurePosition = memPos;
                if (axis === 'column') {
                    this.colMeasures[memberUName] = member;
                    this.colMeasurePos = memPos;
                }
                else {
                    this.rowMeasurePos = memPos;
                }
            }
            else {
                hideFieldPos = hideTotalsObject[hierarchy];
            }
            if (memberType !== '2') {
                if (this.headerGrouping[memPos]) {
                    if (memberlevel > this.lastLevel[memPos]) {
                        this.lastLevel[memPos] = memberlevel;
                    }
                    else if (memberlevel < this.lastLevel[memPos]) {
                        let levelPos = this.lastLevel[memPos];
                        while (levelPos >= memberlevel) {
                            delete this.headerGrouping[memPos].UName[levelPos];
                            delete this.headerGrouping[memPos].Caption[levelPos];
                            levelPos--;
                        }
                        this.lastLevel[memPos] = memberlevel;
                    }
                    this.headerGrouping[memPos].UName[memberlevel] = memberUName;
                    this.headerGrouping[memPos].Caption[memberlevel] = memberCaption;
                }
                else {
                    this.lastLevel[memPos] = memberlevel;
                    this.headerGrouping[memPos] = {
                        UName: { [memberlevel]: memberUName },
                        Caption: { [memberlevel]: memberCaption }
                    };
                }
                if (this.isPaging) {
                    let currUName = parentUName;
                    while (this.drilledSets[currUName]) {
                        const currCaption = this.drilledSets[currUName].querySelector('Caption').textContent;
                        const currLevel = Number(this.drilledSets[currUName].querySelector('LNum').textContent);
                        this.headerGrouping[memPos].UName[currLevel] = currUName;
                        this.headerGrouping[memPos].Caption[currLevel] = currCaption;
                        currUName = this.drilledSets[currUName].querySelector('PARENT_UNIQUE_NAME') === null ? '' :
                            this.drilledSets[currUName].querySelector('PARENT_UNIQUE_NAME').textContent;
                    }
                } /* eslint-disable @typescript-eslint/no-explicit-any */
                let uNames = '';
                const uNamesKeys = Object.keys(this.headerGrouping[memPos].UName);
                for (let i = 0; i < uNamesKeys.length; i++) {
                    const j = uNamesKeys[i];
                    if (i === 0) {
                        uNames = this.headerGrouping[memPos].UName[j];
                    }
                    else {
                        uNames = uNames + '~~' + this.headerGrouping[memPos].UName[j];
                    }
                }
                uNameCollection = uNameCollection === '' ? uNames :
                    (uNameCollection + '::' + uNames);
                let captions = '';
                const captionsKeys = Object.keys(this.headerGrouping[memPos].Caption);
                for (let i = 0; i < captionsKeys.length; i++) {
                    const j = captionsKeys[i]; /* eslint-enable @typescript-eslint/no-explicit-any */
                    if (i === 0) {
                        captions = this.headerGrouping[memPos].Caption[j];
                    }
                    else {
                        captions = captions + '~~' + this.headerGrouping[memPos].Caption[j];
                    }
                }
                if (memPos !== measurePosition) {
                    captionCollection = captionCollection === '' ? captions :
                        (captionCollection + '::' + captions);
                }
            }
            typeColl.push(memberType);
            levelColl.push(memberlevel);
            if (isNullOrUndefined(maxLevel[memPos]) || maxLevel[memPos] < memberlevel) {
                maxLevel[memPos] = memberlevel;
            }
            drillState.push({ level: memberlevel, uName: memberUName, hierarchy: hierarchy, isDrilled: false });
            if (tupInfo[tupPos - 1] && tupInfo[tupPos - 1].typeCollection[memPos] === '1' &&
                drillState[memPos].level > tupInfo[tupPos - 1].drillInfo[memPos].level) {
                const uCollection = uNameCollection.split(/~~|::\[/).map((item) => {
                    return item[0] === '[' ? item : ('[' + item);
                });
                uCollection.pop();
                const parentLevel = uCollection.join('~~');
                this.setDrillInfo(parentUName, parentLevel, memPos, tupPos, tupInfo);
            }
            memPos++;
        }
        if (hideFieldPos > -1) {
            showTotals = typeColl[hideFieldPos + 1] !== '2';
        }
        tupInfo[tupPos] = {
            allCount: allCount,
            allStartPos: allStartPos,
            measure: measure,
            measureName: measureName,
            measurePosition: measurePosition,
            members: members,
            typeCollection: typeColl,
            uNameCollection: uNameCollection,
            captionCollection: captionCollection,
            levelCollection: levelColl,
            drillInfo: drillState,
            drillStartPos: -1,
            drillEndPos: -1,
            showTotals: (!showSubTotals && allCount > 0 && allStartPos > (measurePosition === 0 ? 1 : 0)) ? false : showTotals
        };
        return maxLevel;
    }
    getCaptionCollectionWithMeasure(tuple) {
        let captionColection = tuple.captionCollection;
        if (tuple.measure) {
            const measureName = tuple.measure.querySelector('Caption').textContent;
            const measurePosition = tuple.uNameCollection.split(/[~~::]+/g).indexOf(tuple.measureName);
            const captionCollectionArray = tuple.captionCollection.split(/[~~::]+/g);
            captionCollectionArray.splice(measurePosition, 0, measureName);
            captionColection = captionCollectionArray.join('.');
        }
        else {
            const captionCollectionArray = tuple.captionCollection.split(/[~~::]+/g);
            captionColection = captionCollectionArray.join('.');
        }
        return captionColection;
    }
    /**
     * It performs the set named sets position.
     *
     * @returns {void}
     * @hidden
     */
    setNamedSetsPosition() {
        this.namedSetsPosition = {};
        let axis = 0;
        do {
            const setsPositions = {};
            const axisFields = axis ? this.dataSourceSettings.rows : this.dataSourceSettings.columns;
            for (let fPos = 0; fPos < axisFields.length; fPos++) {
                if (axisFields[fPos].isNamedSet) {
                    setsPositions[fPos] = axisFields[fPos].name;
                }
            }
            this.namedSetsPosition[axis ? 'row' : 'column'] = setsPositions;
            axis++;
        } while (axis < 2);
    }
    updateRowEngine(pivotValues, valueContent, tuplesLength) {
        let currEngineCount = this.pivotValues.length - 1;
        const newEngineCount = Object.keys(pivotValues).length;
        while (currEngineCount > this.customArgs.drillInfo.currentCell.rowIndex) {
            this.pivotValues[currEngineCount + newEngineCount] = this.pivotValues[currEngineCount];
            this.pivotValues[currEngineCount + newEngineCount][0].ordinal += tuplesLength;
            this.pivotValues[currEngineCount + newEngineCount][0].rowIndex += newEngineCount;
            this.valueContent[(currEngineCount + newEngineCount) - this.rowStartPos] =
                this.valueContent[currEngineCount - this.rowStartPos];
            currEngineCount--;
        }
        // for (let key in pivotValues) {
        for (let key = 0; key < pivotValues.length; key++) {
            this.pivotValues[key] = pivotValues[key];
            this.valueContent[Number(key) - this.rowStartPos] = valueContent[Number(key) - this.rowStartPos];
        }
        this.pivotValues[this.customArgs.drillInfo.currentCell.rowIndex][0].isDrilled = true;
    }
    updateTupCollection(newTuplesCount) {
        const tupCollection = this.customArgs.drillInfo.axis === 'row' ? this.tupRowInfo : this.tupColumnInfo;
        let currTupCount = tupCollection.length - 1;
        while (currTupCount > this.customArgs.drillInfo.currentCell.ordinal) {
            tupCollection[currTupCount + newTuplesCount] = tupCollection[currTupCount];
            currTupCount--;
        }
    }
    frameGrandTotalValues(tuples, gTotals, typeColl, measurePos) {
        let tupPos = 0;
        let lastAllStartPos;
        let lastAllCount;
        const availAllMember = false;
        const withoutAllEndPos = -1;
        let isGrandtoalDataAdd = false;
        let prevTupInfo;
        const isGrandTotalTop = false;
        while (tupPos < tuples.length && !isGrandtoalDataAdd) {
            const members = tuples[this.customArgs.action === 'down' ?
                (tupPos - (this.customArgs.drillInfo.currentCell.ordinal + 1)) : tupPos].querySelectorAll('Member');
            // let memPos: number = 0;
            const allCount = this.tupRowInfo[tupPos].allCount;
            const allStartPos = this.tupRowInfo[tupPos].allStartPos;
            const measure = this.tupRowInfo[tupPos].measure;
            const typeColl = this.tupRowInfo[tupPos].typeCollection;
            const drillStartPos = this.tupRowInfo[tupPos].drillStartPos;
            const startDrillUniquename = this.tupRowInfo[tupPos].startDrillUniquename;
            // memPos = 0;
            if (tupPos === 0 && (members.length > (allCount + (measure ? 1 : 0)) || (members.length === 1 && measure))) {
                gTotals.pop();
            }
            if ((tupPos === 0 && this.isPaging) ? gTotals.length === 0 :
                (!availAllMember || allCount === lastAllCount || allStartPos !== lastAllStartPos || (members.length === 1 && measure))) {
                const attrDrill = this.checkAttributeDrill(this.tupRowInfo[tupPos].drillInfo, 'rows');
                let drillAllow = drillStartPos > -1 ? (allCount > 0 ? (attrDrill || allStartPos > drillStartPos) : true) : true;
                drillAllow = (prevTupInfo && drillAllow && drillStartPos > -1) ?
                    (prevTupInfo.startDrillUniquename !== startDrillUniquename ? true :
                        ((withoutAllEndPos > prevTupInfo.measurePosition ? false :
                            prevTupInfo.measureName !== this.tupRowInfo[tupPos].measureName) &&
                            (allStartPos === (drillStartPos + 1) ||
                                this.tupRowInfo[tupPos].measurePosition === (drillStartPos + 1))))
                    : drillAllow;
                if (members.length === allCount + (measure ? 1 : 0) && measure && !isGrandTotalTop) {
                    const levelName = 'Grand Total.' + members[measurePos].querySelector('Caption').textContent;
                    const formattedText = (typeColl[measurePos] === '3' &&
                        this.dataFields[this.getUniqueName(members[measurePos].querySelector('UName').textContent)] &&
                        this.dataFields[this.getUniqueName(members[measurePos].querySelector('UName').textContent)].caption) ?
                        this.dataFields[this.getUniqueName(members[measurePos].querySelector('UName').textContent)].caption :
                        members[measurePos].querySelector('Caption').textContent;
                    gTotals = this.frameGrandTotalAxisSet(gTotals, this.getUniqueName(members[measurePos].querySelector('UName').textContent), formattedText, this.pivotValues.length, tupPos, Number(typeColl[measurePos]), members[measurePos].querySelector('PARENT_UNIQUE_NAME') ?
                        members[measurePos].querySelector('PARENT_UNIQUE_NAME').textContent : undefined, members[measurePos].querySelector('LName').textContent, members[measurePos].getAttribute('Hierarchy'), {
                        levelName: levelName, axis: members[measurePos].getAttribute('Hierarchy')
                    });
                    gTotals[gTotals.length - 1].valueSort['Grand Total.' + members[measurePos].querySelector('Caption').textContent] = 1;
                }
                lastAllCount = allCount;
                lastAllStartPos = allStartPos;
            }
            isGrandtoalDataAdd = this.dataSourceSettings.values.length + 1 === gTotals.length ? true : false;
            tupPos++;
        }
        return gTotals;
    }
    frameColumnHeader(tuples) {
        this.headerGrouping = {};
        this.lastLevel = [];
        let tupPos = 0;
        let maxLevel = [];
        const allType = [];
        const minLevel = [];
        let withoutAllStartPos = -1;
        let withoutAllEndPos = -1;
        const newTupPosition = (this.customArgs.drillInfo && this.customArgs.drillInfo.axis === 'column') ?
            (this.customArgs.drillInfo.currentCell.ordinal + 1) : 0;
        while (tupPos < tuples.length) {
            const members = tuples[tupPos].querySelectorAll('Member');
            maxLevel = this.frameTupCollection(members, maxLevel, (tupPos + newTupPosition), this.tupColumnInfo, this.showColumnSubTotals, this.hideColumnTotalsObject, 'column');
            tupPos++;
        }
        if (tuples.length > 0) {
            const members = tuples[0].querySelectorAll('Member');
            let memPos = 0;
            while (memPos < members.length) {
                minLevel[memPos] = (members[memPos].querySelector('MEMBER_TYPE').textContent === '1' &&
                    Number(members[memPos].querySelector('LNum').textContent) === 0) ? 0 :
                    Number(members[memPos].querySelector('LNum').textContent);
                if (members[memPos].querySelector('MEMBER_TYPE').textContent === '1' &&
                    (this.isPaging || Number(members[memPos].querySelector('LNum').textContent) === 0)) {
                    allType[memPos] = 0;
                    withoutAllStartPos = withoutAllStartPos === -1 ? memPos : withoutAllStartPos;
                    withoutAllEndPos = memPos;
                }
                else {
                    allType[memPos] = 1;
                }
                memPos++;
            }
        }
        tupPos = 0;
        let position = 1;
        const lastSavedInfo = {};
        let isSubTotIncluded = true;
        let withoutAllAvail = false;
        let lastRealTup;
        while (tupPos < tuples.length) {
            const members = tuples[tupPos].querySelectorAll('Member');
            const allCount = this.tupColumnInfo[tupPos].allCount;
            const allStartPos = this.tupColumnInfo[tupPos].allStartPos;
            const measure = this.tupColumnInfo[tupPos].measure;
            const typeColl = this.tupColumnInfo[tupPos].typeCollection;
            const drillInfo = this.tupColumnInfo[tupPos].drillInfo;
            const drillStartPos = this.tupColumnInfo[tupPos].drillStartPos;
            const startDrillUniquename = this.tupColumnInfo[tupPos].startDrillUniquename;
            const endDrillUniquename = this.tupColumnInfo[tupPos].endDrillUniquename;
            const drillEndPos = this.tupColumnInfo[tupPos].drillEndPos;
            const levelColl = this.tupColumnInfo[tupPos].levelCollection;
            let isStartCol = typeColl[0] === '2' ? false : (typeColl[0] === '3' ? typeColl[1] !== '2' : true);
            let depth = 0;
            maxLevel.map((item, pos) => {
                depth = depth + (allType[pos] === 0 ? (item + (1 - (minLevel[pos] > 1 ? 1 : minLevel[pos]))) :
                    (item === 0 ? ((this.isPaging && typeColl[pos] === '2') ? 0 : 1) : item));
            });
            this.colDepth = this.colDepth > depth ? this.colDepth : depth;
            if (tupPos === 0 && members.length > (allCount + (measure ? 1 : 0))) {
                withoutAllAvail = true;
                isStartCol = (allCount > 0 && isStartCol) ? (allStartPos > withoutAllStartPos) : isStartCol;
            }
            let isGrandTotalTop = false;
            if (this.dataSourceSettings.grandTotalsPosition === 'Top' && this.dataSourceSettings.showGrandTotals &&
                this.dataSourceSettings.showColumnGrandTotals) {
                let count = 0;
                for (let i = 0; i < members.length; i++) {
                    if ((members[i].querySelector('Caption').textContent).indexOf('All') === 0) {
                        count++;
                    }
                }
                isGrandTotalTop = count === (this.olapValueAxis === 'column' ? this.dataSourceSettings.columns.length - 1 :
                    this.dataSourceSettings.columns.length);
            }
            if (isStartCol || isGrandTotalTop) {
                if (allCount === 0 || isGrandTotalTop) {
                    let levelComp = [-1, -1, -1];
                    if (this.tupColumnInfo[tupPos - 1] && this.tupColumnInfo[tupPos - 1].allCount === 0) {
                        levelComp = this.levelCompare(levelColl, this.tupColumnInfo[tupPos - 1].levelCollection);
                    }
                    else if (withoutAllAvail && lastRealTup) {
                        levelComp = this.levelCompare(levelColl, lastRealTup.levelCollection);
                    }
                    if (this.tupColumnInfo[tupPos].drillStartPos < 0 || this.showSubTotalsAtTop) {
                        if (!isSubTotIncluded && levelComp[0] > -1 && levelComp[2] > -1) {
                            position = this.mergeTotCollection(position, allCount, maxLevel, minLevel, allType, allStartPos, drillInfo, levelComp);
                        }
                        this.setParentCollection(members);
                        this.frameCommonColumnLoop(members, tupPos, position, maxLevel, allType, minLevel);
                        if (!this.tupColumnInfo[tupPos].showTotals) {
                            position--;
                        }
                        if (!isSubTotIncluded && levelComp[0] > -1 && levelComp[2] > -1) {
                            position = this.mergeTotCollection(position, allCount, maxLevel, minLevel, allType, allStartPos, drillInfo, levelComp);
                        }
                        isSubTotIncluded = false;
                        if (!this.isColDrill) {
                            position++;
                        }
                        else {
                            this.isColDrill = false;
                        }
                    }
                    else if (lastSavedInfo.drillStartPos === drillStartPos ?
                        (lastSavedInfo.startDrillUniquename !== startDrillUniquename ||
                            lastSavedInfo.allCount === allCount) : true) {
                        if (!isSubTotIncluded && levelComp[0] > -1 && levelComp[2] > -1) {
                            position = this.mergeTotCollection(position, allCount, maxLevel, minLevel, allType, allStartPos, drillInfo, levelComp);
                            isSubTotIncluded = true;
                        }
                        this.setParentCollection(members);
                        if (withoutAllAvail ? (withoutAllEndPos <= drillStartPos) : true) {
                            if (!isGrandTotalTop) {
                                this.totalCollection[this.totalCollection.length] =
                                    ({ allCount: allCount, ordinal: tupPos, members: members, drillInfo: drillInfo });
                            }
                            lastSavedInfo.allCount = allCount;
                            lastSavedInfo.allStartPos = allStartPos;
                            lastSavedInfo.drillStartPos = drillStartPos;
                            lastSavedInfo.startDrillUniquename = startDrillUniquename;
                            lastSavedInfo.endDrillUniquename = endDrillUniquename;
                        }
                    }
                    lastRealTup = this.tupColumnInfo[tupPos];
                }
            }
            const attrDrill = this.checkAttributeDrill(this.tupColumnInfo[tupPos].drillInfo, 'columns');
            if (allCount > 0 && (withoutAllAvail ? (isStartCol && (attrDrill || withoutAllEndPos < allStartPos)) : true)) {
                if (allCount === lastSavedInfo.allCount || allStartPos !== lastSavedInfo.allStartPos) {
                    const endAllow = drillEndPos !== drillStartPos ?
                        (lastSavedInfo.endDrillUniquename === endDrillUniquename) : true;
                    const allow = allStartPos !== lastSavedInfo.allStartPos ?
                        (lastSavedInfo.startDrillUniquename !== startDrillUniquename) : endAllow;
                    if (drillStartPos > -1 ? (allow) : true) {
                        if (!isSubTotIncluded) {
                            position = this.mergeTotCollection(position, allCount, maxLevel, minLevel, allType, allStartPos, drillInfo);
                            isSubTotIncluded = true;
                        }
                        this.setParentCollection(members);
                        if ((withoutAllAvail && drillStartPos > -1) ? (withoutAllEndPos <= drillStartPos) : true) {
                            if (!isGrandTotalTop) {
                                this.totalCollection[this.totalCollection.length] =
                                    ({
                                        allCount: allCount, ordinal: tupPos, members: members,
                                        allStartPos: allStartPos, drillInfo: drillInfo
                                    });
                            }
                            lastSavedInfo.allCount = allCount;
                            lastSavedInfo.allStartPos = allStartPos;
                            lastSavedInfo.drillStartPos = drillStartPos;
                            lastSavedInfo.startDrillUniquename = startDrillUniquename;
                            lastSavedInfo.endDrillUniquename = endDrillUniquename;
                        }
                    }
                }
            }
            tupPos++;
        }
        if (this.totalCollection.length > 0) {
            if (Object.keys(this.colMeasures).length > 1) {
                this.orderTotals(position, maxLevel, allType, minLevel);
            }
            else {
                this.totalCollection = this.totalCollection.reverse();
                for (const coll of this.totalCollection) {
                    const isGrandTotal = this.tupColumnInfo[coll.ordinal].measurePosition === 0 ?
                        this.tupColumnInfo[coll.ordinal].allStartPos === 1 : this.tupColumnInfo[coll.ordinal].allStartPos === 0;
                    if (isGrandTotal ? (this.dataSourceSettings.showGrandTotals && this.dataSourceSettings.showColumnGrandTotals) : true) {
                        this.frameCommonColumnLoop(coll.members, coll.ordinal, position, maxLevel, minLevel, allType);
                        const attrDrill = this.checkAttributeDrill(this.tupColumnInfo[coll.ordinal].drillInfo, 'columns');
                        if (this.tupColumnInfo[coll.ordinal].showTotals || attrDrill) {
                            position++;
                        }
                    }
                }
            }
        }
    }
    orderTotals(position, maxLevel, allType, minLevel) {
        const groupColl = {};
        let maxCnt = 1;
        for (const coll of this.totalCollection) {
            const isGrandTotal = this.tupColumnInfo[coll.ordinal].measurePosition === 0 ?
                this.tupColumnInfo[coll.ordinal].allStartPos === 1 : this.tupColumnInfo[coll.ordinal].allStartPos === 0;
            if (isGrandTotal ? (this.dataSourceSettings.showGrandTotals && this.dataSourceSettings.showColumnGrandTotals) : true) {
                const measureName = this.tupColumnInfo[coll.ordinal].measure.querySelector('UName').textContent;
                if (groupColl[measureName]) {
                    groupColl[measureName].coll.push(coll);
                    groupColl[measureName].count++;
                    maxCnt = maxCnt < groupColl[measureName].count ? groupColl[measureName].count : maxCnt;
                }
                else {
                    groupColl[measureName] = { coll: [coll], count: 1 };
                }
            }
        }
        const keys = Object.keys(groupColl);
        let collLength = maxCnt - 1;
        while (collLength > -1) {
            for (const key of keys) {
                const coll = groupColl[key].coll[collLength];
                if (coll) {
                    this.frameCommonColumnLoop(coll.members, coll.ordinal, position, maxLevel, allType, minLevel);
                    if (this.tupColumnInfo[coll.ordinal].showTotals) {
                        position++;
                    }
                }
            }
            collLength--;
        }
    }
    setParentCollection(members) {
        let memPos = 0;
        while (members.length > memPos) {
            const member = members[memPos];
            const memberType = Number(member.querySelector('MEMBER_TYPE').textContent) > 2 ? '3' :
                member.querySelector('MEMBER_TYPE').textContent;
            const memberlevel = Number(member.querySelector('LNum').textContent);
            const memberUName = member.querySelector('UName').textContent;
            const parentUName = member.querySelector('PARENT_UNIQUE_NAME') ?
                member.querySelector('PARENT_UNIQUE_NAME').textContent : '';
            let isSameParent = true;
            let isWithoutAllMember = false;
            if (this.parentObjCollection[memPos]) {
                const levelCollection = Object.keys(this.parentObjCollection[memPos]);
                const parentMember = this.parentObjCollection[memPos][memberlevel - 1];
                isSameParent = parentMember ? parentUName === parentMember.querySelector('UName').textContent :
                    levelCollection.length === 0;
                isWithoutAllMember = this.tupColumnInfo[0].typeCollection[memPos] === '1';
            }
            if (memberType === '2') {
                delete this.parentObjCollection[memPos];
            }
            else {
                if ((this.isPaging || isWithoutAllMember) ? !isSameParent : false) {
                    delete this.parentObjCollection[memPos];
                }
                if (!this.parentObjCollection[memPos]) {
                    this.parentObjCollection[memPos] = {};
                    this.parentObjCollection[memPos][memberlevel] = member;
                }
                else if (!this.parentObjCollection[memPos][memberlevel] ||
                    this.parentObjCollection[memPos][memberlevel].querySelector('UName').textContent !== memberUName) {
                    this.parentObjCollection[memPos][memberlevel] = member;
                }
            }
            memPos++;
        }
    }
    setDrillInfo(pUName, parentLvlCollection, memPos, tupPos, tupInfo) {
        tupPos--;
        while (tupInfo[tupPos] && tupInfo[tupPos].drillInfo[memPos].uName === pUName) {
            const prevUcollection = tupInfo[tupPos].uNameCollection.split(/~~|::\[/).map((item) => {
                return item[0] === '[' ? item : ('[' + item);
            });
            if (prevUcollection.join('~~').indexOf(parentLvlCollection) < 0) {
                break;
            }
            tupInfo[tupPos].drillInfo[memPos].isDrilled = true;
            if (this.curDrillEndPos <= memPos) {
                tupInfo[tupPos].drillEndPos = this.curDrillEndPos = memPos;
                tupInfo[tupPos].endDrillUniquename = pUName;
            }
            if (tupInfo[tupPos].drillStartPos > memPos || tupInfo[tupPos].drillStartPos === -1) {
                tupInfo[tupPos].drillStartPos = memPos;
            }
            tupInfo[tupPos].startDrillUniquename = pUName;
            tupPos--;
        }
    }
    levelCompare(newLevels, oldLevels) {
        let changePos = [-1, 0];
        for (let lPos = 0; lPos < oldLevels.length; lPos++) {
            if (newLevels[lPos] !== oldLevels[lPos]) {
                changePos = [lPos, newLevels[lPos], (oldLevels[lPos] - newLevels[lPos])];
                break;
            }
        }
        return changePos;
    }
    mergeTotCollection(position, allCount, maxLevel, allType, minLevel, allStartPos, drillInfo, levelComp) {
        const prevHdrPos = isNullOrUndefined(allStartPos) ? levelComp[0] : (allStartPos - ((this.colMeasurePos === (allStartPos - 1)) ? 2 : 1));
        const flagLevel = drillInfo[prevHdrPos] && drillInfo[prevHdrPos].level;
        const flagLevelString = this.getLevelsAsString(prevHdrPos - 1, drillInfo);
        const groupColl = {};
        let maxCnt = 1;
        let enterFlag = false;
        for (const coll of this.totalCollection) {
            if (enterFlag || (coll.allCount <= allCount &&
                ((flagLevel > -1 && coll.drillInfo[prevHdrPos]) ? ((coll.drillInfo[prevHdrPos].level >= flagLevel) &&
                    (this.getLevelsAsString(prevHdrPos - 1, coll.drillInfo)) === flagLevelString) : true))) {
                const measureName = this.tupColumnInfo[coll.ordinal].measure ?
                    this.tupColumnInfo[coll.ordinal].measure.querySelector('UName').textContent : 'measure';
                if (groupColl[measureName]) {
                    groupColl[measureName].coll.push(coll);
                    groupColl[measureName].count++;
                    maxCnt = maxCnt < groupColl[measureName].count ? groupColl[measureName].count : maxCnt;
                }
                else {
                    groupColl[measureName] = { coll: [coll], count: 1 };
                }
                enterFlag = false;
            }
        }
        const keys = Object.keys(groupColl);
        let collLength = maxCnt - 1;
        while (collLength > -1) {
            for (const key of keys) {
                const coll1 = groupColl[key].coll[collLength];
                if (coll1) {
                    const isGrandTotal = this.tupColumnInfo[coll1.ordinal].measurePosition === 0 ?
                        this.tupColumnInfo[coll1.ordinal].allStartPos === 1 : this.tupColumnInfo[coll1.ordinal].allStartPos === 0;
                    if (isGrandTotal ? (this.dataSourceSettings.showGrandTotals && this.dataSourceSettings.showColumnGrandTotals) : true) {
                        this.frameCommonColumnLoop(coll1.members, coll1.ordinal, position, maxLevel, minLevel, allType);
                        if (this.tupColumnInfo[coll1.ordinal].showTotals) {
                            position++;
                        }
                    }
                    this.totalCollection.pop();
                }
            }
            collLength--;
        }
        return position;
    }
    getLevelsAsString(prevHdrPos, drillInfo) {
        const lvlCollection = [];
        for (let pos = 0; pos < prevHdrPos; pos++) {
            lvlCollection[pos] = drillInfo[pos].level;
        }
        return lvlCollection.length > 0 ? lvlCollection.toString() : '';
    }
    frameCommonColumnLoop(members, tupPos, position, maxLevel, minLevel, allType) {
        let drillMemberPosition = -1;
        if (this.tupColumnInfo[tupPos].showTotals) {
            let memberPos = 0;
            let memberDepth = 0;
            while (memberPos < members.length) {
                memberDepth += (allType[memberPos] > 0 &&
                    this.getMeasurePosition(this.tupColumnInfo[tupPos].uNameCollection, this.tupColumnInfo[tupPos].measurePosition) !== memberPos) ?
                    maxLevel[memberPos] :
                    (maxLevel[memberPos] + (1 - minLevel[memberPos]));
                if (this.tupColumnInfo[tupPos].drillInfo[memberPos].isDrilled &&
                    this.tupColumnInfo[tupPos].showTotals) {
                    this.tupColumnInfo[tupPos].showTotals = !this.showColumnSubTotals ? false :
                        this.hideColumnTotalsObject[this.tupColumnInfo[tupPos].drillInfo[memberPos].hierarchy] ===
                            undefined;
                    memberDepth -= maxLevel[memberPos] -
                        this.tupColumnInfo[tupPos].levelCollection[memberPos];
                    drillMemberPosition = this.tupColumnInfo[tupPos].showTotals ? -1 : (memberDepth - 1);
                }
                memberPos++;
            }
        }
        const attrDrill = this.checkAttributeDrill(this.tupColumnInfo[tupPos].drillInfo, 'columns');
        if (this.tupColumnInfo[tupPos].showTotals || attrDrill) {
            let memPos = 0;
            let spanMemPos = 0;
            const colMembers = {};
            while (memPos < members.length) {
                let member = members[memPos];
                const memberType = Number(member.querySelector('MEMBER_TYPE').textContent) > 2 ? '3' :
                    member.querySelector('MEMBER_TYPE').textContent;
                let memDup = 0;
                for (let rowDepthPos = memberType !== '2' ? (allType[memPos] ? 1 : minLevel[memPos]) : 1; rowDepthPos <= (memberType === '3' ? 1 : maxLevel[memPos]); rowDepthPos++) {
                    let isDrilled = false;
                    if (!this.pivotValues[spanMemPos]) {
                        this.pivotValues[spanMemPos] = [];
                    }
                    if (Number(members[memPos].querySelector('LNum').textContent) > rowDepthPos && memberType !== '2') {
                        if (!this.parentObjCollection[memPos][rowDepthPos]) {
                            this.getDrilledParent(members[memPos], rowDepthPos, this.parentObjCollection[memPos]);
                        }
                        if (this.parentObjCollection[memPos][rowDepthPos]) {
                            member = this.parentObjCollection[memPos][rowDepthPos];
                        }
                        isDrilled = true;
                    }
                    else {
                        member = members[memPos];
                        memDup++;
                    }
                    if (memberType !== '2') {
                        colMembers[member.querySelector('UName').textContent] = member.querySelector('Caption').textContent;
                    }
                    let levelName = ''; /* eslint-disable @typescript-eslint/no-explicit-any */
                    const levelNameKeys = Object.keys(colMembers);
                    for (let i = 0; i < levelNameKeys.length; i++) {
                        const j = levelNameKeys[i];
                        if (i === 0) {
                            levelName = colMembers[j];
                        }
                        else {
                            levelName = levelName + this.valueSortSettings.headerDelimiter + colMembers[j];
                        }
                    } /* eslint-enable @typescript-eslint/no-explicit-any */
                    const isNamedSet = this.namedSetsPosition['column'][memPos] ? true : false;
                    const uName = this.getUniqueName(member.querySelector('UName').textContent);
                    const depth = this.getDepth(this.tupColumnInfo[tupPos], uName, Number(memberType));
                    if (!(this.isPaging && this.pivotValues[spanMemPos - 1] && this.pivotValues[spanMemPos - 1][position] &&
                        this.fieldList[this.pivotValues[spanMemPos - 1][position].hierarchy] &&
                        this.fieldList[this.pivotValues[spanMemPos - 1][position].hierarchy].isHierarchy &&
                        this.pivotValues[spanMemPos - 1][position].hasChild &&
                        !this.pivotValues[spanMemPos - 1][position].isDrilled &&
                        !this.columns[memPos].isNamedSet && this.fieldList[member.getAttribute('Hierarchy')] &&
                        (this.fieldList[member.getAttribute('Hierarchy')].isHierarchy ||
                            this.fieldList[member.getAttribute('Hierarchy')].hasAllMember) &&
                        this.pivotValues[spanMemPos - 1][position].depth < depth)) {
                        this.pivotValues[spanMemPos][position] = {
                            axis: 'column',
                            actualText: uName,
                            colIndex: position,
                            formattedText: (memberType === '3' && this.dataFields[uName] &&
                                this.dataFields[uName].caption) ? this.dataFields[uName].caption :
                                member.querySelector('Caption').textContent,
                            hasChild: (this.fieldList[member.getAttribute('Hierarchy')] &&
                                this.fieldList[member.getAttribute('Hierarchy')].isHierarchy && memPos < this.columns.length - 1 &&
                                !this.columns[memPos + 1].isNamedSet && this.columns[memPos + 1].name.indexOf('[Measures]') < 0 &&
                                this.fieldList[this.columns[memPos + 1].name] &&
                                this.fieldList[this.columns[memPos + 1].name].hasAllMember) ?
                                true : Number(member.querySelector('CHILDREN_CARDINALITY').textContent) > 0 ? true : false,
                            level: memDup > 1 ? -1 : (Number(member.querySelector('LNum').textContent) -
                                ((allType[memPos] && memberType !== '3') ? 1 : 0)),
                            rowIndex: spanMemPos,
                            ordinal: tupPos,
                            memberType: Number(memberType),
                            depth: depth,
                            isDrilled: (this.fieldList[member.getAttribute('Hierarchy')] &&
                                this.fieldList[member.getAttribute('Hierarchy')].isHierarchy &&
                                !this.isAttributeDrill(member.getAttribute('Hierarchy'), this.tupColumnInfo[tupPos].drillInfo, 'columns')) ? true :
                                (isDrilled || this.tupColumnInfo[tupPos].drillInfo[memPos].isDrilled),
                            parentUniqueName: member.querySelector('PARENT_UNIQUE_NAME') ?
                                member.querySelector('PARENT_UNIQUE_NAME').textContent : undefined,
                            levelUniqueName: member.querySelector('LName').textContent,
                            hierarchy: member.getAttribute('Hierarchy'),
                            isNamedSet: isNamedSet,
                            valueSort: { levelName: levelName, [levelName]: 1, axis: member.getAttribute('Hierarchy') }
                        };
                        if (!this.headerContent[spanMemPos]) {
                            this.headerContent[spanMemPos] = {};
                        }
                        this.headerContent[spanMemPos][position] =
                            this.pivotValues[spanMemPos][position];
                        spanMemPos++;
                    }
                    else {
                        this.isColDrill = true;
                        break;
                    }
                }
                memPos++;
            }
        }
        else {
            if (drillMemberPosition > -1) {
                this.pivotValues[drillMemberPosition][position - 1].ordinal = tupPos;
            }
            else if (this.tupColumnInfo[tupPos].allCount > 0) {
                let memberPos = 0;
                let memberDepth = 0;
                while (memberPos < this.tupColumnInfo[tupPos].allStartPos) {
                    memberDepth += (allType[memberPos] > 0 &&
                        this.getMeasurePosition(this.tupColumnInfo[tupPos].uNameCollection, this.tupColumnInfo[tupPos].measurePosition) !== memberPos) ?
                        maxLevel[memberPos] :
                        (maxLevel[memberPos] + (1 - minLevel[memberPos]));
                    memberPos++;
                }
                if (this.tupColumnInfo[tupPos].allStartPos === (this.tupColumnInfo[tupPos].measurePosition + 1)) {
                    memberDepth -= maxLevel[this.tupColumnInfo[tupPos].allStartPos - 2] -
                        this.tupColumnInfo[tupPos].levelCollection[this.tupColumnInfo[tupPos].allStartPos - 2] + 1;
                }
                else {
                    memberDepth -= maxLevel[this.tupColumnInfo[tupPos].allStartPos - 1] -
                        this.tupColumnInfo[tupPos].levelCollection[this.tupColumnInfo[tupPos].allStartPos - 1];
                }
                if (this.pivotValues[memberDepth - 1]) {
                    this.pivotValues[memberDepth - 1][position - 1].ordinal = tupPos;
                }
            }
        }
    }
    isAttributeDrill(hierarchy, drillInfo, axis) {
        let isDrill = false;
        const isAdjacent = this.isAdjacentToMeasure(hierarchy, axis);
        if (!isAdjacent) {
            for (let i = 0; i < this.drilledMembers.length; i++) {
                if (this.drilledMembers[i].name === hierarchy) {
                    for (let j = 0; j < this.drilledMembers[i].items.length; j++) {
                        const delimiter = this.drilledMembers[i].delimiter;
                        const drillItems = this.drilledMembers[i].items[j].split(delimiter);
                        let levelName = '';
                        for (let k = 0; k < drillItems.length; k++) {
                            if (drillInfo[k] && drillInfo[k].uName) {
                                levelName = levelName + (levelName === '' ? '' : this.drilledMembers[i].delimiter) +
                                    drillInfo[k].uName;
                            }
                        }
                        if (levelName === this.drilledMembers[i].items[j]) {
                            isDrill = true;
                            break;
                        }
                    }
                }
            }
        }
        return isDrill;
    }
    isAdjacentToMeasure(hierarchy, axis) {
        let isAdjacent = false;
        const fields = axis === 'rows' ? this.rows : this.columns;
        for (let i = 0; i < fields.length; i++) {
            if (fields[i].name === hierarchy && fields[i + 1] && (fields[i + 1].name === '[Measures]' ||
                fields[i + 1].isNamedSet || (this.fieldList[fields[i + 1].name] &&
                !this.fieldList[fields[i + 1].name].hasAllMember))) {
                isAdjacent = true;
                break;
            }
        }
        return isAdjacent;
    }
    getDrilledParent(childMember, parentLevel, savedCollection) {
        const childlevel = Number(childMember.querySelector('LNum').textContent);
        let currentChild = childMember;
        for (let lvl = childlevel - 1; lvl >= parentLevel; lvl--) {
            const currentParent = this.drilledSets[currentChild.querySelector('PARENT_UNIQUE_NAME').textContent];
            if (currentParent) {
                savedCollection[lvl] = currentParent;
                currentChild = currentParent;
            }
            else {
                break;
            }
        }
    }
    performRowSorting() {
        if (this.enableSort && this.tupRowInfo.length > 0) {
            const rowCount = this.pivotValues.length;
            const lvlGrouping = {};
            const measureObjects = {};
            let gSumGrouping = [];
            let gSumFlag = false;
            const withoutAllLastPos = this.tupRowInfo[0].typeCollection.lastIndexOf('1');
            let isDrilled;
            for (let rPos = this.colDepth; rPos < rowCount; rPos++) {
                const currentCell = this.pivotValues[rPos][0];
                if (this.showSubTotalsAtBottom && currentCell.isSum && currentCell.memberType !== 3) {
                    continue;
                }
                const currentTuple = this.tupRowInfo[currentCell.ordinal];
                let uniqueName = currentTuple ? (currentTuple.measurePosition === 0 && currentCell.memberType === 3 ?
                    currentTuple.measureName : currentTuple.uNameCollection) : '';
                if (uniqueName !== '') {
                    if (withoutAllLastPos > -1) {
                        uniqueName = this.frameUniqueName(uniqueName, currentCell, currentTuple);
                    }
                    const level = uniqueName.split(/~~|::\[/).length;
                    if (currentCell.memberType === 3 && this.tupRowInfo[0].measurePosition > 0) {
                        const parentUName = this.getParentUname(uniqueName, currentCell, true, true);
                        if (measureObjects[parentUName]) {
                            measureObjects[parentUName].push(currentCell);
                        }
                        else {
                            measureObjects[parentUName] = [currentCell];
                        }
                    }
                    else if (lvlGrouping[level]) {
                        lvlGrouping[level][uniqueName] = [currentCell];
                    }
                    else {
                        lvlGrouping[level] = { [uniqueName]: [currentCell] };
                    }
                }
                if (gSumFlag) {
                    gSumGrouping.push(currentCell);
                }
                if (currentCell.type === 'grand sum') {
                    gSumFlag = true;
                }
            }
            const isMeasureAvail = Object.keys(measureObjects).length > 0 && this.tupRowInfo[0].measurePosition > 0;
            const levels = Object.keys(lvlGrouping).map((item) => {
                return Number(item);
            }).sort((a, b) => (a > b) ? 1 : ((b > a) ? -1 : 0));
            const sortLvlGrouping = {};
            for (let lPos = levels.length - 1; lPos >= 0; lPos--) {
                const parentGrouping = {};
                const objCollection = lvlGrouping[levels[lPos]];
                const objKeys = Object.keys(objCollection);
                for (let oPos = 0; oPos < objKeys.length; oPos++) {
                    const parentUName = lPos === 0 ? 'parent' :
                        this.getParentUname(objKeys[oPos], objCollection[objKeys[oPos]][0], isMeasureAvail, false);
                    if (parentGrouping[parentUName]) {
                        parentGrouping[parentUName].push(objCollection[objKeys[oPos]][0]);
                    }
                    else {
                        parentGrouping[parentUName] = [objCollection[objKeys[oPos]]][0];
                    }
                }
                const pKeys = Object.keys(parentGrouping);
                for (let kPos = 0; kPos < pKeys.length; kPos++) {
                    parentGrouping[pKeys[kPos]] = this.sortRowHeaders(parentGrouping[pKeys[kPos]]);
                }
                if (sortLvlGrouping[levels[lPos + 1]]) {
                    for (let kPos = 0; kPos < pKeys.length; kPos++) {
                        let groupSets = [];
                        const axisSets = parentGrouping[pKeys[kPos]];
                        for (let aPos = 0; aPos < axisSets.length; aPos++) {
                            const tupInfo = this.tupRowInfo[axisSets[aPos].ordinal];
                            let uName = (tupInfo.measurePosition === 0 && axisSets[aPos].memberType === 3) ?
                                tupInfo.measureName : tupInfo.uNameCollection;
                            groupSets.push(axisSets[aPos]);
                            if (withoutAllLastPos > -1) {
                                uName = this.frameUniqueName(uName, axisSets[aPos], tupInfo);
                            }
                            let isMembersIncluded = false;
                            if (isMeasureAvail) {
                                const parentUName = this.getParentUname(uName, axisSets[aPos], isMeasureAvail, true);
                                if (measureObjects[parentUName]) {
                                    measureObjects[parentUName] = this.sortRowHeaders(measureObjects[parentUName]);
                                    const isLastMeasure = uName.lastIndexOf('::[') === uName.indexOf('::[Measures]');
                                    const isFullLength = uName.split('::[').length - 1 === tupInfo.measurePosition;
                                    const isLastNotDrilledMember = !tupInfo.drillInfo[tupInfo.measurePosition - 1].isDrilled;
                                    const isActualLastMember = tupInfo.members.length > (tupInfo.measurePosition + 1);
                                    if (isLastMeasure && isFullLength && isLastNotDrilledMember && isActualLastMember) {
                                        isMembersIncluded = true;
                                        for (let mPos = 0; mPos < measureObjects[parentUName].length; mPos++) {
                                            groupSets.push(measureObjects[parentUName][mPos]);
                                            const matchParent = (uName.substring(0, uName.indexOf('::[Measures]')) + '::' + measureObjects[parentUName][mPos].actualText);
                                            if (sortLvlGrouping[levels[lPos + 1]][matchParent]) {
                                                groupSets = groupSets.concat(sortLvlGrouping[levels[lPos + 1]][matchParent]);
                                            }
                                        }
                                    }
                                    else {
                                        isDrilled = this.showSubTotalsAtBottom && groupSets[groupSets.length - 1].isDrilled;
                                        groupSets = groupSets.concat(measureObjects[parentUName]);
                                    }
                                }
                            }
                            if (!isMembersIncluded &&
                                sortLvlGrouping[levels[lPos + 1]][uName]) {
                                if (this.showSubTotalsAtBottom && groupSets[groupSets.length - 1].memberType === 3 &&
                                    groupSets[groupSets.length - 1].level > -1 && isDrilled) {
                                    let valueColl = [];
                                    let sliceIndex = 0;
                                    for (let i = groupSets.length - 1; i >= 0; i--) {
                                        if (groupSets[i].memberType === 3) {
                                            valueColl[valueColl.length] = groupSets[i];
                                        }
                                        else {
                                            valueColl = valueColl.reverse();
                                            sliceIndex = i + 1;
                                            break;
                                        }
                                    }
                                    groupSets = groupSets.slice(0, sliceIndex).concat(sortLvlGrouping[levels[lPos + 1]][uName]).concat(valueColl);
                                }
                                else {
                                    const currentCell = groupSets[groupSets.length - 1];
                                    let subTotal;
                                    if (this.showSubTotalsAtBottom && currentCell.isDrilled) {
                                        subTotal = PivotUtil.frameHeaderWithKeys(currentCell);
                                        subTotal.hasChild = false;
                                        subTotal.isDrilled = false;
                                        subTotal.isSum = true;
                                        subTotal.formattedText = subTotal.formattedText + ' Total';
                                    }
                                    groupSets = groupSets.concat(sortLvlGrouping[levels[lPos + 1]][uName]);
                                    if (subTotal) {
                                        groupSets[groupSets.length] = subTotal;
                                    }
                                }
                            }
                        }
                        parentGrouping[pKeys[kPos]] = groupSets;
                    }
                }
                else if (isMeasureAvail) {
                    for (let kPos = 0; kPos < pKeys.length; kPos++) {
                        const axisSets = parentGrouping[pKeys[kPos]];
                        let groupSets = [];
                        for (let aPos = 0; aPos < axisSets.length; aPos++) {
                            groupSets.push(axisSets[aPos]);
                            let uName = this.tupRowInfo[axisSets[aPos].ordinal].uNameCollection;
                            if (withoutAllLastPos > -1) {
                                uName = this.frameUniqueName(uName, axisSets[aPos], this.tupRowInfo[axisSets[aPos].ordinal]);
                            }
                            const parentUName = this.getParentUname(uName, axisSets[aPos], true, true);
                            if (measureObjects[parentUName]) {
                                measureObjects[parentUName] = this.sortRowHeaders(measureObjects[parentUName]);
                                groupSets = groupSets.concat(measureObjects[parentUName]);
                            }
                        }
                        parentGrouping[pKeys[kPos]] = groupSets;
                    }
                }
                sortLvlGrouping[levels[lPos]] = parentGrouping;
            }
            let newPos = 0;
            let totPos = 0;
            let valuePos = 0;
            gSumFlag = false;
            gSumGrouping = this.sortRowHeaders(gSumGrouping);
            for (let rPos = this.colDepth; rPos < rowCount; rPos++) {
                if (this.dataSourceSettings.grandTotalsPosition === 'Top' && (this.dataSourceSettings.showGrandTotals && this.dataSourceSettings.showRowGrandTotals) &&
                    ((this.olapValueAxis === 'column' && this.colDepth + 1 === rPos) || (this.olapValueAxis === 'row' && this.colDepth + this.dataSourceSettings.values.length + 1 === rPos))) {
                    newPos = 0;
                    gSumFlag = false;
                }
                const cell = gSumFlag ? gSumGrouping : sortLvlGrouping[levels[0]]['parent'];
                const currPos = (this.dataSourceSettings.grandTotalsPosition === 'Top' && (this.dataSourceSettings.showGrandTotals && this.dataSourceSettings.showRowGrandTotals) && this.colDepth === rPos) ? cell.length : gSumFlag ? (newPos - totPos) : newPos;
                if (cell[currPos]) {
                    this.pivotValues[rPos] = [cell[currPos]];
                    this.pivotValues[rPos][0].rowIndex = rPos;
                    this.valueContent[valuePos][0] = this.pivotValues[rPos][0];
                }
                newPos++;
                valuePos++;
                if (this.pivotValues[rPos][0].type === 'grand sum') {
                    gSumFlag = true;
                    totPos = newPos;
                }
            }
        }
    }
    performColumnSorting() {
        if (this.enableSort) {
            for (let i = 0; i < this.dataSourceSettings.columns.length; i++) {
                const temporary = [];
                let index = 0;
                const grandTotal = [];
                for (let j = 0; j < this.pivotValues.length; j++) {
                    const header = this.pivotValues[j];
                    let key;
                    let keys;
                    let arrange = {};
                    let value = 1;
                    grandTotal[index] = [];
                    temporary[index] = [];
                    let k = 1;
                    const fieldName = header[k].hierarchy;
                    const levelName = header[k].levelUniqueName;
                    for (k; k < header.length; k++) {
                        if (!header[k].isNamedSet) {
                            if (header[k].memberType !== 2 && header[k].hierarchy
                                !== '[Measures]' && header[k].level !== -1) {
                                if (isNullOrUndefined(arrange[header[k].formattedText]) ||
                                    isNullOrUndefined(this.pivotValues[j - 1])) {
                                    arrange[header[k].formattedText] = arrange[header[k].formattedText] ?
                                        arrange[header[k].formattedText] : [];
                                    arrange[header[k].formattedText][header[k].colIndex] = header[k];
                                }
                                else if (arrange[header[k].formattedText] && this.pivotValues[j - 1]) { // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                    const prevRowCell = this.pivotValues[j - 1][header[k].colIndex];
                                    const prevColValue = Number(Object.keys(arrange[header[k].formattedText])[0]);
                                    const prevColIndex = ((arrange[header[k].formattedText])[prevColValue]).colIndex; // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                    const prevColRowCell = this.pivotValues[j - 1][prevColIndex];
                                    if (prevRowCell.formattedText !== prevColRowCell.formattedText) {
                                        let key = Object.keys(arrange);
                                        key = this.sortColumnHeaders(key, this.sortObject[header[k - 1].levelUniqueName] ||
                                            this.sortObject[header[k].hierarchy], fieldName, levelName);
                                        temporary[index] = isNullOrUndefined(temporary[index]) ? [] :
                                            temporary[index];
                                        for (let keyPos = 0; keyPos < key.length; keyPos++) {
                                            const length = Object.keys(arrange[key[keyPos]]).length;
                                            for (let cellPos = 0; cellPos < length; cellPos++) {
                                                value = temporary[index].length === 0 ? 1 : 0;
                                                // eslint-disable-next-line max-len
                                                temporary[index][temporary[index].length + value] = arrange[key[keyPos]][Number(Object.keys(arrange[key[keyPos]])[cellPos])];
                                            }
                                        }
                                        arrange = {};
                                        arrange[header[k].formattedText] = [];
                                        arrange[header[k].formattedText][header[k].colIndex] = header[k];
                                    }
                                    else {
                                        arrange[header[k].formattedText][header[k].colIndex] = header[k];
                                    }
                                }
                            }
                            else if (Object.keys(arrange).length > 0) {
                                grandTotal[index][grandTotal[index].length + value]
                                    = header[k];
                                key = Object.keys(arrange);
                                key = this.sortColumnHeaders(key, this.sortObject[header[k - 1].levelUniqueName] ||
                                    this.sortObject[header[k].hierarchy], fieldName, levelName);
                                temporary[index] = isNullOrUndefined(temporary[index]) ? [] :
                                    temporary[index];
                                for (let l = 0; l < key.length; l++) {
                                    const length = Object.keys(arrange[key[l]]).length;
                                    for (let q = 0; q < length; q++) {
                                        value = temporary[index].length === 0 ? 1 : 0;
                                        temporary[index][temporary[index].length + value] =
                                            arrange[key[l]][Number(Object.keys(arrange[key[l]])[q])];
                                    }
                                }
                            }
                            else if ((header[k].level === -1 || header[k].level === 0) &&
                                Object.keys(arrange).length >= 0 && header[k].hierarchy !== '[Measures]') {
                                grandTotal[index][grandTotal[index].length + value]
                                    = header[k];
                            }
                            if (header[k].level !== -1 && Object.keys(arrange).length === 1 &&
                                header[k].hierarchy !== '[Measures]' && !isNullOrUndefined(header[k + 1]) &&
                                header[k + 1].level === -1) {
                                const height = Object.keys(arrange[header[k].formattedText]).length;
                                const weight = Object.keys(arrange[header[k].formattedText]);
                                if (height > 1) {
                                    for (let hgt = 0; hgt < height; hgt++) {
                                        value = grandTotal[index].length === 0 ? 1 : 0;
                                        grandTotal[index][grandTotal[index].length + value]
                                            = arrange[header[k].formattedText][Number(weight[hgt])];
                                    }
                                }
                                else {
                                    grandTotal[index][grandTotal[index].length + value]
                                        = header[k];
                                }
                            }
                            if (Object.keys(grandTotal[index]).length > 0) {
                                value = temporary[index].length === 0 ? 1 : 0;
                                const height1 = grandTotal[index].length;
                                if (height1 > 2) {
                                    for (let hgt1 = 1; hgt1 < height1; hgt1++) {
                                        value = temporary[index].length === 0 ? 1 : 0;
                                        temporary[index][temporary[index].length + value] =
                                            grandTotal[index][hgt1];
                                    }
                                }
                                else {
                                    temporary[index][temporary[index].length + value] =
                                        grandTotal[index][1] || grandTotal[index][0];
                                }
                                arrange = {};
                                grandTotal[index] = [];
                            }
                        }
                    }
                    if (Object.keys(arrange).length > 0) {
                        grandTotal[index][grandTotal[index].length + value]
                            = header[k];
                        keys = Object.keys(arrange);
                        const order = this.sortObject[header[k - 1].levelUniqueName] || this.sortObject[header[k - 1].hierarchy];
                        key = this.sortColumnHeaders(keys, order, fieldName, levelName);
                        temporary[index] = isNullOrUndefined(temporary[index]) ? [] : temporary[index];
                        for (let len = 0; len < keys.length; len++) {
                            const leng = Object.keys(arrange[keys[len]]).length;
                            for (let q = 0; q < leng; q++) {
                                value = temporary[index].length === 0 ? 1 : 0;
                                temporary[index][temporary[index].length + value] =
                                    arrange[key[len]][Number(Object.keys(arrange[keys[len]])[q])];
                            }
                        }
                    }
                    for (let m = 1; m < temporary[index].length; m++) {
                        this.pivotValues[index][m] = temporary[index][m];
                    }
                    for (let n = j; n < this.pivotValues.length; n++) {
                        const pElement = extend({}, this.pivotValues[n + 1], null, true);
                        const cElement = extend({}, this.pivotValues[n], null, true);
                        if (Object.keys(pElement).length === Object.keys(cElement).length && Object.keys(pElement).length > 2) {
                            for (let o = 1; o < this.pivotValues[j].length; o++) {
                                if (Object.keys(pElement).length > 0 && cElement[o].colIndex
                                    !== pElement[o].colIndex) {
                                    this.pivotValues[n + 1][o] =
                                        pElement[cElement[o].colIndex];
                                }
                            }
                            break;
                        }
                    }
                    index++;
                    arrange = {};
                }
                for (let i = 0; i < this.pivotValues.length; i++) {
                    const header = this.pivotValues[i];
                    for (let j = 1; j < header.length; j++) {
                        header[j].colIndex = j;
                    }
                }
            }
        }
    }
    frameUniqueName(uniqueName, currentCell, currentTuple) {
        const hasLastMeasure = uniqueName.indexOf(currentCell.actualText.toString() + '::[Measures]') > -1;
        uniqueName = uniqueName.substring(0, uniqueName.indexOf(currentCell.actualText.toString())) +
            currentCell.actualText.toString();
        const measureAvail = uniqueName.split('::[').length <= this.getMeasurePosition(uniqueName, currentTuple.measurePosition);
        uniqueName = uniqueName + ((hasLastMeasure || measureAvail) ? ('::' + currentTuple.measureName) : '');
        return uniqueName;
    }
    getMeasurePosition(uniqueName, measurePosition) {
        let position = measurePosition;
        const collection = uniqueName.split('::[');
        for (let i = 0; i < collection.length; i++) {
            if (collection[i] && collection[i].indexOf('Measures') > -1) {
                position = i;
                break;
            }
        }
        return position;
    }
    sortRowHeaders(headers) {
        if (headers.length > 0 && headers[0].memberType !== 3 && !headers[0].isNamedSet) {
            const sortMembers = [];
            for (let i = 0; i < headers.length; i++) {
                sortMembers[i] = headers[i].actualText;
            }
            let isHeaderSortByDefault = false;
            const fieldName = headers[0].actualText !== 'Grand Total' ? headers[0].hierarchy : headers[1].hierarchy;
            const membersInfo = this.fieldList[fieldName] && this.fieldList[fieldName].membersOrder ?
                [...this.fieldList[fieldName].membersOrder] : [];
            const sortDetails = {
                fieldName: fieldName,
                levelName: headers[0].levelUniqueName,
                sortOrder: (this.sortObject[headers[0].hierarchy] || this.sortObject[headers[0].levelUniqueName]),
                members: membersInfo && membersInfo.length > 0 ? membersInfo : sortMembers,
                IsOrderChanged: false
            };
            if (membersInfo && membersInfo.length > 0) {
                PivotUtil.applyCustomSort(sortDetails, headers, 'string', false, true);
            }
            else {
                if (sortDetails.sortOrder === 'Ascending' || sortDetails.sortOrder === undefined) {
                    headers.sort((a, b) => (a.formattedText > b.formattedText) ? 1 :
                        ((b.formattedText > a.formattedText) ? -1 : 0));
                }
                else if (sortDetails.sortOrder === 'Descending') {
                    headers.sort((a, b) => (a.formattedText < b.formattedText) ? 1 :
                        ((b.formattedText < a.formattedText) ? -1 : 0));
                }
                isHeaderSortByDefault = true;
            }
            if (isHeaderSortByDefault && this.getHeaderSortInfo) {
                const copyOrder = [];
                for (let m = 0, n = 0; m < headers.length; m++) {
                    if (headers[m].actualText !== 'Grand Total') {
                        copyOrder[n++] = headers[m].formattedText;
                    }
                }
                sortDetails.members = copyOrder;
            }
            if (this.getHeaderSortInfo) {
                this.getHeaderSortInfo(sortDetails);
            }
            if (sortDetails.IsOrderChanged) {
                PivotUtil.applyCustomSort(sortDetails, headers, 'string', true, true);
            }
            return headers;
        }
        return headers;
    }
    sortColumnHeaders(keys, order, header, levelName) {
        let isHeaderSortByDefault = false;
        const membersInfo = this.fieldList[header] && this.fieldList[header].membersOrder ?
            [...this.fieldList[header].membersOrder] : [];
        const sortDetails = {
            fieldName: header,
            levelName: levelName,
            sortOrder: order,
            members: membersInfo && membersInfo.length > 0 ? membersInfo : keys,
            IsOrderChanged: false
        };
        if (membersInfo && membersInfo.length > 0) {
            this.applyCustomSort(keys, sortDetails);
        }
        else {
            if (sortDetails.sortOrder === 'Ascending' || sortDetails.sortOrder === undefined) {
                keys.sort((a, b) => (a > b) ? 1 : ((b > a) ? -1 : 0));
            }
            else if (sortDetails.sortOrder === 'Descending') {
                keys.sort((a, b) => (a < b) ? 1 : ((b < a) ? -1 : 0));
            }
            isHeaderSortByDefault = true;
        }
        if (isHeaderSortByDefault && this.getHeaderSortInfo) {
            const copyOrder = [];
            for (let m = 0, n = 0; m < keys.length; m++) {
                if (keys[m] !== 'Grand Total') {
                    copyOrder[n++] = keys[m];
                }
            }
            sortDetails.members = copyOrder;
        }
        if (this.getHeaderSortInfo) {
            this.getHeaderSortInfo(sortDetails);
        }
        if (sortDetails.IsOrderChanged) {
            this.applyCustomSort(keys, sortDetails, true);
        }
        return keys;
    }
    applyCustomSort(headers, sortDetails, hasMembersOrder) {
        let order = [];
        const updatedMembers = [];
        let grandTotal;
        if (sortDetails.IsOrderChanged) {
            order = sortDetails.members;
        }
        else {
            order = (sortDetails.sortOrder === 'Ascending' || sortDetails.sortOrder === 'None' || sortDetails.sortOrder === undefined) ? [].concat(sortDetails.members) : [].concat(sortDetails.members).reverse();
        }
        if (headers[0] === 'Grand Total') {
            grandTotal = headers[0];
            headers.shift();
        }
        for (let i = 0, j = 0; i < headers.length; i++) {
            const sortText = headers[i];
            if (order[j] === sortText) {
                headers.splice(j++, 0, sortText);
                headers.splice(++i, 1);
                if (j < order.length) {
                    i = -1;
                }
                else {
                    if (!hasMembersOrder) {
                        updatedMembers.splice(--j, 0, sortText);
                    }
                    break;
                }
            }
            if (i >= 0 && !hasMembersOrder) {
                updatedMembers[i] = headers[i];
            }
        }
        if (!hasMembersOrder) {
            for (let i = updatedMembers.length; i < headers.length; i++) {
                updatedMembers[i] = headers[i];
            }
            if (updatedMembers[updatedMembers.length - 1] === 'Grand Total') {
                updatedMembers.pop();
            }
            sortDetails.members = updatedMembers;
        }
        if (grandTotal) {
            headers.splice(0, 0, grandTotal);
        }
        return headers;
    }
    frameSortObject() {
        if (this.enableSort) {
            for (let fPos = 0; fPos < this.sortSettings.length; fPos++) {
                this.sortObject[this.sortSettings[fPos].name] = this.sortSettings[fPos].order;
            }
        }
    }
    getParentUname(uniqueNameColl, cell, isMeasureAvail, isLastMeasure) {
        let parentString = '';
        if (isMeasureAvail && !isLastMeasure) {
            const tuple = this.tupRowInfo[cell.ordinal];
            const sepPos = [];
            const sepObjects = {};
            for (let i = 0; i < uniqueNameColl.length; i++) {
                if (uniqueNameColl[i] === '~' || uniqueNameColl[i] === ':') {
                    sepPos.push(i);
                    sepObjects[i] = uniqueNameColl[i] + uniqueNameColl[i];
                    i++;
                }
            }
            if (this.getMeasurePosition(uniqueNameColl, tuple.measurePosition) >= (uniqueNameColl.split('::[').length - 1)) {
                if (sepPos[sepPos.length - 2] > -1) {
                    parentString = uniqueNameColl.substring(0, sepPos[sepPos.length - 2]) + sepObjects[sepPos[sepPos.length - 1]] +
                        tuple.measureName;
                }
                else {
                    parentString = 'parent';
                }
            }
            else {
                const lastPosition = uniqueNameColl.lastIndexOf('~~') > uniqueNameColl.lastIndexOf('::[') ?
                    uniqueNameColl.lastIndexOf('~~') : uniqueNameColl.lastIndexOf('::[');
                parentString = lastPosition > -1 ? uniqueNameColl.substring(0, lastPosition) : 'parent';
            }
        }
        else {
            const lastPosition = uniqueNameColl.lastIndexOf('~~') > uniqueNameColl.lastIndexOf('::[') ?
                uniqueNameColl.lastIndexOf('~~') : uniqueNameColl.lastIndexOf('::[');
            parentString = lastPosition > -1 ? uniqueNameColl.substring(0, lastPosition) : 'parent';
        }
        return parentString;
    }
    performColumnSpanning() {
        const spanCollection = {};
        let rowPos = this.rowStartPos - 1;
        const colMeasureCount = Object.keys(this.colMeasures).length;
        while (rowPos > -1) {
            spanCollection[rowPos] = {};
            let colPos = this.pivotValues[rowPos].length - 1;
            while (colPos > 0) {
                spanCollection[rowPos][colPos] = 1;
                const nextColCell = this.pivotValues[rowPos][colPos + 1];
                const nextRowCell = (this.pivotValues[rowPos + 1] && this.rowStartPos - rowPos > 1) ?
                    this.pivotValues[rowPos + 1][colPos] : undefined;
                const currCell = this.pivotValues[rowPos][colPos];
                let colflag = false;
                let rowflag = false;
                const tupColInfo = this.tupColumnInfo[currCell.ordinal];
                const isSubTot = tupColInfo.allStartPos > (tupColInfo.typeCollection[0] === '3' ? 1 : 0);
                const attrDrill = this.checkAttributeDrill(tupColInfo.drillInfo, 'columns');
                if (this.showSubTotalsAtTop && currCell.isDrilled && nextColCell &&
                    (nextColCell.actualText !== currCell.actualText) && currCell.level > -1) {
                    currCell.ordinal = this.getOrdinal(currCell, this.pivotValues[rowPos + 1]);
                }
                if (nextRowCell && nextColCell && ((currCell.memberType === 2 || currCell.level === -1) ?
                    (nextColCell.actualText === currCell.actualText) :
                    ((currCell.memberType === 3 && currCell.actualText === nextColCell.actualText) ||
                        nextColCell.valueSort.levelName === currCell.valueSort.levelName))) {
                    if (currCell.memberType === 2) {
                        if (isSubTot ? nextColCell.type === 'sum' : true) {
                            currCell.colSpan = (nextColCell.colSpan + 1) >
                                (tupColInfo.measurePosition > rowPos ? colMeasureCount : 0) ? 1 : (nextColCell.colSpan + 1);
                        }
                        else {
                            currCell.colSpan = 1;
                        }
                    }
                    else {
                        currCell.colSpan = nextColCell.colSpan + 1;
                        currCell.ordinal = nextColCell.ordinal;
                    }
                    colflag = true;
                }
                if (currCell.memberType === 2) {
                    if (isSubTot) {
                        if (!attrDrill) {
                            currCell.type = 'sum';
                        }
                        //currCell.formattedText = (this.pivotValues[tupColInfo.allStartPos - 1] as IAxisSet[])[colPos as number].formattedText + ' Total';
                        currCell.formattedText = 'Total';
                        currCell.valueSort[currCell.valueSort.levelName.toString()] = 1;
                    }
                    else {
                        let levelName = 'Grand Total';
                        if (nextRowCell && colMeasureCount > 0) {
                            levelName = nextRowCell.memberType === 3 ? ('Grand Total.' + nextRowCell.formattedText) :
                                nextRowCell.valueSort.levelName;
                        }
                        currCell.type = 'grand sum';
                        currCell.formattedText = 'Grand Total';
                        currCell.valueSort.levelName = levelName;
                        currCell.valueSort[levelName.toString()] = 1;
                    }
                    currCell.hasChild = false;
                }
                else if (currCell.level === -1) {
                    currCell.type = 'sum';
                    //currCell.formattedText = currCell.formattedText + ' Total';
                    currCell.formattedText = 'Total';
                    currCell.hasChild = false;
                    currCell.valueSort[currCell.valueSort.levelName.toString()] = 1;
                }
                if (nextRowCell) {
                    if ((currCell.memberType === 2 && nextRowCell.memberType === 2) || nextRowCell.actualText === currCell.actualText) {
                        spanCollection[rowPos][colPos] = spanCollection[rowPos + 1] ?
                            (spanCollection[rowPos + 1][colPos] + 1) : 1;
                        if (rowPos === 0 || (currCell.memberType === 1 && currCell.level > -1 &&
                            nextRowCell.memberType === 1 && nextRowCell.level === -1)) {
                            currCell.rowSpan = (currCell.isDrilled && ((this.fieldList[currCell.hierarchy] &&
                                this.fieldList[currCell.hierarchy].isHierarchy) ? currCell.hasChild : true)) ? 1 :
                                (spanCollection[rowPos + 1][colPos] + 1);
                            nextRowCell.rowSpan = (nextRowCell.isDrilled && ((this.fieldList[nextRowCell.hierarchy] &&
                                this.fieldList[nextRowCell.hierarchy].isHierarchy) ? nextRowCell.hasChild : true) &&
                                nextRowCell.level === -1) ? spanCollection[rowPos + 1][colPos] : nextRowCell.rowSpan;
                        }
                        else {
                            if (currCell.memberType === 3) {
                                currCell.rowSpan = 1;
                            }
                            else {
                                currCell.rowSpan = -1;
                            }
                        }
                        rowflag = true;
                    }
                    else if (currCell.isDrilled && ((this.fieldList[currCell.hierarchy] &&
                        this.fieldList[currCell.hierarchy].isHierarchy) ? currCell.hasChild : true) && currCell.level === -1 &&
                        nextRowCell.memberType === 2) {
                        spanCollection[rowPos][colPos] = spanCollection[rowPos + 1] ?
                            (spanCollection[rowPos + 1][colPos] + 1) : 1;
                        currCell.rowSpan = -1;
                        rowflag = true;
                    }
                    else {
                        currCell.rowSpan = rowPos === 0 ? spanCollection[rowPos][colPos] : -1;
                        nextRowCell.rowSpan = ((nextRowCell.level > -1 && !(nextRowCell.isDrilled &&
                            ((this.fieldList[nextRowCell.hierarchy] && this.fieldList[nextRowCell.hierarchy].isHierarchy) ?
                                nextRowCell.hasChild : true))) || (currCell.memberType !== 2 && nextRowCell.memberType === 2)) ?
                            spanCollection[rowPos + 1][colPos] : 1;
                    }
                }
                else {
                    currCell.rowSpan = (currCell.level > -1 || this.rowStartPos === 1) ?
                        spanCollection[rowPos][colPos] : -1;
                }
                if (!colflag) {
                    currCell.colSpan = 1;
                }
                if (!rowflag) {
                    spanCollection[rowPos][colPos] = 1;
                }
                colPos--;
            }
            rowPos--;
        }
    }
    getOrdinal(currCell, nextRow) {
        let newOrdinal = 0;
        for (let cellIndex = currCell.colIndex; cellIndex > 0; cellIndex--) {
            if (nextRow[cellIndex].level === -1) {
                newOrdinal = nextRow[cellIndex].ordinal;
                break;
            }
        }
        return newOrdinal;
    }
    frameValues(tuples, colLength) {
        let rowStartPos = this.colDepth;
        let rowEndPos = this.pivotValues.length;
        let startRowOrdinal = 0;
        if (this.customArgs.action === 'down') {
            const keys = Object.keys(this.onDemandDrillEngine);
            rowStartPos = Number(keys[0]);
            rowEndPos = Number(keys[keys.length - 1]) + 1;
            startRowOrdinal = this.onDemandDrillEngine[rowStartPos][0].ordinal;
        }
        const valCollection = {};
        for (let colPos = 0; colPos < tuples.length; colPos++) {
            valCollection[Number(tuples[colPos].getAttribute('CellOrdinal'))] = tuples[colPos];
        }
        for (let rowPos = rowStartPos; rowPos < rowEndPos; rowPos++) {
            const columns = this.pivotValues[rowPos];
            const rowOrdinal = columns[0].ordinal;
            for (let colPos = 1; colPos < this.pivotValues[0].length; colPos++) {
                if (this.pivotValues[this.colDepth - 1][colPos]) {
                    const colOrdinal = this.pivotValues[this.colDepth - 1][colPos].ordinal;
                    const lastColCell = this.pivotValues[this.colDepth - 1][colPos];
                    const measure = columns[0].memberType === 3 ? columns[0].actualText.toString() :
                        ((this.tupColumnInfo[lastColCell.ordinal] && this.tupColumnInfo[lastColCell.ordinal].measure) ?
                            this.tupColumnInfo[lastColCell.ordinal].measure.querySelector('UName').textContent :
                            columns[0].actualText);
                    if (columns[0].type === 'header') {
                        columns[colPos] = {
                            axis: 'value',
                            actualText: this.getUniqueName(measure),
                            formattedText: '',
                            value: 0,
                            colIndex: colPos,
                            rowIndex: rowPos
                        };
                    }
                    else {
                        let formattedText;
                        let value = '0';
                        const measureName = this.getUniqueName(measure);
                        let showTotals = true;
                        const attrDrill = (this.fieldList[columns[0].hierarchy] &&
                            this.fieldList[columns[0].hierarchy].isHierarchy) ? columns[0].isDrilled : true;
                        if (this.tupRowInfo[rowOrdinal]) {
                            showTotals = this.tupRowInfo[rowOrdinal].showTotals;
                        }
                        else {
                            showTotals = this.dataSourceSettings.showGrandTotals && this.dataSourceSettings.showRowGrandTotals;
                        }
                        const valElement = valCollection[(rowOrdinal - startRowOrdinal) * colLength + colOrdinal];
                        formattedText = this.showSubTotalsAtBottom && columns[0].isDrilled ? '' : (!showTotals && attrDrill) ? '' :
                            ((!isNullOrUndefined(valElement) && !isNullOrUndefined(valElement.querySelector('FmtValue'))) ?
                                valElement.querySelector('FmtValue').textContent : this.emptyCellTextContent);
                        value = (!showTotals && attrDrill) ? '0' :
                            ((!isNullOrUndefined(valElement) && !isNullOrUndefined(valElement.querySelector('Value'))) ?
                                valElement.querySelector('Value').textContent : null);
                        formattedText = this.showSubTotalsAtBottom && columns[0].isDrilled ? '' : showTotals && !isNullOrUndefined(value) ?
                            this.getFormattedValue(Number(value), measureName, (formattedText !== '' ? formattedText : value)) : formattedText;
                        const isSum = (this.tupColumnInfo[colOrdinal] ?
                            (this.tupColumnInfo[colOrdinal].allCount > 0 ||
                                this.tupColumnInfo[colOrdinal].drillStartPos > -1) : true) ||
                            (this.tupRowInfo[rowOrdinal] ? (this.tupRowInfo[rowOrdinal].allCount > 0 ||
                                this.tupRowInfo[rowOrdinal].drillStartPos > -1) : true);
                        const isGrand = (this.tupRowInfo[rowOrdinal] ?
                            (this.tupRowInfo[rowOrdinal].measurePosition === 0 ?
                                this.tupRowInfo[rowOrdinal].allStartPos === 1 :
                                this.tupRowInfo[rowOrdinal].allStartPos === 0) : false) ||
                            (this.tupColumnInfo[colOrdinal] ?
                                (this.tupColumnInfo[colOrdinal].measurePosition === 0 ?
                                    this.tupColumnInfo[colOrdinal].allStartPos === 1 :
                                    this.tupColumnInfo[colOrdinal].allStartPos === 0) : false);
                        columns[colPos] = {
                            axis: 'value',
                            actualText: measureName,
                            formattedText: formattedText,
                            colOrdinal: colOrdinal,
                            rowOrdinal: rowOrdinal,
                            columnHeaders: this.tupColumnInfo[colOrdinal] ? this.tupColumnInfo[colOrdinal].captionCollection : '',
                            rowHeaders: this.tupRowInfo[rowOrdinal] ? this.tupRowInfo[rowOrdinal].captionCollection : '',
                            value: !isNullOrUndefined(value) ? Number(value) : null,
                            colIndex: colPos,
                            rowIndex: rowPos,
                            isSum: isSum,
                            isGrandSum: isGrand
                        };
                    }
                    this.valueContent[rowPos - this.rowStartPos][colPos] = columns[colPos];
                }
            }
        }
    }
    /**
     * It performs to returns the formatted value.
     *
     * @param {number} value - It Defines the value of formatting data.
     * @param {string} fieldName - It contains the value of the field name.
     * @param {string} formattedText - It contains the value of the formatted text.
     * @returns {string} - It returns formatted Value as string.
     * @hidden
     */
    getFormattedValue(value, fieldName, formattedText) {
        let formattedValue = formattedText;
        if (this.formatFields[fieldName] && !isNullOrUndefined(value)) {
            const formatField = (this.formatFields[fieldName].properties ?
                this.formatFields[fieldName].properties : this.formatFields[fieldName]);
            const formatObj = extend({}, formatField, null, true);
            delete formatObj.name;
            if (!formatObj.minimumSignificantDigits && formatObj.minimumSignificantDigits < 1) {
                delete formatObj.minimumSignificantDigits;
            }
            if (!formatObj.maximumSignificantDigits && formatObj.maximumSignificantDigits < 1) {
                delete formatObj.maximumSignificantDigits;
            }
            if (formatObj.type) {
                formattedValue = this.globalize.formatDate(new Date(value.toString()), formatObj);
            }
            else {
                delete formatObj.type;
                if ((formatObj.format) && !(this.formatRegex.test(formatObj.format))) {
                    const pattern = formatObj.format.match(this.customRegex);
                    const integerPart = pattern[6];
                    formatObj.useGrouping = integerPart.indexOf(',') !== -1;
                }
                formattedValue = this.globalize.formatNumber(value, formatObj);
            }
        }
        return formattedValue;
    }
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
    getMeasureInfo() {
        let mAxis = 'column';
        let mIndex;
        const values = [];
        for (const field of this.values) {
            values[values.length] = (field.isCalculatedField ? this.fieldList[field.name].tag : field.name);
        }
        if (values.length > 1) {
            if (this.isMeasureAvail) {
                let isAvail = false;
                for (let i = 0, cnt = this.rows.length; i < cnt; i++) {
                    if (this.rows[i].name.toLowerCase() === '[measures]') {
                        mAxis = 'row';
                        mIndex = i;
                        isAvail = true;
                        break;
                    }
                }
                if (!isAvail) {
                    for (let i = 0, cnt = this.columns.length; i < cnt; i++) {
                        if (this.columns[i].name.toLowerCase() === '[measures]') {
                            mAxis = 'column';
                            mIndex = i;
                            isAvail = true;
                            break;
                        }
                    }
                }
            }
            else {
                mAxis = this.valueAxis;
                mIndex = mAxis === 'row' ? this.rows.length - 1 : this.columns.length - 1;
            }
            return { measureAxis: mAxis, measureIndex: mIndex, valueInfo: values };
        }
        else {
            return { measureAxis: mAxis, measureIndex: -1, valueInfo: [] };
        }
    }
    frameMeasureOrder(measureInfo, axis, tuples, vTuples, cLen) {
        const orderedTuples = [];
        const orderedVTuples = [];
        const orderedIndex = [];
        const levels = {};
        const cLevels = [];
        const measureAxis = measureInfo.measureAxis;
        const measureIndex = measureInfo.measureIndex;
        const values = measureInfo.valueInfo;
        if (measureAxis === axis && values.length > 0) {
            const levelCollection = {};
            const uniqueLevels = [];
            for (let j = 0, lnt = tuples.length; j < lnt; j++) {
                const node = tuples[j];
                const members = [].slice.call(node.querySelectorAll('Member'));
                let level = '';
                let cLevel = '';
                let i = 0;
                while (i < members.length) {
                    level = level + (level !== '' ? '~~' : '') + members[i].querySelector('UName').textContent;
                    if (i === measureIndex && measureIndex === 0) {
                        cLevel = level;
                    }
                    else if (i === (measureIndex - 1)) {
                        cLevel = level;
                    }
                    i++;
                }
                if (levelCollection[cLevel]) {
                    levelCollection[cLevel][levelCollection[cLevel].length] = level;
                }
                else {
                    levelCollection[cLevel] = [level];
                    uniqueLevels[uniqueLevels.length] = cLevel;
                }
                levels[level] = { index: j, node: node };
                cLevels[cLevels.length] = level;
            }
            if (cLevels.length > 0) {
                if (uniqueLevels.length > 0) {
                    if (measureIndex === 0) {
                        for (const name of values) {
                            for (const key of uniqueLevels) {
                                if (key === name) {
                                    for (const level of levelCollection[key]) {
                                        orderedIndex[orderedIndex.length] = levels[level].index;
                                        orderedTuples[orderedTuples.length] = levels[level].node;
                                    }
                                }
                            }
                        }
                    }
                    else {
                        for (const key of uniqueLevels) {
                            for (const name of values) {
                                for (const level of levelCollection[key]) {
                                    const levelInfo = level.split('~~');
                                    if (levelInfo[measureIndex] === name) {
                                        orderedIndex[orderedIndex.length] = levels[level].index;
                                        orderedTuples[orderedTuples.length] = levels[level].node;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (vTuples.length > 0) {
                const valueIndex = [];
                const vOrdinalIndex = [];
                let len = 0;
                let cRow = 0;
                for (let j = 0, cnt = vTuples.length; j < cnt; j++) {
                    if (len > (cLen - 1)) {
                        cRow++;
                        len = 0;
                        if (!valueIndex[cRow]) {
                            valueIndex[cRow] = [];
                        }
                        valueIndex[cRow][len] = j;
                        len++;
                    }
                    else {
                        if (!valueIndex[cRow]) {
                            valueIndex[cRow] = [];
                        }
                        valueIndex[cRow][len] = j;
                        len++;
                    }
                    vOrdinalIndex[vOrdinalIndex.length] = Number(vTuples[j].getAttribute('CellOrdinal'));
                }
                if (measureAxis === 'column') {
                    if (valueIndex.length > 0 && valueIndex[0].length === orderedIndex.length) {
                        for (let i = 0, cnt = orderedIndex.length; i < cnt; i++) {
                            let j = 0;
                            while (j < valueIndex.length) {
                                const index = (j * cLen) + i;
                                const ordinalValue = vOrdinalIndex[index].toString();
                                const tuple = vTuples[Number(valueIndex[j][orderedIndex[i]])];
                                tuple.setAttribute('CellOrdinal', ordinalValue.toString());
                                orderedVTuples[index] = tuple;
                                j++;
                            }
                        }
                    }
                }
                else {
                    if (valueIndex.length === orderedIndex.length) {
                        for (let i = 0, cnt = orderedIndex.length; i < cnt; i++) {
                            let j = 0;
                            while (j < valueIndex[orderedIndex[i]].length) {
                                const index = (i * cLen) + j;
                                const ordinalValue = vOrdinalIndex[index].toString();
                                const tuple = vTuples[Number(valueIndex[orderedIndex[i]][j])];
                                tuple.setAttribute('CellOrdinal', ordinalValue.toString());
                                orderedVTuples[orderedVTuples.length] = tuple;
                                j++;
                            }
                        }
                    }
                }
            }
            return { orderedHeaderTuples: orderedTuples, orderedValueTuples: orderedVTuples };
        }
        else {
            return { orderedHeaderTuples: tuples, orderedValueTuples: vTuples };
        }
    }
    getDrilledSets(uNameCollection, currentCell, fieldPos, axis) {
        const levels = [];
        const memberName = currentCell.actualText.toString();
        const tupCollection = axis === 'row' ? this.tupRowInfo : this.tupColumnInfo;
        const currTuple = tupCollection[currentCell.ordinal];
        const measurePos = tupCollection[0].typeCollection.indexOf('3');
        const allStartPos = measurePos === 0 ? 1 : 0;
        let tupPos = 0;
        const isWithoutAllMember = tupCollection[0].typeCollection[fieldPos] === '1';
        while (tupPos < tupCollection.length) {
            if (isNullOrUndefined(tupCollection[tupPos].allStartPos) ||
                tupCollection[tupPos].allStartPos > allStartPos) {
                levels[levels.length] = tupCollection[tupPos].uNameCollection;
            }
            tupPos++;
        }
        const memberArray = uNameCollection.split('::[').map((item) => {
            return item[0] === '[' ? item : ('[' + item);
        });
        const joinArray = [];
        for (let memPos = 0; memPos <= fieldPos; memPos++) {
            if (memberArray[memPos]) {
                if ((isWithoutAllMember || this.isPaging) && memPos === fieldPos) {
                    const splitLevels = memberArray[memPos].split('~~');
                    const drillLevel = splitLevels.indexOf(memberName);
                    const cropLevels = [];
                    for (let lPos = 0; lPos <= drillLevel; lPos++) {
                        cropLevels.push(splitLevels[lPos]);
                    }
                    joinArray[joinArray.length] = cropLevels.length > 0 ? cropLevels.join('~~') : memberArray[memPos];
                }
                else {
                    joinArray[joinArray.length] = memberArray[memPos];
                }
            }
        }
        uNameCollection = joinArray.join('::');
        const childSets = [];
        const memberObj = {};
        for (const item of levels) {
            if (item.indexOf(uNameCollection) === 0) {
                childSets.push(item);
                if (this.isPaging) {
                    let drillField = item.split('::[')[fieldPos];
                    drillField = drillField[0] === '[' ? drillField : ('[' + drillField);
                    const drillFieldSep = drillField.split('~~');
                    for (let fPos = drillFieldSep.indexOf(memberName); fPos < drillFieldSep.length; fPos++) {
                        memberObj[drillFieldSep[fPos]] = drillFieldSep[fPos];
                    }
                }
            }
        }
        if (this.isPaging) {
            const fieldSep = currTuple.uNameCollection.split('::[').map((item) => {
                return item[0] === '[' ? item : ('[' + item);
            });
            const cropArray = [];
            for (let fPos = 0; fPos < fieldSep.length; fPos++) {
                if (fPos !== fieldPos) {
                    cropArray[fPos] = fieldSep[fPos];
                }
            }
            const drillFieldSep = Object.keys(memberObj);
            for (let fPos = 0; fPos < drillFieldSep.length; fPos++) {
                cropArray[fieldPos] = drillFieldSep[fPos];
                childSets.push(cropArray.join('::'));
            }
        }
        const drillSets = {};
        for (const level of childSets) {
            const fields = level.split('::[').map((item) => {
                return item[0] === '[' ? item : ('[' + item);
            });
            let set = '';
            for (let pos = 0; pos <= fieldPos; pos++) {
                const field = fields[pos];
                if (field) {
                    const members = field.split('~~');
                    set = set + (set !== '' ? '~~' : '') + members[members.length - 1];
                }
            }
            drillSets[set] = set;
        }
        return drillSets;
    }
    updateDrilledInfo(dataSourceSettings) {
        this.dataSourceSettings = dataSourceSettings;
        this.drilledMembers = dataSourceSettings.drilledMembers ? this.updateDrilledItems(dataSourceSettings.drilledMembers) : [];
        // MDXQuery.getCellSets(this.dataSourceSettings as IDataOptions, this);
        this.generateGridData(dataSourceSettings);
    }
    updateCalcFields(dataSourceSettings, lastcalcInfo) {
        this.dataSourceSettings = dataSourceSettings;
        this.calculatedFieldSettings = dataSourceSettings.calculatedFieldSettings ? dataSourceSettings.calculatedFieldSettings : [];
        this.getAxisFields();
        this.updateFieldlist();
        this.loadCalculatedMemberElements(this.calculatedFieldSettings);
        if (this.dataFields[lastcalcInfo.name]) {
            this.generateGridData(dataSourceSettings);
        }
        else {
            MDXQuery.getCellSets(dataSourceSettings, this, true, undefined, true);
        }
    }
    onSort(dataSourceSettings) {
        this.dataSourceSettings = dataSourceSettings;
        this.sortSettings = dataSourceSettings.sortSettings ? dataSourceSettings.sortSettings : [];
        this.getAxisFields();
        this.frameSortObject();
        this.updateFieldlist();
        if (this.xmlaCellSet.length > 0 && this.xmlDoc) {
            this.generateEngine(this.xmlDoc, this.request, this.customArgs);
        }
        else {
            this.generateGridData(dataSourceSettings);
        }
    }
    updateFieldlist(isInit) {
        let i = 0;
        while (i < this.savedFieldListData.length) {
            const fieldName = this.savedFieldListData[i].id;
            const parentID = this.savedFieldListData[i].pid;
            // let aggregateType: string = this.getAggregateType(fieldName);
            // this.savedFieldListData[i as number].aggregateType = aggregateType;
            if (this.savedFieldList[fieldName]) {
                const sortOrder = (this.enableSort ? this.sortObject[fieldName] ?
                    this.sortObject[fieldName] : 'Ascending' : 'None');
                this.savedFieldList[fieldName].isSelected = false;
                this.savedFieldList[fieldName].isExcelFilter = false;
                // this.savedFieldList[fieldName as string].aggregateType = aggregateType;
                this.savedFieldList[fieldName].sort = sortOrder;
                this.savedFieldList[fieldName].allowDragAndDrop = true;
                this.savedFieldList[fieldName].showFilterIcon = true;
                this.savedFieldList[fieldName].showSortIcon = true;
                this.savedFieldList[fieldName].showEditIcon = true;
                this.savedFieldList[fieldName].showRemoveIcon = true;
                this.savedFieldList[fieldName].showValueTypeIcon = true;
                this.savedFieldList[fieldName].showSubTotals = true;
                this.savedFieldListData[i].sort = sortOrder;
                this.savedFieldListData[i].allowDragAndDrop = true;
                this.savedFieldListData[i].showFilterIcon = true;
                this.savedFieldListData[i].showSortIcon = true;
                this.savedFieldListData[i].showEditIcon = true;
                this.savedFieldListData[i].showRemoveIcon = true;
                this.savedFieldListData[i].showValueTypeIcon = true;
                this.savedFieldListData[i].showSubTotals = true;
                if (isInit) {
                    this.savedFieldList[fieldName].filter = [];
                    this.savedFieldList[fieldName].actualFilter = [];
                }
            }
            if (this.dataFields[fieldName] && this.savedFieldList[fieldName] &&
                this.selectedItems.indexOf(fieldName) > -1) {
                this.savedFieldList[fieldName].isSelected = true;
                this.savedFieldList[fieldName].allowDragAndDrop = (this.dataFields[fieldName] ?
                    this.dataFields[fieldName].allowDragAndDrop : true);
                this.savedFieldList[fieldName].showFilterIcon = (this.dataFields[fieldName] ?
                    this.dataFields[fieldName].showFilterIcon : true);
                this.savedFieldList[fieldName].showSortIcon = (this.dataFields[fieldName] ?
                    this.dataFields[fieldName].showSortIcon : true);
                this.savedFieldList[fieldName].showEditIcon = (this.dataFields[fieldName] ?
                    this.dataFields[fieldName].showEditIcon : true);
                this.savedFieldList[fieldName].showRemoveIcon = (this.dataFields[fieldName] ?
                    this.dataFields[fieldName].showRemoveIcon : true);
                this.savedFieldList[fieldName].showValueTypeIcon = (this.dataFields[fieldName] ?
                    this.dataFields[fieldName].showValueTypeIcon : true);
                this.savedFieldList[fieldName].showSubTotals = (this.dataFields[fieldName] ?
                    this.dataFields[fieldName].showSubTotals : true);
                this.savedFieldListData[i].isSelected = true;
                this.savedFieldListData[i].allowDragAndDrop = (this.dataFields[fieldName] ?
                    this.dataFields[fieldName].allowDragAndDrop : true);
                this.savedFieldListData[i].showFilterIcon = (this.dataFields[fieldName] ?
                    this.dataFields[fieldName].showFilterIcon : true);
                this.savedFieldListData[i].showSortIcon =
                    (this.dataFields[fieldName] ? this.dataFields[fieldName].showSortIcon : true);
                this.savedFieldListData[i].showEditIcon =
                    (this.dataFields[fieldName] ? this.dataFields[fieldName].showEditIcon : true);
                this.savedFieldListData[i].showRemoveIcon =
                    (this.dataFields[fieldName] ? this.dataFields[fieldName].showRemoveIcon : true);
                this.savedFieldListData[i].showValueTypeIcon =
                    (this.dataFields[fieldName] ? this.dataFields[fieldName].showValueTypeIcon : true);
                this.savedFieldListData[i].showSubTotals =
                    (this.dataFields[fieldName] ? this.dataFields[fieldName].showSubTotals : true);
            }
            else {
                if (this.dataFields[parentID] && this.savedFieldList[parentID] &&
                    this.selectedItems.indexOf(parentID) > -1) {
                    this.savedFieldListData[i].isSelected = true;
                }
                else {
                    this.savedFieldListData[i].isSelected = false;
                }
            }
            if ((this.savedFieldList[fieldName] && this.savedFieldList[fieldName].isCalculatedField) ||
                fieldName.toLowerCase() === '[calculated members].[_0]') {
                let isAvail = false;
                for (const field of this.calculatedFieldSettings) {
                    if (fieldName === field.name) {
                        const expression = field.formula;
                        const formatString = field.formatString;
                        this.savedFieldListData[i].formula = expression;
                        this.savedFieldListData[i].formatString = formatString;
                        this.savedFieldListData[i].parentHierarchy = (expression.toLowerCase().indexOf('measure') > -1 ?
                            undefined : field.hierarchyUniqueName);
                        this.savedFieldList[fieldName].formula = expression;
                        this.savedFieldList[fieldName].formatString = formatString;
                        this.savedFieldList[fieldName].parentHierarchy = this.savedFieldListData[i].parentHierarchy;
                        isAvail = true;
                    }
                }
                if (!isAvail || (fieldName.toLowerCase() === '[calculated members].[_0]' &&
                    this.calculatedFieldSettings.length === 0)) {
                    this.savedFieldListData.splice(i, 1);
                    i--;
                    if (this.savedFieldList[fieldName]) {
                        delete this.savedFieldList[fieldName];
                    }
                }
            }
            i++;
        }
        this.fieldList = this.savedFieldList;
        this.fieldListData = this.savedFieldListData;
    }
    updateFieldlistData(name, isSelect) {
        for (const item of this.fieldListData) {
            if (item.id === name) {
                item.isSelected = isSelect ? true : false;
                break;
            }
        }
    }
    getFormattedFields(formats) {
        this.formatFields = {};
        let cnt = formats.length;
        while (cnt--) {
            this.formatFields[formats[cnt].name] = formats[cnt];
        }
    }
    getFieldList(dataSourceSettings) {
        const args = {
            catalog: dataSourceSettings.catalog,
            cube: dataSourceSettings.cube,
            url: dataSourceSettings.url,
            LCID: dataSourceSettings.localeIdentifier.toString(),
            request: 'MDSCHEMA_HIERARCHIES',
            roles: dataSourceSettings.roles
        };
        this.getTreeData(args, this.getFieldListItems.bind(this), { dataSourceSettings: dataSourceSettings, action: 'loadFieldElements' });
    }
    getTreeData(args, successMethod, customArgs) {
        const connectionString = this.getConnectionInfo(args.url, args.LCID); // eslint-disable-next-line no-useless-escape
        const soapMessage = '<Envelope xmlns=\"http://schemas.xmlsoap.org/soap/envelope/\"><Header/><Body><Discover xmlns=\"urn:schemas-microsoft-com:xml-analysis\"><RequestType>' +
            args.request + '</RequestType><Restrictions><RestrictionList><CATALOG_NAME>' + args.catalog +
            '</CATALOG_NAME><CUBE_NAME>' + args.cube + '</CUBE_NAME></RestrictionList></Restrictions><Properties><PropertyList><Catalog>' + args.catalog +
            '</Catalog> <LocaleIdentifier>' + connectionString.LCID + '</LocaleIdentifier>' + (args.roles ? '<Roles>' + args.roles + '</Roles>' : '') + '</PropertyList></Properties></Discover></Body></Envelope>';
        this.doAjaxPost('POST', connectionString.url, soapMessage, successMethod, customArgs);
    }
    getAxisFields() {
        this.rows = this.dataSourceSettings.rows ? this.dataSourceSettings.rows : [];
        this.columns = this.dataSourceSettings.columns ? this.dataSourceSettings.columns : [];
        this.filters = this.dataSourceSettings.filters ? this.dataSourceSettings.filters : [];
        this.values = this.dataSourceSettings.values ? this.dataSourceSettings.values : [];
        let dataFields = extend([], this.rows, null, true);
        dataFields = dataFields.concat(this.columns, this.values, this.filters);
        let len = dataFields.length;
        while (len--) {
            this.dataFields[dataFields[len].name] = dataFields[len];
            if (dataFields[len].name.toLowerCase() === '[measures]') {
                this.isMeasureAvail = true;
            }
            else {
                this.selectedItems.push(dataFields[len].name);
            }
        }
        this.mappingFields = {};
        if (this.dataSourceSettings.fieldMapping) {
            for (const field of this.dataSourceSettings.fieldMapping) {
                this.mappingFields[field.name] = field;
            }
        }
        if (!this.isMeasureAvail && this.values.length > 0) {
            const measureField = {
                name: '[Measures]', caption: 'Measures', showRemoveIcon: true, allowDragAndDrop: true
            };
            if (this.valueAxis === 'row') {
                this.rows.push(measureField);
            }
            else {
                this.columns.push(measureField);
            }
            this.isMeasureAvail = true;
        }
    }
    getAggregateType(fieldName, aggregateType) {
        let type;
        switch (aggregateType) {
            case '1':
                type = 'Sum';
                break;
            case '2':
                type = 'Count';
                break;
            case '3':
                type = 'Min';
                break;
            case '4':
                type = 'Max';
                break;
            case '5':
                type = 'Avg';
                break;
            case '8':
                type = 'DistinctCount';
                break;
            case '127':
                type = 'CalculatedField';
                break;
            default:
                type = undefined;
                break;
        }
        // if (this.dataFields[fieldName as string]) {
        //     return this.dataFields[fieldName as string].type;
        // } else {
        //     return undefined;
        // }
        if (type) {
            return type;
        }
        else {
            return undefined;
        }
    }
    getUniqueName(name) {
        let uName = name;
        for (const item of this.calculatedFieldSettings) {
            const expression = item.formula;
            const prefixName = (expression.toLowerCase().indexOf('measure') > -1 ? '[Measures].' : item.hierarchyUniqueName + '.');
            const uniqueName = prefixName + '[' + item.name + ']';
            if (name === uniqueName) {
                uName = item.name;
                break;
            }
        }
        return uName;
    }
    updateFilterItems(filterItems) {
        let dataFields = extend([], this.rows, null, true);
        dataFields = dataFields.concat(this.columns);
        for (const filter of filterItems) {
            if (filter.type === 'Include' && this.allowMemberFilter) {
                const members = this.fieldList[filter.name].members;
                const isMembersAvail = (members && Object.keys(members).length > 0);
                this.fieldList[filter.name].actualFilter = [...filter.items];
                const selectedElements = extend([], filter.items, null, true);
                if (isMembersAvail) {
                    let i = 0;
                    while (i < selectedElements.length) {
                        let parentNodes = [];
                        parentNodes = this.getParentNode(selectedElements[i], members, parentNodes);
                        for (const node of parentNodes) {
                            const index = PivotUtil.inArray(node, filter.items);
                            if (index !== -1) {
                                filter.items.splice(index, 1);
                            }
                        }
                        i++;
                    }
                }
                const currentItems = [];
                for (const selectedElement of filter.items) {
                    // currentItems.push(selectedElement.replace(/\&/g, '&amp;'));
                    currentItems.push(selectedElement);
                    if (isMembersAvail) {
                        this.fieldList[filter.name].filter.push(members[selectedElement].caption);
                    }
                    else {
                        this.fieldList[filter.name].filter.push(selectedElement);
                    }
                }
                this.filterMembers[filter.name] = currentItems;
                this.fieldList[filter.name].isExcelFilter = false;
            }
            else if ((this.allowValueFilter || this.allowLabelFilter) &&
                ['Date', 'Label', 'Number', 'Value'].indexOf(filter.type) !== -1) {
                for (const item of dataFields) {
                    if (item.name === filter.name) {
                        const filterMembers = this.filterMembers[filter.name];
                        if (filterMembers && (typeof filterMembers[0] === 'object' && filterMembers[0].type === filter.type)) {
                            filterMembers[filterMembers.length] = filter;
                        }
                        else {
                            this.filterMembers[filter.name] = [filter];
                        }
                        this.fieldList[filter.name].isExcelFilter = true;
                        break;
                    }
                }
            }
        }
    }
    getParentNode(name, members, items) {
        if (members[name].parent && name !== members[name].parent) {
            const parentItem = members[name].parent;
            items.push(parentItem);
            this.getParentNode(parentItem, members, items);
        }
        return items;
    }
    updateDrilledItems(drilledMembers) {
        const drilledItems = [];
        let dataFields = extend([], this.rows, null, true);
        dataFields = dataFields.concat(this.columns);
        for (const item of drilledMembers) {
            for (const field of dataFields) {
                if (item.name === field.name) {
                    drilledItems.push(item);
                    break;
                }
            }
        }
        return drilledItems;
    }
    // private updateAllMembers(dataSourceSettings: IDataOptions, slicers: IFieldOptions[]): void {
    //     let query: string = '';
    //     for (let field of slicers) {
    //         let fieldList: IOlapField = this.fieldList[field.name];
    //         if (!(fieldList && fieldList.hasAllMember && fieldList.allMember)) {
    //             query = query + (query !== '' ? ' * ' : '') + '{' + field.name + '}';
    //         } else {
    //             continue;
    //         }
    //     }
    //     if (query !== '') {
    //         this.getAllMember(dataSourceSettings, query);
    //     } else {
    //         return;
    //     }
    // }
    // private getAllMember(dataSourceSettings: IDataOptions, query: string): void {
    //     let dimProp: string = 'DIMENSION PROPERTIES HIERARCHY_UNIQUE_NAME, CHILDREN_CARDINALITY';
    //     let mdxQuery: string = 'SELECT (' + query + ')' + dimProp + ' ON 0 FROM [' + dataSourceSettings.cube + ']';
    //     let xmla: string = this.getSoapMsg(dataSourceSettings, mdxQuery);
    //     let connectionString: ConnectionInfo = this.getConnectionInfo(dataSourceSettings.url, dataSourceSettings.localeIdentifier);
    //     this.doAjaxPost('POST', connectionString.url, xmla, this.generateAllMembers.bind(this),
    // { dataSourceSettings: dataSourceSettings, action: 'fetchAllMembers' });
    // }
    /**
     * It performs to returns the drill through data.
     *
     * @param {IAxisSet} pivotValue - It cotains the pivotValues data.
     * @param {number} maxRows - It cotains the maximum number of row data.
     * @returns {void}
     * @hidden
     */
    getDrillThroughData(pivotValue, maxRows) {
        const column = this.tupColumnInfo[pivotValue.colOrdinal] &&
            this.tupColumnInfo[pivotValue.colOrdinal].uNameCollection &&
            this.tupColumnInfo[pivotValue.colOrdinal].uNameCollection !== '' ?
            this.tupColumnInfo[pivotValue.colOrdinal].uNameCollection.split('::[').map((item) => {
                return item[0] === '[' ? item : ('[' + item);
            }) : [];
        const row = this.tupRowInfo[pivotValue.rowOrdinal] &&
            this.tupRowInfo[pivotValue.rowOrdinal].uNameCollection &&
            this.tupRowInfo[pivotValue.rowOrdinal].uNameCollection !== '' ?
            this.tupRowInfo[pivotValue.rowOrdinal].uNameCollection.split('::[').map((item) => {
                return item[0] === '[' ? item : ('[' + item);
            }) : [];
        let filters;
        const filteritems = [];
        let filterQuery = '';
        for (let i = 0; i < this.filters.length; i++) {
            filters = this.filterMembers[this.filters[i].name];
            if (filters) {
                for (let j = 0; j < filters.length; j++) {
                    filterQuery = filterQuery + filters[j];
                    filterQuery = j < filters.length - 1 ? filterQuery + ',' : filterQuery + '';
                }
                filteritems[i] = filterQuery;
                filterQuery = '';
            }
        }
        for (let i = 0; i < filteritems.length; i++) {
            filterQuery = filterQuery === '' ? '{' + filteritems[i] + '}' : (filterQuery + ',' + '{' + filteritems[i] + '}');
        }
        let columnQuery = '';
        let rowQuery = '';
        for (let i = 0; i < column.length; i++) {
            columnQuery = (columnQuery.length > 0 ? (columnQuery + ',') : '') + (column[i].split('~~').length > 1 ?
                column[i].split('~~')[column[i].split('~~').length - 1] : column[i]);
        }
        for (let i = 0; i < row.length; i++) {
            rowQuery = (rowQuery.length > 0 ? (rowQuery + ',') : '') + (row[i].split('~~').length > 1 ?
                row[i].split('~~')[row[i].split('~~').length - 1] : row[i]);
        }
        let drillQuery = 'DRILLTHROUGH MAXROWS ' + maxRows + ' Select(' + (columnQuery.length > 0 ? columnQuery : '') +
            (columnQuery.length > 0 && rowQuery.length > 0 ? ',' : '') + (rowQuery.length > 0 ? rowQuery : '') + ') on 0 from ' +
            (filterQuery === '' ? '[' + this.dataSourceSettings.cube + ']' : '(SELECT (' + filterQuery + ') ON COLUMNS FROM [' +
                this.dataSourceSettings.cube + '])');
        drillQuery = drillQuery.replace(/&/g, '&amp;');
        const xmla = this.getSoapMsg(this.dataSourceSettings, drillQuery);
        const connectionString = this.getConnectionInfo(this.dataSourceSettings.url, this.dataSourceSettings.localeIdentifier);
        this.doAjaxPost('POST', connectionString.url, xmla, this.drillThroughSuccess.bind(this), { dataSourceSettings: this.dataSourceSettings, action: 'drillThrough' });
    }
    drillThroughSuccess(xmlDoc) {
        const tag = [].slice.call(xmlDoc.querySelectorAll('row'));
        let gridJSON = '';
        if (tag.length > 0) {
            const json = [];
            let i = 0;
            while (i < tag.length) {
                const child = [].slice.call(tag[i].children);
                let j = 0;
                while (j < child.length) {
                    json.push('"' + child[j].tagName + '"' + ':' + '"' + child[j].textContent + '"');
                    j++;
                }
                i++;
            }
            const value = json[0];
            let k = 0;
            while (k < json.length) {
                if (Object.keys(JSON.parse('[{' + json[k] + '}]')[0])[0] === Object.keys(JSON.parse('[{' + value + '}]')[0])[0]) {
                    gridJSON += gridJSON === '' ? '[{' + json[k] : '}, {' + json[k];
                    k++;
                    continue;
                }
                gridJSON += ',' + json[k];
                k++;
            }
            gridJSON += '}]';
        }
        else {
            const tag = [].slice.call(xmlDoc.querySelectorAll('faultstring'));
            let i = 0;
            while (i < tag.length) {
                gridJSON += tag[i].textContent;
                i++;
            }
        }
        this.gridJSON = gridJSON;
    }
    getFilterMembers(dataSourceSettings, fieldName, levelCount, isSearchFilter, loadLevelMember) {
        // let dimProp: string = 'DIMENSION PROPERTIES PARENT_UNIQUE_NAME, HIERARCHY_UNIQUE_NAME, CHILDREN_CARDINALITY, MEMBER_TYPE';
        const levels = this.fieldList[fieldName].levels;
        const cLevel = this.fieldList[fieldName].levelCount;
        let filterQuery;
        if (loadLevelMember) {
            filterQuery = 'Descendants({' + levels[cLevel].id + '}, ' +
                levels[levelCount - 1].id + ', ' + ((levelCount - cLevel) === 1 ? 'SELF)' : 'SELF_AND_BEFORE)');
        }
        else {
            filterQuery = fieldName + ', Descendants({' + levels[0].id + '}, ' + levels[levelCount - 1].id + ', SELF_AND_BEFORE)';
        }
        this.fieldList[fieldName].levelCount = levelCount;
        if (!isSearchFilter) {
            this.getMembers(dataSourceSettings, fieldName, false, filterQuery, loadLevelMember);
        }
        return filterQuery;
    }
    getMembers(dataSourceSettings, fieldName, isAllFilterData, filterParentQuery, loadLevelMember) {
        // dimProp = "dimension properties CHILDREN_CARDINALITY, MEMBER_TYPE";
        const dimProp = 'DIMENSION PROPERTIES PARENT_UNIQUE_NAME, HIERARCHY_UNIQUE_NAME, CHILDREN_CARDINALITY, MEMBER_TYPE, MEMBER_VALUE';
        let mdxQuery;
        const hasAllMember = this.fieldList[fieldName].hasAllMember;
        const hierarchy = (hasAllMember ? fieldName : fieldName + '.LEVELS(0)').replace(/\&/g, '&amp;'); /* eslint-disable-line no-useless-escape */
        if (!isAllFilterData) {
            mdxQuery = 'SELECT ({' + (filterParentQuery ?
                filterParentQuery : (hasAllMember ? hierarchy + ', ' + hierarchy + '.CHILDREN' : hierarchy + '.ALLMEMBERS')) + '})' +
                dimProp + ' ON 0 FROM [' + dataSourceSettings.cube + ']';
        }
        else {
            mdxQuery = 'SELECT ({' + hierarchy + '.ALLMEMBERS})' + dimProp + ' ON 0 FROM [' + dataSourceSettings.cube + ']';
        }
        const xmla = this.getSoapMsg(dataSourceSettings, mdxQuery);
        const connectionString = this.getConnectionInfo(dataSourceSettings.url, dataSourceSettings.localeIdentifier);
        if (!loadLevelMember) {
            this.fieldList[fieldName].filterMembers = [];
            this.fieldList[fieldName].childMembers = [];
            this.fieldList[fieldName].searchMembers = [];
            // this.fieldList[fieldName as string].isHierarchy = true;
            this.fieldList[fieldName].members = {};
            this.fieldList[fieldName].currrentMembers = {};
        }
        this.doAjaxPost('POST', connectionString.url, xmla, this.generateMembers.bind(this), { dataSourceSettings: dataSourceSettings, fieldName: fieldName, loadLevelMembers: loadLevelMember, action: 'fetchMembers' });
    }
    getChildMembers(dataSourceSettings, memberUQName, fieldName) {
        // dimProp = "dimension properties CHILDREN_CARDINALITY, MEMBER_TYPE";
        const dimProp = 'DIMENSION PROPERTIES PARENT_UNIQUE_NAME, HIERARCHY_UNIQUE_NAME, CHILDREN_CARDINALITY, MEMBER_TYPE, MEMBER_VALUE';
        // var mdxQuery = 'SELECT SUBSET({' + memberUQName + '.CHILDREN}, 0, 5000)' + dimProp + ' ON 0 FROM [' + dataSourceSettings.cube + ']';
        const mdxQuery = 'SELECT ({' + memberUQName.replace(/\&/g, '&amp;') + '.CHILDREN})' + dimProp + ' ON 0 FROM [' + dataSourceSettings.cube + ']'; /* eslint-disable-line no-useless-escape */
        const xmla = this.getSoapMsg(dataSourceSettings, mdxQuery);
        const connectionString = this.getConnectionInfo(dataSourceSettings.url, dataSourceSettings.localeIdentifier);
        this.doAjaxPost('POST', connectionString.url, xmla, this.generateMembers.bind(this), { dataSourceSettings: dataSourceSettings, fieldName: fieldName, action: 'fetchChildMembers' });
    }
    getCalcChildMembers(dataSourceSettings, memberUQName) {
        this.calcChildMembers = [];
        const dimProp = 'DIMENSION PROPERTIES PARENT_UNIQUE_NAME, HIERARCHY_UNIQUE_NAME, CHILDREN_CARDINALITY, MEMBER_TYPE, MEMBER_VALUE';
        const mdxQuery = 'SELECT ({' + memberUQName.replace(/\&/g, '&amp;') + '.MEMBERS})' + /* eslint-disable-line no-useless-escape */
            dimProp + ' ON 0 FROM [' + dataSourceSettings.cube + ']';
        const connectionString = this.getConnectionInfo(dataSourceSettings.url, dataSourceSettings.localeIdentifier);
        const xmla = this.getSoapMsg(dataSourceSettings, mdxQuery);
        this.doAjaxPost('POST', connectionString.url, xmla, this.generateMembers.bind(this), { dataSourceSettings: dataSourceSettings, action: 'fetchCalcChildMembers' });
    }
    getSearchMembers(dataSourceSettings, fieldName, searchString, maxNodeLimit, isAllFilterData, levelCount) {
        this.fieldList[fieldName].searchMembers = [];
        this.fieldList[fieldName].currrentMembers = {};
        if (searchString !== '') {
            // dimProp = "dimension properties CHILDREN_CARDINALITY, MEMBER_TYPE";
            const dimProp = 'DIMENSION PROPERTIES PARENT_UNIQUE_NAME, HIERARCHY_UNIQUE_NAME, CHILDREN_CARDINALITY, MEMBER_TYPE, MEMBER_VALUE';
            const hierarchy = fieldName.replace(/\&/g, '&amp;'); /* eslint-disable-line no-useless-escape */
            const mdxQuery = 'WITH SET [SearchMembersSet] AS &#39;FILTER(' + (isAllFilterData ? hierarchy + '.ALLMEMBERS, ' :
                '{' + (levelCount > 1 ? this.getFilterMembers(dataSourceSettings, fieldName, levelCount, true) :
                    hierarchy + ', ' + hierarchy + '.CHILDREN') + '},') +
                '(INSTR(1, ' + hierarchy + '.CurrentMember.member_caption, "' + searchString + '") > 0))&#39;' +
                'SET [SearchParentsSet] AS &#39;GENERATE([SearchMembersSet], ASCENDANTS([SearchMembersSet].Current))&#39;' +
                'SET [SearchSet] AS &#39;HIERARCHIZE(DISTINCT({[SearchMembersSet], [SearchParentsSet]}))&#39;' +
                'SELECT SUBSET([SearchSet], 0, ' + maxNodeLimit + ')' + dimProp + ' ON 0 FROM [' + dataSourceSettings.cube + ']';
            const xmla = this.getSoapMsg(dataSourceSettings, mdxQuery);
            const connectionString = this.getConnectionInfo(dataSourceSettings.url, dataSourceSettings.localeIdentifier);
            this.doAjaxPost('POST', connectionString.url, xmla, this.generateMembers.bind(this), {
                dataSourceSettings: dataSourceSettings,
                fieldName: fieldName, action: 'fetchSearchMembers'
            });
        }
        else {
            return;
        }
    }
    generateMembers(xmlDoc, request, customArgs) {
        const fields = [].slice.call(xmlDoc.querySelectorAll('Axis[name="Axis0"] Tuple'));
        const fieldName = customArgs.fieldName;
        let allMember;
        let filterMembers = {};
        for (const field of fields) {
            // let hierarchyUqName: string = fields[0].querySelector('Member HIERARCHY_UNIQUE_NAME').textContent;
            const member = field.querySelector('Member');
            const memberType = member.querySelector('MEMBER_TYPE').textContent;
            const memberUqName = member.querySelector('UName').textContent;
            const caption = member.querySelector('Caption').textContent;
            const parentUqName = member.querySelector('PARENT_UNIQUE_NAME') ? member.querySelector('PARENT_UNIQUE_NAME').textContent : '';
            const nodeAttr = { 'data-fieldName': fieldName, 'data-memberId': memberUqName };
            if (parentUqName === '' && memberType === '1') {
                filterMembers = {
                    hasChildren: (field.querySelector('CHILDREN_CARDINALITY') ? (field.querySelector('CHILDREN_CARDINALITY').textContent !== '0') ? true : false : false),
                    isSelected: false,
                    id: memberUqName,
                    tag: memberUqName,
                    name: caption,
                    caption: caption,
                    htmlAttributes: nodeAttr
                };
                if (customArgs.action === 'fetchMembers' || customArgs.action === 'fetchChildMembers') {
                    this.fieldList[fieldName].members[memberUqName] =
                        { name: memberUqName, caption: caption, parent: undefined, isNodeExpand: false, isSelected: false };
                    this.fieldList[fieldName].filterMembers.push(filterMembers);
                    this.fieldList[fieldName].childMembers.push(filterMembers);
                }
                else if (customArgs.action === 'fetchSearchMembers') {
                    this.fieldList[fieldName].currrentMembers[memberUqName] =
                        { name: memberUqName, caption: caption, parent: undefined, isNodeExpand: false, isSelected: false };
                    this.fieldList[fieldName].searchMembers.push(filterMembers);
                    filterMembers.expanded = true;
                }
                else {
                    this.calcChildMembers.push(filterMembers);
                }
            }
            else if (parentUqName !== '' && memberType === '1') {
                if (parentUqName === allMember && memberType === '1') {
                    filterMembers = {
                        hasChildren: (field.querySelector('CHILDREN_CARDINALITY') ? (field.querySelector('CHILDREN_CARDINALITY').textContent !== '0') ? true : false : false),
                        id: memberUqName,
                        name: caption,
                        isSelected: false,
                        caption: caption,
                        htmlAttributes: nodeAttr,
                        tag: memberUqName
                    };
                    if (customArgs.action === 'fetchMembers' || customArgs.action === 'fetchChildMembers') {
                        this.fieldList[fieldName].filterMembers.push(filterMembers);
                        this.fieldList[fieldName].childMembers.push(filterMembers);
                        this.fieldList[fieldName].members[memberUqName] =
                            { name: memberUqName, caption: caption, parent: undefined, isNodeExpand: false, isSelected: false };
                    }
                    else if (customArgs.action === 'fetchSearchMembers') {
                        filterMembers.expanded = true;
                        this.fieldList[fieldName].searchMembers.push(filterMembers);
                        this.fieldList[fieldName].currrentMembers[memberUqName] =
                            { name: memberUqName, caption: caption, parent: undefined, isNodeExpand: false, isSelected: false };
                    }
                    else {
                        this.calcChildMembers.push(filterMembers);
                    }
                }
                else {
                    if (customArgs.action === 'fetchMembers' && this.fieldList[fieldName].members[memberUqName]) {
                        continue;
                    }
                    const nodeSelect = (customArgs.loadLevelMembers ?
                        this.fieldList[fieldName].members[parentUqName].isSelected : false);
                    filterMembers = {
                        hasChildren: (field.querySelector('CHILDREN_CARDINALITY') ?
                            (field.querySelector('CHILDREN_CARDINALITY').textContent !== '0') ? true : false : false),
                        htmlAttributes: nodeAttr,
                        isSelected: false,
                        id: memberUqName,
                        pid: parentUqName,
                        name: caption,
                        caption: caption,
                        tag: memberUqName
                    };
                    if (customArgs.action === 'fetchMembers' || customArgs.action === 'fetchChildMembers') {
                        this.fieldList[fieldName].isHierarchy = false;
                        this.fieldList[fieldName].filterMembers.push(filterMembers);
                        this.fieldList[fieldName].childMembers.push(filterMembers);
                        this.fieldList[fieldName].members[memberUqName] =
                            { name: memberUqName, caption: caption, parent: parentUqName, isNodeExpand: false, isSelected: nodeSelect };
                    }
                    else if (customArgs.action === 'fetchSearchMembers') {
                        this.fieldList[fieldName].searchMembers.push(filterMembers);
                        filterMembers.expanded = true;
                        this.fieldList[fieldName].currrentMembers[memberUqName] =
                            { name: memberUqName, caption: caption, parent: parentUqName, isNodeExpand: false, isSelected: false };
                    }
                    else {
                        this.calcChildMembers.push(filterMembers);
                    }
                }
            }
            else if (memberType === '2') {
                allMember = memberUqName;
            }
        }
    }
    // private generateAllMembers(xmlDoc: Document, request: Ajax, customArgs: FieldData): void {
    //     let members: HTMLElement[] = [].slice.call(xmlDoc.querySelectorAll('Axis[name="Axis0"] Member'));
    //     for (let member of members) {
    //         let caption: string = member.querySelector('Caption').textContent;
    //         let fieldName: string = member.querySelector('HIERARCHY_UNIQUE_NAME').textContent;
    //         this.fieldList[fieldName as string].allMember = caption;
    //     }
    // }
    getFieldListItems(xmlDoc, request, customArgs) {
        let fieldDate = {};
        const hierarchyElements = [];
        const fields = [].slice.call(xmlDoc.querySelectorAll('row'));
        for (const field of fields) {
            const isAllMemberAvail = [].slice.call(field.querySelectorAll('ALL_MEMBER')).length > 0;
            const dimensionName = field.querySelector('DIMENSION_UNIQUE_NAME').textContent;
            const hierarchyName = field.querySelector('HIERARCHY_UNIQUE_NAME').textContent;
            const isSameDim = dimensionName === hierarchyName && dimensionName.toLowerCase() !== '[measures]' && hierarchyName.toLowerCase() !== '[measures]';
            hierarchyElements.push({
                pid: ((this.isMondrian || isSameDim) ? dimensionName + '~#^Dim' : dimensionName),
                id: hierarchyName,
                name: field.querySelector('HIERARCHY_CAPTION').textContent,
                caption: field.querySelector('HIERARCHY_CAPTION').textContent,
                tag: hierarchyName,
                hasAllMember: isAllMemberAvail,
                allMember: (isAllMemberAvail ? field.querySelectorAll('ALL_MEMBER')[0].textContent : undefined),
                // aggregateType: this.getAggregateType(field.querySelector('HIERARCHY_UNIQUE_NAME').textContent),
                type: 'string'
            });
        }
        fieldDate = {
            hierarchy: hierarchyElements,
            hierarchySuccess: xmlDoc,
            measures: []
        };
        this.fieldListObj = fieldDate;
        const args = {
            catalog: customArgs.dataSourceSettings.catalog,
            cube: customArgs.dataSourceSettings.cube,
            url: customArgs.dataSourceSettings.url,
            LCID: customArgs.dataSourceSettings.localeIdentifier.toString(),
            request: 'MDSCHEMA_DIMENSIONS',
            roles: customArgs.dataSourceSettings.roles
        };
        this.getTreeData(args, this.loadDimensionElements.bind(this), customArgs);
    }
    loadCalculatedMemberElements(calcMembers) {
        if (calcMembers.length > 0) {
            const fieldListElements = this.fieldListData;
            // let calcElements: IOlapField[] = [];
            const calcObj = {
                hasChildren: true,
                isSelected: false,
                id: '[Calculated Members].[_0]',
                name: '[Calculated Members].[_0]',
                caption: 'Calculated Members',
                spriteCssClass: 'e-calcMemberGroupCDB' + ' ' + ICON,
                tag: '[Calculated Members].[_0]',
                //aggregateType: this.getAggregateType(dimensionName),
                type: 'string'
            };
            if (fieldListElements.length > 0 && fieldListElements[0].id.toLowerCase() === '[measures]') {
                fieldListElements.splice(0, 0, calcObj);
            }
            for (const field of calcMembers) {
                if (!this.fieldList[field.name]) {
                    const expression = field.formula;
                    const prefixName = (expression.toLowerCase().indexOf('measure') > -1 ? '[Measures].' :
                        field.hierarchyUniqueName + '.');
                    const uniqueName = prefixName + '[' + field.name + ']';
                    const caption = (this.dataFields[field.name] && this.dataFields[field.name].caption ?
                        this.dataFields[field.name].caption :
                        this.mappingFields[field.name] && this.mappingFields[field.name].caption ?
                            this.mappingFields[field.name].caption : field.name);
                    const formatString = field.formatString;
                    const calcField = {
                        hasChildren: false,
                        isSelected: false,
                        id: field.name,
                        pid: '[Calculated Members].[_0]',
                        name: field.name,
                        caption: caption,
                        spriteCssClass: 'e-calc-member' + ' ' + (expression.toLowerCase().indexOf('measure') > -1 ?
                            'e-calc-measure-icon' : 'e-calc-dimension-icon') + ' ' + ICON,
                        tag: uniqueName,
                        formula: expression,
                        formatString: formatString,
                        aggregateType: undefined,
                        type: 'CalculatedField',
                        filter: [],
                        dateMember: [],
                        sort: 'Ascending',
                        actualFilter: [],
                        filterMembers: [],
                        childMembers: [],
                        searchMembers: [],
                        members: {},
                        currrentMembers: {},
                        isHierarchy: true,
                        isExcelFilter: false,
                        isCalculatedField: true,
                        allowDragAndDrop: (this.dataFields[field.name] ? this.dataFields[field.name].allowDragAndDrop :
                            this.mappingFields[field.name] ? this.mappingFields[field.name].allowDragAndDrop : true),
                        showFilterIcon: (this.dataFields[field.name] ? this.dataFields[field.name].showFilterIcon :
                            this.mappingFields[field.name] ? this.mappingFields[field.name].showFilterIcon : true),
                        showSortIcon: (this.dataFields[field.name] ? this.dataFields[field.name].showSortIcon :
                            this.mappingFields[field.name] ? this.mappingFields[field.name].showSortIcon : true),
                        showEditIcon: (this.dataFields[field.name] ? this.dataFields[field.name].showEditIcon :
                            this.mappingFields[field.name] ? this.mappingFields[field.name].showEditIcon : true),
                        showRemoveIcon: (this.dataFields[field.name] ? this.dataFields[field.name].showRemoveIcon :
                            this.mappingFields[field.name] ? this.mappingFields[field.name].showRemoveIcon : true),
                        showValueTypeIcon: (this.dataFields[field.name] ? this.dataFields[field.name].showValueTypeIcon :
                            this.mappingFields[field.name] ? this.mappingFields[field.name].showValueTypeIcon : true),
                        showSubTotals: (this.dataFields[field.name] ? this.dataFields[field.name].showSubTotals :
                            this.mappingFields[field.name] ? this.mappingFields[field.name].showSubTotals : true),
                        fieldType: (expression.toLowerCase().indexOf('measure') > -1 ? 'Measure' : 'Dimension'),
                        parentHierarchy: (expression.toLowerCase().indexOf('measure') > -1 ? undefined : field.hierarchyUniqueName)
                    };
                    fieldListElements.push(calcField);
                    this.fieldList[calcField.id] = calcField;
                    this.updateMembersOrder(field.name);
                }
            }
        }
        else {
            return;
        }
    }
    loadDimensionElements(xmlDoc, request, customArgs) {
        const hierarchyElements = [];
        const fields = [].slice.call(xmlDoc.querySelectorAll('row'));
        let measure = {};
        for (const field of fields) {
            const dimensionName = field.querySelector('DIMENSION_UNIQUE_NAME').textContent;
            const defaultHierarchy = field.querySelector('DEFAULT_HIERARCHY').textContent;
            const dimensionCaption = field.querySelector('DIMENSION_CAPTION').textContent;
            const isSameDim = dimensionName === defaultHierarchy;
            if (dimensionName.toLowerCase().indexOf('[measure') >= 0) {
                measure = {
                    hasChildren: true,
                    isSelected: false,
                    id: dimensionName,
                    name: dimensionName,
                    caption: dimensionCaption,
                    spriteCssClass: dimensionName.toLowerCase() === '[measures]' ? 'e-measureGroupCDB-icon' + ' ' + ICON : 'e-dimensionCDB-icon' + ' ' + ICON,
                    tag: dimensionName,
                    // aggregateType: this.getAggregateType(dimensionName),
                    type: 'string'
                };
            }
            else if (isNullOrUndefined(fields[0].querySelector('HIERARCHY_CAPTION'))) {
                hierarchyElements.push({
                    hasChildren: true,
                    isSelected: false,
                    id: ((this.isMondrian || isSameDim) ? dimensionName + '~#^Dim' : dimensionName),
                    name: dimensionName,
                    caption: dimensionCaption,
                    spriteCssClass: 'e-dimensionCDB-icon' + ' ' + ICON,
                    tag: dimensionName,
                    defaultHierarchy: field.querySelector('DEFAULT_HIERARCHY').textContent,
                    // aggregateType: this.getAggregateType(dimensionName),
                    type: 'string'
                });
            }
        }
        hierarchyElements.splice(0, 0, measure);
        this.fieldListData = hierarchyElements;
        // customArgs.hierarchy = this.fieldListData;
        // customArgs.hierarchySuccess = this.fieldListObj.hierarchySuccess;
        // this.loadHierarchyElements(customArgs);
        const args = {
            catalog: customArgs.dataSourceSettings.catalog,
            cube: customArgs.dataSourceSettings.cube,
            url: customArgs.dataSourceSettings.url,
            LCID: customArgs.dataSourceSettings.localeIdentifier.toString(),
            request: 'MDSCHEMA_SETS',
            roles: customArgs.dataSourceSettings.roles
        };
        this.getTreeData(args, this.loadNamedSetElements.bind(this), customArgs);
    }
    loadNamedSetElements(xmlDoc, request, customArgs) {
        let dataFields = extend([], this.rows, null, true);
        dataFields = dataFields.concat(this.columns, this.filters);
        const dimensionElements = this.fieldListData;
        const reportElement = [];
        for (const field of dataFields) {
            reportElement.push(field.name);
        }
        const measureGroupItems = [];
        const fields = [].slice.call(xmlDoc.querySelectorAll('row'));
        for (const field of fields) {
            if (!(measureGroupItems.indexOf(field.querySelector('DIMENSIONS').textContent.split('.')[0]) >= 0)) {
                dimensionElements.push({
                    hasChildren: true,
                    isSelected: false,
                    pid: field.querySelector('DIMENSIONS').textContent.split('.')[0],
                    id: field.querySelector('SET_DISPLAY_FOLDER').textContent + '_' + field.querySelector('DIMENSIONS').textContent.split('.')[0],
                    name: field.querySelector('SET_DISPLAY_FOLDER').textContent,
                    spriteCssClass: 'e-folderCDB-icon' + ' ' + ICON + ' ' + 'namedSets',
                    caption: field.querySelector('SET_DISPLAY_FOLDER').textContent,
                    // aggregateType: this.getAggregateType(field.querySelector('SET_DISPLAY_FOLDER').textContent + '_' + field.querySelector('DIMENSIONS').textContent.split('.')[0]),
                    type: 'string'
                });
                measureGroupItems.push(field.querySelector('DIMENSIONS').textContent.split('.')[0]);
            }
            const id = '[' + field.querySelector('SET_NAME').textContent.trim() + ']';
            const fieldObj = {
                hasChildren: true,
                isNamedSets: true,
                isSelected: (reportElement.indexOf('[' + field.querySelector('SET_NAME').textContent + ']') >= 0),
                pid: field.querySelector('SET_DISPLAY_FOLDER').textContent + '_' + field.querySelector('DIMENSIONS').textContent.split('.')[0],
                id: id,
                name: field.querySelector('SET_CAPTION').textContent,
                caption: this.dataFields[id] && this.dataFields[id].caption ? this.dataFields[id].caption : this.mappingFields[id] && this.mappingFields[id].caption ? this.mappingFields[id].caption : field.querySelector('SET_CAPTION').textContent,
                spriteCssClass: 'e-namedSetCDB-icon' + ' ' + ICON,
                tag: field.querySelector('EXPRESSION').textContent,
                // aggregateType: this.getAggregateType(id),
                type: 'string',
                filter: [],
                dateMember: [],
                // sort: 'Ascending',
                actualFilter: [],
                filterMembers: [],
                childMembers: [],
                searchMembers: [],
                members: {},
                currrentMembers: {},
                isHierarchy: true,
                isExcelFilter: false,
                allowDragAndDrop: (this.dataFields[id] ? this.dataFields[id].allowDragAndDrop :
                    this.mappingFields[id] ? this.mappingFields[id].allowDragAndDrop : true),
                showFilterIcon: (this.dataFields[id] ? this.dataFields[id].showFilterIcon :
                    this.mappingFields[id] ? this.mappingFields[id].showFilterIcon : true),
                showSortIcon: (this.dataFields[id] ? this.dataFields[id].showSortIcon :
                    this.mappingFields[id] ? this.mappingFields[id].showSortIcon : true),
                showEditIcon: (this.dataFields[id] ? this.dataFields[id].showEditIcon :
                    this.mappingFields[id] ? this.mappingFields[id].showEditIcon : true),
                showRemoveIcon: (this.dataFields[id] ? this.dataFields[id].showRemoveIcon :
                    this.mappingFields[id] ? this.mappingFields[id].showRemoveIcon : true),
                showValueTypeIcon: (this.dataFields[id] ? this.dataFields[id].showValueTypeIcon :
                    this.mappingFields[id] ? this.mappingFields[id].showValueTypeIcon : true),
                showSubTotals: (this.dataFields[id] ? this.dataFields[id].showSubTotals :
                    this.mappingFields[id] ? this.mappingFields[id].showSubTotals : true)
            };
            dimensionElements.push(fieldObj);
            this.fieldList[id] = fieldObj;
            this.updateMembersOrder(id);
        }
        // let args: ConnectionInfo = {
        //     catalog: customArgs.dataSourceSettings.catalog,
        //     cube: customArgs.dataSourceSettings.cube,
        //     url: customArgs.dataSourceSettings.url,
        //     LCID: customArgs.dataSourceSettings.localeIdentifier.toString(),
        //     request: 'MDSCHEMA_SETS'
        // };
        // this.getTreeData(args, this.loadHierarchyElements.bind(this), customArgs);
        customArgs.hierarchy = this.fieldListData;
        customArgs.hierarchySuccess = this.fieldListObj.hierarchySuccess;
        this.loadHierarchyElements(customArgs);
    }
    loadHierarchyElements(customArgs) {
        const data = customArgs.hierarchySuccess;
        const dimensionElements = customArgs.hierarchy;
        let dataFields = extend([], this.rows, null, true);
        dataFields = dataFields.concat(this.columns, this.filters);
        const reportElement = [];
        for (const field of dataFields) {
            reportElement.push(field.name);
        }
        const fields = [].slice.call(data.querySelectorAll('row'));
        for (const field of fields) {
            const dimensionName = field.querySelector('DIMENSION_UNIQUE_NAME').textContent;
            const hierarchyName = field.querySelector('HIERARCHY_UNIQUE_NAME').textContent;
            const isAllMemberAvail = [].slice.call(field.querySelectorAll('ALL_MEMBER')).length > 0;
            let allMember;
            if (isAllMemberAvail) {
                const stringCollection = field.querySelectorAll('ALL_MEMBER')[0].textContent.replace(/[\]']+/g, '').split('.');
                allMember = stringCollection[stringCollection.length - 1].trim();
            }
            else {
                allMember = undefined;
            }
            const hierarchyFolderName = ((field.querySelector('HIERARCHY_DISPLAY_FOLDER')) ? (field.querySelector('HIERARCHY_DISPLAY_FOLDER').textContent) : '');
            const curElement = [];
            for (const item of dimensionElements) {
                if (item.tag === dimensionName) {
                    curElement.push(item);
                }
            }
            if (curElement.length > 0) {
                const isSameDim = dimensionName === hierarchyName && dimensionName.toLowerCase() !== '[measures]' && hierarchyName.toLowerCase() !== '[measures]';
                if (dimensionName.toLowerCase() !== '[measures]' && hierarchyName.toLowerCase() !== '[measures]') {
                    let parentID = dimensionName + ((this.isMondrian || isSameDim) ? '~#^Dim' : '');
                    if (hierarchyFolderName !== '') {
                        const folderName = dimensionName + ((this.isMondrian || isSameDim) ? '~#^Dim' : '') + '_' + hierarchyFolderName;
                        const curParentElement = [];
                        for (const item of dimensionElements) {
                            if (item.tag === folderName && item.pid === parentID) {
                                curParentElement.push(item);
                            }
                        }
                        if (curParentElement.length === 0) {
                            const fieldObj = {
                                hasChildren: true,
                                isSelected: false,
                                pid: dimensionName + ((this.isMondrian || isSameDim) ? '~#^Dim' : ''),
                                id: folderName,
                                name: hierarchyFolderName,
                                spriteCssClass: 'e-folderCDB-icon' + ' ' + ICON,
                                tag: folderName,
                                caption: hierarchyFolderName,
                                // aggregateType: this.getAggregateType(hierarchyFolderName),
                                type: 'string'
                            };
                            dimensionElements.push(fieldObj);
                        }
                        parentID = folderName;
                    }
                    const fieldObj = {
                        hasChildren: (field.querySelector('HIERARCHY_ORIGIN') ? ((field.querySelector('HIERARCHY_ORIGIN').textContent !== '2') && field.querySelector('HIERARCHY_ORIGIN').textContent !== '6') ? true : false : true),
                        // hasChildren: true,
                        isSelected: (reportElement.indexOf(hierarchyName) >= 0),
                        pid: parentID,
                        id: hierarchyName,
                        name: field.querySelector('HIERARCHY_CAPTION').textContent,
                        spriteCssClass: (field.querySelector('HIERARCHY_ORIGIN') ? ((field.querySelector('HIERARCHY_ORIGIN').textContent !== '2') && field.querySelector('HIERARCHY_ORIGIN').textContent !== '6') ? 'e-hierarchyCDB-icon' : 'e-attributeCDB-icon' : 'e-hierarchyCDB-icon') + ' ' + ICON,
                        hasAllMember: isAllMemberAvail,
                        allMember: allMember,
                        tag: hierarchyName,
                        caption: this.dataFields[hierarchyName] && this.dataFields[hierarchyName].caption ? this.dataFields[hierarchyName].caption : this.mappingFields[hierarchyName] && this.mappingFields[hierarchyName].caption ? this.mappingFields[hierarchyName].caption : field.querySelector('HIERARCHY_CAPTION').textContent,
                        // aggregateType: this.getAggregateType(hierarchyName),
                        type: 'string',
                        filter: [],
                        dateMember: [],
                        sort: (this.enableSort ? this.sortObject[hierarchyName] ? this.sortObject[hierarchyName] : 'Ascending' : 'None'),
                        actualFilter: [],
                        filterMembers: [],
                        childMembers: [],
                        searchMembers: [],
                        members: {},
                        currrentMembers: {},
                        levels: [],
                        levelCount: 1,
                        isHierarchy: (field.querySelector('HIERARCHY_ORIGIN') ? ((field.querySelector('HIERARCHY_ORIGIN').textContent !== '2') &&
                            field.querySelector('HIERARCHY_ORIGIN').textContent !== '6') ? false : true : false),
                        isExcelFilter: false,
                        allowDragAndDrop: (this.dataFields[hierarchyName] ?
                            this.dataFields[hierarchyName].allowDragAndDrop : this.mappingFields[hierarchyName] ?
                            this.mappingFields[hierarchyName].allowDragAndDrop : true),
                        showFilterIcon: (this.dataFields[hierarchyName] ?
                            this.dataFields[hierarchyName].showFilterIcon : this.mappingFields[hierarchyName] ?
                            this.mappingFields[hierarchyName].showFilterIcon : true),
                        showSortIcon: (this.dataFields[hierarchyName] ?
                            this.dataFields[hierarchyName].showSortIcon : this.mappingFields[hierarchyName] ?
                            this.mappingFields[hierarchyName].showSortIcon : true),
                        showEditIcon: (this.dataFields[hierarchyName] ?
                            this.dataFields[hierarchyName].showEditIcon : this.mappingFields[hierarchyName] ?
                            this.mappingFields[hierarchyName].showEditIcon : true),
                        showRemoveIcon: (this.dataFields[hierarchyName] ?
                            this.dataFields[hierarchyName].showRemoveIcon : this.mappingFields[hierarchyName] ?
                            this.mappingFields[hierarchyName].showRemoveIcon : true),
                        showValueTypeIcon: (this.dataFields[hierarchyName] ?
                            this.dataFields[hierarchyName].showValueTypeIcon : this.mappingFields[hierarchyName] ?
                            this.mappingFields[hierarchyName].showValueTypeIcon : true),
                        showSubTotals: (this.dataFields[hierarchyName] ? this.dataFields[hierarchyName].showSubTotals :
                            this.mappingFields[hierarchyName] ? this.mappingFields[hierarchyName].showSubTotals : true)
                    };
                    dimensionElements.push(fieldObj);
                    this.fieldList[hierarchyName] = fieldObj;
                    this.updateMembersOrder(hierarchyName);
                }
            }
        }
        const args = {
            catalog: customArgs.dataSourceSettings.catalog,
            cube: customArgs.dataSourceSettings.cube,
            url: customArgs.dataSourceSettings.url,
            LCID: customArgs.dataSourceSettings.localeIdentifier.toString(),
            request: 'MDSCHEMA_LEVELS',
            roles: customArgs.dataSourceSettings.roles
        };
        this.getTreeData(args, this.loadLevelElements.bind(this), customArgs);
    }
    updateMembersOrder(key) {
        for (const sortInfo of this.sortSettings) {
            if (key === sortInfo.name && sortInfo.membersOrder) {
                this.fieldList[key].membersOrder = sortInfo.membersOrder;
                break;
            }
        }
    }
    loadLevelElements(xmlDoc, request, customArgs) {
        let newDataSource = [];
        let dimensionElements = this.fieldListData;
        newDataSource = [];
        const fields = [].slice.call(xmlDoc.querySelectorAll('row'));
        for (const field of fields) {
            if (parseInt(field.querySelector('LEVEL_TYPE').textContent, 10) !== 1 && field.querySelector('HIERARCHY_UNIQUE_NAME').textContent.toLowerCase() !== '[measures]') {
                const dimensionName = field.querySelector('HIERARCHY_UNIQUE_NAME').textContent;
                const levelName = field.querySelector('LEVEL_UNIQUE_NAME').textContent;
                const levelCaption = field.querySelector('LEVEL_CAPTION').textContent;
                const levelObj = {
                    hasChildren: false,
                    isChecked: false,
                    isSelected: this.fieldList[dimensionName].isSelected,
                    pid: dimensionName,
                    id: levelName,
                    name: levelCaption,
                    tag: levelName,
                    spriteCssClass: 'e-level-members e-hierarchy-level-' + parseInt(field.querySelector('LEVEL_NUMBER').textContent, 10) + '-icon' + ' ' + ICON,
                    caption: levelCaption,
                    // aggregateType: this.getAggregateType(levelName),
                    type: 'string'
                };
                newDataSource.push(levelObj);
                if (this.fieldList[dimensionName] && this.fieldList[dimensionName].spriteCssClass &&
                    this.fieldList[dimensionName].spriteCssClass.indexOf('e-attributeCDB-icon') === -1) {
                    this.fieldList[dimensionName].levels.push(levelObj);
                    this.fieldList[dimensionName].isHierarchy = false;
                }
                else {
                    this.fieldList[dimensionName].isHierarchy = true;
                }
            }
        }
        this.fieldListData = dimensionElements = dimensionElements.concat(newDataSource);
        const args = {
            catalog: customArgs.dataSourceSettings.catalog,
            cube: customArgs.dataSourceSettings.cube,
            url: customArgs.dataSourceSettings.url,
            LCID: customArgs.dataSourceSettings.localeIdentifier.toString(),
            request: 'MDSCHEMA_MEASURES',
            roles: customArgs.dataSourceSettings.roles
        };
        this.getTreeData(args, this.loadMeasureElements.bind(this), customArgs);
    }
    loadMeasureElements(xmlDoc, request, customArgs) {
        const dimensionElements = this.fieldListData;
        const measureGroupItems = [];
        let caption;
        const dataFields = extend([], this.values, null, true);
        const reportElement = [];
        for (const field of dataFields) {
            reportElement.push(field.name);
        }
        if (this.locale !== 'en-US') {
            const args = {
                catalog: customArgs.dataSourceSettings.catalog,
                cube: customArgs.dataSourceSettings.cube,
                url: customArgs.dataSourceSettings.url,
                LCID: customArgs.dataSourceSettings.localeIdentifier.toString(),
                request: 'MDSCHEMA_MEASUREGROUPS',
                roles: customArgs.dataSourceSettings.roles
            };
            this.getTreeData(args, this.loadMeasureGroups.bind(this), customArgs);
        }
        const fields = [].slice.call(xmlDoc.querySelectorAll('row'));
        for (const field of fields) {
            const measureGRPName = isNullOrUndefined(field.querySelector('MEASUREGROUP_NAME')) ? '' : field.querySelector('MEASUREGROUP_NAME').textContent;
            const measureName = field.querySelector('MEASURE_UNIQUE_NAME').textContent;
            const formatString = field.querySelector('DEFAULT_FORMAT_STRING') ?
                field.querySelector('DEFAULT_FORMAT_STRING').textContent : '#,#';
            const aggregateType = field.querySelector('MEASURE_AGGREGATOR') ?
                field.querySelector('MEASURE_AGGREGATOR').textContent : '1';
            if (!(measureGroupItems.indexOf(measureGRPName) >= 0)) {
                if (this.locale !== 'en-US') {
                    const measureInfo = [];
                    for (const item of this.fieldListObj.measuresGroups) {
                        if (item.querySelector('MEASUREGROUP_NAME').textContent === measureGRPName) {
                            measureInfo.push(item);
                        }
                    }
                    caption = measureInfo.length > 0 ? measureInfo[0].querySelector('MEASUREGROUP_CAPTION').textContent : measureGRPName;
                }
                else {
                    caption = measureGRPName;
                }
                if (measureGRPName !== '') {
                    dimensionElements.push({
                        hasChildren: true,
                        isChecked: false,
                        isSelected: false,
                        pid: '[Measures]',
                        id: measureGRPName,
                        name: caption,
                        spriteCssClass: 'e-measureCDB e-folderCDB-icon' + ' ' + ICON,
                        tag: measureGRPName,
                        caption: caption,
                        aggregateType: this.getAggregateType(measureGRPName, aggregateType),
                        type: 'string'
                    });
                    measureGroupItems.push(measureGRPName);
                }
            }
            const fieldObj = {
                hasChildren: false,
                isSelected: (reportElement.indexOf(measureName) >= 0),
                pid: measureGRPName === '' ? '[Measures]' : measureGRPName,
                id: measureName,
                name: field.querySelector('MEASURE_CAPTION').textContent,
                spriteCssClass: 'e-measure-icon' + ' ' + ICON,
                tag: measureName,
                caption: this.dataFields[measureName] && this.dataFields[measureName].caption ?
                    this.dataFields[measureName].caption : this.mappingFields[measureName] &&
                    this.mappingFields[measureName].caption ? this.mappingFields[measureName].caption :
                    field.querySelector('MEASURE_CAPTION').textContent,
                aggregateType: this.getAggregateType(measureName, aggregateType),
                type: 'number',
                filter: [],
                // sort: 'Ascending',
                actualFilter: [],
                filterMembers: [],
                childMembers: [],
                searchMembers: [],
                members: {},
                currrentMembers: {},
                formatString: formatString,
                allowDragAndDrop: (this.dataFields[measureName] ? this.dataFields[measureName].allowDragAndDrop :
                    this.mappingFields[measureName] ? this.mappingFields[measureName].allowDragAndDrop : true),
                showFilterIcon: (this.dataFields[measureName] ? this.dataFields[measureName].showFilterIcon :
                    this.mappingFields[measureName] ? this.mappingFields[measureName].showFilterIcon : true),
                showSortIcon: (this.dataFields[measureName] ? this.dataFields[measureName].showSortIcon :
                    this.mappingFields[measureName] ? this.mappingFields[measureName].showSortIcon : true),
                showEditIcon: (this.dataFields[measureName] ? this.dataFields[measureName].showEditIcon :
                    this.mappingFields[measureName] ? this.mappingFields[measureName].showEditIcon : true),
                showRemoveIcon: (this.dataFields[measureName] ? this.dataFields[measureName].showRemoveIcon :
                    this.mappingFields[measureName] ? this.mappingFields[measureName].showRemoveIcon : true),
                showValueTypeIcon: (this.dataFields[measureName] ? this.dataFields[measureName].showValueTypeIcon :
                    this.mappingFields[measureName] ? this.mappingFields[measureName].showValueTypeIcon : true),
                showSubTotals: (this.dataFields[measureName] ? this.dataFields[measureName].showSubTotals :
                    this.mappingFields[measureName] ? this.mappingFields[measureName].showSubTotals : true)
            };
            dimensionElements.push(fieldObj);
            this.fieldList[measureName] = fieldObj;
            if ((reportElement.indexOf(measureName) >= 0)) {
                reportElement.splice(reportElement.indexOf(measureName), 1);
            }
        }
        this.measureReportItems = reportElement;
        // let args: ConnectionInfo = {
        //     catalog: customArgs.dataSourceSettings.catalog,
        //     cube: customArgs.dataSourceSettings.cube,
        //     url: customArgs.dataSourceSettings.url,
        //     LCID: customArgs.dataSourceSettings.localeIdentifier.toString(),
        //     request: 'MDSCHEMA_KPIS'
        // };
        // customArgs.reportElement = this.measureReportItems;
        // this.getTreeData(args, this.loadKPIElements.bind(this), customArgs);
    }
    loadMeasureGroups(xmlDoc) {
        if (isNullOrUndefined(this.fieldListObj)) {
            this.fieldListObj = {};
        }
        this.fieldListObj.measuresGroups = [].slice.call(xmlDoc.querySelectorAll('row'));
    }
    // private loadKPIElements(xmlDoc: Document, request: Ajax, customArgs: FieldData): void {
    //     let dimensionElements: IOlapField[] = this.fieldListData;
    //     let parser = new DOMParser();
    //     let measureGroupItems: string[] = [];
    //     let fields: HTMLElement[] = [].slice.call(xmlDoc.querySelectorAll('row'));
    //     dimensionElements.splice(1, 0, {
    //         hasChildren: true,
    //         isChecked: false,
    //         id: 'folderStruct',
    //         name: 'KPI',
    //         spriteCssClass: 'kpiCDB e-kpiCDB-icon' + ' ' +  cls.ICON,
    //         tag: '',
    //         caption: 'KPI',
    //         aggregateType: this.getAggregateType('folderStruct'),
    //         type: 'string'
    //     });
    //     for (let field of fields) {
    //         let kpiName: string = field.querySelector('KPI_CAPTION').textContent;
    //         let kpiGoal: string = field.querySelector('KPI_GOAL').textContent;
    //         let kpiStatus: string = field.querySelector('KPI_STATUS').textContent;
    //         let kpiTrend: string = field.querySelector('KPI_TREND').textContent;
    //         let kpiValue: string = field.querySelector('KPI_VALUE').textContent;
    //         if (!(measureGroupItems.indexOf(field.querySelector('KPI_NAME').textContent) >= 0)) {
    //             dimensionElements.push({
    //                 hasChildren: true,
    //                 isChecked: false,
    //                 pid: 'folderStruct',
    //                 id: kpiName,
    //                 name: kpiName,
    //                 spriteCssClass: 'e-folderCDB-icon' + ' ' +  cls.ICON,
    //                 tag: kpiName,
    //                 caption: kpiName,
    //                 aggregateType: this.getAggregateType(kpiName),
    //                 type: 'string'
    //             });
    //             measureGroupItems.push(kpiName);
    //         }
    //         let kpiCollection: { [key: string]: string } = {
    //             'kpiGoal': kpiGoal,
    //             'kpiStatus': kpiStatus,
    //             'kpiTrend': kpiTrend,
    //             'kpiValue': kpiValue
    //         };
    //         let i: number = 0;
    //         for (let kpi of Object.keys(kpiCollection)) {
    //             let id: string = kpiCollection[kpi];
    //             let name: string = (kpi).split('kpi')[1];
    //             let cssClass: string = 'e-' + kpi + '-icon';
    //             let fieldObj: IOlapField = {
    //                 hasChildren: true,
    //                 isSelected: (customArgs.reportElement.indexOf(id) >= 0),
    //                 id: id,
    //                 pid: kpiName,
    //                 name: name,
    //                 spriteCssClass: cssClass + ' ' +  cls.ICON,
    //                 tag: id,
    //                 caption: name,
    //                 aggregateType: this.getAggregateType(id),
    //                 type: 'number',
    //                 filter: [],
    //                 sort: 'Ascending',
    //                 filterMembers: [],
    //                 searchMembers: [],
    //                 members: {},
    //                 currrentMembers: {}
    //             };
    //             dimensionElements.push(fieldObj);
    //             this.fieldList[id] = fieldObj;
    //         }
    //     }
    // }
    doAjaxPost(type, url, data, success, customArgs) {
        const ajax = new Ajax({
            mode: false,
            contentType: 'text/xml',
            url: url,
            data: data,
            dataType: 'xml',
            type: type,
            beforeSend: this.beforeSend.bind(this),
            onSuccess: (args, request) => {
                const parser = new DOMParser();
                // parsing string type result as XML
                const xmlDoc = parser.parseFromString(args, 'text/xml');
                success(xmlDoc, request, customArgs);
            },
            onFailure: (e) => {
                return e;
            }
        });
        ajax.send();
    }
    beforeSend(args) {
        if (this.dataSourceSettings.authentication.userName && this.dataSourceSettings.authentication.password) {
            args.httpRequest.setRequestHeader('Authorization', 'Basic ' + btoa(this.dataSourceSettings.authentication.userName + // eslint-disable-line @typescript-eslint/no-explicit-any
                ':' + this.dataSourceSettings.authentication.password));
        }
    }
    getSoapMsg(dataSourceSettings, query) {
        let xmlMsg = '';
        let sourceInfo = '';
        const connectionString = this.getConnectionInfo(dataSourceSettings.url, dataSourceSettings.localeIdentifier);
        if (this.isMondrian) {
            sourceInfo = ''; // eslint-disable-next-line no-useless-escape
            xmlMsg = '<SOAP-ENV:Envelope xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" SOAP-ENV:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\"><SOAP-ENV:Body><Execute xmlns=\"urn:schemas-microsoft-com:xml-analysis\"><Command><Statement><![CDATA[' +
                query + ']]></Statement></Command><Properties><PropertyList><DataSourceInfo>' + sourceInfo +
                '</DataSourceInfo><Catalog>' + dataSourceSettings.catalog + '</Catalog><AxisFormat>TupleFormat</AxisFormat><Content>Data</Content><Format>Multidimensional</Format></PropertyList></Properties></Execute></SOAP-ENV:Body></SOAP-ENV:Envelope>';
        }
        else { // eslint-disable-next-line no-useless-escape
            xmlMsg = '<Envelope xmlns=\"http://schemas.xmlsoap.org/soap/envelope/\"> <Header></Header> <Body> <Execute xmlns=\"urn:schemas-microsoft-com:xml-analysis\"> <Command> <Statement> ' +
                query + ' </Statement> </Command> <Properties> <PropertyList> <Catalog>' + dataSourceSettings.catalog +
                '</Catalog> <LocaleIdentifier>' + connectionString.LCID + '</LocaleIdentifier>' + (dataSourceSettings.roles ? '<Roles>' + dataSourceSettings.roles + '</Roles>' : '') + '</PropertyList> </Properties> </Execute> </Body> </Envelope>';
        }
        return xmlMsg;
    }
    getConnectionInfo(connectionString, locale) {
        const connectionInfo = { url: '', LCID: !isNullOrUndefined(locale) ? locale.toString() : '1033' };
        if (connectionString !== '') {
            for (const obj of connectionString.split(';')) {
                if (obj.toLowerCase().indexOf('locale') < 0 && connectionInfo.url.length === 0) {
                    connectionInfo.url = obj;
                }
                else if (obj.toLowerCase().indexOf('locale') >= 0) {
                    connectionInfo.LCID = obj.replace(/ /g, '').split('=')[1];
                }
            }
        }
        return connectionInfo;
    }
    getMDXQuery(dataSourceSettings) {
        MDXQuery.getCellSets(dataSourceSettings, this, true, undefined, true);
        return this.mdxQuery;
    }
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 * `ChartExport` module is used to handle the Pivot Chart PDF export action.
 *
 * @hidden
 */
class ChartExport {
    /**
     * Constructor for chart and accumulation annotation
     *
     *  @param {PivotView} parent - Instance of pivot table.
     */
    constructor(parent) {
        this.parent = parent;
    }
    /**
     * For internal use only - Get the module name.
     *
     * @returns {string} - string.
     * @private
     */
    getModuleName() {
        return 'chartExport';
    }
    /**
     * Method allow to export the pivot chart as PDF and image formats like PNG, JPEG, and SVG.
     *
     * @param {PdfExportProperties} pdfExportProperties - Allows to define the export properties for the chart.
     * @param {boolean} isMultipleExport - Allows to export multiple tables and charts into a single PDF document.
     * @param {Object} pdfDoc - Allows the export of an external PDF document along with current PDF document.
     * @param {boolean} isBlob - Allows the PDF document to be saved as blob data.
     * @returns {Promise<any>}
     * @hidden
     */
    pdfChartExport(pdfExportProperties, pdfDoc, isMultipleExport, isBlob) {
        const controls = [this.parent.chart];
        const chartInfo = this.getChartInfo(controls);
        const width = chartInfo.width;
        const height = chartInfo.height;
        let element = this.parent.chart.svgObject;
        const isCanvas = this.parent.chart.enableCanvas;
        if (!isCanvas) {
            element = createElement('canvas', {
                id: 'ej2-canvas',
                attrs: {
                    'width': width.toString(),
                    'height': height.toString()
                }
            });
        }
        const url = window.URL.createObjectURL(new Blob([(new XMLSerializer()).serializeToString(chartInfo.svg)], { type: 'image/svg+xml' }));
        const image = new Image();
        const ctx = element.getContext('2d');
        image.src = url;
        // eslint-disable-next-line @typescript-eslint/tslint/config
        return new Promise((resolve) => {
            image.onload = (() => {
                if (!isNullOrUndefined(pdfDoc)) {
                    this.pdfDocument = pdfDoc;
                }
                else {
                    this.pdfDocument = new PdfDocument();
                }
                ctx.drawImage(image, 0, 0);
                window.URL.revokeObjectURL(url);
                this.exportPdf(element, isMultipleExport, isBlob, width, height, pdfExportProperties);
                resolve(this.pdfDocument);
            });
        });
    }
    getChartInfo(controls, isVertical) {
        let width = 0;
        let height = 0;
        const isCanvas = this.parent.chart.enableCanvas;
        const svgObject = new SvgRenderer('').createSvg({
            id: 'Svg_Export_Element',
            width: 200, height: 200
        });
        let backgroundColor;
        controls.map((control) => {
            const svg = control.svgObject.cloneNode(true);
            const groupEle = control.renderer.createGroup({
                style: (isNullOrUndefined(isVertical) || isVertical) ? 'transform: translateY(' + height + 'px)' :
                    'transform: translateX(' + width + 'px)'
            });
            backgroundColor = svg.childNodes[0] ? svg.childNodes[0].getAttribute('fill') : 'transparent';
            if (backgroundColor === 'transparent') {
                if (control.theme.indexOf('Dark') > -1 || control.theme === 'HighContrast') {
                    backgroundColor = 'rgba(0, 0, 0, 1)';
                }
                else {
                    backgroundColor = 'rgba(255, 255, 255, 1)';
                }
            }
            if (!isCanvas) {
                groupEle.appendChild(svg);
            }
            width = control.availableSize.width;
            height = control.availableSize.height;
            if (!isCanvas) {
                svgObject.appendChild(groupEle);
            }
        });
        if (!isCanvas) {
            svgObject.setAttribute('width', width + '');
            svgObject.setAttribute('height', height + '');
            svgObject.setAttribute('style', 'background-color: ' + backgroundColor + ';');
        }
        return {
            'width': width,
            'height': height,
            'svg': svgObject
        };
    }
    exportPdf(element, isMultipleExport, isBlob, width, height, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    pdfExportProperties) {
        const documentSection = this.pdfDocument.sections.add();
        const documentWidth = this.pdfDocument.pageSettings.width;
        let documentHeight = this.pdfDocument.pageSettings.height;
        const margin = this.pdfDocument.pageSettings.margins;
        const chartWidth = (width + margin.left + margin.right);
        this.pdfDocument.pageSettings.size = new SizeF(chartWidth, documentHeight);
        const fileName = this.exportProperties.fileName ? this.exportProperties.fileName :
            (!isNullOrUndefined(pdfExportProperties) && !isNullOrUndefined(pdfExportProperties.fileName)) ?
                pdfExportProperties.fileName : 'default';
        if (this.exportProperties.width || this.exportProperties.height) {
            this.pdfDocument.pageSettings.orientation = ((this.exportProperties.width > this.exportProperties.height) ||
                (!this.exportProperties.height && (this.exportProperties.width > documentHeight)) || (!this.exportProperties.width &&
                (documentWidth > this.exportProperties.height))) ? PdfPageOrientation.Landscape : PdfPageOrientation.Portrait;
            this.pdfDocument.pageSettings.size = new SizeF(this.exportProperties.width ? this.exportProperties.width
                : documentWidth, this.exportProperties.height ? this.exportProperties.height : documentHeight);
        }
        else {
            this.pdfDocument.pageSettings.orientation = (this.exportProperties.orientation === 0 || this.exportProperties.orientation)
                ? this.exportProperties.orientation : (!isNullOrUndefined(pdfExportProperties) &&
                !isNullOrUndefined(pdfExportProperties.pageOrientation)) ? (pdfExportProperties.pageOrientation === 'Landscape' ?
                PdfPageOrientation.Landscape : PdfPageOrientation.Portrait) : PdfPageOrientation.Landscape;
            if (!isNullOrUndefined(pdfExportProperties) && !isNullOrUndefined(pdfExportProperties.pageSize)) {
                this.pdfDocument.pageSettings.size = PivotUtil.getPageSize(pdfExportProperties.pageSize);
            }
        }
        if (!isNullOrUndefined(this.exportProperties.pdfMargins)) {
            const margins = this.pdfDocument.pageSettings.margins;
            margins.top = !isNullOrUndefined(this.exportProperties.pdfMargins.top) ? this.exportProperties.pdfMargins.top : margins.top;
            margins.bottom = !isNullOrUndefined(this.exportProperties.pdfMargins.bottom) ? this.exportProperties.pdfMargins.bottom :
                margins.bottom;
            margins.left = !isNullOrUndefined(this.exportProperties.pdfMargins.left) ? this.exportProperties.pdfMargins.left : margins.left;
            margins.right = !isNullOrUndefined(this.exportProperties.pdfMargins.right) ? this.exportProperties.pdfMargins.right :
                margins.right;
        }
        documentSection.setPageSettings(this.pdfDocument.pageSettings);
        documentHeight = this.pdfDocument.pageSettings.height;
        let imageString = element.toDataURL('image/jpeg').replace('image/jpeg', 'image/octet-stream');
        imageString = imageString.slice(imageString.indexOf(',') + 1);
        const image = new PdfBitmap(imageString);
        const pdfPage = documentSection.pages.add();
        pdfPage.graphics.drawImage(image, 0, 0, (documentHeight < height || this.exportProperties.width
            || this.pdfDocument.pageSettings.size) ? pdfPage.getClientSize().width : chartWidth, documentHeight < height
            ? pdfPage.getClientSize().height : height);
        if (isBlob || isMultipleExport) {
            if (isBlob) {
                this.blobPromise = this.pdfDocument.save();
            }
        }
        else {
            this.pdfDocument.save(fileName + '.pdf');
            this.pdfDocument.destroy();
        }
        const exportCompleteEventArgs = {
            type: 'PDF',
            promise: isBlob ? this.blobPromise : null
        };
        this.parent.trigger(exportComplete, exportCompleteEventArgs);
        return new Promise(() => {
            // eslint-disable-next-line @typescript-eslint/no-unused-expressions
            this.pdfDocument;
        });
    }
    /**
     * To destroy the pdf export module.
     *
     * @returns {void}
     * @hidden
     */
    destroy() {
        if (this.pdfDocument) {
            this.pdfDocument.destroy();
            this.pdfDocument = null;
        }
        if (this.blobPromise) {
            this.blobPromise = null;
        }
        if (this.exportProperties) {
            this.exportProperties = null;
        }
    }
}

var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Allows a set of options for customizing the grouping bar UI with a variety of settings such as UI visibility to a specific view port,
 * customizing the pivot button features such as filtering, sorting, changing aggregate types, removing any fields.
 * The options available to customize the grouping bar UI are:
 * * `showFilterIcon`: Allows you to show or hide the filter icon that used to be displayed on the pivot button of the grouping bar UI.
 * This filter icon is used to filter the members of a particular field at runtime in the pivot table.
 * * `showSortIcon`: Allows you to show or hide the sort icon that used to be displayed in the pivot button of the grouping bar UI.
 * This sort icon is used to order members of a particular fields either in ascending or descending at runtime.
 * * `showRemoveIcon`: Allows you to show or hide the remove icon that used to be displayed in the pivot button of the grouping bar UI.
 * This remove icon is used to remove any field during runtime.
 * * `showValueTypeIcon`: Allows you to show or hide the value type icon that used to be displayed in the pivot button of the grouping bar UI.
 * This value type icon helps to select the appropriate aggregation type to value fields at runtime.
 * * `displayMode`: Allow options to show the grouping bar UI to specific view port such as either pivot table or pivot chart or both table and chart.
 * For example, to show the grouping bar UI to pivot table on its own, set the property `displayMode` to **Table**.
 * * `allowDragAndDrop`: Allows you to restrict the pivot buttons that were used to drag on runtime in the grouping bar UI. This will prevent you from modifying the current report.
 */
class GroupingBarSettings extends ChildProperty {
}
__decorate([
    Property(true)
], GroupingBarSettings.prototype, "showFilterIcon", void 0);
__decorate([
    Property(true)
], GroupingBarSettings.prototype, "showSortIcon", void 0);
__decorate([
    Property(true)
], GroupingBarSettings.prototype, "showRemoveIcon", void 0);
__decorate([
    Property(true)
], GroupingBarSettings.prototype, "showValueTypeIcon", void 0);
__decorate([
    Property('Both')
], GroupingBarSettings.prototype, "displayMode", void 0);
__decorate([
    Property(true)
], GroupingBarSettings.prototype, "allowDragAndDrop", void 0);
__decorate([
    Property(false)
], GroupingBarSettings.prototype, "showFieldsPanel", void 0);
/**
 * Allow options for performing CRUD operations, such as add, edit, delete, and update the raw items of any cell from the pivot table.
 * The raw items can be viewed in a data grid that used to be displayed as a dialog by double-clicking the appropriate value cell in the pivot table.
 * CRUD operations can be performed in this data grid either by double-clicking the cells or using toolbar options.
 * The options available are as follows:
 * * `allowAdding`: Allows you to add a new record to the data grid used to update the appropriate cells in the pivot table.
 * * `allowEditing`: Allows you to edit the existing record in the data grid that used to update the appropriate cells in the pivot table.
 * * `allowDeleting`: Allows you to delete the existing record from the data grid that used to  update the appropriate cells in the pivot table.
 * * `allowCommandColumns`: Allows an additional column appended in the data grid layout holds the command buttons to perform the CRUD operations to edit,
 * delete, and update the raw items to the data grid that used to update the appropriate cells in the pivot table.
 * * `mode`: Allow options for performing CRUD operations with different modes in the data grid that used to update the appropriate cells in the pivot table.
 * The available modes are normal, batch and dialog. **Normal** mode is enabled for CRUD operations in the data grid by default.
 * * `allowEditOnDblClick`: Allows you to restrict CRUD operations by double-clicking the appropriate value cell in the pivot table.
 * * `showConfirmDialog`: Allows you to show the confirmation dialog to save and discard CRUD operations performed in the data grid that used to update the appropriate cells in the pivot table.
 * * `showDeleteConfirmDialog`: Allows you to show the confirmation dialog to delete any records from the data grid.
 *
 * > This feature is applicable only for the relational data source.
 */
class CellEditSettings extends ChildProperty {
}
__decorate([
    Property(false)
], CellEditSettings.prototype, "allowAdding", void 0);
__decorate([
    Property(false)
], CellEditSettings.prototype, "allowEditing", void 0);
__decorate([
    Property(false)
], CellEditSettings.prototype, "allowDeleting", void 0);
__decorate([
    Property(false)
], CellEditSettings.prototype, "allowCommandColumns", void 0);
__decorate([
    Property(false)
], CellEditSettings.prototype, "allowInlineEditing", void 0);
__decorate([
    Property('Normal')
], CellEditSettings.prototype, "mode", void 0);
__decorate([
    Property(true)
], CellEditSettings.prototype, "allowEditOnDblClick", void 0);
__decorate([
    Property(true)
], CellEditSettings.prototype, "showConfirmDialog", void 0);
__decorate([
    Property(false)
], CellEditSettings.prototype, "showDeleteConfirmDialog", void 0);
/**
 * Allow options for setting the visibility of hyperlink based on specific condition. The options available here are as follows:
 * * `measure`: Allows you to specify the value field caption to get visibility of hyperlink option for specific measure.
 * * `condition`: Allows you to choose the operator type such as equals, greater than, less than, etc.
 * * `value1`: Allows you to set the start value.
 * * `value2`: Allows you to set the end value. This option will be used by default when the operator **Between** and **NotBetween** is chosen to apply.
 */
class ConditionalSettings extends ChildProperty {
}
__decorate([
    Property()
], ConditionalSettings.prototype, "measure", void 0);
__decorate([
    Property()
], ConditionalSettings.prototype, "label", void 0);
__decorate([
    Property('NotEquals')
], ConditionalSettings.prototype, "conditions", void 0);
__decorate([
    Property()
], ConditionalSettings.prototype, "value1", void 0);
__decorate([
    Property()
], ConditionalSettings.prototype, "value2", void 0);
/**
 * Allow a set of options to display a hyperlink to link data for individual cells that are shown in the pivot table.
 * These options allow you to enable a separate hyperlink for row headers, column headers, value cells, and summary cells in the `hyperlinkSettings` class.
 * The options available are:
 * * `showHyperlink`: Allows you to set the visibility of hyperlink in all cells.
 * * `showRowHeaderHyperlink`: Allows you to set the visibility of hyperlink in row headers.
 * * `showColumnHeaderHyperlink`: Allows you to set the visibility of hyperlink in column headers.
 * * `showValueCellHyperlink`: Allows you to set the visibility of hyperlink in value cells.
 * * `showSummaryCellHyperlink`: Allows you to set the visibility of hyperlink in summary cells.
 * * `headerText`: Allows you to set the visibility of hyperlink based on header text.
 * * `conditionalSettings`: Allows you to set the visibility of hyperlink based on specific condition.
 * * `cssClass`: Allows you to add CSS class name to the hyperlink options.
 *
 * > By default, the hyperlink options are disabled for all cells in the pivot table.
 */
class HyperlinkSettings extends ChildProperty {
}
__decorate([
    Property(false)
], HyperlinkSettings.prototype, "showHyperlink", void 0);
__decorate([
    Property(false)
], HyperlinkSettings.prototype, "showRowHeaderHyperlink", void 0);
__decorate([
    Property(false)
], HyperlinkSettings.prototype, "showColumnHeaderHyperlink", void 0);
__decorate([
    Property(false)
], HyperlinkSettings.prototype, "showValueCellHyperlink", void 0);
__decorate([
    Property(false)
], HyperlinkSettings.prototype, "showSummaryCellHyperlink", void 0);
__decorate([
    Collection([], ConditionalSettings)
], HyperlinkSettings.prototype, "conditionalSettings", void 0);
__decorate([
    Property()
], HyperlinkSettings.prototype, "headerText", void 0);
__decorate([
    Property('')
], HyperlinkSettings.prototype, "cssClass", void 0);
/**
 * Allows you to configure page information such as page size and current page details for each axis in order to display the pivot table with a specific page when paging.
 */
class PageSettings extends ChildProperty {
}
__decorate([
    Property(5)
], PageSettings.prototype, "columnPageSize", void 0);
__decorate([
    Property(5)
], PageSettings.prototype, "rowPageSize", void 0);
__decorate([
    Property(1)
], PageSettings.prototype, "currentColumnPage", void 0);
__decorate([
    Property(1)
], PageSettings.prototype, "currentRowPage", void 0);
/**
 * Allows a set of options for customizing the paging UI with a variety of settings such as UI position, template and visibility to a specific axis info such as page size, paging data.
 * > To use this option, it requires the property `enablePaging` to be true.
 */
class PagerSettings extends ChildProperty {
}
__decorate([
    Property('Bottom')
], PagerSettings.prototype, "position", void 0);
__decorate([
    Property(false)
], PagerSettings.prototype, "isInversed", void 0);
__decorate([
    Property(true)
], PagerSettings.prototype, "showRowPager", void 0);
__decorate([
    Property(true)
], PagerSettings.prototype, "showColumnPager", void 0);
__decorate([
    Property(true)
], PagerSettings.prototype, "showRowPageSize", void 0);
__decorate([
    Property(true)
], PagerSettings.prototype, "showColumnPageSize", void 0);
__decorate([
    Property([10, 50, 100, 200])
], PagerSettings.prototype, "rowPageSizes", void 0);
__decorate([
    Property([5, 10, 20, 50, 100])
], PagerSettings.prototype, "columnPageSizes", void 0);
__decorate([
    Property(false)
], PagerSettings.prototype, "enableCompactView", void 0);
__decorate([
    Property()
], PagerSettings.prototype, "template", void 0);
/**
 * Allow options to configure the view port as either pivot table or pivot chart or both table and chart. The options available are:
 * * `view`: Allows you to choose the view port as either pivot table or pivot chart or both table and chart.
 * * `primary`: Allows you to set the primary view to be either pivot table or pivot chart. To use this option, it requires the property `view` to be **Both**.
 */
class DisplayOption extends ChildProperty {
}
__decorate([
    Property('Table')
], DisplayOption.prototype, "view", void 0);
__decorate([
    Property('Table')
], DisplayOption.prototype, "primary", void 0);
/**
 * Represents the PivotView component.
 * ```html
 * <div id="PivotView"></div>
 * <script>
 *  var pivotviewObj = new PivotView({ enableGroupingBar: true });
 *  pivotviewObj.appendTo("#pivotview");
 * </script>
 * ```
 */
let PivotView = class PivotView extends Component {
    /**
     * Constructor for creating the widget
     *
     * @param  {PivotViewModel} options - options.
     * @param  {string|HTMLElement} element - element.
     */
    constructor(options, element) {
        super(options, element);
        /** @hidden */
        this.verticalScrollScale = 1;
        /** @hidden */
        this.horizontalScrollScale = 1;
        /** @hidden */
        this.scrollerBrowserLimit = 8000000;
        /** @hidden */
        this.lastSortInfo = {};
        /** @hidden */
        this.lastFilterInfo = {};
        /** @hidden */
        this.lastAggregationInfo = {};
        /** @hidden */
        this.lastCalcFieldInfo = {};
        /** @hidden */
        this.isScrolling = false;
        /** @hidden */
        this.allowEngineExport = false;
        /** @hidden */
        this.isInitial = true;
        this.shiftLockedPos = [];
        this.savedSelectedCellsPos = [];
        this.cellSelectionPos = [];
        this.isPopupClicked = false;
        this.isMouseDown = false;
        this.isMouseUp = false;
        this.fieldsType = {};
        this.remoteData = [];
        this.defaultItems = {};
        this.isCellBoxMultiSelection = false;
        /** @hidden */
        this.gridHeaderCellInfo = [];
        /** @hidden */
        this.gridCellCollection = {};
        /** @hidden */
        this.rowRangeSelection = { enable: false, startIndex: 0, endIndex: 0 };
        /** @hidden */
        this.isStaticRefresh = false;
        /** @hidden */
        this.resizeInfo = {};
        /** @hidden */
        this.scrollPosObject = {
            vertical: 0, horizontal: 0, verticalSection: 0,
            horizontalSection: 0, top: 0, left: 0, scrollDirection: { direction: '', position: 0 }
        };
        /** @hidden */
        this.pivotColumns = [];
        /** @hidden */
        this.totColWidth = 0;
        /** @hidden */
        this.posCount = 0;
        /** @hidden */
        this.isModified = false;
        /** @hidden */
        this.isInitialRendering = false;
        this.needsID = true;
        this.pivotRefresh = Component.prototype.refresh;
        this.request = new XMLHttpRequest();
        /** @hidden */
        this.isServerWaitingPopup = false;
        /** @hidden */
        this.actionObj = {};
        /** @hidden */
        this.defaultFieldListOrder = 'None';
        /** @hidden */
        this.destroyEngine = false;
        this.pivotView = this;
        setValue('mergePersistData', this.mergePersistPivotData, this);
    }
    /**
     * To provide the array of modules needed for control rendering
     *
     * @returns {ModuleDeclaration[]} - return.
     * @hidden
     */
    requiredModules() {
        const modules = [];
        if (this.showGroupingBar) {
            modules.push({ args: [this], member: 'groupingBar' });
        }
        if (this.allowConditionalFormatting) {
            modules.push({ args: [this], member: 'conditionalFormatting' });
        }
        if (this.allowNumberFormatting) {
            modules.push({ args: [this], member: 'numberFormatting' });
        }
        if (this.allowCalculatedField) {
            modules.push({ args: [this], member: 'calculatedField' });
        }
        if (this.showToolbar && (this.toolbar.length > 0 || this.toolbarTemplate)) {
            modules.push({ args: [this], member: 'toolbar' });
        }
        if (this.showFieldList) {
            modules.push({ args: [this], member: 'fieldList' });
        }
        if (this.allowExcelExport) {
            modules.push({ args: [this], member: 'excelExport' });
        }
        if (this.allowPdfExport) {
            modules.push({ args: [this], member: 'pdfExport' });
            modules.push({ args: [this], member: 'chartExport' });
        }
        if (this.enableVirtualization) {
            modules.push({ args: [this], member: 'virtualscroll' });
        }
        if (this.allowGrouping) {
            modules.push({ args: [this], member: 'grouping' });
        }
        if (this.allowDrillThrough || (this.editSettings && this.editSettings.allowEditing)) {
            modules.push({ args: [this], member: 'drillThrough' });
        }
        if (this.displayOption.view !== 'Table') {
            modules.push({ args: [this], member: 'pivotChart' });
        }
        if (this.enablePaging) {
            modules.push({ args: [this], member: 'pager' });
        }
        return modules;
    }
    /**
     *
     * For internal use only - Initializing internal properties;
     *
     * @private
     */
    preRender() {
        if (this.dataSourceSettings && this.dataSourceSettings.providerType === 'SSAS') {
            this.dataType = 'olap';
            this.olapEngineModule = new OlapEngine();
        }
        else {
            this.dataType = 'pivot';
            this.engineModule = new PivotEngine();
        }
        this.isAdaptive = Browser.isDevice;
        if (Browser.isIE || Browser.info.name === 'edge') {
            this.scrollerBrowserLimit = 1500000;
        }
        else if (Browser.info.name === 'chrome') {
            this.scrollerBrowserLimit = 15000000;
        }
        this.isTouchMode = closest(this.element, 'e-bigger') ? true : false;
        this.initProperties();
        this.renderToolTip();
        this.keyboardModule = new KeyboardInteraction(this);
        this.contextMenuModule = new PivotContextMenu(this);
        this.globalize = new Internationalization(this.locale);
        if (this.showFieldList || this.showGroupingBar || this.allowNumberFormatting || this.allowCalculatedField ||
            this.toolbar || this.allowGrouping || this.gridSettings.contextMenuItems) {
            this.commonModule = new Common(this);
        }
        if (this.allowPdfExport && (this.displayOption.view === 'Both' || this.displayOption.view === 'Chart')) {
            this.chartExportModule = new ChartExport(this);
        }
        this.defaultLocale = {
            grandTotal: 'Grand Total',
            total: 'Total',
            value: 'Value',
            noValue: 'No value',
            row: 'Row',
            column: 'Column',
            collapse: 'Collapse',
            expand: 'Expand',
            rowAxisPrompt: 'Drop row here',
            columnAxisPrompt: 'Drop column here',
            valueAxisPrompt: 'Drop value here',
            filterAxisPrompt: 'Drop filter here',
            filter: 'Filter',
            filtered: 'Filtered',
            sort: 'Sort',
            filters: 'Filters',
            rows: 'Rows',
            columns: 'Columns',
            values: 'Values',
            close: 'Close',
            cancel: 'Cancel',
            delete: 'Delete',
            CalculatedField: 'Calculated Field',
            createCalculatedField: 'Create Calculated Field',
            fieldName: 'Enter the field name',
            error: 'Error',
            invalidFormula: 'Invalid formula.',
            dropText: 'Example: ("Sum(Order_Count)" + "Sum(In_Stock)") * 250',
            dropTextMobile: 'Add fields and edit formula here.',
            dropAction: 'Calculated field cannot be place in any other region except value axis.',
            alert: 'Alert',
            warning: 'Warning',
            ok: 'OK',
            search: 'Search',
            drag: 'Drag',
            remove: 'Remove',
            allFields: 'All Fields',
            formula: 'Formula',
            addToRow: 'Add to Row',
            addToColumn: 'Add to Column',
            addToValue: 'Add to Value',
            addToFilter: 'Add to Filter',
            emptyData: 'No records to display',
            fieldExist: 'A field already exists in this name. Please enter a different name.',
            confirmText: 'A calculation field already exists in this name. Do you want to replace it?',
            noMatches: 'No matches',
            format: 'Summaries values by',
            edit: 'Edit',
            clear: 'Clear',
            sortAscending: 'Sort ascending order',
            sortDescending: 'Sort descending order',
            sortNone: 'Sort data order',
            clearCalculatedField: 'Clear edited field info',
            editCalculatedField: 'Edit calculated field',
            formulaField: 'Drag and drop fields to formula',
            dragField: 'Drag field to formula',
            clearFilter: 'Clear',
            by: 'by',
            all: 'All',
            multipleItems: 'Multiple items',
            member: 'Member',
            label: 'Label',
            date: 'Date',
            enterValue: 'Enter value',
            chooseDate: 'Enter date',
            Before: 'Before',
            BeforeOrEqualTo: 'Before Or Equal To',
            After: 'After',
            AfterOrEqualTo: 'After Or Equal To',
            labelTextContent: 'Show the items for which the label',
            dateTextContent: 'Show the items for which the date',
            valueTextContent: 'Show the items for which',
            Equals: 'Equals',
            DoesNotEquals: 'Does Not Equal',
            BeginWith: 'Begins With',
            DoesNotBeginWith: 'Does Not Begin With',
            EndsWith: 'Ends With',
            DoesNotEndsWith: 'Does Not End With',
            Contains: 'Contains',
            DoesNotContains: 'Does Not Contain',
            GreaterThan: 'Greater Than',
            GreaterThanOrEqualTo: 'Greater Than Or Equal To',
            LessThan: 'Less Than',
            LessThanOrEqualTo: 'Less Than Or Equal To',
            Between: 'Between',
            NotBetween: 'Not Between',
            And: 'and',
            Sum: 'Sum',
            Count: 'Count',
            DistinctCount: 'Distinct Count',
            Product: 'Product',
            Avg: 'Avg',
            Median: 'Median',
            Min: 'Min',
            SampleVar: 'Sample Var',
            PopulationVar: 'Population Var',
            RunningTotals: 'Running Totals',
            Max: 'Max',
            Index: 'Index',
            SampleStDev: 'Sample StDev',
            PopulationStDev: 'Population StDev',
            PercentageOfRowTotal: '% of Row Total',
            PercentageOfParentTotal: '% of Parent Total',
            PercentageOfParentColumnTotal: '% of Parent Column Total',
            PercentageOfParentRowTotal: '% of Parent Row Total',
            DifferenceFrom: 'Difference From',
            PercentageOfDifferenceFrom: '% of Difference From',
            PercentageOfGrandTotal: '% of Grand Total',
            PercentageOfColumnTotal: '% of Column Total',
            MoreOption: 'More...',
            NotEquals: 'Not Equals',
            AllValues: 'All Values',
            conditionalFormating: 'Conditional Formatting',
            apply: 'Apply',
            condition: 'Add Condition',
            formatLabel: 'Format',
            valueFieldSettings: 'Value field settings',
            baseField: 'Base field',
            baseItem: 'Base item',
            summarizeValuesBy: 'Summarize values by',
            sourceName: 'Field name :',
            sourceCaption: 'Field caption',
            example: 'e.g:',
            editorDataLimitMsg: ' more items. Search to refine further.',
            details: 'Details',
            manageRecords: 'Manage Records',
            Years: 'Years',
            Quarters: 'Quarters',
            Months: 'Months',
            Days: 'Days',
            Hours: 'Hours',
            Minutes: 'Minutes',
            Seconds: 'Seconds',
            save: 'Save a report',
            new: 'Create a new report',
            load: 'Load',
            saveAs: 'Save as current report',
            rename: 'Rename a current report',
            deleteReport: 'Delete a current report',
            export: 'Export',
            subTotals: 'Sub totals',
            grandTotals: 'Grand totals',
            reportName: 'Report Name :',
            pdf: 'PDF',
            excel: 'Excel',
            csv: 'CSV',
            png: 'PNG',
            jpeg: 'JPEG',
            svg: 'SVG',
            mdxQuery: 'MDX Query',
            showSubTotals: 'Show subtotals',
            doNotShowSubTotals: 'Do not show subtotals',
            showSubTotalsRowsOnly: 'Show subtotals rows only',
            showSubTotalsColumnsOnly: 'Show subtotals columns only',
            showGrandTotals: 'Show grand totals',
            doNotShowGrandTotals: 'Do not show grand totals',
            showGrandTotalsRowsOnly: 'Show grand totals rows only',
            showGrandTotalsColumnsOnly: 'Show grand totals columns only',
            fieldList: 'Show fieldlist',
            grid: 'Show table',
            toolbarFormatting: 'Conditional formatting',
            chart: 'Chart',
            reportMsg: 'Please enter vaild report name!!!',
            reportList: 'Report list',
            removeConfirm: 'Are you sure you want to delete this report?',
            emptyReport: 'No reports found!!',
            bar: 'Bar',
            pie: 'Pie',
            funnel: 'Funnel',
            doughnut: 'Doughnut',
            pyramid: 'Pyramid',
            stackingcolumn: 'Stacked Column',
            stackingarea: 'Stacked Area',
            stackingbar: 'Stacked Bar',
            stackingline: 'Stacked Line',
            stepline: 'Step Line',
            steparea: 'Step Area',
            splinearea: 'Spline Area',
            spline: 'Spline',
            stackingcolumn100: '100% Stacked Column',
            stackingbar100: '100% Stacked Bar',
            stackingarea100: '100% Stacked Area',
            stackingline100: '100% Stacked Line',
            bubble: 'Bubble',
            pareto: 'Pareto',
            radar: 'Radar',
            line: 'Line',
            area: 'Area',
            scatter: 'Scatter',
            polar: 'Polar',
            of: 'of',
            emptyFormat: 'No format found!!!',
            emptyInput: 'Enter a value',
            newReportConfirm: 'Do you want to save the changes to this report?',
            emptyReportName: 'Enter a report name',
            qtr: 'Qtr',
            null: 'null',
            undefined: 'undefined',
            groupOutOfRange: 'Out of Range',
            fieldDropErrorAction: 'The field you are moving cannot be placed in that area of the report',
            aggregate: 'Aggregate',
            drillThrough: 'Drill Through',
            ascending: 'Ascending',
            descending: 'Descending',
            number: 'Number',
            currency: 'Currency',
            percentage: 'Percentage',
            formatType: 'Format Type',
            customText: 'Currency Symbol',
            symbolPosition: 'Symbol Position',
            left: 'Left',
            right: 'Right',
            grouping: 'Grouping',
            true: 'True',
            false: 'False',
            decimalPlaces: 'Decimal Places',
            numberFormat: 'Number Formatting',
            memberType: 'Field Type',
            formatString: 'Format',
            expressionField: 'Expression',
            customFormat: 'Enter custom format string',
            numberFormatString: 'Example: C, P, 0000 %, ###0.##0#, etc.',
            selectedHierarchy: 'Parent Hierarchy',
            olapDropText: 'Example: [Measures].[Order Quantity] + ([Measures].[Order Quantity] * 0.10)',
            Percent: 'Percent',
            Currency: 'Currency',
            Custom: 'Custom',
            Measure: 'Measure',
            Dimension: 'Dimension',
            Standard: 'Standard',
            blank: '(Blank)',
            fieldTooltip: 'Drag and drop fields to create an expression. ' +
                'And, if you want to edit the existing calculated fields! ' +
                'You can achieve it by simply selecting the field under "Calculated Members".',
            fieldTitle: 'Field Name',
            QuarterYear: 'Quarter Year',
            drillError: 'Cannot show the raw items of calculated fields.',
            caption: 'Field Caption',
            copy: 'Copy',
            defaultReport: 'Sample Report',
            customFormatString: 'Custom Format',
            invalidFormat: 'Invalid Format.',
            group: 'Group',
            unGroup: 'Ungroup',
            invalidSelection: 'Cannot group that selection.',
            groupName: 'Enter the caption to display in header',
            captionName: 'Enter the caption for group field',
            selectedItems: 'Selected items',
            groupFieldCaption: 'Field caption',
            groupTitle: 'Group name',
            startAt: 'Starting at',
            endAt: 'Ending at',
            groupBy: 'Interval by',
            selectGroup: 'Select groups',
            multipleAxes: 'Multiple Axis',
            showLegend: 'Show Legend',
            exit: 'Exit',
            chartTypeSettings: 'Chart Type Settings',
            ChartType: 'Chart Type',
            yes: 'Yes',
            no: 'No',
            numberFormatMenu: 'Number Formatting...',
            conditionalFormatingMenu: 'Conditional Formatting...',
            removeCalculatedField: 'Are you sure you want to delete this calculated field?',
            replaceConfirmBefore: 'A report named ',
            replaceConfirmAfter: ' already exists. Do you want to replace it?',
            invalidJSON: 'Invalid JSON data',
            invalidCSV: 'Invalid CSV data',
            stacked: 'Stacked',
            single: 'Single',
            combined: 'Combined',
            multipleAxisMode: 'Multiple Axis Mode',
            grandTotalPosition: 'Grand totals position',
            top: 'Top',
            bottom: 'Bottom',
            None: 'None',
            rowPage: 'Row pager',
            rowPerPage: 'Rows per page',
            columnPage: 'Column pager',
            columnPerPage: 'Columns per page',
            goToFirstPage: 'Go to first page',
            goToPreviousPage: 'Go to previous page',
            goToNextPage: 'Go to next page',
            goToLastPage: 'Go to last page',
            subTotalPosition: 'Subtotals position',
            auto: 'Auto'
        };
        this.localeObj = new L10n(this.getModuleName(), this.defaultLocale, this.locale);
        this.renderContextMenu();
        this.isDragging = false;
        this.addInternalEvents();
        //setCurrencyCode(this.currencyCode);
    }
    onBeforeTooltipOpen(args) {
        args.element.classList.add('e-pivottooltipwrap');
    }
    renderToolTip() {
        if (this.showTooltip) {
            if (this.tooltipTemplate) {
                this.tooltip = new Tooltip({
                    target: 'td.e-valuescontent',
                    cssClass: 'e-pivottooltiptemplate' + (this.cssClass ? (' ' + this.cssClass) : ''),
                    showTipPointer: false,
                    position: 'BottomRight',
                    mouseTrail: true,
                    enableRtl: this.enableRtl,
                    locale: this.locale,
                    enableHtmlSanitizer: this.enableHtmlSanitizer,
                    beforeRender: this.setToolTip.bind(this),
                    beforeOpen: this.onBeforeTooltipOpen
                });
            }
            else {
                this.tooltip = new Tooltip({
                    target: 'td.e-valuescontent',
                    cssClass: this.cssClass,
                    showTipPointer: false,
                    position: 'BottomRight',
                    mouseTrail: true,
                    enableRtl: this.enableRtl,
                    locale: this.locale,
                    enableHtmlSanitizer: this.enableHtmlSanitizer,
                    beforeRender: this.setToolTip.bind(this),
                    beforeOpen: this.onBeforeTooltipOpen
                });
            }
            this.tooltip.isStringTemplate = true;
            this.tooltip.appendTo(this.element);
        }
        else if (this.tooltip) {
            this.tooltip.destroy();
        }
    }
    /** @hidden */
    renderContextMenu() {
        if (this.gridSettings.contextMenuItems || (this.allowGrouping && this.dataType === 'pivot')) {
            const conmenuItems = [];
            const groupItems = [];
            const customItems = [];
            const exportItems = [];
            const aggItems = [];
            const expItems = [];
            let aggregateItems = [];
            if (this.gridSettings.contextMenuItems) {
                for (const item of this.gridSettings.contextMenuItems) {
                    if (typeof item === 'string' && this.getDefaultItems().indexOf(item) !== -1) {
                        if (item.toString().toLowerCase().indexOf('aggregate') !== -1 && this.dataType === 'pivot') {
                            aggregateItems = [
                                { text: this.localeObj.getConstant('Sum') }
                            ];
                            const aggregateGroup = this.buildDefaultItems('Aggregate');
                            aggregateGroup.items = aggregateItems;
                            aggItems.push(aggregateGroup);
                        }
                        else if (item.toString().toLowerCase().indexOf('export') !== -1) {
                            exportItems.push(this.buildDefaultItems(item));
                        }
                        else {
                            conmenuItems.push(this.buildDefaultItems(item));
                        }
                    }
                    else if (typeof item !== 'string') {
                        customItems.push(item);
                    }
                }
            }
            if (this.allowGrouping && this.dataType === 'pivot') {
                if (!this.getFieldByID(this.element.id + '_custom_group', this.gridSettings.contextMenuItems)) {
                    groupItems.push(this.buildDefaultItems('Group'));
                }
                if (!this.getFieldByID(this.element.id + '_custom_ungroup', this.gridSettings.contextMenuItems)) {
                    groupItems.push(this.buildDefaultItems('Ungroup'));
                }
            }
            if (exportItems.length > 0) {
                const exportGroupItems = this.buildDefaultItems('export');
                exportGroupItems.items = exportItems;
                expItems.push(exportGroupItems);
            }
            const contextMenuItems = [];
            Array.prototype.push.apply(contextMenuItems, aggItems);
            Array.prototype.push.apply(contextMenuItems, conmenuItems);
            Array.prototype.push.apply(contextMenuItems, groupItems);
            Array.prototype.push.apply(contextMenuItems, expItems);
            Array.prototype.push.apply(contextMenuItems, customItems);
            this.setProperties({ gridSettings: { contextMenuItems: contextMenuItems } }, true);
        }
    }
    getFieldByID(id, fields) {
        return new DataManager({ json: fields }).executeLocal(new Query().where('id', 'equal', id))[0];
    }
    /**
     *
     * @hidden
     *
     */
    getAllSummaryType() {
        return ['Sum', 'Count', 'DistinctCount', 'Product', 'Min', 'Max', 'Avg', 'Median', 'Index',
            'PopulationVar', 'SampleVar', 'PopulationStDev', 'SampleStDev', 'RunningTotals', 'PercentageOfGrandTotal',
            'PercentageOfColumnTotal', 'PercentageOfRowTotal', 'PercentageOfParentColumnTotal', 'PercentageOfParentRowTotal',
            'DifferenceFrom', 'PercentageOfDifferenceFrom', 'PercentageOfParentTotal'];
    }
    getDefaultItems() {
        return ['Drillthrough', 'Expand',
            'Collapse', 'Pdf Export', 'Excel Export', 'Csv Export', 'Sort Ascending', 'Sort Descending',
            'Aggregate', 'CalculatedField'];
    }
    buildDefaultItems(item) {
        let menuItem;
        switch (item) {
            case 'Aggregate':
                menuItem = {
                    text: this.localeObj.getConstant('aggregate'), target: 'th.e-valuesheader,td.e-valuescontent,.e-stot.e-rowsheader',
                    id: this.element.id + '_aggregate'
                };
                break;
            case 'CalculatedField':
                menuItem = {
                    text: this.localeObj.getConstant('CalculatedField'), target: 'td.e-valuescontent',
                    id: this.element.id + '_CalculatedField'
                };
                break;
            case 'Drillthrough':
                menuItem = {
                    text: this.localeObj.getConstant('drillThrough'), target: 'td.e-valuescontent',
                    id: this.element.id + '_drillthrough_menu', iconCss: PIVOTVIEW_GRID + ' ' + ICON
                };
                break;
            case 'export':
                menuItem = {
                    text: this.localeObj.getConstant('export'), target: 'td.e-valuescontent',
                    id: this.element.id + '_exporting', iconCss: PIVOTVIEW_EXPORT + ' ' + ICON
                };
                break;
            case 'Pdf Export':
                menuItem = {
                    text: this.localeObj.getConstant('pdf'), id: this.element.id + '_pdf',
                    iconCss: GRID_PDF_EXPORT + ' ' + ICON
                };
                break;
            case 'Excel Export':
                menuItem = {
                    text: this.localeObj.getConstant('excel'), id: this.element.id + '_excel',
                    iconCss: GRID_EXCEL_EXPORT + ' ' + ICON
                };
                break;
            case 'Csv Export':
                menuItem = {
                    text: this.localeObj.getConstant('csv'), id: this.element.id + '_csv',
                    iconCss: GRID_CSV_EXPORT + ' ' + ICON
                };
                break;
            case 'Expand':
                menuItem = {
                    text: this.localeObj.getConstant('expand'), target: 'td.e-rowsheader,.e-columnsheader',
                    id: this.element.id + '_expand', iconCss: PIVOTVIEW_EXPAND + ' ' + ICON
                };
                break;
            case 'Collapse':
                menuItem = {
                    text: this.localeObj.getConstant('collapse'), target: 'td.e-rowsheader,.e-columnsheader',
                    id: this.element.id + '_collapse', iconCss: PIVOTVIEW_COLLAPSE + ' ' + ICON
                };
                break;
            case 'Sort Ascending':
                menuItem = {
                    text: this.localeObj.getConstant('ascending'), target: 'th.e-valuesheader,.e-stot',
                    id: this.element.id + '_sortasc', iconCss: ICON_ASC + ' ' + ICON
                };
                break;
            case 'Sort Descending':
                menuItem = {
                    text: this.localeObj.getConstant('descending'), target: 'th.e-valuesheader,.e-stot',
                    id: this.element.id + '_sortdesc', iconCss: ICON_DESC + ' ' + ICON
                };
                break;
            case 'Group':
                menuItem = {
                    text: this.localeObj.getConstant('group'), target: 'td.e-rowsheader,.e-columnsheader',
                    id: this.element.id + '_custom_group', iconCss: PIVOTVIEW_GROUP + ' ' + ICON
                };
                break;
            case 'Ungroup':
                menuItem = {
                    text: this.localeObj.getConstant('unGroup'), target: 'td.e-rowsheader,.e-columnsheader',
                    id: this.element.id + '_custom_ungroup', iconCss: PIVOTVIEW_UN_GROUP + ' ' + ICON
                };
                break;
        }
        this.defaultItems[item] = {
            text: menuItem.text, id: menuItem.id,
            target: menuItem.target, iconCss: menuItem.iconCss
        };
        return this.defaultItems[item];
    }
    initProperties() {
        this.pivotRefresh = Component.prototype.refresh;
        this.minHeight = isNullOrUndefined(this.minHeight) ? 300 : (this.minHeight < 10 ? 10 : this.minHeight);
        this.isScrolling = false;
        this.allowServerDataBinding = false;
        this.isStaticRefresh = false;
        this.setProperties({ pivotValues: [] }, true);
        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
        delete this.bulkChanges.pivotValues;
        this.allowServerDataBinding = true;
        this.scrollPosObject = {
            vertical: 0, horizontal: 0, verticalSection: 0,
            horizontalSection: 0, top: 0, left: 0, scrollDirection: { direction: '', position: 0 }
        };
        this.queryCellInfo = this.gridSettings.queryCellInfo ? this.gridSettings.queryCellInfo.bind(this) : undefined;
        this.headerCellInfo = this.gridSettings.headerCellInfo ? this.gridSettings.headerCellInfo.bind(this) : undefined;
        this.resizing = this.gridSettings.resizing ? this.gridSettings.resizing.bind(this) : undefined;
        this.resizeStop = this.gridSettings.resizeStop ? this.gridSettings.resizeStop.bind(this) : undefined;
        this.pdfHeaderQueryCellInfo = this.gridSettings.pdfHeaderQueryCellInfo ? this.gridSettings.pdfHeaderQueryCellInfo : undefined;
        this.pdfQueryCellInfo = this.gridSettings.pdfQueryCellInfo ? this.gridSettings.pdfQueryCellInfo : undefined;
        this.excelHeaderQueryCellInfo = this.gridSettings.excelHeaderQueryCellInfo ? this.gridSettings.excelHeaderQueryCellInfo : undefined;
        this.excelQueryCellInfo = this.gridSettings.excelQueryCellInfo ? this.gridSettings.excelQueryCellInfo : undefined;
        this.columnDragStart = this.gridSettings.columnDragStart ? this.gridSettings.columnDragStart.bind(this) : undefined;
        this.columnDrag = this.gridSettings.columnDrag ? this.gridSettings.columnDrag.bind(this) : undefined;
        this.columnDrop = this.gridSettings.columnDrop ? this.gridSettings.columnDrop.bind(this) : undefined;
        this.beforeColumnsRender = this.gridSettings.columnRender ? this.gridSettings.columnRender : undefined;
        this.selected = this.gridSettings.cellSelected ? this.gridSettings.cellSelected : undefined;
        this.cellDeselected = this.gridSettings.cellDeselected ? this.gridSettings.cellDeselected : undefined;
        this.rowSelected = this.gridSettings.rowSelected ? this.gridSettings.rowSelected : undefined;
        this.rowDeselected = this.gridSettings.rowDeselected ? this.gridSettings.rowDeselected : undefined;
        this.chartTooltipRender = this.chartSettings.tooltipRender ? this.chartSettings.tooltipRender : undefined;
        this.chartLegendClick = this.chartSettings.legendClick ? this.chartSettings.legendClick : undefined;
        this.chartLoaded = this.chartSettings.loaded ? this.chartSettings.loaded : undefined;
        this.chartLoad = this.chartSettings.load ? this.chartSettings.load : undefined;
        this.chartResized = this.chartSettings.resized ? this.chartSettings.resized : undefined;
        this.chartAxisLabelRender = this.chartSettings.axisLabelRender ? this.chartSettings.axisLabelRender : undefined;
        this.multiLevelLabelClick = this.chartSettings.multiLevelLabelClick ? this.chartSettings.multiLevelLabelClick : undefined;
        this.chartPointClick = this.chartSettings.pointClick ? this.chartSettings.pointClick : undefined;
        this.contextMenuClick = this.gridSettings.contextMenuClick ? this.gridSettings.contextMenuClick : undefined;
        this.contextMenuOpen = this.gridSettings.contextMenuOpen ? this.gridSettings.contextMenuOpen : undefined;
        this.beforePdfExport = this.gridSettings.beforePdfExport ? this.gridSettings.beforePdfExport.bind(this) : undefined;
        this.beforeExcelExport = this.gridSettings.beforeExcelExport ? this.gridSettings.beforeExcelExport.bind(this) : undefined;
        if (this.gridSettings.rowHeight === null) {
            if (this.isTouchMode) {
                this.setProperties({ gridSettings: { rowHeight: 36 } }, true);
            }
            else {
                this.setProperties({ gridSettings: { rowHeight: this.isAdaptive ? 36 : 30 } }, true);
            }
        }
        if (this.chartSettings && this.chartSettings.showMemberSeries && !this.chartSettings.showPointColorByMembers) {
            this.setProperties({ chartSettings: { showPointColorByMembers: true } }, true);
        }
        this.element.style.height = '100%';
        if (this.enableVirtualization) {
            this.updatePageSettings(true);
        }
        this.isCellBoxMultiSelection = this.gridSettings.allowSelection &&
            this.gridSettings.selectionSettings.cellSelectionMode === 'Box' &&
            this.gridSettings.selectionSettings.mode === 'Cell' && this.gridSettings.selectionSettings.type === 'Multiple';
        if (this.allowGrouping && !this.isCellBoxMultiSelection) {
            this.isCellBoxMultiSelection = true;
            this.setProperties({ gridSettings: { allowSelection: true, selectionSettings: { cellSelectionMode: 'Box', mode: 'Cell', type: 'Multiple' } } }, true);
        }
        if (this.displayOption.view !== 'Table') {
            this.pivotChartModule = new PivotChart();
        }
        this.currentView = this.currentView ? this.currentView : (this.displayOption.view === 'Both' ?
            this.displayOption.primary : this.displayOption.view);
    }
    /**
     *
     * @hidden
     *
     */
    updatePageSettings(isInit) {
        if (this.enableVirtualization) {
            let colValues = 1;
            let rowValues = 1;
            if (this.dataSourceSettings.values.length > 1 && this.dataType === 'pivot') {
                if (this.dataSourceSettings.valueAxis === 'row') {
                    rowValues = this.dataSourceSettings.values.length;
                }
                else {
                    colValues = this.dataSourceSettings.values.length;
                }
            }
            let heightAsNumber = this.getHeightAsNumber();
            if (isNaN(heightAsNumber)) {
                heightAsNumber = this.element.offsetHeight;
            }
            this.pageSettings = {
                currentColumnPage: isInit ? 1 : this.pageSettings.currentColumnPage,
                currentRowPage: isInit ? 1 : this.pageSettings.currentRowPage,
                columnPageSize: Math.ceil((Math.floor((this.getWidthAsNumber()) /
                    this.gridSettings.columnWidth) - 1) / colValues),
                rowPageSize: Math.ceil(Math.floor((heightAsNumber) / this.gridSettings.rowHeight) / rowValues)
            };
        }
    }
    /**
     * Initialize the control rendering
     *
     * @returns {void}
     * @hidden
     */
    render() {
        this.loadData();
    }
    loadData() {
        if (this.dataSourceSettings.formatSettings.length > 0) {
            const formatfield = this.dataSourceSettings.formatSettings;
            for (let i = 0; i < formatfield.length; i++) {
                if ((!isNullOrUndefined(formatfield[i].maximumFractionDigits) || !isNullOrUndefined(formatfield[i].minimumFractionDigits)) && formatfield[i].format.match(/^(P|N|C|P[0-9]|C[0-9]|N[0-9])$/g) === null) {
                    formatfield[i].maximumFractionDigits = undefined;
                    formatfield[i].minimumIntegerDigits = undefined;
                }
            }
        }
        if (this.dataType === 'pivot' && this.dataSourceSettings.url && this.dataSourceSettings.url !== '') {
            if (this.dataSourceSettings.mode === 'Server') {
                this.guid = PivotUtil.generateUUID();
                this.initialLoad();
                if (this.displayOption.view !== 'Chart') {
                    this.renderEmptyGrid();
                }
                this.showWaitingPopup();
            }
            else {
                const request = new Fetch(this.dataSourceSettings.url, 'GET');
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                request.send().then((response) => typeof (response) === 'string' ? response : response.text())
                    .then(this.onReadyStateChange.bind(this));
            }
        }
        else {
            this.initialLoad();
        }
    }
    onSuccess(excelExportProperties) {
        if (this.request.readyState === XMLHttpRequest.DONE) {
            if (this.currentAction === 'onExcelExport' || this.currentAction === 'onCsvExport') {
                if (this.request.statusText === 'OK') {
                    const buffer = this.request.response;
                    const fileName = isNullOrUndefined(excelExportProperties.fileName) ? (this.currentAction === 'onExcelExport' ? 'default.xlsx' : 'default.csv') : excelExportProperties.fileName;
                    Save.save(fileName, buffer);
                }
            }
            else {
                this.isServerWaitingPopup = true;
                try {
                    /* eslint-disable @typescript-eslint/no-explicit-any */
                    const engine = JSON.parse(this.request.responseText);
                    if (this.currentAction === 'fetchFieldMembers') {
                        const currentMembers = JSON.parse(engine.members);
                        const dateMembers = [];
                        const formattedMembers = {};
                        const members = {};
                        /* eslint-enable @typescript-eslint/no-explicit-any */
                        for (let i = 0; i < currentMembers.length; i++) {
                            dateMembers.push({
                                formattedText: currentMembers[i].FormattedText,
                                actualText: currentMembers[i].ActualText
                            });
                            formattedMembers[currentMembers[i].FormattedText] = {};
                            members[currentMembers[i].ActualText] = {};
                        }
                        this.engineModule.fieldList[engine.memberName].dateMember = dateMembers;
                        this.engineModule.fieldList[engine.memberName].formattedMembers = formattedMembers;
                        this.engineModule.fieldList[engine.memberName].members = members;
                        if (this.showGroupingBar) {
                            this.pivotButtonModule.updateFilterEvents();
                        }
                        else {
                            this.pivotFieldListModule.pivotButtonModule.updateFilterEvents();
                        }
                    }
                    else if (this.currentAction === 'fetchRawData') {
                        const valueCaption = this.engineModule.fieldList[this.drillThroughValue.actualText.toString()]
                            ? this.engineModule.fieldList[this.drillThroughValue.actualText.toString()].caption
                            : this.drillThroughValue.actualText.toString();
                        const aggType = this.engineModule.fieldList[this.drillThroughValue.actualText] ? this.engineModule.fieldList[this.drillThroughValue.actualText].aggregateType : '';
                        const rawData = JSON.parse(engine.rawData);
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        const parsedObj = JSON.parse(engine.indexObject);
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        const indexObject = {};
                        for (let len = 0; len < parsedObj.length; len++) {
                            indexObject[parsedObj[len].Key] = parsedObj[len].Value;
                        }
                        this.drillThroughValue.indexObject = indexObject;
                        this.drillThroughModule.triggerDialog(valueCaption, aggType, rawData, this.drillThroughValue, this.drillThroughElement);
                    }
                    else {
                        const fList = PivotUtil.formatFieldList(JSON.parse(engine.fieldList));
                        if (this.engineModule.fieldList) {
                            const keys = Object.keys(this.engineModule.fieldList);
                            for (let i = 0; i < keys.length; i++) {
                                if (this.engineModule.fieldList[keys[i]] && fList[keys[i]]) {
                                    fList[keys[i]].dateMember = this.engineModule.fieldList[keys[i]].dateMember;
                                    fList[keys[i]].formattedMembers =
                                        this.engineModule.fieldList[keys[i]].formattedMembers;
                                    fList[keys[i]].members = this.engineModule.fieldList[keys[i]].members;
                                }
                            }
                        }
                        this.engineModule.fieldList = fList;
                        this.engineModule.fields = JSON.parse(engine.fields);
                        this.engineModule.rowCount = JSON.parse(engine.pivotCount).RowCount;
                        this.engineModule.columnCount = JSON.parse(engine.pivotCount).ColumnCount;
                        this.engineModule.rowStartPos = JSON.parse(engine.pivotCount).RowStartPosition;
                        this.engineModule.colStartPos = JSON.parse(engine.pivotCount).ColumnStartPosition;
                        this.engineModule.rowFirstLvl = JSON.parse(engine.pivotCount).RowFirstLevel;
                        this.engineModule.colFirstLvl = JSON.parse(engine.pivotCount).ColumnFirstLevel;
                        this.engineModule.columnPageCount = JSON.parse(engine.pivotCount).ColumnPageCount;
                        this.engineModule.rowPageCount = JSON.parse(engine.pivotCount).RowPageCount;
                        let rowPos;
                        const pivotValues = PivotUtil.formatPivotValues(JSON.parse(engine.pivotValue)); /* eslint-disable-line @typescript-eslint/no-explicit-any */
                        for (let rCnt = 0; rCnt < pivotValues.length; rCnt++) {
                            if (pivotValues[rCnt] && pivotValues[rCnt][0] && pivotValues[rCnt][0].axis === 'row') {
                                rowPos = rCnt;
                                break;
                            }
                        }
                        this.engineModule.headerContent = PivotUtil.frameContent(pivotValues, 'header', rowPos, this);
                        this.engineModule.pageSettings = this.pageSettings;
                        if (this.dataSourceSettings.groupSettings.length > 0) {
                            PivotUtil.updateReport(this, JSON.parse(engine.dataSourceSettings));
                        }
                        const valueSort = JSON.parse(engine.dataSourceSettings).ValueSortSettings; /* eslint-disable-line @typescript-eslint/no-explicit-any */
                        this.engineModule.valueSortSettings = {
                            headerText: valueSort.HeaderText,
                            headerDelimiter: valueSort.HeaderDelimiter,
                            sortOrder: valueSort.SortOrder,
                            columnIndex: valueSort.ColumnIndex
                        };
                        this.engineModule.pivotValues = pivotValues;
                    }
                }
                catch (error) {
                    this.engineModule.pivotValues = [];
                }
                if (this.currentAction === 'onScroll') {
                    if (this.scrollDirection === 'vertical') {
                        const rowValues = this.dataSourceSettings.valueAxis === 'row' ? this.dataSourceSettings.values.length : 1;
                        const exactSize = (this.pageSettings.rowPageSize * rowValues * this.gridSettings.rowHeight);
                        const exactPage = Math.ceil(this.engineModule.rowStartPos / (this.pageSettings.rowPageSize * rowValues));
                        const pos = exactSize * exactPage -
                            (this.engineModule.rowFirstLvl * rowValues * this.gridSettings.rowHeight);
                        this.scrollPosObject.verticalSection = pos;
                    }
                    else if (this.scrollDirection === 'horizondal') {
                        const colValues = this.dataSourceSettings.valueAxis === 'column' ? this.dataSourceSettings.values.length : 1;
                        const exactSize = (this.pageSettings.columnPageSize * colValues * this.gridSettings.columnWidth);
                        const exactPage = Math.ceil(this.engineModule.colStartPos / (this.pageSettings.columnPageSize * colValues));
                        const pos = exactSize * exactPage -
                            (this.engineModule.colFirstLvl * colValues * this.gridSettings.columnWidth);
                        this.scrollPosObject.horizontalSection = pos;
                    }
                }
                if (this.currentAction !== 'fetchFieldMembers' && this.currentAction !== 'fetchRawData') {
                    this.initEngine();
                    if (this.calculatedFieldModule && this.calculatedFieldModule.isRequireUpdate) {
                        this.calculatedFieldModule.endDialog();
                        this.calculatedFieldModule.isRequireUpdate = false;
                    }
                    if (this.pivotFieldListModule && this.pivotFieldListModule.calculatedFieldModule &&
                        this.pivotFieldListModule.calculatedFieldModule.isRequireUpdate) {
                        this.pivotFieldListModule.calculatedFieldModule.endDialog();
                        this.pivotFieldListModule.calculatedFieldModule.isRequireUpdate = false;
                    }
                }
            }
        }
    }
    /** @hidden */
    getEngine(action, drillItem, sortItem, aggField, cField, filterItem, memberName, rawDataArgs, editArgs, excelExportProperties) {
        this.engineModule.isEmptyData = false;
        if (this.element.querySelector('.e-spin-hide') && !(action === 'onExcelExport' || action === 'onCsvExport')) {
            this.showWaitingPopup();
        }
        this.currentAction = action;
        this.isServerWaitingPopup = false;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const customProperties = {
            pageSettings: JSON.parse(this.getPersistData()).pageSettings,
            enableValueSorting: this.enableValueSorting,
            enablePaging: this.enablePaging,
            enableVirtualization: this.enableVirtualization,
            enableDrillThrough: (this.allowDrillThrough || this.editSettings.allowEditing),
            locale: JSON.stringify(PivotUtil.getLocalizedObject(this))
        };
        this.request.open('POST', this.dataSourceSettings.url, true);
        const params = {
            request: this.request,
            dataSourceSettings: JSON.parse(this.getPersistData()).dataSourceSettings,
            action: action,
            customProperties: {},
            internalProperties: customProperties,
            drillItem: drillItem,
            sortItem: sortItem,
            aggregatedItem: aggField,
            calculatedItem: cField,
            filterItem: filterItem,
            memberName: memberName,
            fetchRawDataArgs: rawDataArgs,
            editArgs: editArgs,
            hash: this.guid,
            excelExportProperties: excelExportProperties,
            exportAllPages: this.exportAllPages,
            isGroupingUpdated: (this.currentAction === 'onRefresh' && this.dataSourceSettings.groupSettings.length > 0) ? true : (this.groupingModule ? this.groupingModule.isUpdate : false)
        };
        this.trigger(beforeServiceInvoke, params, (observedArgs) => {
            this.request = observedArgs.request;
            params.internalProperties = observedArgs.internalProperties;
            params.customProperties = observedArgs.customProperties;
            params.dataSourceSettings = observedArgs.dataSourceSettings;
            params.calculatedItem = observedArgs.calculatedItem;
            params.drillItem = observedArgs.drillItem;
            params.editArgs = observedArgs.editArgs;
            params.fetchRawDataArgs = observedArgs.fetchRawDataArgs;
            params.filterItem = observedArgs.filterItem;
            params.hash = observedArgs.hash;
            params.memberName = observedArgs.memberName;
            params.sortItem = observedArgs.sortItem;
            params.excelExportProperties = observedArgs.excelExportProperties;
            params.exportAllPages = observedArgs.exportAllPages;
        });
        this.request.withCredentials = false;
        this.request.onreadystatechange = this.onSuccess.bind(this, params.excelExportProperties);
        if (params.action === 'onExcelExport' || params.action === 'onCsvExport') {
            this.request.responseType = 'blob';
        }
        else {
            this.request.responseType = '';
        }
        this.request.setRequestHeader('Content-type', 'application/json');
        this.request.send(JSON.stringify(params));
    }
    onReadyStateChange(result) {
        let dataSource = [];
        if (this.dataSourceSettings.type === 'CSV') {
            const jsonObject = result.split(/\r?\n|\r/);
            // (dataSource as string[][]).push(jsonObject[0].split(',').map(function (e) { return e.replace(/ /g, '').replace(/^\"(.+)\"$/, "$1"); }));
            for (let i = 0; i < jsonObject.length; i++) {
                if (!isNullOrUndefined(jsonObject[i]) && jsonObject[i] !== '') {
                    dataSource.push(jsonObject[i].split(','));
                }
            }
        }
        else {
            try {
                dataSource = JSON.parse(result);
            }
            catch (error) {
                dataSource = [];
            }
        }
        if (dataSource && dataSource.length > 0) {
            this.setProperties({ dataSourceSettings: { dataSource: dataSource } }, true);
        }
        this.initialLoad();
    }
    initialLoad() {
        try {
            this.cellTemplateFn = this.templateParser(this.cellTemplate);
            this.tooltipTemplateFn = this.templateParser(this.tooltipTemplate);
            if (this.spinnerTemplate) { // eslint-disable-next-line @typescript-eslint/no-explicit-any
                createSpinner({ target: this.element, template: this.spinnerTemplate, cssClass: this.cssClass
                        ? this.cssClass : undefined }, this.createElement);
            }
            else {
                createSpinner({ target: this.element, cssClass: this.cssClass ? this.cssClass : undefined }, this.createElement);
            }
            const loadArgs = {
                dataSourceSettings: this.dataSourceSettings,
                pivotview: this,
                fieldsType: {},
                defaultFieldListOrder: this.defaultFieldListOrder
            };
            this.trigger(load, loadArgs, (observedArgs) => {
                this.dataSourceSettings = observedArgs.dataSourceSettings;
                this.fieldsType = observedArgs.fieldsType;
                this.defaultFieldListOrder = loadArgs.defaultFieldListOrder;
                this.updateClass();
                this.notify(initSubComponent, {});
                if (this.dataSourceSettings.mode !== 'Server') {
                    this.notify(initialLoad, {});
                }
                if (this.isAdaptive) {
                    this.contextMenuModule.render();
                }
                this.notify(initToolbar, {});
                this.notify(initPivotPager, {});
            });
        }
        catch (execption) {
            this.actionFailureMethod(execption);
        }
    }
    /**
     * Register the internal events.
     *
     * @returns {void}
     * @hidden
     */
    addInternalEvents() {
        this.on(initialLoad, this.generateData, this);
        this.on(dataReady, this.renderPivotGrid, this);
        this.on(contentReady, this.onContentReady, this);
    }
    /**
     * De-Register the internal events.
     *
     * @returns {void}
     * @hidden
     */
    removeInternalEvents() {
        this.off(initialLoad, this.generateData);
        this.off(dataReady, this.renderPivotGrid);
        this.off(contentReady, this.onContentReady);
    }
    /**
     * Get the Pivot widget properties to be maintained in the persisted state.
     *
     * @returns {string} - string.
     */
    getPersistData() {
        const keyEntity = ['dataSourceSettings', 'pivotValues', 'gridSettings', 'chartSettings', 'displayOption', 'pageSettings'];
        /* eslint-disable @typescript-eslint/no-explicit-any */
        const columnRender = this.gridSettings['columnRender'];
        const excelQueryCellInfo$$1 = this.gridSettings['excelQueryCellInfo'];
        const excelHeaderQueryCellInfo$$1 = this.gridSettings['excelHeaderQueryCellInfo'];
        const pdfQueryCellInfo$$1 = this.gridSettings['pdfQueryCellInfo'];
        const pdfHeaderQueryCellInfo$$1 = this.gridSettings['pdfHeaderQueryCellInfo'];
        const chartLoadEvent = this.chartSettings['load'];
        const chartLoadedEvent = this.chartSettings['loaded'];
        const chartTextRenderEvent = this.chartSettings['textRender'];
        const chartPointRenderEvent = this.chartSettings['pointRender'];
        const chartSeriesRenderEvent = this.chartSettings['seriesRender'];
        const chartLegendRenderEvent = this.chartSettings['legendRender'];
        const chartPointClickEvent = this.chartSettings['pointClick'];
        const chartTooltipRenderEvent = this.chartSettings['tooltipRender'];
        const chartLegendClickEvent = this.chartSettings['legendClick'];
        /* eslint-enable @typescript-eslint/no-explicit-any */
        this.gridSettings['columnRender'] = undefined;
        this.gridSettings['excelQueryCellInfo'] = undefined;
        this.gridSettings['excelHeaderQueryCellInfo'] = undefined;
        this.gridSettings['pdfQueryCellInfo'] = undefined;
        this.gridSettings['pdfHeaderQueryCellInfo'] = undefined;
        this.chartSettings['tooltipRender'] = undefined;
        this.chartSettings['legendClick'] = undefined;
        this.chartSettings['load'] = undefined;
        this.chartSettings['loaded'] = undefined;
        this.chartSettings['textRender'] = undefined;
        this.chartSettings['pointRender'] = undefined;
        this.chartSettings['seriesRender'] = undefined;
        this.chartSettings['legendRender'] = undefined;
        this.chartSettings['pointClick'] = undefined;
        const persistData = this.addOnPersist(keyEntity);
        this.gridSettings['columnRender'] = columnRender;
        this.gridSettings['excelQueryCellInfo'] = excelQueryCellInfo$$1;
        this.gridSettings['excelHeaderQueryCellInfo'] = excelHeaderQueryCellInfo$$1;
        this.gridSettings['pdfQueryCellInfo'] = pdfQueryCellInfo$$1;
        this.gridSettings['pdfHeaderQueryCellInfo'] = pdfHeaderQueryCellInfo$$1;
        this.chartSettings['load'] = chartLoadEvent;
        this.chartSettings['loaded'] = chartLoadedEvent;
        this.chartSettings['textRender'] = chartTextRenderEvent;
        this.chartSettings['pointRender'] = chartPointRenderEvent;
        this.chartSettings['seriesRender'] = chartSeriesRenderEvent;
        this.chartSettings['legendRender'] = chartLegendRenderEvent;
        this.chartSettings['pointClick'] = chartPointClickEvent;
        this.chartSettings['tooltipRender'] = chartTooltipRenderEvent;
        this.chartSettings['legendClick'] = chartLegendClickEvent;
        return persistData;
    }
    /**
     * Loads pivot Layout
     *
     * @param {string} persistData - Specifies the persist data to be loaded to pivot.
     * @returns {void}
     */
    loadPersistData(persistData) {
        const pivotData = JSON.parse(persistData);
        this.allowServerDataBinding = false;
        this.setProperties({
            gridSettings: pivotData.gridSettings,
            pivotValues: pivotData.pivotValues,
            chartSettings: pivotData.chartSettings,
            displayOption: pivotData.displayOption
        }, true);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        delete this.bulkChanges.pivotValues;
        this.allowServerDataBinding = true;
        this.dataSourceSettings = pivotData.dataSourceSettings;
    }
    mergePersistPivotData() {
        const data = window.localStorage.getItem(this.getModuleName() + this.element.id);
        if (!(isNullOrUndefined(data) || (data === ''))) {
            this.setProperties(JSON.parse(data), true);
        }
    }
    /**
     * Method to open conditional formatting dialog.
     *
     * @returns {void}
     */
    showConditionalFormattingDialog() {
        if (this.conditionalFormattingModule) {
            this.conditionalFormattingModule.showConditionalFormattingDialog();
        }
    }
    /**
     * Method to open calculated field dialog.
     *
     * @returns {void}
     */
    createCalculatedFieldDialog() {
        if (this.calculatedFieldModule) {
            this.calculatedFieldModule.createCalculatedFieldDialog();
        }
    }
    /**
     * It returns the Module name.
     *
     * @returns {string} - string.
     * @hidden
     */
    getModuleName() {
        return 'pivotview';
    }
    /**
     * Copy the selected rows or cells data into clipboard.
     *
     * @param {boolean} withHeader - Specifies whether the column header text needs to be copied along with rows or cells.
     * @returns {void}
     * @hidden
     */
    copy(withHeader) {
        this.grid.copy(withHeader);
    }
    /**
     * By default, prints all the pages of the Grid and hides the pager.
     * > You can customize print options using the
     * [`printMode`](./api-pivotgrid.html#printmode-string).
     *
     * @returns {void}
     * @hidden
     */
    // public print(): void {
    //     this.grid.print();
    // }
    /**
     *
     * Called internally if any of the property value changed.
     *
     * @returns {void}
     * @hidden
     */
    onPropertyChanged(newProp, oldProp) {
        let isRequireRefresh = false;
        for (const prop of Object.keys(newProp)) {
            switch (prop) {
                case 'dataSourceSettings':
                case 'hyperlinkSettings':
                case 'allowDrillThrough':
                case 'editSettings':
                case 'allowDataCompression':
                    if (newProp.dataSourceSettings && Object.keys(newProp.dataSourceSettings).length === 1
                        && newProp.dataSourceSettings.groupSettings && this.dataType === 'pivot') {
                        this.updateGroupingReport(newProp.dataSourceSettings.groupSettings, 'Date');
                    }
                    if (newProp.dataSourceSettings && Object.keys(newProp.dataSourceSettings).length === 1
                        && Object.keys(newProp.dataSourceSettings)[0] === 'dataSource') {
                        if (!isNullOrUndefined(this.savedDataSourceSettings) && this.dataSourceSettings.dataSource.length > 0) {
                            PivotUtil.updateDataSourceSettings(this, this.savedDataSourceSettings);
                            this.savedDataSourceSettings = undefined;
                        }
                        if ((newProp.dataSourceSettings.dataSource && newProp.dataSourceSettings.dataSource).length === 0) {
                            this.savedDataSourceSettings = PivotUtil.getClonedDataSourceSettings(this.dataSourceSettings);
                            this.setProperties({ dataSourceSettings: { rows: [] } }, true);
                            this.setProperties({ dataSourceSettings: { columns: [] } }, true);
                            this.setProperties({ dataSourceSettings: { values: [] } }, true);
                            this.setProperties({ dataSourceSettings: { filters: [] } }, true);
                        }
                        if (!this.isStaticRefresh) {
                            this.pivotValues = [];
                            if (this.dataType === 'pivot') {
                                this.engineModule.fieldList = null;
                                this.engineModule.isEmptyData = true;
                                this.engineModule.data = [];
                            }
                            else if (this.dataType === 'olap') {
                                this.olapEngineModule.fieldList = {};
                                this.olapEngineModule.fieldListData = undefined;
                                this.olapEngineModule.isEmptyData = true;
                            }
                        }
                        if (this.dataSourceSettings.groupSettings.length > 0) {
                            this.clonedDataSet = newProp.dataSourceSettings.dataSource;
                            this.updateGroupingReport(this.dataSourceSettings.groupSettings, 'Date');
                        }
                        this.showWaitingPopup();
                        this.notify(initialLoad, {});
                    }
                    else {
                        if (PivotUtil.isButtonIconRefesh(prop, oldProp, newProp)) {
                            if (this.showGroupingBar && this.groupingBarModule) {
                                this.axisFieldModule.render();
                            }
                            if (this.showFieldList && this.pivotFieldListModule) {
                                const rows = PivotUtil.cloneFieldSettings(this.dataSourceSettings.rows);
                                const columns = PivotUtil.cloneFieldSettings(this.dataSourceSettings.columns);
                                const values = PivotUtil.cloneFieldSettings(this.dataSourceSettings.values);
                                const filters = PivotUtil.cloneFieldSettings(this.dataSourceSettings.filters);
                                this.pivotFieldListModule.setProperties({ dataSourceSettings: { rows: rows, columns: columns,
                                        values: values, filters: filters } }, true);
                                this.pivotFieldListModule.axisFieldModule.render();
                                if (this.pivotFieldListModule.treeViewModule.fieldTable && !this.isAdaptive) {
                                    this.pivotFieldListModule.notify(treeViewUpdate, {});
                                }
                            }
                        }
                        else {
                            this.remoteData = [];
                            if (this.dataType === 'pivot' && this.dataSourceSettings.url && this.dataSourceSettings.url !== '' &&
                                ('type' in newProp.dataSourceSettings || 'url' in newProp.dataSourceSettings)) {
                                this.engineModule.fieldList = null;
                                this.loadData();
                            }
                            else {
                                if (newProp.dataSourceSettings && ((this.dataType === 'pivot' && 'dataSource' in newProp.dataSourceSettings) ||
                                    (this.dataType === 'olap' && 'url' in newProp.dataSourceSettings))) {
                                    if (!this.isStaticRefresh) {
                                        if (this.dataType === 'pivot') {
                                            this.engineModule.fieldList = null;
                                            this.engineModule.isEmptyData = true;
                                            this.engineModule.data = [];
                                        }
                                        else if (this.dataType === 'olap') {
                                            this.olapEngineModule.fieldList = {};
                                            this.olapEngineModule.fieldListData = undefined;
                                            this.olapEngineModule.isEmptyData = true;
                                        }
                                        this.pivotValues = [];
                                    }
                                }
                                this.notify(initialLoad, {});
                            }
                        }
                    }
                    break;
                case 'height':
                case 'width':
                    this.layoutRefresh();
                    break;
                case 'pivotValues':
                case 'displayOption':
                    if (!this.showToolbar && newProp.displayOption && Object.keys(newProp.displayOption).length === 1 &&
                        newProp.displayOption.view) {
                        this.currentView = (newProp.displayOption.view === 'Both' ?
                            this.displayOption.primary : newProp.displayOption.view);
                        if (this.showGroupingBar || this.showFieldList) {
                            if (this.showFieldList && this.pivotFieldListModule) {
                                this.pivotFieldListModule.destroyEngine = true;
                                this.pivotFieldListModule.destroy();
                                if (select('#' + this.element.id + '_PivotFieldList', this.element) !== null) {
                                    remove(select('#' + this.element.id + '_PivotFieldList', this.element));
                                }
                                this.pivotFieldListModule.destroyEngine = false;
                            }
                            /**
                             * Below lines are affected the grouping bar render between table and chart.
                             * In "Init subcomponent" function, grouping bar rendered properly for table and chart view.
                             * So, The below lines are commanded out.
                             */
                            // if (this.showGroupingBar && this.groupingBarModule) {
                            //     this.groupingBarModule.destroy();
                            // }
                            this.notify(initSubComponent, this);
                        }
                        if (!this.grid && newProp.displayOption.view !== 'Chart') {
                            this.renderEmptyGrid();
                            if (newProp.displayOption.view === 'Table') {
                                if (this.pivotChartModule) {
                                    this.destroyEngine = true;
                                    this.pivotChartModule.destroy();
                                    this.destroyEngine = false;
                                    this.chart = undefined;
                                    this.pivotChartModule = undefined;
                                }
                            }
                        }
                        else if (!this.pivotChartModule && this.displayOption.view !== 'Table') {
                            if (this.grid) {
                                this.grid.destroy();
                                this.grid = undefined;
                            }
                            this.pivotChartModule = new PivotChart();
                        }
                    }
                    else if (this.showToolbar && !isNullOrUndefined(newProp.displayOption) && newProp.displayOption.view) {
                        this.currentView = (newProp.displayOption.view === 'Both' ?
                            this.displayOption.primary : newProp.displayOption.view);
                    }
                    // eslint-disable-next-line no-case-declarations, @typescript-eslint/no-explicit-any
                    const engine = this.dataType === 'pivot' ? this.engineModule : this.olapEngineModule;
                    if (!isNullOrUndefined(engine.fieldList) || !isNullOrUndefined(engine.pivotValues)) {
                        this.notify(dataReady, {});
                    }
                    break;
                case 'gridSettings':
                    this.lastGridSettings = newProp.gridSettings;
                    this.isCellBoxMultiSelection = this.gridSettings.allowSelection &&
                        this.gridSettings.selectionSettings.cellSelectionMode === 'Box' &&
                        this.gridSettings.selectionSettings.mode === 'Cell' && this.gridSettings.selectionSettings.type === 'Multiple';
                    if (this.allowGrouping && this.groupingModule && !this.isCellBoxMultiSelection) {
                        this.setProperties({ gridSettings: { allowSelection: true, selectionSettings: { cellSelectionMode: 'Box', mode: 'Cell', type: 'Multiple' } } }, true);
                        this.isCellBoxMultiSelection = true;
                    }
                    this.renderModule.updateGridSettings();
                    break;
                case 'chartSettings':
                    if (this.showGroupingBar &&
                        this.groupingBarModule &&
                        (Object.keys(newProp.chartSettings).indexOf('enableMultipleAxis') !== -1 ||
                            (newProp.chartSettings.chartSeries && Object.keys(newProp.chartSettings.chartSeries).indexOf('type') !== -1))) {
                        this.groupingBarModule.renderLayout();
                    }
                    if (isNullOrUndefined(this.pivotChartModule) && this.displayOption.view !== 'Table') {
                        this.pivotChartModule = new PivotChart();
                    }
                    // eslint-disable-next-line no-case-declarations, @typescript-eslint/no-explicit-any
                    const engineModule = this.dataType === 'pivot' ? this.engineModule : this.olapEngineModule;
                    if (!isNullOrUndefined(this.pivotChartModule) && !isNullOrUndefined(engineModule.pivotValues)) {
                        this.pivotChartModule.loadChart(this, this.chartSettings);
                    }
                    if (!isNullOrUndefined(engineModule.pivotValues) && !isNullOrUndefined(engineModule.fieldList)) {
                        this.notify(uiUpdate, this);
                    }
                    break;
                case 'locale':
                case 'currencyCode':
                case 'enableRtl':
                    if (this.tooltip) {
                        this.tooltip.destroy();
                    }
                    if (this.dataSourceSettings.groupSettings && this.dataSourceSettings.groupSettings.length > 0 && this.clonedDataSet) {
                        const dataSet = PivotUtil.getClonedData(this.clonedDataSet);
                        this.setProperties({ dataSourceSettings: { dataSource: dataSet } }, true);
                    }
                    super.refresh();
                    this.updateClass();
                    break;
                case 'enableValueSorting':
                    this.enableValueSorting = newProp.enableValueSorting;
                    this.updateDataSource();
                    break;
                case 'showGroupingBar':
                    if (this.element.querySelector('.e-grouping-bar')) {
                        this.element.querySelector('.e-grouping-bar').remove();
                    }
                    else if (this.groupingBarModule) {
                        this.groupingBarModule.renderLayout();
                    }
                    if (isNullOrUndefined(newProp.showFieldList)) {
                        this.renderPivotGrid();
                    }
                    break;
                case 'showFieldList':
                    this.initialLoad();
                    break;
                case 'groupingBarSettings':
                    if (this.showGroupingBar && this.groupingBarModule) {
                        if (newProp.groupingBarSettings && Object.keys(newProp.groupingBarSettings).indexOf('showFieldsPanel') > -1) {
                            this.groupingBarModule.RefreshFieldsPanel();
                            this.layoutRefresh();
                        }
                        else {
                            this.axisFieldModule.render();
                        }
                    }
                    break;
                case 'showValuesButton':
                    if (this.showGroupingBar && this.groupingBarModule && this.axisFieldModule) {
                        this.axisFieldModule.render();
                    }
                    if (this.showFieldList && this.pivotFieldListModule && this.pivotFieldListModule.axisFieldModule) {
                        this.pivotFieldListModule.setProperties({ showValuesButton: newProp.showValuesButton }, true);
                        this.pivotFieldListModule.axisFieldModule.render();
                    }
                    break;
                case 'showTooltip':
                    this.renderToolTip();
                    break;
                case 'toolbar':
                    if (this.toolbarModule) {
                        this.toolbarModule.refreshToolbar();
                    }
                    break;
                case 'chartTypes':
                    if (this.toolbarModule) {
                        this.toolbarModule.createChartMenu();
                    }
                    break;
                case 'aggregateTypes':
                    if (this.showGroupingBar && this.groupingBarModule) {
                        if (this.axisFieldModule) {
                            this.axisFieldModule.render();
                        }
                    }
                    if (this.showFieldList && this.pivotFieldListModule && this.pivotFieldListModule.axisFieldModule) {
                        this.pivotFieldListModule.setProperties({ aggregateTypes: newProp.aggregateTypes }, true);
                        this.pivotFieldListModule.axisFieldModule.render();
                    }
                    break;
                case 'enableFieldSearching':
                    if (this.pivotFieldListModule) {
                        this.pivotFieldListModule.enableFieldSearching = this.enableFieldSearching;
                    }
                    break;
                case 'pageSettings':
                    if (!this.enableVirtualization) {
                        this.engineModule.pageSettings = this.pageSettings;
                        this.refreshPageData();
                    }
                    break;
                case 'pagerSettings':
                case 'enablePaging':
                    this.notify(initPivotPager, this);
                    break;
                case 'cellTemplate':
                    this.cellTemplateFn = this.templateParser(this.cellTemplate);
                    isRequireRefresh = true;
                    break;
                case 'tooltipTemplate':
                    this.tooltipTemplateFn = this.templateParser(this.tooltipTemplate);
                    isRequireRefresh = true;
                    break;
            }
        }
        if (isRequireRefresh && this.grid) {
            this.grid.refreshColumns();
        }
    }
    /**
     * Method to parse the template string.
     *
     * @private
     */
    templateParser(template) {
        if (template) {
            try {
                if (typeof template !== 'function' && document.querySelectorAll(template).length) {
                    return compile(document.querySelector(template).innerHTML.trim());
                }
                else {
                    return compile(template);
                }
            }
            catch (error) {
                return compile(template);
            }
        }
        return undefined;
    }
    /**
     * Method to get the cell template.
     *
     * @private
     */
    getCellTemplate() {
        return this.cellTemplateFn;
    }
    /**
     * @hidden
     */
    appendHtml(node, innerHtml) {
        const tempElement = document.createElement('div');
        tempElement.innerHTML = innerHtml;
        if (!isNullOrUndefined(tempElement.firstChild)) {
            node.appendChild(tempElement.firstChild);
        }
        return node;
    }
    /**
     * Render the UI section of PivotView.
     *
     * @returns {void}
     * @hidden
     */
    renderPivotGrid() {
        this.clearTemplate();
        if (this.pivotChartModule) {
            this.pivotChartModule.engineModule = this.engineModule;
            this.pivotChartModule.loadChart(this, this.chartSettings);
            if (this.enableRtl && this.chart && document.body.getAttribute('dir') !== 'rtl') {
                addClass([this.chart.element], PIVOTCHART_LTR);
            }
        }
        if (this.showFieldList || this.showGroupingBar || this.allowNumberFormatting || this.allowCalculatedField ||
            this.toolbar || this.allowGrouping || this.gridSettings.contextMenuItems) {
            this.notify(uiUpdate, this);
            if (this.pivotFieldListModule && this.allowDeferLayoutUpdate) {
                this.pivotFieldListModule.clonedDataSource = extend({}, this.dataSourceSettings, null, true);
            }
        }
        if (this.enableVirtualization) {
            this.virtualscrollModule = new VirtualScroll$1(this);
        }
        if (this.allowDrillThrough || this.editSettings.allowEditing) {
            this.drillThroughModule = new DrillThrough(this);
        }
        if (this.enablePaging) {
            this.notify(initPivotPager, this);
        }
        if (this.displayOption.view !== 'Chart') {
            if (this.hyperlinkSettings) {
                this.isRowCellHyperlink = (this.hyperlinkSettings.showRowHeaderHyperlink ?
                    true : this.hyperlinkSettings.showHyperlink ? true : false);
                this.isColumnCellHyperlink = (this.hyperlinkSettings.showColumnHeaderHyperlink ?
                    true : this.hyperlinkSettings.showHyperlink ? true : false);
                this.isValueCellHyperlink = (this.hyperlinkSettings.showValueCellHyperlink ?
                    true : this.hyperlinkSettings.showHyperlink ? true : false);
                this.isSummaryCellHyperlink = (this.hyperlinkSettings.showSummaryCellHyperlink ?
                    true : this.hyperlinkSettings.showHyperlink ? true : false);
                this.applyHyperlinkSettings();
            }
            this.renderModule = this.renderModule ? this.renderModule : new Render(this);
            this.renderModule.render(true);
        }
        else if (this.grid) {
            remove(this.grid.element);
        }
        if (this.allowConditionalFormatting) {
            this.applyFormatting(this.pivotValues);
        }
        if (this.showToolbar) {
            if (this.displayOption.view === 'Both' && this.chart && this.grid) {
                if (this.showGroupingBar && this.groupingBarModule && this.element.querySelector('.' + GROUPING_BAR_CLASS)) {
                    this.groupingBarModule.refreshUI();
                }
                if (this.toolbarModule && this.toolbarModule.toolbar) {
                    this.toolbarModule.toolbar.width = this.getGridWidthAsNumber() - 2;
                }
                if (this.chartSettings.enableScrollOnMultiAxis && this.chartSettings.enableMultipleAxis) {
                    this.element.querySelector('.' + PIVOTCHART).style.width = formatUnit(this.getGridWidthAsNumber());
                }
                this.chart.width = formatUnit(this.getGridWidthAsNumber());
                if (this.currentView === 'Table') {
                    this.grid.element.style.display = '';
                    this.chart.element.style.display = 'none';
                    if (this.chartSettings.enableMultipleAxis && this.chartSettings.enableScrollOnMultiAxis) {
                        this.element.querySelector('.e-pivotchart').style.display = 'none';
                    }
                }
                else {
                    this.grid.element.style.display = 'none';
                    this.chart.element.style.display = '';
                    if (this.chartSettings.enableMultipleAxis && this.chartSettings.enableScrollOnMultiAxis) {
                        this.element.querySelector('.e-pivotchart').style.display = '';
                    }
                }
            }
        }
        if (this.toolbarModule) {
            if (this.showFieldList && select('#' + this.element.id + '_PivotFieldList', this.element)) {
                if (this.toolbar && this.toolbar.indexOf('FieldList') !== -1) {
                    select('#' + this.element.id + '_PivotFieldList', this.element).style.display = 'none';
                }
                else {
                    select('#' + this.element.id + '_PivotFieldList', this.element).style.top = this.element.querySelector('.' + GRID_TOOLBAR).offsetHeight.toString() + 'px';
                    select('#' + this.element.id + '_PivotFieldList', this.element).style.position = 'relative';
                }
            }
            if (this.toolbar && this.toolbar.indexOf('FieldList') !== -1 &&
                this.showToolbar && this.element.querySelector('.e-toggle-field-list')) {
                this.element.querySelector('.e-toggle-field-list').style.display = 'none';
            }
            if (this.toolbarModule && this.toolbarModule.action !== 'New' && this.toolbarModule.action !== 'Load'
                && this.toolbarModule.action !== 'Remove') {
                this.isModified = true;
            }
            if (!this.isInitialRendering) {
                this.isModified = false;
                this.isInitialRendering = !this.isInitialRendering;
            }
            this.toolbarModule.action = '';
        }
    }
    /**
     * @hidden
     */
    showWaitingPopup() {
        if (this.grid && this.grid.element && !this.spinnerTemplate && this.currentView === 'Table') {
            showSpinner(this.grid.element);
        }
        else {
            showSpinner(this.element);
        }
    }
    /**
     * @hidden
     */
    hideWaitingPopup() {
        if (this.grid && this.grid.element && !this.spinnerTemplate && this.currentView === 'Table') {
            hideSpinner(this.grid.element);
        }
        else {
            hideSpinner(this.element);
        }
    }
    /**
     * Updates the PivotEngine using dataSource from Pivot View component.
     *
     * @function updateDataSource
     * @returns {void}
     * @hidden
     */
    updateDataSource() {
        this.showWaitingPopup();
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const pivot = this;
        //setTimeout(() => {
        const isSorted = Object.keys(pivot.lastSortInfo).length > 0 ? true : false;
        const isFiltered = Object.keys(pivot.lastFilterInfo).length > 0 ? true : false;
        const isAggChange = Object.keys(pivot.lastAggregationInfo).length > 0 ? true : false;
        const isCalcChange = Object.keys(pivot.lastCalcFieldInfo).length > 0 ? true : false;
        const args = {
            dataSourceSettings: PivotUtil.getClonedDataSourceSettings(pivot.dataSourceSettings)
        };
        pivot.trigger(enginePopulating, args, (observedArgs) => {
            if (!((pivot.enableVirtualization || pivot.enablePaging) && (isSorted || isFiltered || isAggChange || isCalcChange))) {
                PivotUtil.updateDataSourceSettings(pivot, observedArgs.dataSourceSettings);
            }
            pivot.updatePageSettings(false);
            if (pivot.dataType === 'pivot' && (pivot.enableVirtualization || pivot.enablePaging) && (isSorted || isFiltered || isAggChange || isCalcChange)) {
                if (isSorted) {
                    pivot.setProperties({ dataSourceSettings: { valueSortSettings: { headerText: '' } } }, true);
                    if (this.dataSourceSettings.mode === 'Server') {
                        pivot.getEngine('onSort', null, pivot.lastSortInfo, null, null, null, null);
                    }
                    else {
                        pivot.engineModule.onSort(pivot.lastSortInfo);
                    }
                    pivot.lastSortInfo = {};
                }
                if (isAggChange) {
                    if (this.dataSourceSettings.mode === 'Server') {
                        pivot.getEngine('onAggregation', null, null, pivot.lastAggregationInfo, null, null, null);
                    }
                    else {
                        pivot.engineModule.onAggregation(pivot.lastAggregationInfo);
                    }
                    pivot.lastAggregationInfo = {};
                }
                if (isCalcChange) {
                    if (this.dataSourceSettings.mode === 'Server') {
                        pivot.getEngine('onCalcOperation', null, null, null, pivot.lastCalcFieldInfo, null, null);
                    }
                    else {
                        pivot.engineModule.onCalcOperation(pivot.lastCalcFieldInfo, pivot.dataSourceSettings);
                    }
                    pivot.lastCalcFieldInfo = {};
                }
                if (isFiltered) {
                    if (this.dataSourceSettings.mode === 'Server') {
                        pivot.getEngine('onFilter', null, null, null, null, pivot.lastFilterInfo, null);
                    }
                    else {
                        pivot.engineModule.onFilter(pivot.lastFilterInfo, pivot.dataSourceSettings);
                    }
                    pivot.lastFilterInfo = {};
                }
                pivot.allowServerDataBinding = false;
                pivot.setProperties({ pivotValues: pivot.engineModule.pivotValues }, true);
                /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                delete pivot.bulkChanges.pivotValues;
                pivot.allowServerDataBinding = true;
                if (pivot.dataSourceSettings.mode !== 'Server') {
                    pivot.enginePopulatedEventMethod('updateDataSource');
                }
            }
            else {
                if (pivot.dataType === 'olap') {
                    const customProperties = {
                        mode: '',
                        savedFieldList: pivot.olapEngineModule.fieldList,
                        savedFieldListData: pivot.olapEngineModule.fieldListData,
                        pageSettings: pivot.pageSettings,
                        enableValueSorting: pivot.enableValueSorting,
                        isDrillThrough: (pivot.allowDrillThrough || pivot.editSettings.allowEditing),
                        localeObj: pivot.localeObj,
                        enableVirtualization: this.enableVirtualization
                    };
                    if (isCalcChange || isSorted) {
                        pivot.olapEngineModule.savedFieldList = pivot.olapEngineModule.fieldList;
                        pivot.olapEngineModule.savedFieldListData = pivot.olapEngineModule.fieldListData;
                        if (isCalcChange) {
                            pivot.olapEngineModule.updateCalcFields(pivot.dataSourceSettings, pivot.lastCalcFieldInfo);
                            pivot.lastCalcFieldInfo = {};
                        }
                        else {
                            pivot.olapEngineModule.onSort(pivot.dataSourceSettings);
                            pivot.lastSortInfo = {};
                        }
                    }
                    else {
                        pivot.olapEngineModule.renderEngine(pivot.dataSourceSettings, customProperties, pivot.onHeadersSort
                            ? pivot.getHeaderSortInfo.bind(pivot) : undefined);
                    }
                    pivot.allowServerDataBinding = false;
                    pivot.setProperties({ pivotValues: pivot.olapEngineModule.pivotValues }, true);
                    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                    delete pivot.bulkChanges.pivotValues;
                    pivot.allowServerDataBinding = true;
                    pivot.enginePopulatedEventMethod('updateDataSource');
                }
                else {
                    const customProperties = {
                        mode: '',
                        savedFieldList: pivot.engineModule.fieldList,
                        pageSettings: pivot.pageSettings,
                        enableValueSorting: pivot.enableValueSorting,
                        isDrillThrough: (pivot.allowDrillThrough || pivot.editSettings.allowEditing),
                        localeObj: pivot.localeObj,
                        fieldsType: pivot.fieldsType,
                        clonedReport: pivot.clonedReport,
                        globalize: pivot.globalize,
                        currenyCode: pivot.currencyCode,
                        enablePaging: this.enablePaging,
                        enableVirtualization: this.enableVirtualization,
                        allowDataCompression: this.allowDataCompression,
                        enableHtmlSanitizer: this.enableHtmlSanitizer
                    };
                    /* eslint-enable @typescript-eslint/indent */
                    if (pivot.dataSourceSettings.mode === 'Server') {
                        if (isSorted) {
                            pivot.getEngine('onSort', null, pivot.lastSortInfo, null, null, null, null);
                        }
                        else if (isAggChange) {
                            pivot.getEngine('onAggregation', null, null, pivot.lastAggregationInfo, null, null, null);
                        }
                        else if (isCalcChange) {
                            pivot.getEngine('onCalcOperation', null, null, null, pivot.lastCalcFieldInfo, null, null);
                        }
                        else if (isFiltered) {
                            pivot.getEngine('onFilter', null, null, null, null, pivot.lastFilterInfo, null);
                        }
                        else {
                            pivot.getEngine('onDrop', null, null, null, null, null, null);
                        }
                    }
                    else {
                        if (isSorted && pivot.dataSourceSettings.valueSortSettings.headerText !== '') {
                            pivot.setProperties({ dataSourceSettings: { valueSortSettings: { headerText: '' } } }, true);
                        }
                        pivot.engineModule.renderEngine(pivot.dataSourceSettings, customProperties, pivot.aggregateCellInfo ?
                            pivot.getValueCellInfo.bind(pivot) : undefined, pivot.onHeadersSort ? pivot.getHeaderSortInfo.bind(pivot)
                            : undefined);
                        pivot.allowServerDataBinding = false;
                        pivot.setProperties({ pivotValues: pivot.engineModule.pivotValues }, true);
                        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                        delete pivot.bulkChanges.pivotValues;
                        pivot.allowServerDataBinding = true;
                        pivot.enginePopulatedEventMethod('updateDataSource');
                    }
                    pivot.lastSortInfo = {};
                    pivot.lastAggregationInfo = {};
                    pivot.lastCalcFieldInfo = {};
                    pivot.lastFilterInfo = {};
                }
            }
        });
        //});
    }
    refreshPageData() {
        const args = {
            dataSourceSettings: PivotUtil.getClonedDataSourceSettings(this.dataSourceSettings)
        };
        this.actionBeginMethod();
        this.showWaitingPopup();
        this.trigger(enginePopulating, args);
        if (this.dataType === 'pivot') {
            if (this.dataSourceSettings.mode === 'Server') {
                this.getEngine('onPageChange', null, null, null, null, null, null);
            }
            else {
                this.engineModule.generateGridData(this.dataSourceSettings, true, this.engineModule.headerCollection);
            }
            this.setProperties({ pivotValues: this.engineModule.pivotValues }, true);
            this.enginePopulatedEventMethod('updateDataSource');
        }
        this.actionObj.actionName = this.getActionCompleteName();
        if (this.actionObj.actionName) {
            this.actionCompleteMethod();
        }
    }
    /**
     * Export the Pivot table data to an Excel file (.xlsx).
     *
     * @param  {ExcelExportProperties} excelExportProperties - Defines the export properties for customizing the table, such as custom columns, data source, and theme.
     * @param  {boolean} isMultipleExport - Specifies whether multiple exports are enabled.
     * @param  {workbook} workbook - Defines the Workbook if multiple exports are enabled.
     * @param  {boolean} isBlob - If set to true, the exported file will be returned as blob data.
     * @param  {boolean} isServerExport - Specifies whether server-side Excel export is enabled.
     * @returns {void}
     */
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any, max-len
    excelExport(excelExportProperties, isMultipleExport, workbook, isBlob, isServerExport) {
        if (isServerExport && this.dataSourceSettings.mode === 'Server') {
            this.getEngine('onExcelExport', null, null, null, null, null, null, null, null, excelExportProperties);
        }
        else {
            if ((this.enableVirtualization || this.enablePaging || this.allowEngineExport || (this.allowConditionalFormatting && this.dataSourceSettings.conditionalFormatSettings.length > 0)) && this.dataSourceSettings.mode !== 'Server') {
                this.excelExportModule.exportToExcel('Excel', excelExportProperties, isBlob);
            }
            else {
                this.exportType = 'Excel';
                this.grid.excelExport(excelExportProperties, isMultipleExport, workbook, isBlob);
            }
            this.actionObj.actionName = this.getActionCompleteName();
            const actionInfo = {
                exportInfo: { type: this.exportType, info: excelExportProperties }
            };
            this.actionObj.actionInfo = actionInfo;
            if (this.actionObj.actionName) {
                this.actionCompleteMethod();
            }
        }
    }
    /**
     * Export the Pivot table data to a CSV file (.csv).
     *
     * @param  {ExcelExportProperties} excelExportProperties - Defines the export properties for customizing the table, such as custom columns, data source, and theme.
     * @param  {boolean} isMultipleExport - Specifies whether multiple exports are enabled.
     * @param  {workbook} workbook - Defines the Workbook if multiple exports are enabled.
     * @param  {boolean} isBlob - If set to true, the export will be returned as blob data.
     * @param  {boolean} isServerExport - Specifies whether server-side CSV export is enabled.
     * @returns {void}
     */
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any, max-len
    csvExport(excelExportProperties, isMultipleExport, workbook, isBlob, isServerExport) {
        if (isServerExport && this.dataSourceSettings.mode === 'Server') {
            this.getEngine('onCsvExport', null, null, null, null, null, null, null, null, excelExportProperties);
        }
        else {
            if ((this.enableVirtualization || this.enablePaging || this.allowEngineExport || (this.allowConditionalFormatting && this.dataSourceSettings.conditionalFormatSettings.length > 0)) && this.dataSourceSettings.mode !== 'Server') {
                this.excelExportModule.exportToExcel('CSV', excelExportProperties, isBlob);
            }
            else {
                this.exportType = 'CSV';
                this.grid.csvExport(excelExportProperties, isMultipleExport, workbook, isBlob);
            }
            this.actionObj.actionName = this.getActionCompleteName();
            const actionInfo = {
                exportInfo: { type: this.exportType, info: excelExportProperties }
            };
            this.actionObj.actionInfo = actionInfo;
            if (this.actionObj.actionName) {
                this.actionCompleteMethod();
            }
        }
    }
    /**
     *
     * Export pivot table data to PDF document.
     *
     * @param  {PdfExportProperties} pdfExportProperties - Defines the export properties of the Grid.
     * @param  {boolean} isMultipleExport - Define to enable multiple export.
     * @param  {Object} pdfDoc - Defined the PDF document if multiple export is enabled.
     * @param  {boolean} isBlob - If 'isBlob' set to true, then it will be returned as blob data.
     * @returns {Promise<any>}
     */
    gridPdfExport(pdfExportProperties, isMultipleExport, pdfDoc, isBlob) {
        const args = {
            pdfExportProperties: pdfExportProperties, isMultipleExport: isMultipleExport, isBlob: isBlob, pdfDoc: pdfDoc, currentExportView: 'Table',
            pdfMargins: {}
        };
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        let pdfDocument = null;
        this.trigger(beforeExport, args);
        if (this.pdfExportModule) {
            this.pdfExportModule.exportProperties = args;
        }
        if ((this.enableVirtualization || this.enablePaging || this.allowEngineExport || (this.allowConditionalFormatting && this.dataSourceSettings.conditionalFormatSettings.length > 0) || args.height || args.width || Object.keys(args.pdfMargins).length > 0) && this.dataSourceSettings.mode !== 'Server') {
            pdfDocument = this.pdfExportModule.exportToPDF(args.pdfExportProperties, args.isMultipleExport, args.pdfDoc, args.isBlob);
        }
        else {
            pdfDocument = this.grid.pdfExport(args.pdfExportProperties, args.isMultipleExport, args.pdfDoc, args.isBlob);
        }
        this.actionObj.actionName = this.getActionCompleteName();
        const actionInfo = {
            exportInfo: { type: 'PDF', info: pdfExportProperties }
        };
        this.actionObj.actionInfo = actionInfo;
        if (this.actionObj.actionName) {
            this.actionCompleteMethod();
        }
        return pdfDocument;
    }
    /**
     * Method allow to export the pivot chart as PDF and image formats like PNG, JPEG, and SVG.
     *
     * @param {ExportType} type - Defines the export type.
     * @param {PdfExportProperties} pdfExportProperties - Allows to define the export properties for the chart.
     * @param {boolean} isMultipleExport - Allows to export multiple tables and charts into a single PDF document.
     * @param {Object} pdfDoc - Allows the export of an external PDF document along with current PDF document.
     * @param {boolean} isBlob - Allows the PDF document to be saved as blob data.
     * @returns {Promise<any>}
     */
    chartExport(type, pdfExportProperties, isMultipleExport, 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    pdfDoc, isBlob) {
        const args = {
            pdfExportProperties: pdfExportProperties, isMultipleExport: isMultipleExport, isBlob: isBlob, pdfDoc: pdfDoc,
            type: type, currentExportView: 'Chart', pdfMargins: {}
        };
        this.trigger(beforeExport, args);
        this.chartExportModule.exportProperties = args;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        let pdfDocument;
        const fileName = args.fileName ? args.fileName : (!isNullOrUndefined(pdfExportProperties) &&
            !isNullOrUndefined(pdfExportProperties.fileName)) ? pdfExportProperties.fileName : 'default';
        if (type === 'PDF') {
            pdfDocument = this.chartExportModule.pdfChartExport(args.pdfExportProperties, args.pdfDoc, args.isMultipleExport, args.isBlob);
        }
        else {
            const orientation = (args.orientation === 0 || args.orientation) ? args.orientation :
                (!isNullOrUndefined(pdfExportProperties) && !isNullOrUndefined(pdfExportProperties.pageOrientation)) ? (pdfExportProperties.pageOrientation === 'Landscape' ?
                    PdfPageOrientation.Landscape : PdfPageOrientation.Portrait) : PdfPageOrientation.Landscape;
            pdfDocument = this.chart.exportModule.export(args.type, fileName, orientation, null);
        }
        this.actionObj.actionName = this.getActionCompleteName();
        const actionInfo = {
            exportInfo: { type: type, info: fileName }
        };
        this.actionObj.actionInfo = actionInfo;
        if (this.actionObj.actionName) {
            this.actionCompleteMethod();
        }
        return pdfDocument;
    }
    /**
     * Method allow to export both pivot table and pivot chart in a same PDF document.
     *
     * @param {PdfExportProperties} pdfExportProperties - Allows to define the export properties for the table and chart.
     * @param {boolean} isMultipleExport - Allows to export multiple tables and charts into a single PDF document.
     * @param {Object} pdfDoc - Allows the export of an external PDF document along with current PDF document.
     * @param {boolean} isBlob - Allows the PDF document to be saved as blob data.
     * @param {boolean} exportBothTableAndChart - When the `view` property inside the `displayOption` is set to **Both**, both table and chart data can be exported into a single PDF document.
     * @returns {Promise<any>}
     */
    /* eslint-disable @typescript-eslint/no-explicit-any */
    pdfExport(pdfExportProperties, isMultipleExport, pdfDoc, isBlob, exportBothTableAndChart) {
        let pdfDocument = null;
        return new Promise((resolve) => {
            if (exportBothTableAndChart && this.displayOption.view === 'Both') {
                if (this.displayOption.primary === 'Chart') {
                    const chartAndTableExportDocument = this.chartExport('PDF', pdfExportProperties, true, pdfDoc, false);
                    chartAndTableExportDocument.then((pdfData) => {
                        pdfDocument = this.gridPdfExport(pdfExportProperties, isMultipleExport, pdfData, isBlob);
                        resolve(pdfDocument);
                    });
                }
                else {
                    const tableAndChartExportDocument = this.gridPdfExport(pdfExportProperties, true, pdfDoc, false);
                    tableAndChartExportDocument.then((pdfData) => {
                        pdfDocument = this.chartExport('PDF', pdfExportProperties, isMultipleExport, pdfData, isBlob);
                        resolve(pdfDocument);
                    });
                }
            }
            else {
                const tableExportDocumnt = this.gridPdfExport(pdfExportProperties, isMultipleExport, pdfDoc, isBlob);
                /* eslint-enable @typescript-eslint/no-explicit-any */
                resolve(tableExportDocumnt);
            }
        });
    }
    /**
     * Print method for the chart.
     *
     * @returns {void}
     */
    printChart() {
        if (this.chart) {
            this.chart.print();
        }
    }
    /** @hidden */
    onDrill(target, chartDrillInfo) {
        let delimiter = (this.dataSourceSettings.drilledMembers[0] && this.dataSourceSettings.drilledMembers[0].delimiter) ?
            this.dataSourceSettings.drilledMembers[0].delimiter : '**';
        let fieldName = '';
        let axis = '';
        let action = '';
        if (chartDrillInfo) {
            fieldName = chartDrillInfo.fieldName;
            axis = chartDrillInfo.cell.axis;
            action = chartDrillInfo.isDrilled ? 'up' : 'down';
        }
        else {
            axis = target.parentElement.classList.contains(ROWSHEADER) ? 'row' : 'column';
            fieldName = axis === 'row' ? closest(target, 'td').getAttribute('fieldname') : closest(target, 'th').getAttribute('fieldname');
            action = target.classList.contains(COLLAPSE) ? 'up' : 'down';
        }
        if (this.dataType === 'pivot') {
            const clonedDrillMembers = PivotUtil.cloneDrillMemberSettings(this.dataSourceSettings.drilledMembers);
            const colIndex = axis === 'row' ? Number(closest(target, 'td').getAttribute('data-colindex')) : Number(closest(target, 'th').getAttribute('data-colindex'));
            const rowIndex = axis === 'row' ? Number(closest(target, 'td').getAttribute('index')) : Number(closest(target, 'th').getAttribute('index'));
            const currentCell = chartDrillInfo ? chartDrillInfo.cell :
                this.engineModule.pivotValues[rowIndex][colIndex];
            let memberName = currentCell.valueSort.levelName.
                split(this.engineModule.valueSortSettings.headerDelimiter).join(delimiter);
            let fieldAvail = false;
            if (this.dataSourceSettings.drilledMembers.length === 0) {
                this.setProperties({ dataSourceSettings: { drilledMembers: [{ name: fieldName, items: [memberName],
                                delimiter: delimiter }] } }, true);
            }
            else {
                const drillMembers = PivotUtil.cloneDrillMemberSettings(this.dataSourceSettings.drilledMembers);
                for (let fCnt = 0; fCnt < drillMembers.length; fCnt++) {
                    const field = drillMembers[fCnt];
                    memberName = memberName.split(delimiter).join(field.delimiter ? field.delimiter : delimiter);
                    delimiter = field.delimiter = field.delimiter ? field.delimiter : delimiter;
                    if (field.name === fieldName) {
                        fieldAvail = true;
                        const memIndex = field.items.indexOf(memberName);
                        if (memIndex > -1) {
                            field.items.splice(memIndex, 1);
                        }
                        else {
                            field.items.push(memberName);
                        }
                    }
                    else {
                        continue;
                    }
                }
                this.setProperties({ dataSourceSettings: { drilledMembers: drillMembers } }, true);
                if (!fieldAvail) {
                    this.dataSourceSettings.drilledMembers.push({ name: fieldName, items: [memberName], delimiter: delimiter });
                }
            }
            this.showWaitingPopup();
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const pivot = this;
            //setTimeout(() => {
            const drilledItem = {
                fieldName: fieldName, memberName: memberName, delimiter: delimiter,
                axis: axis,
                action: action,
                currentCell: currentCell
            };
            const drillArgs = {
                drillInfo: drilledItem,
                pivotview: pivot,
                cancel: false
            };
            pivot.trigger(drill, drillArgs, (observedArgs) => {
                if (!observedArgs.cancel) {
                    const args = {
                        dataSourceSettings: PivotUtil.getClonedDataSourceSettings(this.dataSourceSettings)
                    };
                    pivot.trigger(enginePopulating, args);
                    pivot.setProperties({ dataSourceSettings: args.dataSourceSettings }, true);
                    if (pivot.enableVirtualization || pivot.enablePaging) {
                        if (this.dataSourceSettings.mode === 'Server') {
                            this.getEngine('onDrill', drilledItem, null, null, null, null, null);
                        }
                        else {
                            pivot.engineModule.drilledMembers = pivot.dataSourceSettings.drilledMembers;
                            pivot.engineModule.onDrill(drilledItem);
                        }
                    }
                    else if (this.dataSourceSettings.mode === 'Server') {
                        this.getEngine('onDrill', drilledItem, null, null, null, null, null);
                    }
                    else {
                        pivot.engineModule.generateGridData(pivot.dataSourceSettings, true);
                    }
                    pivot.allowServerDataBinding = false;
                    pivot.setProperties({ pivotValues: pivot.engineModule.pivotValues }, true);
                    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                    delete pivot.bulkChanges.pivotValues;
                    pivot.allowServerDataBinding = true;
                    const eventArgs = {
                        dataSourceSettings: PivotUtil.getClonedDataSourceSettings(args.dataSourceSettings),
                        pivotValues: this.pivotValues
                    };
                    this.trigger(enginePopulated, eventArgs);
                    pivot.engineModule.pivotValues = eventArgs.pivotValues;
                    const actionInfo = {
                        drillInfo: drilledItem
                    };
                    this.actionObj.actionInfo = actionInfo;
                    pivot.renderPivotGrid();
                }
                else {
                    this.hideWaitingPopup();
                    this.setProperties({ dataSourceSettings: { drilledMembers: clonedDrillMembers } }, true);
                }
            });
        }
        else {
            this.onOlapDrill(fieldName, axis, action, delimiter, target, chartDrillInfo);
        }
    }
    onOlapDrill(fieldName, axis, action, delimiter, target, chartDrillInfo) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const pivot = this;
        const clonedDrillMembers = PivotUtil.cloneDrillMemberSettings(this.dataSourceSettings.drilledMembers);
        let currentCell;
        if (chartDrillInfo) {
            currentCell = chartDrillInfo.cell;
        }
        else {
            const colIndex = axis === 'row' ? Number(closest(target, 'td').getAttribute('data-colindex'))
                : Number(closest(target, 'th').getAttribute('data-colindex'));
            const rowIndex = axis === 'row' ? Number(closest(target, 'td').getAttribute('index')) : Number(closest(target, 'th').getAttribute('index'));
            currentCell = this.olapEngineModule.pivotValues[rowIndex][colIndex];
        }
        const tupInfo = axis === 'row' ? this.olapEngineModule.tupRowInfo[currentCell.ordinal] :
            this.olapEngineModule.tupColumnInfo[currentCell.ordinal];
        const drillInfo = {
            axis: axis,
            action: action,
            fieldName: fieldName,
            delimiter: '~~',
            memberName: tupInfo.uNameCollection,
            currentCell: currentCell
        };
        this.showWaitingPopup();
        const drillArgs = {
            drillInfo: drillInfo,
            pivotview: pivot,
            cancel: false
        };
        const isAttributeHierarchy = this.olapEngineModule.fieldList[drillInfo.fieldName]
            && this.olapEngineModule.fieldList[drillInfo.fieldName].isHierarchy;
        const fieldPos = tupInfo.drillInfo.map((item) => { return item.hierarchy; }).indexOf(currentCell.hierarchy.toString());
        let clonedMembers = PivotUtil.cloneDrillMemberSettings(this.dataSourceSettings.drilledMembers);
        if (drillInfo && drillInfo.action === 'down') {
            const fields = tupInfo.drillInfo.map((item) => { return item.uName; });
            let member = '';
            for (let pos = 0; pos <= fieldPos; pos++) {
                const field = fields[pos];
                const members = field.split('~~');
                member = member + (member !== '' ? '~~' : '') + members[members.length - 1];
            }
            const drillSets = this.olapEngineModule.getDrilledSets(drillInfo.memberName, currentCell, (this.olapEngineModule.fieldList[currentCell.hierarchy] &&
                !this.olapEngineModule.fieldList[currentCell.hierarchy].hasAllMember) ?
                currentCell.valueSort.levelName
                    .split(this.dataSourceSettings.valueSortSettings.headerDelimiter).length - 1
                : fieldPos, axis);
            const keys = Object.keys(drillSets);
            for (const key of keys) {
                const drillSet = drillSets[key];
                for (let i = 0, cnt = clonedMembers.length; i < cnt; i++) {
                    const drillMembers = clonedMembers[i];
                    let memberItem = drillSet;
                    if (drillMembers.delimiter) {
                        memberItem = memberItem.replace(/~~/g, drillMembers.delimiter);
                    }
                    const items = [];
                    for (let itemPos = 0; itemPos < drillMembers.items.length; itemPos++) {
                        if (drillMembers.items[itemPos].indexOf(memberItem) !== 0) {
                            items[items.length] = drillMembers.items[itemPos];
                        }
                    }
                    drillMembers.items = items;
                }
            }
            this.olapEngineModule.drilledSets[currentCell.actualText] = tupInfo.members[fieldPos];
            drillInfo.memberName = member;
            const drillItem = [];
            for (const field of clonedMembers) {
                if (field.name === drillInfo.fieldName) {
                    drillItem.push(field);
                }
            }
            if (drillItem.length > 0) {
                if (drillItem[0].delimiter) {
                    member = member.replace(/~~/g, drillItem[0].delimiter);
                }
                const index = PivotUtil.inArray(member, drillItem[0].items);
                if (index === -1) {
                    drillItem[0].items.push(member);
                }
                if (isAttributeHierarchy) {
                    let i = 0;
                    while (i < drillItem[0].items.length) {
                        if (drillItem[0].items[i] === member) {
                            drillItem[0].items.splice(i, 1);
                        }
                        else {
                            ++i;
                        }
                    }
                }
            }
            else if (!isAttributeHierarchy) {
                const drilledMember = { name: drillInfo.fieldName, items: [member], delimiter: '~~' };
                if (!clonedMembers) {
                    clonedMembers = [drilledMember];
                }
                else {
                    clonedMembers.push(drilledMember);
                }
            }
            drillArgs.drillInfo.memberName = member;
            this.setProperties({ dataSourceSettings: { drilledMembers: clonedMembers } }, true);
            pivot.trigger(drill, drillArgs, (observedArgs) => {
                if (!observedArgs.cancel) {
                    const args = {
                        dataSourceSettings: PivotUtil.getClonedDataSourceSettings(this.dataSourceSettings)
                    };
                    this.trigger(enginePopulating, args);
                    this.setProperties({ dataSourceSettings: args.dataSourceSettings }, true);
                    this.olapEngineModule.updateDrilledInfo(this.dataSourceSettings);
                    this.allowServerDataBinding = false;
                    this.setProperties({ pivotValues: this.olapEngineModule.pivotValues }, true);
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    delete this.bulkChanges.pivotValues;
                    this.allowServerDataBinding = true;
                    const eventArgs = {
                        dataSourceSettings: PivotUtil.getClonedDataSourceSettings(args.dataSourceSettings),
                        pivotValues: pivot.olapEngineModule.pivotValues
                    };
                    this.trigger(enginePopulated, eventArgs);
                    this.olapEngineModule.pivotValues = eventArgs.pivotValues;
                    this.renderPivotGrid();
                }
                else {
                    this.hideWaitingPopup();
                    this.setProperties({ dataSourceSettings: { drilledMembers: clonedDrillMembers } }, true);
                }
            });
        }
        else {
            delete this.olapEngineModule.drilledSets[currentCell.actualText];
            const drillSets = this.olapEngineModule.getDrilledSets(drillInfo.memberName, currentCell, fieldPos, axis);
            const keys = Object.keys(drillSets);
            const fields = tupInfo.drillInfo.map((item) => { return item.uName; });
            let member = '';
            for (let pos = 0; pos <= fieldPos; pos++) {
                const field = fields[pos];
                const members = field.split('~~');
                member = member + (member !== '' ? '~~' : '') + members[members.length - 1];
            }
            for (const key of keys) {
                const drillSet = drillSets[key];
                const drillItemCollection = [];
                for (let i = 0, cnt = clonedMembers.length; i < cnt; i++) {
                    const drillItem = clonedMembers[i];
                    let member = drillSet;
                    if (drillItem.name === drillInfo.fieldName) {
                        drillItemCollection.push(drillItem);
                    }
                    if (drillItem.delimiter) {
                        member = drillSet.replace(/~~/g, drillItem.delimiter);
                    }
                    if (!isAttributeHierarchy) {
                        const items = [];
                        for (let itemPos = 0; itemPos < drillItem.items.length; itemPos++) {
                            if (drillItem.items[itemPos].indexOf(member) !== 0) {
                                items[items.length] = drillItem.items[itemPos];
                            }
                        }
                        drillItem.items = items;
                    }
                }
                if (isAttributeHierarchy) {
                    if (drillItemCollection.length > 0) {
                        if (drillItemCollection[0].delimiter) {
                            member = member.replace(/~~/g, drillItemCollection[0].delimiter);
                        }
                        const index = PivotUtil.inArray(member, drillItemCollection[0].items);
                        if (index === -1) {
                            drillItemCollection[0].items.push(member);
                        }
                    }
                    else {
                        const drilledMember = { name: drillInfo.fieldName, items: [member], delimiter: '~~' };
                        if (!clonedMembers) {
                            clonedMembers = [drilledMember];
                        }
                        else {
                            clonedMembers.push(drilledMember);
                        }
                    }
                }
            }
            const drilledMembers = [];
            for (const fields of clonedMembers) {
                if (fields.items.length > 0) {
                    drilledMembers.push(fields);
                }
            }
            this.setProperties({ dataSourceSettings: { drilledMembers: clonedMembers } }, true);
            pivot.trigger(drill, drillArgs, (observedArgs) => {
                if (!observedArgs.cancel) {
                    const args = {
                        dataSourceSettings: PivotUtil.getClonedDataSourceSettings(this.dataSourceSettings)
                    };
                    this.trigger(enginePopulating, args);
                    this.setProperties({ dataSourceSettings: args.dataSourceSettings }, true);
                    this.setProperties({ dataSourceSettings: { drilledMembers: drilledMembers } }, true);
                    this.olapEngineModule.updateDrilledInfo(this.dataSourceSettings);
                    this.allowServerDataBinding = false;
                    this.setProperties({ pivotValues: this.olapEngineModule.pivotValues }, true);
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    delete this.bulkChanges.pivotValues;
                    this.allowServerDataBinding = true;
                    const eventArgs = {
                        dataSourceSettings: PivotUtil.getClonedDataSourceSettings(args.dataSourceSettings),
                        pivotValues: pivot.olapEngineModule.pivotValues
                    };
                    this.trigger(enginePopulated, eventArgs);
                    this.olapEngineModule.pivotValues = eventArgs.pivotValues;
                    this.renderPivotGrid();
                }
                else {
                    this.hideWaitingPopup();
                    this.setProperties({ dataSourceSettings: { drilledMembers: clonedDrillMembers } }, true);
                }
            });
        }
    }
    onContentReady() {
        this.isPopupClicked = false;
        if (this.showFieldList && this.pivotFieldListModule) {
            this.pivotFieldListModule.element.style.display = 'block';
            hideSpinner(this.pivotFieldListModule.fieldListSpinnerElement);
        }
        else if (this.fieldListSpinnerElement) {
            hideSpinner(this.fieldListSpinnerElement);
        }
        if (!this.isEmptyGrid) {
            if ((this.dataSourceSettings.mode === 'Server' && this.isServerWaitingPopup) || this.dataSourceSettings.mode === 'Local') {
                this.hideWaitingPopup();
            }
        }
        else {
            this.isEmptyGrid = false;
            this.notEmpty = true;
        }
        if (this.grid) {
            const engine = this.dataType === 'pivot' ? this.engineModule : this.olapEngineModule;
            if (this.enableVirtualization && engine) {
                if (this.element.querySelector('.' + MOVABLECONTENT_DIV) &&
                    !this.element.querySelector('.' + MOVABLECONTENT_DIV).querySelector('.' + VIRTUALTRACK_DIV)) {
                    this.virtualDiv = createElement('div', { className: VIRTUALTRACK_DIV });
                    this.element.querySelector('.' + MOVABLECONTENT_DIV).appendChild(this.virtualDiv);
                }
                if (this.element.querySelector('.' + MOVABLEHEADER_DIV) &&
                    !this.element.querySelector('.' + MOVABLEHEADER_DIV).querySelector('.' + VIRTUALTRACK_DIV)) {
                    this.virtualHeaderDiv = createElement('div', { className: VIRTUALTRACK_DIV });
                    this.element.querySelector('.' + MOVABLEHEADER_DIV).appendChild(this.virtualHeaderDiv);
                }
                else {
                    this.virtualHeaderDiv =
                        this.element.querySelector('.' + MOVABLEHEADER_DIV).querySelector('.' + VIRTUALTRACK_DIV);
                }
                const movableTable = this.element.querySelector('.' + MOVABLECONTENT_DIV).querySelector('.e-table');
                let vHeight = (this.gridSettings.rowHeight * engine.rowCount + 0.1 - movableTable.clientHeight);
                if (vHeight > this.scrollerBrowserLimit) {
                    this.verticalScrollScale = vHeight / this.scrollerBrowserLimit;
                    vHeight = this.scrollerBrowserLimit;
                }
                let vWidth = this.gridSettings.columnWidth * engine.columnCount;
                if (vWidth > this.scrollerBrowserLimit) {
                    this.horizontalScrollScale = vWidth / this.scrollerBrowserLimit;
                    vWidth = this.scrollerBrowserLimit;
                }
                setStyleAttribute(this.virtualDiv, {
                    height: (vHeight > 0.1 ? vHeight : 0.1) + 'px',
                    width: (vWidth > 0.1 ? vWidth : 0.1) + 'px'
                });
                setStyleAttribute(this.virtualHeaderDiv, {
                    height: 0, width: (vWidth > 0.1 ? vWidth : 0.1) + 'px'
                });
                const mCnt = this.element.querySelector('.' + MOVABLECONTENT_DIV);
                const fCnt = this.element.querySelector('.' + FROZENCONTENT_DIV);
                const mHdr = this.element.querySelector('.' + MOVABLEHEADER_DIV);
                if (this.isAdaptive) {
                    mCnt.parentElement.parentElement.querySelector('.' + MOVABLESCROLL_DIV).children[0].style.minHeight = '1px';
                    mCnt.parentElement.parentElement.querySelector('.' + MOVABLESCROLL_DIV).style.minHeight = '1px';
                }
                const ele = this.isAdaptive ? mCnt : mCnt.parentElement.parentElement.querySelector('.' + MOVABLESCROLL_DIV);
                const verOffset = (mCnt.parentElement.scrollTop > this.scrollerBrowserLimit) ?
                    mCnt.querySelector('.' + TABLE).style.transform.split(',')[1].trim() :
                    -(((mCnt.parentElement.scrollTop * this.verticalScrollScale) - this.scrollPosObject.verticalSection - mCnt.parentElement.scrollTop)) + 'px)';
                let horiOffset = (ele.scrollLeft > this.scrollerBrowserLimit) ?
                    (mCnt.querySelector('.' + TABLE).style.transform.split(',')[0].trim() + ',') :
                    'translate(' + -(((ele.scrollLeft * this.horizontalScrollScale) -
                        this.scrollPosObject.horizontalSection - ele.scrollLeft)) + 'px,';
                setStyleAttribute(fCnt.querySelector('.e-table'), {
                    transform: 'translate(' + 0 + 'px,' + verOffset
                });
                setStyleAttribute(mCnt.querySelector('.e-table'), {
                    transform: horiOffset + verOffset
                });
                setStyleAttribute(mHdr.querySelector('.e-table'), {
                    transform: horiOffset + 0 + 'px)'
                });
                if (!isNullOrUndefined(this.resizedValue)) {
                    this.element.querySelector('.e-frozenscrollbar').style.width = this.resizedValue + 'px';
                }
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                this.grid.element.querySelector('.' + MOVABLECHILD_DIV).style.width = (vWidth + (mCnt.parentElement.offsetWidth - mCnt.parentElement.clientWidth)) + 'px';
                const colValues = this.dataType === 'pivot' ? (this.dataSourceSettings.valueAxis === 'column' ? this.dataSourceSettings.values.length : 1) : 1;
                const exactSize = (this.pageSettings.columnPageSize * colValues * this.gridSettings.columnWidth);
                const hScrollPos = (ele.scrollWidth - (ele.scrollLeft + ele.offsetWidth));
                if (this.virtualscrollModule && exactSize > 0 && hScrollPos <= exactSize && ele.scrollLeft > 0) {
                    this.virtualDiv.style.display = 'none';
                    const mCntScrollPos = (mCnt.scrollWidth - (mCnt.scrollLeft + mCnt.offsetWidth));
                    this.virtualDiv.style.display = '';
                    const mCntVScrollPos = (mCnt.scrollWidth - (mCnt.scrollLeft + mCnt.offsetWidth));
                    if (mCntScrollPos > 1) {
                        this.scrollPosObject.horizontalSection -= (hScrollPos <= 0 ? (mCntScrollPos > hScrollPos ? mCntScrollPos
                            : -mCntVScrollPos) : (mCntVScrollPos === mCntScrollPos ? (mCntScrollPos - hScrollPos) :
                            (mCntScrollPos < mCntVScrollPos && (hScrollPos === mCntVScrollPos || hScrollPos > mCntScrollPos) ?
                                -(mCntVScrollPos - mCntScrollPos) : 0)));
                    }
                    if (this.actionObj.actionName === 'Sort value' || this.actionObj.actionName === 'Sort field') {
                        const excessMove = -this.scrollPosObject.horizontalSection;
                        this.scrollPosObject.horizontalSection = this.scrollPosObject.horizontalSection + excessMove;
                    }
                    horiOffset = (ele.scrollLeft > this.scrollerBrowserLimit) ?
                        (mCnt.querySelector('.' + TABLE).style.transform.split(',')[0].trim() + ',') :
                        'translate(' + -(((ele.scrollLeft * this.horizontalScrollScale) -
                            this.scrollPosObject.horizontalSection - ele.scrollLeft)) + 'px,';
                    setStyleAttribute(mCnt.querySelector('.e-table'), {
                        transform: horiOffset + verOffset
                    });
                    setStyleAttribute(mHdr.querySelector('.e-table'), {
                        transform: horiOffset + 0 + 'px)'
                    });
                }
                if (this.grid.height !== 'auto') {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    this.grid.contentModule.setHeightToContent(this.virtualDiv.offsetHeight + movableTable.clientHeight);
                }
                else {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    this.grid.contentModule.setHeightToContent(this.element.querySelector('.' + FROZENCONTENT_DIV + ' .' + TABLE).offsetHeight);
                }
            }
            if (this.currentView !== 'Chart') {
                this.grid.hideScroll();
            }
            if (this.showGroupingBar) {
                this.element.style.minWidth = '400px';
                this.grid.element.style.minWidth = '400px';
            }
            else {
                this.element.style.minWidth = '310px';
                this.grid.element.style.minWidth = '310px';
            }
        }
        this.unwireEvents();
        this.wireEvents();
        this.isChartLoaded = false;
        if (!this.isEmptyGrid) {
            this.trigger(dataBound);
        }
        this.actionObj.actionName = this.getActionCompleteName();
        if (this.actionObj.actionName) {
            if (this.actionObj.actionName !== windowResize) {
                this.actionCompleteMethod();
            }
        }
        if (this.groupingModule) {
            this.groupingModule.isUpdate = false;
        }
        if (this.engineModule) {
            this.engineModule.clearProperties();
        }
    }
    setToolTip(args) {
        const colIndex = Number(args.target.getAttribute('data-colindex'));
        const rowIndex = Number(args.target.getAttribute('index'));
        const cell = (this.dataSourceSettings.values.length > 0 && this.pivotValues &&
            this.pivotValues[rowIndex] && this.pivotValues[rowIndex][colIndex]) ?
            this.pivotValues[rowIndex][colIndex] : undefined;
        this.tooltip.content = '';
        let aggregateType;
        let caption;
        let hasField = false;
        if (cell && this.dataType === 'olap') {
            let measureName = cell.actualText;
            if (!isNullOrUndefined(measureName) && this.olapEngineModule.fieldList &&
                !this.olapEngineModule.fieldList[measureName]) {
                const tupleInfo = this.olapEngineModule.tupRowInfo;
                measureName = cell.rowOrdinal > -1 && tupleInfo.length > 0 && tupleInfo[cell.rowOrdinal] &&
                    !isNullOrUndefined(tupleInfo[cell.rowOrdinal].measureName) ? tupleInfo[cell.rowOrdinal].measureName : measureName;
            }
            if (this.olapEngineModule.fieldList && this.olapEngineModule.fieldList[measureName]) {
                const field = this.olapEngineModule.fieldList[measureName];
                aggregateType = field.isCalculatedField ? field.type : field.aggregateType;
                caption = (this.olapEngineModule.dataFields[measureName] &&
                    this.olapEngineModule.dataFields[measureName].caption) ?
                    this.olapEngineModule.dataFields[measureName].caption : field.caption;
                hasField = true;
            }
        }
        else {
            if (cell && this.engineModule.fieldList && this.engineModule.fieldList[cell.actualText]) {
                const field = this.engineModule.fieldList[cell.actualText];
                aggregateType = field.aggregateType;
                if ((aggregateType !== 'DistinctCount') && (field.type !== 'number' || field.type === 'include' ||
                    field.type === 'exclude')) {
                    aggregateType = 'Count';
                }
                else {
                    aggregateType = (aggregateType === undefined) ? 'Sum' : field.aggregateType;
                }
                caption = field.caption;
                hasField = true;
            }
        }
        if (cell && hasField) {
            const rowHeaders = this.getRowText(rowIndex, 0);
            const columnHeaders = this.getColText(0, colIndex, rowIndex);
            const value = (cell.formattedText === '' ? this.localeObj.getConstant('noValue') :
                cell.formattedText);
            if (this.tooltipTemplate && this.getTooltipTemplate() !== undefined) {
                const rowFields = this.getHeaderField(rowIndex, colIndex, 'row');
                const columnFields = this.getHeaderField(rowIndex, colIndex, 'column');
                const templateObject = {
                    rowHeaders: rowHeaders,
                    columnHeaders: columnHeaders,
                    aggregateType: aggregateType,
                    valueField: caption,
                    value: value,
                    rowFields: rowFields,
                    columnFields: columnFields
                };
                if (typeof (this.tooltipTemplate) === 'function' && this.isReact) {
                    const tooltipContent = document.createElement('div');
                    this.getTooltipTemplate()(templateObject, this, 'tooltipTemplate', this.element.id + 'tooltipTemplate', null, null, tooltipContent);
                    this.renderReactTemplates(() => {
                        if (this.enableHtmlSanitizer) {
                            this.tooltip.content = SanitizeHtmlHelper.sanitize(tooltipContent.outerHTML);
                        }
                        else {
                            this.tooltip.content = tooltipContent.outerHTML;
                        }
                    });
                }
                else {
                    const element = this.getTooltipTemplate()(templateObject, this, 'tooltipTemplate', this.element.id + 'tooltipTemplate')[0].outerHTML;
                    if (this.enableHtmlSanitizer) {
                        this.tooltip.content = SanitizeHtmlHelper.sanitize(element);
                    }
                    else {
                        this.tooltip.content = element;
                    }
                }
            }
            else {
                const contentTemp = '<div class=' + PIVOTTOOLTIP + '><p class=' + TOOLTIP_HEADER + '>' +
                    this.localeObj.getConstant('row') + ':</p><p class=' + TOOLTIP_CONTENT + '>' +
                    rowHeaders + '</p></br><p class=' + TOOLTIP_HEADER + '>' + this.localeObj.getConstant('column') +
                    ':</p><p class=' + TOOLTIP_CONTENT + '>' + columnHeaders + '</p></br>' +
                    (cell.actualText !== '' ? ('<p class=' + TOOLTIP_HEADER + '>' + (this.dataType === 'olap' ? '' :
                        (this.localeObj.getConstant(aggregateType) + ' ' + this.localeObj.getConstant('of') + ' ')) +
                        caption + ':</p><p class=' + TOOLTIP_CONTENT + '>' + value + '</p></div>') : ''); // eslint-disable-next-line @typescript-eslint/tslint/config
                const contentFunc = function () {
                    return contentTemp;
                }; // eslint-disable-next-line @typescript-eslint/no-explicit-any
                this.tooltip.content = initializeCSPTemplate(contentFunc);
            }
        }
        else {
            args.cancel = true;
        }
    }
    /** @hidden */
    getTooltipTemplate() {
        return this.tooltipTemplateFn;
    }
    /** @hidden */
    getHeaderField(rowIndex, colIndex, axis) {
        let fields = '';
        let len;
        const engineModule = this.dataType === 'olap' ? this.olapEngineModule : this.engineModule;
        const delimiter = engineModule.valueSortSettings.headerDelimiter;
        if (axis === 'row') {
            len = this.pivotValues[rowIndex][0].valueSort.levelName.toString().split(delimiter).length;
            for (let i = 0; i < len && this.dataSourceSettings.rows.length > 0 && this.dataSourceSettings.rows[i]; i++) {
                fields += (i ? ' - ' : '') + ((this.dataSourceSettings.rows[i].caption) ? this.dataSourceSettings.rows[i].caption : this.dataSourceSettings.rows[i].name);
            }
        }
        else {
            if (this.dataSourceSettings.columns.length > 0) {
                const pos = this.dataSourceSettings.values.length === 0 ? 0 :
                    Number(Object.keys(engineModule.headerContent)[Object.keys(engineModule.headerContent).length - 1]);
                len =
                    this.pivotValues[pos][colIndex].valueSort.levelName.toString().split(delimiter).length;
                len = this.dataSourceSettings.values.length > 1 ? len - 1 : len;
            } // eslint-disable-next-line max-len
            for (let j = 0; j < len && this.dataSourceSettings.columns.length > 0 && this.dataSourceSettings.columns[j]; j++) {
                fields += (j ? ' - ' : '') + ((this.dataSourceSettings.columns[j].caption) ? this.dataSourceSettings.columns[j].caption : this.dataSourceSettings.columns[j].name);
            }
        }
        return fields;
    }
    getLevel(cell) {
        const levelName = cell.valueSort ? cell.valueSort.levelName.toString() : '';
        const memberPos = cell.actualText ?
            cell.actualText.toString().split(this.dataSourceSettings.valueSortSettings.headerDelimiter).length : 0;
        const levelPosition = levelName.split(this.dataSourceSettings.valueSortSettings.headerDelimiter).length -
            (memberPos ? memberPos - 1 : memberPos);
        return levelPosition ? (levelPosition - 1) : 0;
    }
    /**
     * It used to get row text
     *
     * @param {number} rowIndex - Specifies row Index.
     * @param {number} colIndex - Specifies column Index.
     * @returns {string} - Returns row text.
     * @hidden
     */
    getRowText(rowIndex, colIndex) {
        let cell = this.pivotValues[rowIndex][colIndex];
        let rowText = '';
        if (cell) {
            let level = this.getLevel(cell);
            rowText = cell.type === 'grand sum' ? this.localeObj.getConstant('grandTotal') : cell.formattedText;
            if (this.dataSourceSettings.valueAxis === 'row') {
                rowText = (this.dataSourceSettings.rows.length === 0 && this.dataSourceSettings.values.length > 1) ? this.pivotValues[rowIndex][0].valueSort.levelName.toString().slice((this.localeObj.getConstant('grandTotal')
                    + this.dataSourceSettings.valueSortSettings.headerDelimiter).length).toString()
                    : this.dataSourceSettings.values.length === 1 ? !isNullOrUndefined(this.dataSourceSettings.values[0].caption)
                        ? this.dataSourceSettings.values[0].caption : this.dataSourceSettings.values[0].name
                        : this.pivotValues[rowIndex][0].valueSort.levelName.toString();
                rowText = rowText.split(this.dataSourceSettings.valueSortSettings.headerDelimiter).join(' - ');
            }
            else {
                while (level > 0 || cell.index === undefined) {
                    rowIndex--;
                    cell = this.pivotValues[rowIndex][colIndex];
                    if (cell.index !== undefined) {
                        if (level > cell.level) {
                            rowText = rowText + this.dataSourceSettings.valueSortSettings.headerDelimiter + cell.formattedText;
                            level = level - 1;
                        }
                    }
                }
            }
            rowText = rowText.split(this.dataSourceSettings.valueSortSettings.headerDelimiter).reverse().join(' - ');
        }
        return rowText;
    }
    getColText(rowIndex, colIndex, limit) {
        let cell = this.pivotValues[0][colIndex];
        let axis = cell.axis;
        let colText = cell.type === 'grand sum' ? this.localeObj.getConstant('grandTotal') : cell.formattedText;
        while (axis !== 'value' && limit > rowIndex) {
            rowIndex++;
            if (this.pivotValues[rowIndex]) {
                cell = this.pivotValues[rowIndex][colIndex];
                axis = cell.axis;
                if (cell.type !== 'sum' && cell.type !== 'grand sum' && axis !== 'value') {
                    colText = colText + ' - ' + cell.formattedText;
                }
            }
        }
        return colText;
    }
    updateClass() {
        if (this.enableRtl) {
            addClass([this.element], RTL);
        }
        else {
            removeClass([this.element], RTL);
        }
        if (this.isAdaptive) {
            addClass([this.element], DEVICE);
        }
        else {
            removeClass([this.element], DEVICE);
        }
        if (this.cssClass) {
            addClass([this.element], this.cssClass);
        }
    }
    mouseRclickHandler(e) {
        if (e.which === 3) {
            this.lastCellClicked = e.target;
        }
        else if (e.which === 0) {
            this.lastCellClicked = e.target;
        }
        this.lastCellClicked = e.target;
    }
    mouseDownHandler(e) {
        if (e.which === 3) {
            this.lastCellClicked = e.target;
        }
        if (this.isCellBoxMultiSelection) {
            this.isMouseDown = true;
            this.isMouseUp = false;
            this.lastSelectedElement = undefined;
        }
    }
    mouseMoveHandler(e) {
        if (this.isCellBoxMultiSelection) {
            e.preventDefault();
            if (this.isMouseDown && e.target) {
                let ele = e.target;
                const axis = (ele.parentElement.classList.contains(ROWSHEADER) || ele.classList.contains(ROWSHEADER)) ? 'row' : 'column';
                ele = axis === 'column' ? closest(ele, 'th') : closest(ele, 'td');
                if (ele) {
                    const colIndex = Number(ele.getAttribute('data-colindex'));
                    const rowIndex = Number(ele.getAttribute('index'));
                    const selectArgs = {
                        cancel: false,
                        isCellClick: true,
                        currentCell: ele,
                        data: this.pivotValues[rowIndex][colIndex]
                    };
                    this.trigger(cellSelecting, selectArgs, (observedArgs) => {
                        if (!observedArgs.cancel) {
                            this.grid.clearSelection();
                            const parentElement = this.parentAt(ele, 'TH');
                            if (this.lastSelectedElement && this.lastSelectedElement !== parentElement &&
                                parentElement.classList.contains(SELECTED_BGCOLOR)) {
                                this.lastSelectedElement.classList.remove(CELL_ACTIVE_BGCOLOR);
                                this.lastSelectedElement.classList.remove(SELECTED_BGCOLOR);
                                this.lastSelectedElement = parentElement;
                            }
                            else {
                                this.lastSelectedElement = parentElement;
                                parentElement.classList.add(CELL_ACTIVE_BGCOLOR);
                                parentElement.classList.add(SELECTED_BGCOLOR);
                            }
                            this.renderModule.selected();
                        }
                    });
                }
            }
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    mouseUpHandler(e) {
        if (this.isCellBoxMultiSelection) {
            this.isMouseDown = false;
            this.isMouseUp = true;
        }
    }
    parentAt(target, tagName) {
        while (target.tagName !== tagName) {
            if (target.parentElement) {
                target = target.parentElement;
            }
            else {
                break;
            }
        }
        return target;
    }
    mouseClickHandler(e) {
        if (e.which === 3) {
            this.lastCellClicked = e.target;
        }
        else if (e.which === 0) {
            this.lastCellClicked = e.target;
        }
        const target = e.target;
        if (closest(target, '.' + PIVOT_BUTTON_CLASS)) {
            return;
        }
        let ele = null;
        const axis = (target.parentElement.classList.contains(ROWSHEADER) || target.classList.contains(ROWSHEADER)) ? 'row' : 'column';
        ele = axis === 'column' ? closest(target, 'th') : closest(target, 'td');
        if (axis === 'column' && !ele && this.gridSettings.selectionSettings.mode !== 'Row') {
            ele = closest(target, 'td');
        }
        if (!target.classList.contains(COLLAPSE) && !target.classList.contains(EXPAND) && this.enableValueSorting && this.dataType === 'pivot') {
            this.cellClicked(target, ele, e);
            try {
                if (ele && ((ele.parentElement.parentElement.parentElement.parentElement.classList.contains('e-movableheader')
                    && this.dataSourceSettings.valueAxis === 'column') || (ele.parentElement.classList.contains('e-row') &&
                    this.dataSourceSettings.valueAxis === 'row') && (ele.classList.contains('e-rowsheader') ||
                    ele.classList.contains('e-stot')))) {
                    const FieldName = ele.getAttribute('fieldname');
                    const fieldInfo = PivotUtil.getFieldInfo(FieldName, this);
                    this.actionObj.actionName = sortValue;
                    this.actionObj.fieldInfo = fieldInfo.fieldItem;
                    if (this.actionBeginMethod()) {
                        return;
                    }
                    let colIndex = Number(ele.getAttribute('data-colindex'));
                    let rowIndex = Number(ele.getAttribute('index'));
                    if (this.dataSourceSettings.valueAxis === 'row' && (this.dataSourceSettings.values.length > 1 || this.dataSourceSettings.alwaysShowValueHeader)) {
                        const header = this.pivotValues[rowIndex][colIndex];
                        if (this.dataSourceSettings.valueIndex === -1) {
                            rowIndex = header.type === 'value' ? rowIndex : (rowIndex + 1);
                        }
                        else {
                            const level = this.getLevel(header);
                            rowIndex = (level <= this.engineModule.measureIndex &&
                                header.members && header.members.length > 0) ? header.members[0].rowIndex : rowIndex;
                        }
                    }
                    else if (this.dataSourceSettings.valueAxis === 'column' && (this.dataSourceSettings.values.length > 1 || this.dataSourceSettings.alwaysShowValueHeader)) {
                        colIndex = (Number(ele.getAttribute('data-colindex')) + Number(ele.getAttribute('aria-colspan')) - 1);
                        rowIndex = this.engineModule.headerContent.length - 1;
                    }
                    this.setProperties({
                        dataSourceSettings: {
                            valueSortSettings: {
                                columnIndex: (Number(ele.getAttribute('data-colindex')) +
                                    Number(ele.getAttribute('aria-colspan')) - 1),
                                sortOrder: this.dataSourceSettings.valueSortSettings.sortOrder === 'Descending' ? 'Ascending' : 'Descending',
                                headerText: this.pivotValues[rowIndex][colIndex].valueSort.levelName,
                                headerDelimiter: this.dataSourceSettings.valueSortSettings.headerDelimiter ?
                                    this.dataSourceSettings.valueSortSettings.headerDelimiter : '.'
                            }
                        }
                    }, true);
                    this.showWaitingPopup();
                    // eslint-disable-next-line @typescript-eslint/no-this-alias
                    const pivot = this;
                    pivot.engineModule.enableValueSorting = true;
                    if (pivot.enableVirtualization || pivot.enablePaging) {
                        if (pivot.dataSourceSettings.enableSorting) {
                            for (const key of Object.keys(pivot.engineModule.fieldList)) {
                                pivot.engineModule.fieldList[key].sort = 'Ascending';
                            }
                            pivot.setProperties({ dataSourceSettings: { sortSettings: [] } }, true);
                        }
                        if (pivot.dataSourceSettings.mode === 'Server') {
                            pivot.getEngine('onValueSort', null, null, null, null, null, null);
                        }
                        else {
                            pivot.engineModule.rMembers = pivot.engineModule.headerCollection.rowHeaders;
                            pivot.engineModule.cMembers = pivot.engineModule.headerCollection.columnHeaders;
                            pivot.engineModule.applyValueSorting();
                            pivot.engineModule.updateEngine();
                        }
                    }
                    else if (pivot.dataSourceSettings.mode === 'Server') {
                        pivot.getEngine('onValueSort', null, null, null, null, null, null);
                    }
                    else {
                        pivot.engineModule.generateGridData(pivot.dataSourceSettings, true);
                    }
                    pivot.allowServerDataBinding = false;
                    pivot.setProperties({ pivotValues: pivot.engineModule.pivotValues }, true);
                    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                    delete pivot.bulkChanges.pivotValues;
                    pivot.allowServerDataBinding = true;
                    const actionInfo = {
                        valueSortInfo: this.engineModule.valueSortSettings
                    };
                    this.actionObj.actionInfo = actionInfo;
                    pivot.renderPivotGrid();
                }
            }
            catch (execption) {
                this.actionFailureMethod(execption);
            }
        }
        else if (target.classList.contains(COLLAPSE) || target.classList.contains(EXPAND)) {
            const drillFieldName = target.parentElement.getAttribute('fieldname');
            const fieldInfo = PivotUtil.getFieldInfo(drillFieldName, this);
            const actionName = target.classList.contains(COLLAPSE) ? this.actionObj.actionName = drillUp : target.classList.contains(EXPAND) ? this.actionObj.actionName = drillDown : '';
            this.actionObj.actionName = actionName;
            this.actionObj.fieldInfo = fieldInfo.fieldItem;
            if (this.actionBeginMethod()) {
                return;
            }
            try {
                this.onDrill(target);
            }
            catch (execption) {
                this.actionFailureMethod(execption);
            }
        }
        else {
            this.cellClicked(target, ele, e);
            return;
        }
    }
    updateTotColWidth() {
        this.totColWidth = 0;
        for (const column of this.pivotColumns) {
            this.totColWidth = this.totColWidth + column.width;
        }
    }
    framePivotColumns(gridcolumns) {
        for (const column of gridcolumns) {
            if (column.columns && column.columns.length > 0) {
                this.framePivotColumns(column.columns);
            }
            else {
                const levelName = column.field === '0.formattedText' ? '' :
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    ((column.customAttributes && column.customAttributes.cell && column.customAttributes.cell.valueSort) ? column.customAttributes.cell.valueSort.levelName : '');
                const width = this.renderModule.setSavedWidth(column.field === '0.formattedText' ? column.field :
                    levelName, Number(column.width === 'auto' ? column.minWidth : column.width));
                this.pivotColumns.push({
                    allowReordering: column.allowReordering,
                    allowResizing: column.allowResizing,
                    headerText: levelName,
                    width: width,
                    autoFit: column.autoFit
                });
                this.totColWidth = this.totColWidth + Number(width);
            }
        }
    }
    /** @hidden */
    setGridColumns(gridcolumns) {
        if ((!isNullOrUndefined(this.totColWidth) && this.totColWidth > 0) || this.renderModule.isAutoFitEnabled) {
            for (const column of gridcolumns) {
                if (column.columns && column.columns.length > 0) {
                    this.setGridColumns(column.columns);
                }
                else if (this.renderModule.isAutoFitEnabled) {
                    column.autoFit = this.pivotColumns[this.posCount].autoFit;
                    this.posCount++;
                }
                else {
                    const levelName = column.field === '0.formattedText' ? '' :
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        (column.customAttributes ? column.customAttributes.cell.valueSort.levelName : '');
                    column.allowReordering = this.pivotColumns[this.posCount].allowReordering;
                    column.allowResizing = this.pivotColumns[this.posCount].allowResizing;
                    column.autoFit = this.pivotColumns[this.posCount].autoFit;
                    const calcWidth = this.renderModule.setSavedWidth(column.field === '0.formattedText' ? column.field :
                        levelName, Number(this.pivotColumns[this.posCount].width));
                    if (!column.autoFit) {
                        if (column.width !== 'auto') {
                            column.width = calcWidth;
                        }
                        else {
                            column.minWidth = calcWidth;
                        }
                    }
                    else {
                        this.renderModule.isAutoFitEnabled = true;
                    }
                    this.posCount++;
                    if (column.allowReordering) {
                        this.gridSettings.allowReordering = true;
                    }
                    if (column.allowResizing) {
                        this.gridSettings.allowResizing = true;
                    }
                }
            }
            if (this.gridSettings.allowReordering) {
                Grid.Inject(Reorder);
            }
            if (this.gridSettings.allowResizing) {
                Grid.Inject(Resize);
            }
        }
    }
    /** @hidden */
    fillGridColumns(gridcolumns) {
        for (const column of gridcolumns) {
            column.allowReordering = this.gridSettings.allowReordering;
            column.allowResizing = this.gridSettings.allowResizing;
            column.clipMode = this.gridSettings.clipMode;
            this.posCount++;
            if (column.columns && column.columns.length > 0) {
                this.fillGridColumns(column.columns);
            }
        }
    }
    /** @hidden */
    triggerColumnRenderEvent(gridcolumns) {
        this.pivotColumns = [];
        this.totColWidth = 0;
        this.framePivotColumns(gridcolumns);
        const firstColWidth = this.pivotColumns[0].width;
        const eventArgs = {
            columns: this.pivotColumns,
            dataSourceSettings: this.dataSourceSettings,
            stackedColumns: this.getStackedColumns(gridcolumns, [])
        };
        this.trigger(beforeColumnsRender, eventArgs);
        if (this.enableVirtualization && eventArgs.columns.length > 0
            && eventArgs.columns[0].width !== gridcolumns[0].width) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this.element.querySelector('.e-frozenscrollbar').style.width = Number(eventArgs.columns[0].width.toString().split('px')[0]) + 'px';
        }
        this.updateTotColWidth();
        if (firstColWidth !== this.pivotColumns[0].width) {
            this.firstColWidth = this.pivotColumns[0].width;
            // eslint-disable-next-line radix
            this.renderModule.resColWidth = parseInt(this.firstColWidth.toString());
        }
        this.posCount = 0;
        this.setGridColumns(gridcolumns);
    }
    /** @hidden */
    setCommonColumnsWidth(columns, width) {
        for (const column of columns) {
            if (column.field !== '0.formattedText') {
                if (column.columns) {
                    this.setCommonColumnsWidth(column.columns, width);
                }
                else {
                    if (!column.autoFit) {
                        if (column.width !== 'auto') {
                            column.width = width;
                        }
                        else {
                            column.minWidth = width;
                        }
                    }
                }
            }
            else {
                column.width = !this.firstColWidth ? column.width : this.firstColWidth;
            }
        }
    }
    /** @hidden */
    getHeightAsNumber() {
        let height;
        if (isNaN(this.height)) {
            if (this.height.toString().indexOf('%') > -1) {
                height = (parseFloat(this.height.toString()) / 100) * this.element.offsetHeight;
            }
            else if (this.height.toString().indexOf('px') > -1) {
                height = Number(this.height.toString().split('px')[0]);
            }
        }
        else {
            height = Number(this.height);
        }
        if (height < this.minHeight) {
            height = this.minHeight;
        }
        return height;
    }
    /** @hidden */
    getWidthAsNumber() {
        let width;
        if (isNaN(this.width)) {
            if (this.width.toString().indexOf('%') > -1) {
                width = (parseFloat(this.width.toString()) / 100) * this.element.offsetWidth;
            }
            else if (this.width.toString().indexOf('px') > -1) {
                width = Number(this.width.toString().split('px')[0]);
            }
            if (isNaN(width)) {
                width = this.element.offsetWidth;
            }
        }
        else {
            width = Number(this.width);
        }
        if (width < 400) {
            width = 400;
        }
        return width;
    }
    /** @hidden */
    getGridWidthAsNumber() {
        let width;
        const offsetWidth = this.element.offsetWidth ? this.element.offsetWidth :
            this.element.getBoundingClientRect().width;
        if (isNaN(this.grid.width)) {
            if (this.grid.width.toString().indexOf('%') > -1) {
                width = (parseFloat(this.grid.width.toString()) / 100) * offsetWidth;
            }
            else if (this.grid.width.toString().indexOf('px') > -1) {
                width = Number(this.grid.width.toString().split('px')[0]);
            }
            if (isNaN(width)) {
                width = offsetWidth;
            }
        }
        else {
            width = Number(this.grid.width);
        }
        return width;
    }
    /** @hidden */
    onWindowResize() {
        this.actionObj.actionName = windowResize;
        if (this.actionBeginMethod()) {
            return;
        }
        clearTimeout(this.timeOutObj);
        this.timeOutObj = setTimeout(this.layoutRefresh.bind(this), 500);
        this.actionObj.actionName = this.getActionCompleteName();
        if (this.actionObj.actionName) {
            this.actionCompleteMethod();
        }
    }
    /**
     * Refreshes the Pivot Table for blazor layoutRefresh is called for other base refresh is called.
     *
     * @returns {void}
     */
    refresh() {
        this.pivotRefresh();
    }
    /** @hidden */
    layoutRefresh() {
        if (this.element && this.element.classList.contains('e-pivotview') &&
            (this.dataType === 'olap' ? (this.olapEngineModule && this.olapEngineModule.pivotValues) :
                this.engineModule && this.engineModule.pivotValues)) {
            if (this.grid) {
                const colLength = (this.dataType === 'olap' && this.olapEngineModule.pivotValues.length > 0) ?
                    this.olapEngineModule.pivotValues[0].length : (this.dataSourceSettings.values.length > 0 &&
                    this.engineModule.pivotValues.length > 0 ? this.engineModule.pivotValues[0].length : 2);
                const colWidth = this.renderModule.resizeColWidth(colLength);
                this.grid.width = this.renderModule.calculateGridWidth();
                this.renderModule.calculateGridHeight(true);
                if (this.gridSettings.allowAutoResizing) {
                    this.setCommonColumnsWidth(this.grid.columns, colWidth);
                }
                this.pivotColumns = [];
                this.totColWidth = 0;
                this.framePivotColumns(this.grid.columns);
                this.posCount = 0;
                if (!this.showGroupingBar) {
                    this.setGridColumns(this.grid.columns);
                }
                this.grid.refreshColumns();
                if (this.showGroupingBar && this.groupingBarModule && this.element.querySelector('.' + GROUPING_BAR_CLASS)) {
                    this.groupingBarModule.setGridRowWidth();
                }
                if (this.chart || this.pivotChartModule) {
                    this.chart.height = this.pivotChartModule.getResizedChartHeight();
                }
            }
            if (this.showToolbar && this.toolbarModule && this.toolbarModule.toolbar) {
                this.toolbarModule.toolbar.width = this.grid ? (this.getGridWidthAsNumber() - 2) : (this.getWidthAsNumber() - 2);
            }
            if (this.enablePaging) {
                this.notify(initPivotPager, this);
            }
            if (this.chart && ((this.showToolbar && this.currentView === 'Chart') || !this.showToolbar)) {
                this.chart.width = (this.showToolbar && this.grid) ? this.getGridWidthAsNumber().toString() :
                    (this.displayOption.view === 'Both' && this.grid) ? this.getGridWidthAsNumber().toString() : this.getWidthAsNumber().toString();
                this.chart.height = this.pivotChartModule.getResizedChartHeight();
                if (this.displayOption.view === 'Chart' && this.showGroupingBar && this.groupingBarModule &&
                    this.element.querySelector('.' + CHART_GROUPING_BAR_CLASS)) {
                    this.groupingBarModule.refreshUI();
                }
            }
        }
    }
    cellClicked(target, ele, e) {
        if (target.classList.contains(ROW_SELECT)) {
            if (target.classList.contains(SPAN_CLICKED)) {
                this.isPopupClicked = false;
            }
            else {
                this.isPopupClicked = true;
            }
        }
        if (ele && !isNullOrUndefined(this.pivotValues) && this.pivotValues.length > 0) {
            const colIndex = Number(ele.getAttribute('data-colindex'));
            const rowIndex = Number(ele.getAttribute('index'));
            const colSpan = Number(ele.getAttribute('aria-colspan'));
            const selectArgs = {
                cancel: false,
                isCellClick: true,
                currentCell: ele,
                data: this.pivotValues[rowIndex][colIndex]
            };
            this.trigger(cellSelecting, selectArgs, (observedArgs) => {
                if (this.gridSettings.allowSelection) {
                    if (this.gridSettings.selectionSettings.mode === 'Both' ? !ele.classList.contains(ROW_CELL_CLASS) :
                        this.gridSettings.selectionSettings.mode !== 'Row') {
                        if (!observedArgs.cancel) {
                            this.clearSelection(ele, e, colIndex, rowIndex);
                            this.applyColumnSelection(e, ele, colIndex, colIndex + (colSpan > 0 ? (colSpan - 1) : 0), rowIndex);
                        }
                    }
                    else {
                        this.clearSelection(ele, e, colIndex, rowIndex);
                    }
                    if (this.gridSettings.selectionSettings.mode !== 'Column' && !ele.classList.contains(COLUMNSHEADER)) {
                        this.rowDeselect(ele, e, rowIndex, this.gridSettings.selectionSettings.mode, observedArgs);
                    }
                    if (this.gridSettings.selectionSettings.mode !== 'Column' && !observedArgs.cancel) {
                        if (this.gridSettings.selectionSettings.type === 'Multiple' ? (!e.ctrlKey && !e.shiftKey) : true && this.selectedRowIndex !== rowIndex) {
                            this.selectedRowIndex = rowIndex;
                            this.grid.selectionModule.selectRow(rowIndex - this.renderModule.rowStartPos);
                        }
                        else {
                            this.selectedRowIndex = undefined;
                        }
                    }
                }
                if (this.cellClick && observedArgs.isCellClick) {
                    this.trigger(cellClick, {
                        currentCell: ele,
                        data: this.pivotValues[rowIndex][colIndex],
                        nativeEvent: e
                    });
                }
                this.getSelectedCellsPos();
            });
        }
        else {
            this.clearSelection(null, e, null, null);
        }
    }
    rowDeselect(ele, e, rowIndex, mode, observedArgs) {
        if (!e.shiftKey && !e.ctrlKey && this.gridSettings.selectionSettings.mode !== 'Both'
            || this.gridSettings.selectionSettings.type === 'Single') {
            if (!ele.classList.contains(CELL_SELECTED_BGCOLOR) && !ele.classList.contains(SELECTED_BGCOLOR)
                && !ele.classList.contains(CELL_ACTIVE_BGCOLOR)) {
                if (!observedArgs.cancel) {
                    removeClass(this.element.querySelectorAll('.' + CELL_SELECTED_BGCOLOR), CELL_SELECTED_BGCOLOR);
                    removeClass(this.element.querySelectorAll('.' + SELECTED_BGCOLOR), SELECTED_BGCOLOR);
                    removeClass(this.element.querySelectorAll('.' + CELL_ACTIVE_BGCOLOR), CELL_ACTIVE_BGCOLOR);
                }
                else {
                    this.setSavedSelectedCells();
                }
            }
            else {
                removeClass(this.element.querySelectorAll('.' + CELL_SELECTED_BGCOLOR), CELL_SELECTED_BGCOLOR);
                removeClass(this.element.querySelectorAll('.' + SELECTED_BGCOLOR), SELECTED_BGCOLOR);
                removeClass(this.element.querySelectorAll('.' + CELL_ACTIVE_BGCOLOR), CELL_ACTIVE_BGCOLOR);
                if (!observedArgs.cancel) {
                    if ((mode === 'Cell')) {
                        addClass([ele], [CELL_SELECTED_BGCOLOR]);
                    }
                    else if (mode === 'Row' || this.gridSettings.selectionSettings.type === 'Single') {
                        const query = '[index="' + rowIndex + '"]';
                        addClass(this.element.querySelectorAll(query), [SELECTED_BGCOLOR, CELL_ACTIVE_BGCOLOR]);
                        if (mode !== 'Row') {
                            ele.classList.add(CELL_SELECTED_BGCOLOR);
                        }
                    }
                }
                else {
                    this.setSavedSelectedCells();
                }
            }
        }
        else if (((e.shiftKey || e.ctrlKey) || this.gridSettings.selectionSettings.mode === 'Both') && (observedArgs.cancel)) {
            removeClass(this.element.querySelectorAll('.' + CELL_SELECTED_BGCOLOR), CELL_SELECTED_BGCOLOR);
            removeClass(this.element.querySelectorAll('.' + SELECTED_BGCOLOR), SELECTED_BGCOLOR);
            removeClass(this.element.querySelectorAll('.' + CELL_ACTIVE_BGCOLOR), CELL_ACTIVE_BGCOLOR);
            this.setSavedSelectedCells();
        }
    }
    /** @hidden */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    clearSelection(ele, e, colIndex, rowIndex) {
        if ((!e.shiftKey && !e.ctrlKey) || this.gridSettings.selectionSettings.type === 'Single') {
            if (this.gridSettings.selectionSettings.mode === 'Cell') {
                if (ele && ele.classList.contains(COLUMNSHEADER)) {
                    removeClass(this.element.querySelectorAll(('.' + ROW_CELL_CLASS + '.') + CELL_SELECTED_BGCOLOR), CELL_SELECTED_BGCOLOR);
                }
                else {
                    removeClass(this.element.querySelectorAll(('.' + COLUMNSHEADER + '.') + CELL_ACTIVE_BGCOLOR), [CELL_ACTIVE_BGCOLOR, SELECTED_BGCOLOR]);
                }
            }
            else if (this.gridSettings.selectionSettings.mode === 'Both') {
                if (ele && ele.classList.contains(ROW_CELL_CLASS)) {
                    for (const ele of [].slice.call(this.element.querySelectorAll('.' + SELECTED_BGCOLOR + ', .' + CELL_SELECTED_BGCOLOR))) {
                        // if (Number((ele as HTMLElement).getAttribute('index')) !== rowIndex) {
                        removeClass([ele], [CELL_ACTIVE_BGCOLOR, SELECTED_BGCOLOR, CELL_SELECTED_BGCOLOR]);
                        // }
                    }
                }
                else {
                    removeClass(this.element.querySelectorAll('.' + CELL_SELECTED_BGCOLOR), CELL_SELECTED_BGCOLOR);
                }
            }
        }
    }
    /** @hidden */
    applyRowSelection(colIndex, rowIndex, e) {
        let pivotValue = this.engineModule.pivotValues[rowIndex][colIndex];
        if (!e.ctrlKey && !e.shiftKey && pivotValue && this.selectedRowIndex !== rowIndex) {
            this.selectedRowIndex = rowIndex;
            const parentLevel = pivotValue.level;
            let rCount = rowIndex;
            do {
                rCount++;
                pivotValue = this.engineModule.pivotValues[rCount][colIndex];
            } while (pivotValue && parentLevel < pivotValue.level);
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const _this = this;
            if (this.isAdaptive) {
                this.rowRangeSelection = {
                    enable: true,
                    startIndex: rowIndex - _this.renderModule.rowStartPos,
                    endIndex: rCount - (1 + _this.renderModule.rowStartPos)
                };
            }
            else {
                _this.grid.selectionModule.selectRowsByRange(rowIndex -
                    _this.renderModule.rowStartPos, rCount - (1 + _this.renderModule.rowStartPos));
            }
        }
        else {
            this.selectedRowIndex = undefined;
        }
    }
    /** @hidden */
    applyColumnSelection(e, target, colStart, colEnd, rowStart) {
        if (!target.classList.contains(ROWSHEADER) &&
            (this.gridSettings.selectionSettings.mode === 'Cell' ? target.classList.contains(COLUMNSHEADER) : true)) {
            let isCtrl = e.ctrlKey;
            if (this.isAdaptive && this.gridSettings.selectionSettings.type === 'Multiple') {
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                this.grid.selectionModule.showPopup(e);
                if (this.isPopupClicked) {
                    this.element.querySelector('.' + ROW_SELECT).classList.add(SPAN_CLICKED);
                    isCtrl = true;
                }
                else {
                    this.element.querySelector('.' + ROW_SELECT).classList.remove(SPAN_CLICKED);
                    isCtrl = false;
                }
            }
            const queryStringArray = [];
            const type = this.gridSettings.selectionSettings.type;
            let isToggle = target.classList.contains(CELL_ACTIVE_BGCOLOR);
            let activeColumns = [];
            const actColPos = {};
            for (let cCnt = colStart; cCnt <= colEnd; cCnt++) {
                activeColumns.push(cCnt.toString());
            }
            if (!isCtrl || type === 'Single') {
                for (const ele of [].slice.call(this.element.querySelectorAll('.' + CELL_ACTIVE_BGCOLOR))) {
                    removeClass([ele], [CELL_ACTIVE_BGCOLOR, SELECTED_BGCOLOR]);
                    if (activeColumns.indexOf(ele.getAttribute('data-colindex')) === -1) {
                        isToggle = false;
                    }
                    const colIndex = Number(ele.getAttribute('data-colindex'));
                    actColPos[colIndex] = colIndex;
                }
                // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/tslint/config
                activeColumns = Object.keys(actColPos).length > 0 ? Object.keys(actColPos).sort(function (a, b) {
                    return a - b;
                }) : activeColumns;
            }
            else {
                isToggle = false;
            }
            if (type === 'Multiple' && e.shiftKey) {
                this.shiftLockedPos = this.shiftLockedPos.length === 0 ? activeColumns : this.shiftLockedPos;
                if (Number(this.shiftLockedPos[0]) <= colStart) {
                    colStart = Number(this.shiftLockedPos[0]);
                }
                else {
                    colEnd = colEnd < Number(this.shiftLockedPos[this.shiftLockedPos.length - 1]) ?
                        Number(this.shiftLockedPos[this.shiftLockedPos.length - 1]) : colEnd;
                }
            }
            else {
                this.shiftLockedPos = [];
            }
            const rowSelectedList = [];
            if (e.ctrlKey && this.gridSettings.selectionSettings.mode === 'Both' && type === 'Multiple' && !target.classList.contains(ROWSHEADER)) {
                for (const ele of [].slice.call(this.element.querySelectorAll('.' + ROWSHEADER + '.' + CELL_SELECTED_BGCOLOR))) {
                    rowSelectedList.push(ele.getAttribute('index'));
                }
            }
            let count = colStart;
            while (count <= colEnd) {
                queryStringArray.push('[data-colindex="' + count + '"]' + (this.gridSettings.selectionSettings.mode === 'Cell' ?
                    '[index="' + rowStart + '"]' : '') + '');
                count++;
            }
            if (!isToggle) {
                rowStart = target.classList.contains('e-headercell') ? rowStart : (this.renderModule.rowStartPos - 1);
                const isTargetSelected = target.classList.contains(CELL_ACTIVE_BGCOLOR);
                for (const ele of [].slice.call(this.element.querySelectorAll(queryStringArray.toString()))) {
                    if (Number(ele.getAttribute('index')) >= rowStart) {
                        if (isTargetSelected && isCtrl && (rowSelectedList.indexOf(ele.getAttribute('index')) === -1)) {
                            removeClass([ele], [CELL_ACTIVE_BGCOLOR, SELECTED_BGCOLOR]);
                        }
                        else {
                            addClass([ele], [CELL_ACTIVE_BGCOLOR, SELECTED_BGCOLOR]);
                        }
                    }
                }
            }
            this.renderModule.selected();
        }
    }
    getSelectedCellsPos() {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const control = this;
        control.savedSelectedCellsPos = [];
        control.cellSelectionPos = [];
        for (const ele of [].slice.call(this.element.querySelectorAll('.' + SELECTED_BGCOLOR))) {
            control.savedSelectedCellsPos.push({ rowIndex: ele.getAttribute('index'), colIndex: ele.getAttribute('data-colindex') });
        }
        for (const ele of [].slice.call(this.element.querySelectorAll('.' + CELL_SELECTED_BGCOLOR))) {
            control.cellSelectionPos.push({ rowIndex: ele.getAttribute('index'), colIndex: ele.getAttribute('data-colindex') });
        }
    }
    setSavedSelectedCells() {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const control = this;
        for (const item of [].slice.call(this.savedSelectedCellsPos)) {
            const query = '[data-colindex="' + item.colIndex + '"][index="' + item.rowIndex + '"]';
            addClass([control.element.querySelector(query)], [CELL_ACTIVE_BGCOLOR, SELECTED_BGCOLOR]);
        }
        for (const item of [].slice.call(this.cellSelectionPos)) {
            const query = '[data-colindex="' + item.colIndex + '"][index="' + item.rowIndex + '"]';
            addClass([control.element.querySelector(query)], [CELL_SELECTED_BGCOLOR]);
        }
    }
    renderEmptyGrid() {
        this.isEmptyGrid = true;
        this.notEmpty = false;
        this.isInitial = true;
        this.renderModule = this.renderModule ? this.renderModule : new Render(this);
        if (this.grid && this.grid.element && this.element.querySelector('.e-grid')) {
            this.notEmpty = true;
            this.grid.setProperties({
                columns: this.renderModule.frameEmptyColumns(),
                dataSource: this.renderModule.frameEmptyData()
            }, true);
            this.grid.notify('datasource-modified', {});
            this.grid.refreshColumns();
        }
        else {
            if (this.element.querySelector('.' + GRID_CLASS)) {
                remove(this.element.querySelector('.' + GRID_CLASS));
            }
            this.renderModule.bindGrid(this, true);
            // eslint-disable-next-line @typescript-eslint/no-empty-function
            this.grid.showSpinner = () => { };
            // eslint-disable-next-line @typescript-eslint/no-empty-function
            this.grid.hideSpinner = () => { };
            const element = createElement('div', { id: this.element.id + '_grid' });
            this.element.appendChild(element);
            this.grid.isStringTemplate = true;
            this.grid.appendTo(element);
            this.grid.on('refresh-frozen-height', () => {
                if (!this.enableVirtualization) {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    this.grid.contentModule.setHeightToContent(this.grid.contentModule.getTable().offsetHeight);
                }
            });
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this.grid.off('data-ready', this.grid.dataReady);
            this.grid.on('data-ready', () => {
                this.grid.scrollModule.setWidth();
                this.grid.scrollModule.setHeight();
            });
        }
    }
    /** @hidden */
    initEngine() {
        if (this.element.querySelector('.e-spin-hide')) {
            this.showWaitingPopup();
        }
        if (this.dataType === 'pivot') {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const data = !isNullOrUndefined(this.dataSourceSettings.dataSource)
                ? this.dataSourceSettings.dataSource[0] :
                !isNullOrUndefined(this.engineModule.data) ? this.engineModule.data[0] : undefined;
            if (data && this.pivotCommon) {
                const isArray = Object.prototype.toString.call(data) === '[object Array]';
                if (isArray && this.dataSourceSettings.type === 'JSON') {
                    this.pivotCommon.errorDialog.createErrorDialog(this.localeObj.getConstant('error'), this.localeObj.getConstant('invalidJSON'));
                    return;
                }
                else if (!isArray && this.dataSourceSettings.type === 'CSV') {
                    this.pivotCommon.errorDialog.createErrorDialog(this.localeObj.getConstant('error'), this.localeObj.getConstant('invalidCSV'));
                    return;
                }
            }
        }
        const args = {
            dataSourceSettings: PivotUtil.getClonedDataSourceSettings(this.dataSourceSettings)
        };
        this.trigger(enginePopulating, args, (observedArgs) => {
            PivotUtil.updateDataSourceSettings(this, observedArgs.dataSourceSettings);
            this.updatePageSettings(false);
            const customProperties = {
                mode: '',
                savedFieldList: undefined,
                pageSettings: this.pageSettings,
                enableValueSorting: this.enableValueSorting,
                isDrillThrough: (this.allowDrillThrough || this.editSettings.allowEditing),
                localeObj: this.localeObj,
                fieldsType: this.fieldsType,
                clonedReport: this.clonedReport,
                globalize: this.globalize,
                currenyCode: this.currencyCode,
                enablePaging: this.enablePaging,
                enableVirtualization: this.enableVirtualization,
                allowDataCompression: this.allowDataCompression,
                enableHtmlSanitizer: this.enableHtmlSanitizer
            };
            if (this.dataType === 'pivot') {
                if (this.dataSourceSettings.groupSettings && this.dataSourceSettings.groupSettings.length > 0) {
                    const dataSet = this.engineModule.data;
                    this.clonedDataSet = (this.clonedDataSet ? this.clonedDataSet : PivotUtil.getClonedData(dataSet));
                    const dataSourceSettings = JSON.parse(this.getPersistData()).dataSourceSettings;
                    dataSourceSettings.dataSource = [];
                    this.clonedReport = this.clonedReport ? this.clonedReport : dataSourceSettings;
                }
                if (this.dataSourceSettings.mode !== 'Server') {
                    this.engineModule.renderEngine(this.dataSourceSettings, customProperties, this.aggregateCellInfo
                        ? this.getValueCellInfo.bind(this) : undefined, this.onHeadersSort ? this.getHeaderSortInfo.bind(this) : undefined);
                }
                this.allowServerDataBinding = false;
                this.setProperties({ pivotValues: this.engineModule.pivotValues }, true);
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                delete this.bulkChanges.pivotValues;
                this.allowServerDataBinding = true;
                this.enginePopulatedEventMethod('initEngine');
            }
            else if (this.dataSourceSettings.providerType === 'SSAS' && this.dataType === 'olap') {
                customProperties.savedFieldList = this.olapEngineModule.fieldList;
                customProperties.savedFieldListData = this.olapEngineModule.fieldListData;
                this.olapEngineModule.renderEngine(this.dataSourceSettings, customProperties, this.onHeadersSort
                    ? this.getHeaderSortInfo.bind(this) : undefined);
                this.allowServerDataBinding = false;
                this.setProperties({ pivotValues: this.olapEngineModule.pivotValues }, true);
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                delete this.bulkChanges.pivotValues;
                this.allowServerDataBinding = true;
                this.enginePopulatedEventMethod('initEngine');
            }
        });
    }
    enginePopulatedEventMethod(action, control) {
        if (action === 'initEngine') {
            const this$ = control ? control : this;
            this.trigger(enginePopulated, { pivotValues: this.pivotValues }, (observedArgs) => {
                if (this$.dataType === 'olap') {
                    this$.olapEngineModule.pivotValues = observedArgs.pivotValues;
                    this$.pivotValues = this$.olapEngineModule.pivotValues;
                }
                else {
                    this$.engineModule.pivotValues = observedArgs.pivotValues;
                    this$.pivotValues = this$.engineModule.pivotValues;
                }
                this$.notify(dataReady, {});
                this$.notEmpty = true;
            });
        }
        else {
            const pivot = control ? control : this;
            const eventArgs = {
                dataSourceSettings: pivot.dataSourceSettings,
                pivotValues: pivot.pivotValues
            };
            pivot.trigger(enginePopulated, eventArgs, (observedArgs) => {
                pivot.dataSourceSettings = observedArgs.dataSourceSettings;
                if (pivot.dataType === 'olap') {
                    pivot.olapEngineModule.pivotValues = observedArgs.pivotValues;
                    pivot.allowServerDataBinding = false;
                    pivot.setProperties({ pivotValues: pivot.olapEngineModule.pivotValues }, true);
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    delete pivot.bulkChanges.pivotValues;
                    pivot.allowServerDataBinding = true;
                }
                else {
                    pivot.engineModule.pivotValues = observedArgs.pivotValues;
                    pivot.allowServerDataBinding = false;
                    pivot.setProperties({ pivotValues: pivot.engineModule.pivotValues }, true);
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    delete pivot.bulkChanges.pivotValues;
                    pivot.allowServerDataBinding = true;
                }
                pivot.pivotCommon.engineModule = pivot.dataType === 'olap' ? pivot.olapEngineModule : pivot.engineModule;
                pivot.pivotCommon.dataSourceSettings = pivot.dataSourceSettings;
                pivot.renderPivotGrid();
            });
        }
    }
    generateData() {
        if (!this.isStaticRefresh) {
            if (this.displayOption.view === 'Chart' || !isNullOrUndefined(this.grid)) {
                this.showWaitingPopup();
                clearTimeout(this.timeOutObj);
                this.timeOutObj = setTimeout(this.refreshData.bind(this), 100);
            }
            else {
                this.renderEmptyGrid();
                this.showWaitingPopup();
            }
        }
    }
    /** @hidden */
    refreshData() {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const pivot = this;
        if (!pivot.isStaticRefresh) {
            if (pivot.dataSourceSettings && (pivot.dataSourceSettings.dataSource || pivot.dataSourceSettings.url)) {
                if (pivot.dataSourceSettings.dataSource instanceof DataManager) {
                    if (pivot.dataType === 'pivot' && pivot.remoteData.length > 0) {
                        if (!this.element.querySelector('.e-spinner-pane')) {
                            this.showWaitingPopup();
                        }
                        this.engineModule.data = pivot.remoteData;
                        this.initEngine();
                    }
                    else {
                        setTimeout(pivot.getData.bind(pivot), 100);
                    }
                }
                else if ((this.dataSourceSettings.url !== '' && this.dataType === 'olap') ||
                    (pivot.dataSourceSettings.dataSource && pivot.dataSourceSettings.dataSource.length > 0
                        || this.engineModule.data.length > 0)) {
                    if (pivot.dataType === 'pivot') {
                        this.hideWaitingPopup();
                        pivot.engineModule.data = pivot.dataSourceSettings.dataSource;
                    }
                    pivot.initEngine();
                }
                else {
                    if (this.dataSourceSettings.mode === 'Server') {
                        this.getEngine('onRefresh');
                    }
                    else {
                        this.notify(dataReady, {});
                        this.hideWaitingPopup();
                    }
                }
            }
            else {
                this.notify(dataReady, {});
                this.hideWaitingPopup();
            }
        }
        else {
            pivot.isStaticRefresh = false;
            pivot.hideWaitingPopup();
        }
    }
    getValueCellInfo(aggregateObj) {
        const args = aggregateObj;
        this.trigger(aggregateCellInfo, args);
        return args;
    }
    getHeaderSortInfo(sortingObj) {
        const args = sortingObj;
        this.trigger(onHeadersSort, args);
        return args;
    }
    /**
     * De-Register the internal events.
     *
     * @param {Object} args - args.
     * @returns {void}
     * @hidden
     */
    bindTriggerEvents(args) {
        this.trigger(getObject('name', args), args);
    }
    getData() {
        if (this.dataSourceSettings.dataSource.defaultQuery) {
            this.dataSourceSettings.dataSource.executeQuery(this.dataSourceSettings.dataSource
                .defaultQuery).then(this.executeQuery.bind(this));
        }
        else {
            this.dataSourceSettings.dataSource.executeQuery(new Query()).then(this.executeQuery.bind(this));
        }
    }
    executeQuery(e) {
        if (!this.element.querySelector('.e-spinner-pane')) {
            this.showWaitingPopup();
        }
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const pivot = this;
        pivot.engineModule.data = e.result;
        if (!isNullOrUndefined(pivot.engineModule.data) && pivot.engineModule.data.length > 0) {
            pivot.initEngine();
        }
        else {
            this.hideWaitingPopup();
        }
    }
    /** @hidden */
    applyFormatting(pivotValues) {
        if (pivotValues) {
            const colIndex = [];
            for (let len = pivotValues.length, i = 0; i < len; i++) {
                if (pivotValues[i] !== undefined && pivotValues[i][0] === undefined) {
                    colIndex.push(i);
                }
            }
            for (let i = 0; i < pivotValues.length; i++) {
                for (let j = 1; (pivotValues[i] && j < pivotValues[i].length); j++) {
                    if (pivotValues[i][j].axis === 'value' && pivotValues[i][j].formattedText !== '') {
                        pivotValues[i][j].style = undefined;
                        pivotValues[i][j].cssClass = undefined;
                        const format = this.dataSourceSettings.conditionalFormatSettings;
                        for (let k = 0; k < format.length; k++) {
                            if ((format[k].applyGrandTotals === true || isNullOrUndefined(format[k].applyGrandTotals))
                                ? true : pivotValues[i][j].rowHeaders !== '' &&
                                pivotValues[i][j].columnHeaders !== '') {
                                if (this.checkCondition(pivotValues[i][j].value, format[k].conditions, format[k].value1, format[k].value2)) {
                                    // let ilen: number =
                                    //     (this.dataSourceSettings.valueAxis === 'row' ? i : this.engineModule.headerContent.length - 1);
                                    // let jlen: number = (this.dataSourceSettings.valueAxis === 'row' ? 0 : j);
                                    if ((!format[k].measure || pivotValues[i][j].actualText ===
                                        format[k].measure) &&
                                        (format[k].measure === undefined || format[k].measure !== '') && (format[k].label === undefined ||
                                        format[k].label !== '') && ((!format[k].label ||
                                        (pivotValues[i][0].valueSort.levelName
                                            .indexOf(format[k].label)) > -1) ||
                                        (pivotValues[i][j].rowHeaders
                                            .indexOf(format[k].label) > -1) ||
                                        (pivotValues[i][j].columnHeaders
                                            .indexOf(format[k].label) > -1))) {
                                        if (format[k].style && format[k].style.backgroundColor) {
                                            format[k].style.backgroundColor = this.conditionalFormattingModule
                                                .isHex(format[k].style.backgroundColor.substr(1))
                                                ? format[k].style.backgroundColor :
                                                this.conditionalFormattingModule.colourNameToHex(format[k].style.backgroundColor);
                                        }
                                        if (format[k].style && format[k].style.color) {
                                            format[k].style.color = this.conditionalFormattingModule
                                                .isHex(format[k].style.color.substr(1)) ? format[k].style.color :
                                                this.conditionalFormattingModule.colourNameToHex(format[k].style.color);
                                        }
                                        pivotValues[i][j].style = format[k].style;
                                        pivotValues[i][j].cssClass = 'format' + this.element.id + k;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            const format = this.dataSourceSettings.conditionalFormatSettings;
            for (let k = 0; k < format.length; k++) {
                const sheet = (this.createStyleSheet.bind(this))();
                const str = 'color: ' + format[k].style.color + '!important;background-color: ' + format[k].style.backgroundColor +
                    '!important;font-size: ' + format[k].style.fontSize + '!important;font-family: ' + format[k].style.fontFamily +
                    ' !important;';
                const formatClass = '.format' + this.element.id + k;
                sheet.insertRule(formatClass + ', ' + formatClass + ' .e-cellvalue' + '{' + str + '}', 0);
            }
        }
    }
    createStyleSheet() {
        const style = document.createElement('style');
        style.appendChild(document.createTextNode(''));
        document.head.appendChild(style);
        return style.sheet;
    }
    applyHyperlinkSettings() {
        if (this.pivotValues) {
            const pivotValues = this.pivotValues;
            const colIndex = [];
            for (let len = pivotValues.length, i = 0; i < len; i++) {
                if (!isNullOrUndefined(pivotValues[i]) && pivotValues[i][0] === undefined) {
                    colIndex.push(i);
                }
            }
            if (this.hyperlinkSettings.conditionalSettings.length > 0) {
                for (let i = 0; i < pivotValues.length; i++) {
                    for (let j = 1; (pivotValues[i] && j < pivotValues[i].length); j++) {
                        if (pivotValues[i][j].axis === 'value') {
                            pivotValues[i][j].enableHyperlink = false;
                            const collection = this.hyperlinkSettings.conditionalSettings;
                            for (let k = 0; k < collection.length; k++) {
                                if (this.checkCondition(pivotValues[i][j].value, collection[k].conditions, collection[k].value1, collection[k].value2)) {
                                    const ilen = (this.dataSourceSettings.valueAxis === 'row' ?
                                        i : (this.dataType === 'pivot' ?
                                        this.engineModule.headerContent.length - 1 : this.olapEngineModule.headerContent.length - 1));
                                    const jlen = (this.dataSourceSettings.valueAxis === 'row' ? 0 : j);
                                    if ((!collection[k].measure || this.dataSourceSettings.values.length === 1 ||
                                        (pivotValues[ilen][jlen].valueSort &&
                                            (pivotValues[ilen][jlen].actualText ===
                                                collection[k].measure))) && (!collection[k].label ||
                                        ((pivotValues[colIndex[collection[k].label.split('.').length - 1]] &&
                                            pivotValues[colIndex[collection[k].label.split('.').length - 1]][j] &&
                                            pivotValues[colIndex[collection[k].label.split('.').length - 1]][j].valueSort &&
                                            pivotValues[colIndex[collection[k].label.split('.').length - 1]][j].
                                                valueSort[collection[k].label]) || (pivotValues[i][0].
                                            valueSort.levelName.indexOf(collection[k].label) > -1)))) {
                                        pivotValues[i][j].enableHyperlink = true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (!isNullOrUndefined(this.hyperlinkSettings.headerText)) {
                const headerDelimiter = this.dataSourceSettings.valueSortSettings.headerDelimiter ? this.dataSourceSettings.valueSortSettings.headerDelimiter : '.';
                for (let i = 0; i < pivotValues.length; i++) {
                    for (let j = 1; (pivotValues[i] && j < pivotValues[i].length); j++) {
                        if (pivotValues[i][j].axis === 'value') {
                            let label = this.hyperlinkSettings.headerText;
                            if (pivotValues[i][0].valueSort.levelName.indexOf(label) > -1) {
                                pivotValues[i][0].enableHyperlink = true;
                                pivotValues[i][j].enableHyperlink = true;
                            }
                            else {
                                let isApplyHyperLink = false;
                                for (let k = 0; k < colIndex.length; k++) {
                                    label = headerDelimiter + this.hyperlinkSettings.headerText;
                                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                    if ((headerDelimiter + pivotValues[colIndex[k]][j].valueSort
                                        .levelName).indexOf(label) > -1) {
                                        pivotValues[colIndex[k]][j].enableHyperlink = true;
                                        isApplyHyperLink = true;
                                    }
                                }
                                pivotValues[i][j].enableHyperlink = isApplyHyperLink;
                            }
                        }
                    }
                }
            }
            else {
                return;
            }
        }
    }
    checkCondition(cellValue, conditions, conditionalValue1, conditionalValue2) {
        switch (conditions) {
            case 'LessThan':
                return cellValue < conditionalValue1;
            case 'LessThanOrEqualTo':
                return cellValue <= conditionalValue1;
            case 'GreaterThan':
                return cellValue > conditionalValue1;
            case 'GreaterThanOrEqualTo':
                return cellValue >= conditionalValue1;
            case 'Equals':
                return cellValue === conditionalValue1;
            case 'NotEquals':
                return cellValue !== conditionalValue1;
            case 'Between':
                return (conditionalValue1 < conditionalValue2 && cellValue >= conditionalValue1 && cellValue <= conditionalValue2) ||
                    (conditionalValue1 > conditionalValue2 && cellValue <= conditionalValue1 && cellValue >= conditionalValue2);
            case 'NotBetween':
                return !((conditionalValue1 < conditionalValue2 && cellValue >= conditionalValue1 && cellValue <= conditionalValue2) ||
                    (conditionalValue1 > conditionalValue2 && cellValue <= conditionalValue1 && cellValue >= conditionalValue2));
            default:
                return false;
        }
    }
    /** @hidden */
    updateGroupingReport(newGroupSettings, updateGroupType) {
        if (!this.clonedDataSet && !this.clonedReport) {
            const dataSet = this.engineModule.data;
            this.clonedDataSet = PivotUtil.getClonedData(dataSet);
            const dataSourceSettings = JSON.parse(this.getPersistData()).dataSourceSettings;
            dataSourceSettings.dataSource = [];
            this.clonedReport = this.clonedReport ? this.clonedReport : dataSourceSettings;
        }
        const dateGroup = /_date_group_years|_date_group_quarters|_date_group_quarterYear|_date_group_months|_date_group_days|_date_group_hours|_date_group_minutes|_date_group_seconds/g;
        const data = PivotUtil.getClonedData(this.clonedDataSet);
        const dataSource = this.dataSourceSettings;
        const clonedReport = this.clonedReport.properties ?
            this.clonedReport.properties : this.clonedReport;
        const axisFields = [dataSource.rows, dataSource.columns, dataSource.values, dataSource.filters];
        const fieldSettings = [dataSource.filterSettings, dataSource.sortSettings, dataSource.formatSettings, dataSource.drilledMembers];
        let clonedAxisFields = clonedReport.rows;
        clonedAxisFields = clonedAxisFields.concat(clonedReport.columns, clonedReport.values, clonedReport.filters);
        if (newGroupSettings.length === 0 || newGroupSettings.length > 0) {
            this.engineModule.groupingFields = {};
            this.setProperties({ dataSourceSettings: { dataSource: data, groupSettings: newGroupSettings.length > 0
                        ? dataSource.groupSettings : [] } }, true);
            const isDateGroupUpdated = updateGroupType === 'Date';
            const fields = [];
            let newFieldName;
            for (let i = 0, cnt = axisFields.length; i < cnt; i++) {
                for (let j = 0, len = axisFields[i].length; j < len; j++) {
                    let fieldName = axisFields[i][j].name;
                    if (fields.indexOf(fieldName) === -1) {
                        fields.push(fieldName);
                    }
                    const index = fields.indexOf(fieldName);
                    if ((!isNullOrUndefined(fieldName.match(dateGroup)) &&
                        isDateGroupUpdated) || (fieldName.indexOf('_custom_group') !== -1 &&
                        !PivotUtil.getFieldByName(fieldName.replace('_custom_group', ''), dataSource.groupSettings))) {
                        axisFields[i].splice(j, 1);
                        fields.splice(index, 1);
                        j--;
                        len--;
                        fieldName = fieldName.split('_')[0];
                        let isSameField = false;
                        for (let i = 0; i < axisFields.length; i++) { // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/tslint/config, security/detect-object-injection
                            isSameField = axisFields[i].filter(x => x.name === fieldName).length > 0 ? true : false;
                            if (isSameField) {
                                break;
                            }
                        }
                        if (!isSameField) {
                            newFieldName = fieldName.split('_')[0];
                            const fieldObj = PivotUtil.getFieldByName(newFieldName, clonedAxisFields); // eslint-disable-next-line @typescript-eslint/tslint/config
                            clonedAxisFields = clonedAxisFields.filter(x => x.name !== newFieldName);
                            fields.push(newFieldName);
                            if (fieldObj) { // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                                !isSameField ? axisFields[i].splice(++j, 0, fieldObj) :
                                    axisFields[i].splice(j, 1, fieldObj);
                            }
                        }
                    }
                    else {
                        const fieldObj = PivotUtil.getFieldByName(fieldName, clonedAxisFields);
                        if (fieldObj) {
                            axisFields[i].splice(j, 1, fieldObj);
                        }
                        else if (newFieldName === fieldName) { // eslint-disable-next-line security/detect-object-injection
                            axisFields[i].splice(j, 1);
                        }
                    }
                }
            }
            for (const fieldName of fields) {
                const filterObj = PivotUtil.getFilterItemByName(fieldName, clonedReport.filterSettings);
                const sortObj = PivotUtil.getFieldByName(fieldName, clonedReport.sortSettings);
                const formatObj = PivotUtil.getFieldByName(fieldName, clonedReport.formatSettings);
                const drillObj = PivotUtil.getFieldByName(fieldName, clonedReport.drilledMembers);
                const settingsObj = [filterObj, sortObj, formatObj, drillObj];
                for (let i = 0, cnt = fieldSettings.length; i < cnt; i++) {
                    let isExists = false;
                    for (let j = 0, len = fieldSettings[i].length; j < len; j++) {
                        const name = fieldSettings[i][j].name;
                        if ((!isNullOrUndefined(name.match(dateGroup)) && isDateGroupUpdated) || (name.indexOf('_custom_group') !== -1 &&
                            !PivotUtil.getFieldByName(name.replace('_custom_group', ''), dataSource.groupSettings))) {
                            fieldSettings[i].splice(j, 1);
                            j--;
                            len--;
                        }
                        else if (fieldName === fieldSettings[i][j].name) {
                            isExists = true;
                            if (settingsObj[i]) {
                                fieldSettings[i].splice(j, 1, settingsObj[i]);
                            }
                            else {
                                fieldSettings[i].splice(j, 1);
                                j--;
                                len--;
                            }
                            break;
                        }
                    }
                    if (!isExists && i === 0 && filterObj) {
                        fieldSettings[i].push(filterObj);
                    }
                    if (!isExists && i === 1 && sortObj) {
                        fieldSettings[i].push(sortObj);
                    }
                    if (!isExists && i === 2 && formatObj) {
                        fieldSettings[i].push(formatObj);
                    }
                    if (!isExists && i === 3 && drillObj) {
                        fieldSettings[i].push(drillObj);
                    }
                }
            }
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    removeButtonFocus(e) {
        if (document.querySelectorAll('.e-btn-focused')) {
            removeClass(document.querySelectorAll('.e-btn-focused'), 'e-btn-focused');
        }
    }
    wireEvents() {
        if (this.displayOption.view !== 'Chart') {
            EventHandler.add(this.element, this.isAdaptive ? 'touchend' : 'click', this.mouseClickHandler, this);
            EventHandler.add(this.element, 'mousedown', this.mouseDownHandler, this);
            EventHandler.add(this.element.querySelector('.' + GRID_HEADER), 'mousemove', this.mouseMoveHandler, this);
            EventHandler.add(this.element, 'mouseup', this.mouseUpHandler, this);
            EventHandler.add(this.element, this.isAdaptive ? 'touchend' : 'contextmenu', this.mouseRclickHandler, this);
        }
        EventHandler.add(document, this.isAdaptive ? 'touchend' : 'click', this.removeButtonFocus, this);
        window.addEventListener('resize', this.onWindowResize.bind(this), true);
    }
    unwireEvents() {
        if (this.displayOption.view !== 'Chart') {
            EventHandler.remove(this.element, this.isAdaptive ? 'touchend' : 'click', this.mouseClickHandler);
            EventHandler.remove(this.element, 'mousedown', this.mouseDownHandler);
            if (this.element.querySelector('.' + GRID_HEADER)) {
                EventHandler.remove(this.element.querySelector('.' + GRID_HEADER), 'mousemove', this.mouseMoveHandler);
            }
            EventHandler.remove(this.element, 'mouseup', this.mouseUpHandler);
            EventHandler.remove(this.element, this.isAdaptive ? 'touchend' : 'contextmenu', this.mouseRclickHandler);
        }
        EventHandler.remove(document, this.isAdaptive ? 'touchend' : 'click', this.removeButtonFocus);
        window.removeEventListener('resize', this.onWindowResize.bind(this), true);
    }
    /** @hidden */
    actionBeginMethod() {
        const eventArgs = {
            dataSourceSettings: PivotUtil.getClonedDataSourceSettings(this.dataSourceSettings),
            actionName: this.actionObj.actionName,
            fieldInfo: this.actionObj.fieldInfo,
            cancel: false
        };
        this.trigger(actionBegin, eventArgs);
        return eventArgs.cancel;
    }
    /** @hidden */
    actionCompleteMethod() {
        const eventArgs = {
            dataSourceSettings: PivotUtil.getClonedDataSourceSettings(this.dataSourceSettings),
            actionName: this.actionObj.actionName,
            fieldInfo: this.actionObj.fieldInfo,
            actionInfo: this.actionObj.actionInfo
        };
        this.trigger(actionComplete, eventArgs);
        this.actionObj.actionName = '';
        this.actionObj.actionInfo = undefined;
        this.actionObj.fieldInfo = undefined;
    }
    /** @hidden */
    actionFailureMethod(error) {
        const eventArgs = {
            actionName: this.actionObj.actionName,
            errorInfo: error
        };
        this.trigger(actionFailure, eventArgs);
    }
    /** @hidden */
    getActionCompleteName() {
        let actionName;
        switch (this.actionObj.actionName) {
            case openConditionalFormatting:
                actionName = conditionallyFormatted;
                break;
            case openNumberFormatting:
                actionName = numberFormatted;
                break;
            case tableView:
                actionName = tableViewed;
                break;
            case chartView:
                actionName = chartViewed;
                break;
            case hideSubTotals:
                actionName = subTotalsHidden;
                break;
            case subTotalsRow:
                actionName = subTotalsRowShown;
                break;
            case subTotalsColumn:
                actionName = subTotalsColumnShown;
                break;
            case showSubTotals:
                actionName = subTotalsShown;
                break;
            case hideGrandTotals:
                actionName = grandTotalsHidden;
                break;
            case grandTotalsRow:
                actionName = grandTotalsRowShown;
                break;
            case grandTotalsColumn:
                actionName = grandTotalsColumnShown;
                break;
            case showGrandTotals:
                actionName = grandTotalsShown;
                break;
            case sortValue:
                actionName = valueSorted;
                break;
            case openCalculatedField:
                actionName = calculatedFieldApplied;
                break;
            case editCalculatedField:
                actionName = calculatedFieldEdited;
                break;
            case sortField:
                actionName = fieldSorted;
                break;
            case filterField:
                actionName = fieldFiltered;
                break;
            case removeField:
                actionName = fieldRemoved;
                break;
            case aggregateField:
                actionName = fieldAggregated;
                break;
            case editRecord:
                actionName = recordEdited;
                break;
            case reportChange:
                actionName = reportChanged;
                break;
            case saveEditedRecords:
                actionName = editedRecordsSaved;
                break;
            case addNewRecord:
                actionName = newRecordAdded;
                break;
            case removeRecord:
                actionName = recordRemoved;
                break;
            case pngExport:
                actionName = pngExported;
                break;
            case jpegExport:
                actionName = jpegExported;
                break;
            case svgExport:
                actionName = svgExported;
                break;
            case pdfExport:
                actionName = pdfExported;
                break;
            case csvExport:
                actionName = csvExported;
                break;
            case excelExport:
                actionName = excelExported;
                break;
            case windowResize:
                actionName = windowResized;
                break;
            case saveCurrentReport:
                actionName = reportSaved;
                break;
            case addNewReport:
                actionName = newReportAdded;
                break;
            case saveAsCurrentReport:
                actionName = reportReSaved;
                break;
            case renameCurrentReport:
                actionName = reportRenamed;
                break;
            case horizontalScroll:
                actionName = horizontalScrolled;
                break;
            case verticalScroll:
                actionName = verticalScrolled;
                break;
            case rowPageNavigation:
                actionName = rowPageNavigated;
                break;
            case columnPageNavigation:
                actionName = columnPageNavigated;
                break;
            default:
                actionName = this.actionObj.actionName;
        }
        return actionName;
    }
    /** @hidden */
    getStackedColumns(gridcolumns, stackedColumns) {
        for (const column of gridcolumns) {
            stackedColumns.push(column);
            if (column.columns && column.columns.length > 0) {
                this.getStackedColumns(column.columns, stackedColumns);
            }
        }
        return stackedColumns;
    }
    /**
     * To destroy the PivotView elements.
     *
     * @returns {void}
     */
    destroy() {
        this.removeInternalEvents();
        if (this.engineModule) {
            this.engineModule.fieldList = {};
            this.engineModule.rMembers = null;
            this.engineModule.cMembers = null;
            this.engineModule.valueMatrix = null;
            this.engineModule.indexMatrix = null;
            this.engineModule = {};
        }
        if (this.olapEngineModule) {
            this.olapEngineModule.fieldList = {};
            this.olapEngineModule = {};
        }
        if (this.showGroupingBar && this.groupingBarModule) {
            this.groupingBarModule.destroy();
        }
        if (this.allowGrouping && this.groupingModule) {
            this.groupingModule.destroy();
        }
        if (this.showToolbar && this.toolbarModule) {
            this.toolbarModule.destroy();
        }
        if (this.enablePaging && this.pagerModule) {
            this.pagerModule.destroy();
        }
        if (this.enableVirtualization && this.virtualscrollModule) {
            this.virtualscrollModule.destroy();
        }
        if (this.allowConditionalFormatting && this.conditionalFormattingModule) {
            this.conditionalFormattingModule.destroy();
        }
        if (this.allowNumberFormatting && this.numberFormattingModule) {
            this.numberFormattingModule.destroy();
        }
        if (this.contextMenuModule) {
            this.contextMenuModule.destroy();
        }
        if (this.keyboardModule) {
            this.keyboardModule.destroy();
        }
        if (this.tooltip && !this.tooltip.isDestroyed) {
            this.tooltip.destroy();
        }
        if (this.calculatedFieldModule) {
            this.calculatedFieldModule.destroy();
        }
        if (this.chart && !this.chart.isDestroyed) {
            this.chart.destroy();
            if (this.chart.isDestroyed && select('#' + this.element.id + '_chart', this.element)) {
                remove(select('#' + this.element.id + '_chart', this.element));
            }
        }
        if (this.grid && !this.grid.isDestroyed) {
            this.grid.destroy();
            if (this.grid.isDestroyed && select('#' + this.element.id + '_grid', this.element)) {
                remove(select('#' + this.element.id + '_grid', this.element));
            }
        }
        if (this.commonModule) {
            this.commonModule.destroy();
        }
        if (this.pivotChartModule) {
            this.pivotChartModule.destroy();
        }
        if (this.pivotButtonModule && !this.pivotButtonModule.isDestroyed) {
            this.pivotButtonModule.destroy();
        }
        if (this.pivotFieldListModule && !this.pivotFieldListModule.isDestroyed) {
            this.pivotFieldListModule.destroy();
            if (this.pivotFieldListModule.isDestroyed && select('#' + this.element.id + '_PivotFieldList', this.element) !== null) {
                remove(select('#' + this.element.id + '_PivotFieldList', this.element));
            }
        }
        if ((this.allowDrillThrough || (this.editSettings && this.editSettings.allowEditing)) && this.drillThroughModule) {
            this.drillThroughModule.destroy();
        }
        if (this.chartExportModule) {
            this.chartExportModule.destroy();
        }
        this.unwireEvents();
        super.destroy();
        if (this.groupingBarModule) {
            this.groupingBarModule = null;
        }
        if (this.groupingModule) {
            this.groupingModule = null;
        }
        if (this.pivotFieldListModule) {
            this.pivotFieldListModule = null;
        }
        if (this.calculatedFieldModule) {
            this.calculatedFieldModule = null;
        }
        if (this.conditionalFormattingModule) {
            this.conditionalFormattingModule = null;
        }
        if (this.numberFormattingModule) {
            this.numberFormattingModule = null;
        }
        if (this.toolbarModule) {
            this.toolbarModule = null;
        }
        if (this.pagerModule) {
            this.pagerModule = null;
        }
        if (this.virtualscrollModule) {
            this.virtualscrollModule = null;
        }
        if (this.contextMenuModule) {
            this.contextMenuModule = null;
        }
        if (this.keyboardModule) {
            this.keyboardModule = null;
        }
        if (this.tooltip) {
            this.tooltip = null;
        }
        if (this.chart) {
            this.chart = null;
        }
        if (this.grid) {
            this.grid = null;
        }
        if (this.commonModule) {
            this.commonModule = null;
        }
        if (this.pivotChartModule) {
            this.pivotChartModule = null;
        }
        if (this.pivotButtonModule) {
            this.pivotButtonModule = null;
        }
        if (this.renderModule) {
            this.renderModule = null;
        }
        if (this.axisFieldModule) {
            this.axisFieldModule = null;
        }
        if (this.pdfExportModule) {
            this.pdfExportModule = null;
        }
        if (this.excelExportModule) {
            this.excelExportModule = null;
        }
        if (this.drillThroughModule) {
            this.drillThroughModule = null;
        }
        if (this.clonedDataSet) {
            this.clonedDataSet = null;
        }
        if (this.clonedReport) {
            this.clonedReport = null;
        }
        if (this.pagerModule) {
            this.pagerModule = null;
        }
        if (this.chartExportModule) {
            this.chartExportModule = null;
        }
        this.element.innerHTML = '';
        removeClass([this.element], ROOT);
        removeClass([this.element], RTL);
        removeClass([this.element], DEVICE);
    }
    /**
     * Method to open the number formatting dialog to set the format dynamically.
     *
     * @returns {void}
     */
    showNumberFormattingDialog() {
        if (this.allowNumberFormatting) {
            this.numberFormattingModule.showNumberFormattingDialog();
        }
    }
    /** @hidden */
    getValuesHeader(pivotCell, type) {
        const values = this.dataSourceSettings.values;
        if (type === 'value' && !isNullOrUndefined(pivotCell.valueSort) && (this.localeObj.getConstant('grandTotal') + this.dataSourceSettings.valueSortSettings.headerDelimiter + pivotCell.formattedText)
            === pivotCell.valueSort.levelName && ((pivotCell.axis === 'column' && this.dataSourceSettings.columns.length === 0 && this.dataSourceSettings.valueAxis === 'column') || (pivotCell.axis === 'row' &&
            this.dataSourceSettings.rows.length === 0 && this.dataSourceSettings.valueAxis === 'row'))) {
            return this.localeObj.getConstant('total') + ' ' + this.localeObj.getConstant(this.engineModule.fieldList[pivotCell.actualText].aggregateType) + ' ' +
                this.localeObj.getConstant('of') + ' ' + pivotCell.formattedText;
        }
        else if (type === 'grandTotal' && values.length === 1 && this.dataSourceSettings.valueAxis === 'row' && pivotCell.formattedText === this.localeObj.getConstant('grandTotal')) {
            return this.localeObj.getConstant('total') + ' ' + this.localeObj.getConstant(values[values.length - 1].type) + ' ' +
                this.localeObj.getConstant('of') + ' ' + (!isNullOrUndefined(values[values.length - 1].caption) ? values[values.length - 1].caption
                : values[values.length - 1].name);
        }
        return pivotCell.formattedText;
    }
};
__decorate([
    Property('USD')
], PivotView.prototype, "currencyCode", void 0);
__decorate([
    Property(false)
], PivotView.prototype, "showFieldList", void 0);
__decorate([
    Complex({}, GridSettings)
], PivotView.prototype, "gridSettings", void 0);
__decorate([
    Complex({}, ChartSettings)
], PivotView.prototype, "chartSettings", void 0);
__decorate([
    Complex({}, GroupingBarSettings)
], PivotView.prototype, "groupingBarSettings", void 0);
__decorate([
    Complex({}, HyperlinkSettings)
], PivotView.prototype, "hyperlinkSettings", void 0);
__decorate([
    Complex({}, PageSettings)
], PivotView.prototype, "pageSettings", void 0);
__decorate([
    Complex({}, PagerSettings)
], PivotView.prototype, "pagerSettings", void 0);
__decorate([
    Complex({}, DataSourceSettings)
], PivotView.prototype, "dataSourceSettings", void 0);
__decorate([
    Complex({}, CellEditSettings)
], PivotView.prototype, "editSettings", void 0);
__decorate([
    Complex({}, DisplayOption)
], PivotView.prototype, "displayOption", void 0);
__decorate([
    Property()
], PivotView.prototype, "pivotValues", void 0);
__decorate([
    Property(false)
], PivotView.prototype, "showGroupingBar", void 0);
__decorate([
    Property(true)
], PivotView.prototype, "showTooltip", void 0);
__decorate([
    Property(false)
], PivotView.prototype, "showToolbar", void 0);
__decorate([
    Property([])
], PivotView.prototype, "toolbar", void 0);
__decorate([
    Property(false)
], PivotView.prototype, "showValuesButton", void 0);
__decorate([
    Property(false)
], PivotView.prototype, "allowCalculatedField", void 0);
__decorate([
    Property(false)
], PivotView.prototype, "enableFieldSearching", void 0);
__decorate([
    Property(false)
], PivotView.prototype, "enableValueSorting", void 0);
__decorate([
    Property(false)
], PivotView.prototype, "allowConditionalFormatting", void 0);
__decorate([
    Property(false)
], PivotView.prototype, "allowNumberFormatting", void 0);
__decorate([
    Property('auto')
], PivotView.prototype, "height", void 0);
__decorate([
    Property('auto')
], PivotView.prototype, "width", void 0);
__decorate([
    Property(false)
], PivotView.prototype, "allowExcelExport", void 0);
__decorate([
    Property(false)
], PivotView.prototype, "enableVirtualization", void 0);
__decorate([
    Property(false)
], PivotView.prototype, "enablePaging", void 0);
__decorate([
    Property(false)
], PivotView.prototype, "allowDrillThrough", void 0);
__decorate([
    Property(false)
], PivotView.prototype, "allowPdfExport", void 0);
__decorate([
    Property(false)
], PivotView.prototype, "allowDeferLayoutUpdate", void 0);
__decorate([
    Property(false)
], PivotView.prototype, "allowDataCompression", void 0);
__decorate([
    Property(1000)
], PivotView.prototype, "maxNodeLimitInMemberEditor", void 0);
__decorate([
    Property(10000)
], PivotView.prototype, "maxRowsInDrillThrough", void 0);
__decorate([
    Property(true)
], PivotView.prototype, "loadOnDemandInMemberEditor", void 0);
__decorate([
    Property(false)
], PivotView.prototype, "enableHtmlSanitizer", void 0);
__decorate([
    Property()
], PivotView.prototype, "cellTemplate", void 0);
__decorate([
    Property()
], PivotView.prototype, "toolbarTemplate", void 0);
__decorate([
    Property()
], PivotView.prototype, "tooltipTemplate", void 0);
__decorate([
    Property()
], PivotView.prototype, "spinnerTemplate", void 0);
__decorate([
    Property(false)
], PivotView.prototype, "allowGrouping", void 0);
__decorate([
    Property(true)
], PivotView.prototype, "exportAllPages", void 0);
__decorate([
    Property(['Sum', 'Count', 'DistinctCount', 'Product', 'Min', 'Max', 'Avg', 'Median', 'Index', 'PopulationVar', 'SampleVar', 'PopulationStDev', 'SampleStDev', 'RunningTotals', 'PercentageOfGrandTotal', 'PercentageOfColumnTotal', 'PercentageOfRowTotal', 'PercentageOfParentColumnTotal', 'PercentageOfParentRowTotal', 'DifferenceFrom', 'PercentageOfDifferenceFrom', 'PercentageOfParentTotal'])
], PivotView.prototype, "aggregateTypes", void 0);
__decorate([
    Property(['Column', 'Bar', 'Line', 'Area', 'Scatter', 'Polar', 'StackingColumn', 'StackingArea', 'StackingBar', 'StackingLine', 'StepLine', 'StepArea', 'SplineArea', 'Spline', 'StackingColumn100', 'StackingBar100', 'StackingArea100', 'StackingLine100', 'Bubble', 'Pareto', 'Radar', 'Pie', 'Doughnut', 'Funnel', 'Pyramid'])
], PivotView.prototype, "chartTypes", void 0);
__decorate([
    Property('')
], PivotView.prototype, "cssClass", void 0);
__decorate([
    Event()
], PivotView.prototype, "queryCellInfo", void 0);
__decorate([
    Event()
], PivotView.prototype, "headerCellInfo", void 0);
__decorate([
    Event()
], PivotView.prototype, "resizing", void 0);
__decorate([
    Event()
], PivotView.prototype, "resizeStop", void 0);
__decorate([
    Event()
], PivotView.prototype, "pdfHeaderQueryCellInfo", void 0);
__decorate([
    Event()
], PivotView.prototype, "pdfQueryCellInfo", void 0);
__decorate([
    Event()
], PivotView.prototype, "excelHeaderQueryCellInfo", void 0);
__decorate([
    Event()
], PivotView.prototype, "excelQueryCellInfo", void 0);
__decorate([
    Event()
], PivotView.prototype, "columnDragStart", void 0);
__decorate([
    Event()
], PivotView.prototype, "columnDrag", void 0);
__decorate([
    Event()
], PivotView.prototype, "columnDrop", void 0);
__decorate([
    Event()
], PivotView.prototype, "beforePdfExport", void 0);
__decorate([
    Event()
], PivotView.prototype, "beforeExcelExport", void 0);
__decorate([
    Event()
], PivotView.prototype, "beforeColumnsRender", void 0);
__decorate([
    Event()
], PivotView.prototype, "selected", void 0);
__decorate([
    Event()
], PivotView.prototype, "cellDeselected", void 0);
__decorate([
    Event()
], PivotView.prototype, "rowSelected", void 0);
__decorate([
    Event()
], PivotView.prototype, "rowDeselected", void 0);
__decorate([
    Event()
], PivotView.prototype, "chartTooltipRender", void 0);
__decorate([
    Event()
], PivotView.prototype, "chartLegendClick", void 0);
__decorate([
    Event()
], PivotView.prototype, "chartLoaded", void 0);
__decorate([
    Event()
], PivotView.prototype, "chartLoad", void 0);
__decorate([
    Event()
], PivotView.prototype, "chartResized", void 0);
__decorate([
    Event()
], PivotView.prototype, "chartAxisLabelRender", void 0);
__decorate([
    Event()
], PivotView.prototype, "multiLevelLabelClick", void 0);
__decorate([
    Event()
], PivotView.prototype, "chartPointClick", void 0);
__decorate([
    Event()
], PivotView.prototype, "contextMenuClick", void 0);
__decorate([
    Event()
], PivotView.prototype, "contextMenuOpen", void 0);
__decorate([
    Event()
], PivotView.prototype, "onPdfCellRender", void 0);
__decorate([
    Event()
], PivotView.prototype, "saveReport", void 0);
__decorate([
    Event()
], PivotView.prototype, "fetchReport", void 0);
__decorate([
    Event()
], PivotView.prototype, "loadReport", void 0);
__decorate([
    Event()
], PivotView.prototype, "renameReport", void 0);
__decorate([
    Event()
], PivotView.prototype, "removeReport", void 0);
__decorate([
    Event()
], PivotView.prototype, "newReport", void 0);
__decorate([
    Event()
], PivotView.prototype, "toolbarRender", void 0);
__decorate([
    Event()
], PivotView.prototype, "toolbarClick", void 0);
__decorate([
    Event()
], PivotView.prototype, "load", void 0);
__decorate([
    Event()
], PivotView.prototype, "enginePopulating", void 0);
__decorate([
    Event()
], PivotView.prototype, "enginePopulated", void 0);
__decorate([
    Event()
], PivotView.prototype, "onFieldDropped", void 0);
__decorate([
    Event()
], PivotView.prototype, "fieldDrop", void 0);
__decorate([
    Event()
], PivotView.prototype, "fieldDragStart", void 0);
__decorate([
    Event()
], PivotView.prototype, "dataBound", void 0);
__decorate([
    Event()
], PivotView.prototype, "created", void 0);
__decorate([
    Event()
], PivotView.prototype, "destroyed", void 0);
__decorate([
    Event()
], PivotView.prototype, "beforeExport", void 0);
__decorate([
    Event()
], PivotView.prototype, "exportComplete", void 0);
__decorate([
    Event()
], PivotView.prototype, "conditionalFormatting", void 0);
__decorate([
    Event()
], PivotView.prototype, "memberFiltering", void 0);
__decorate([
    Event()
], PivotView.prototype, "cellClick", void 0);
__decorate([
    Event()
], PivotView.prototype, "drillThrough", void 0);
__decorate([
    Event()
], PivotView.prototype, "editCompleted", void 0);
__decorate([
    Event()
], PivotView.prototype, "beginDrillThrough", void 0);
__decorate([
    Event()
], PivotView.prototype, "hyperlinkCellClick", void 0);
__decorate([
    Event()
], PivotView.prototype, "cellSelecting", void 0);
__decorate([
    Event()
], PivotView.prototype, "drill", void 0);
__decorate([
    Event()
], PivotView.prototype, "cellSelected", void 0);
__decorate([
    Event()
], PivotView.prototype, "chartSeriesCreated", void 0);
__decorate([
    Event()
], PivotView.prototype, "aggregateCellInfo", void 0);
__decorate([
    Event()
], PivotView.prototype, "fieldListRefreshed", void 0);
__decorate([
    Event()
], PivotView.prototype, "memberEditorOpen", void 0);
__decorate([
    Event()
], PivotView.prototype, "calculatedFieldCreate", void 0);
__decorate([
    Event()
], PivotView.prototype, "numberFormatting", void 0);
__decorate([
    Event()
], PivotView.prototype, "aggregateMenuOpen", void 0);
__decorate([
    Event()
], PivotView.prototype, "fieldRemove", void 0);
__decorate([
    Event()
], PivotView.prototype, "beforeServiceInvoke", void 0);
__decorate([
    Event()
], PivotView.prototype, "actionBegin", void 0);
__decorate([
    Event()
], PivotView.prototype, "actionComplete", void 0);
__decorate([
    Event()
], PivotView.prototype, "actionFailure", void 0);
__decorate([
    Event()
], PivotView.prototype, "onHeadersSort", void 0);
PivotView = __decorate([
    NotifyPropertyChanges
], PivotView);

/**
 * Base export
 */

/**
 * Renderer Export
 */

/**
 * This is a file to perform common utility for OLAP and Relational datasource
 *
 * @hidden
 */
class PivotExportUtil {
    /* eslint-disable @typescript-eslint/no-explicit-any */
    static getClonedPivotValues(pivotValues) {
        const clonedSets = [];
        for (let i = 0; i < pivotValues.length; i++) {
            if (pivotValues[i]) {
                clonedSets[i] = [];
                for (let j = 0; j < pivotValues[i].length; j++) {
                    if (pivotValues[i][j]) {
                        clonedSets[i][j] =
                            this.getClonedPivotValueObj(pivotValues[i][j]);
                    }
                }
            }
        }
        return clonedSets;
    }
    static getClonedPivotValueObj(data) {
        let keyPos = 0;
        let framedSet = {};
        if (!(data === null || data === undefined)) {
            const fields = Object.keys(data);
            while (keyPos < fields.length) {
                framedSet[fields[keyPos]] = data[fields[keyPos]];
                keyPos++;
            }
        }
        else {
            framedSet = data;
        }
        return framedSet;
    }
    static isContainCommonElements(collection1, collection2) {
        for (let i = 0, cnt = collection1.length; i < cnt; i++) {
            for (let j = 0, lnt = collection2.length; j < lnt; j++) {
                if (collection2[j] === collection1[i]) {
                    return true;
                }
            }
        }
        return false;
    }
}

/**
 * @hidden
 * `ExcelExport` module is used to handle the Excel export action.
 */
class ExcelExport$1 {
    /**
     * Constructor for the PivotGrid Excel Export module.
     *
     * @param {PivotView} parent - Instance of pivot table.
     * @hidden
     */
    constructor(parent) {
        this.actualrCnt = 0;
        this.parent = parent;
    }
    /**
     * For internal use only - Get the module name.
     *
     * @returns {string} - string.
     * @private
     */
    getModuleName() {
        return 'excelExport';
    }
    addHeaderAndFooter(excelExportProperties, stringValue, type, rowCount) {
        let cells = [];
        if (!isNullOrUndefined(excelExportProperties.rows)) {
            this.actualrCnt = (type === 'footer') ? this.actualrCnt + rowCount - (excelExportProperties.rows[0].cells.length) : this.actualrCnt;
            const row = excelExportProperties.rows;
            for (let i = 0; i < row.length; i++) {
                let spanCount = 0;
                cells = [];
                const currentRow = row[i];
                for (let j = 0; j < currentRow.cells.length; j++) {
                    cells.push({
                        index: spanCount + 1, value: currentRow.cells[j].value,
                        colSpan: currentRow.cells[j].colSpan, rowSpan: currentRow.cells[j].rowSpan,
                        style: currentRow.cells[j].style
                    });
                    spanCount = spanCount + cells[j].colSpan;
                }
                /* eslint-enable @typescript-eslint/no-explicit-any */
                this.actualrCnt++;
                this.rows.push({ index: this.actualrCnt, cells: cells });
            }
            this.actualrCnt = (type === 'header') ? rowCount : this.actualrCnt;
        }
        else {
            if (stringValue !== '') {
                if (type === 'footer') {
                    this.actualrCnt++;
                }
                cells.push({
                    index: 1, value: stringValue
                });
                this.rows.push({ index: this.actualrCnt + 1, cells: cells });
                this.actualrCnt = (type === 'header') ? this.actualrCnt + 2 : this.actualrCnt;
            }
        }
    }
    /**
     *
     * Method to perform excel export.
     *
     * @hidden
     */
    exportToExcel(type, exportProperties, isBlob) {
        this.rows = [];
        this.actualrCnt = 0;
        const isHeaderSet = !isNullOrUndefined(exportProperties) && !isNullOrUndefined(exportProperties.header);
        const isFooterSet = !isNullOrUndefined(exportProperties) && !isNullOrUndefined(exportProperties.footer);
        const isFileNameSet = !isNullOrUndefined(exportProperties) && !isNullOrUndefined(exportProperties.fileName);
        this.engine = this.parent.dataType === 'olap' ? this.parent.olapEngineModule : this.parent.engineModule;
        /** Event trigerring */
        let clonedValues;
        const currentPivotValues = PivotExportUtil.getClonedPivotValues(this.engine.pivotValues);
        const customFileName = isFileNameSet ? exportProperties.fileName : 'default.xlsx';
        if (this.parent.exportAllPages && (this.parent.enableVirtualization || this.parent.enablePaging) && this.parent.dataType !== 'olap') {
            const pageSettings = this.engine.pageSettings;
            this.engine.pageSettings = null;
            this.engine.isPagingOrVirtualizationEnabled = false;
            this.engine.generateGridData(this.parent.dataSourceSettings, true);
            this.parent.applyFormatting(this.engine.pivotValues);
            clonedValues = PivotExportUtil.getClonedPivotValues(this.engine.pivotValues);
            this.engine.pivotValues = currentPivotValues;
            this.engine.pageSettings = pageSettings;
            this.engine.isPagingOrVirtualizationEnabled = true;
        }
        else {
            clonedValues = currentPivotValues;
        }
        const args = {
            fileName: customFileName, header: '', footer: '', dataCollections: [clonedValues], excelExportProperties: exportProperties
        };
        let fileName;
        let header;
        let footer;
        let dataCollections;
        this.parent.trigger(beforeExport, args, (observedArgs) => {
            fileName = observedArgs.fileName;
            header = observedArgs.header;
            footer = observedArgs.footer;
            dataCollections = observedArgs.dataCollections;
        });
        if (!isHeaderSet && isNullOrUndefined(args.excelExportProperties) && header !== '') {
            this.addHeaderAndFooter({}, header, 'header', undefined);
        }
        else if (!isNullOrUndefined(args.excelExportProperties) && !isNullOrUndefined(args.excelExportProperties.header)) {
            this.addHeaderAndFooter(args.excelExportProperties.header, '', 'header', args.excelExportProperties.header.headerRows);
        }
        /** Fill data and export */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const workSheets = [];
        for (let dataColl = 0; dataColl < dataCollections.length; dataColl++) {
            const pivotValues = dataCollections[dataColl];
            let colLen = 0;
            const rowLen = pivotValues.length;
            const formatList = this.parent.renderModule.getFormatList();
            let maxLevel = 0;
            for (let rCnt = 0; rCnt < rowLen; rCnt++) {
                if (pivotValues[rCnt]) {
                    this.actualrCnt++;
                    colLen = pivotValues[rCnt].length;
                    const cells = [];
                    for (let cCnt = 0; cCnt < colLen; cCnt++) {
                        if (pivotValues[rCnt][cCnt]) {
                            const pivotCell = pivotValues[rCnt][cCnt];
                            if (pivotCell && pivotCell.axis === 'value' && pivotCell.formattedText === '') {
                                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                pivotCell.value = pivotCell.formattedText;
                            }
                            const field = (this.parent.dataSourceSettings.valueAxis === 'row' &&
                                this.parent.dataType === 'olap' && pivotCell.rowOrdinal &&
                                this.engine.tupRowInfo[pivotCell.rowOrdinal]) ?
                                this.engine.tupRowInfo[pivotCell.rowOrdinal].measureName :
                                pivotCell.actualText;
                            const styles = (pivotCell.axis === 'row') ? { hAlign: 'Left', bold: true, wrapText: true } : { numberFormat: formatList[field], bold: false, wrapText: true };
                            const headerStyle = { bold: true, vAlign: 'Center', wrapText: true, indent: cCnt === 0 ? pivotCell.level * 10 : 0 };
                            if (!(pivotCell.level === -1 && !pivotCell.rowSpan)) {
                                const aggMatrix = this.engine.aggregatedValueMatrix;
                                let cellValue = pivotCell.axis === 'value' ? ((aggMatrix[rCnt] && aggMatrix[rCnt][cCnt]) ? aggMatrix[rCnt][cCnt] : (pivotCell.formattedText === '#DIV/0!' ? pivotCell.formattedText : pivotCell.value)) : pivotCell.formattedText;
                                const isgetValuesHeader = ((this.parent.dataSourceSettings.rows.length === 0 && this.parent.dataSourceSettings.valueAxis === 'row')
                                    || (this.parent.dataSourceSettings.columns.length === 0 && this.parent.dataSourceSettings.valueAxis === 'column'));
                                if (pivotCell.type === 'grand sum' && !(this.parent.dataSourceSettings.values.length === 1 && this.parent.dataSourceSettings.valueAxis === 'row' && pivotCell.axis === 'column')) {
                                    cellValue = isgetValuesHeader ? this.parent.getValuesHeader(pivotCell, 'grandTotal') : this.parent.localeObj.getConstant('grandTotal');
                                }
                                else if (pivotCell.type === 'sum') {
                                    cellValue = cellValue.toString().replace('Total', this.parent.localeObj.getConstant('total'));
                                }
                                else {
                                    cellValue = (!isNullOrUndefined(pivotCell.valueSort) && (this.parent.localeObj.getConstant('grandTotal') + this.parent.dataSourceSettings.valueSortSettings.headerDelimiter + pivotCell.formattedText
                                        === pivotCell.valueSort.levelName) && isgetValuesHeader) ? this.parent.getValuesHeader(pivotCell, 'value') : cellValue;
                                }
                                if (!(pivotCell.level === -1 && !pivotCell.rowSpan)) {
                                    cells.push({
                                        index: cCnt + 1, value: cellValue,
                                        colSpan: pivotCell.colSpan, rowSpan: (pivotCell.rowSpan === -1 ? 1 : pivotCell.rowSpan)
                                    });
                                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                    const lastCell = cells[cells.length - 1];
                                    if (pivotCell.axis === 'value') {
                                        if (isNaN(pivotCell.value) || pivotCell.formattedText === '' ||
                                            pivotCell.formattedText === undefined || isNullOrUndefined(pivotCell.value)) {
                                            lastCell.value = type === 'Excel' ? null : '';
                                        }
                                        styles.numberFormat = typeof cellValue === 'string' ? undefined : styles.numberFormat;
                                        lastCell.style = !isNullOrUndefined(lastCell.value) ? styles : { bold: false, wrapText: true };
                                    }
                                    else {
                                        lastCell.style = headerStyle;
                                        if (pivotCell.axis === 'row' && cCnt === 0) {
                                            lastCell.style = styles;
                                            if (this.parent.dataType === 'olap') {
                                                const indent = this.parent.renderModule.indentCollection[rCnt];
                                                lastCell.style.indent = indent * 2;
                                                maxLevel = maxLevel > indent ? maxLevel : indent;
                                            }
                                            else {
                                                const levelName = pivotCell.valueSort ? pivotCell.valueSort.levelName.toString() : '';
                                                const memberPos = pivotCell.actualText ?
                                                    pivotCell.actualText.toString().
                                                        split(this.parent.dataSourceSettings.valueSortSettings.headerDelimiter).length : 0;
                                                const levelPosition = levelName.
                                                    split(this.parent.dataSourceSettings.valueSortSettings.headerDelimiter).length -
                                                    (memberPos ? memberPos - 1 : memberPos);
                                                const level = levelPosition ? (levelPosition - 1) : 0;
                                                lastCell.style.indent = level * 2;
                                                maxLevel = level > maxLevel ? level : maxLevel;
                                            }
                                        }
                                    }
                                    if (pivotCell.style || lastCell.style.backColor || lastCell.style.backgroundColor ||
                                        lastCell.style.fontColor || lastCell.style.fontName || lastCell.style.fontSize) {
                                        lastCell.style.backColor = lastCell.style.backgroundColor ? lastCell.style.backgroundColor
                                            : pivotCell.style.backgroundColor;
                                        lastCell.style.fontColor = lastCell.style.fontColor ? lastCell.style.fontColor
                                            : pivotCell.style.color;
                                        lastCell.style.fontName = lastCell.style.fontName ? lastCell.style.fontName
                                            : pivotCell.style.fontFamily;
                                        lastCell.style.fontSize = lastCell.style.fontSize ? Number(lastCell.style.fontSize) : Number(pivotCell.style.fontSize.split('px')[0]);
                                    }
                                    lastCell.style.borders = { color: '#000000', lineStyle: 'Thin' };
                                    let excelHeaderQueryCellInfoArgs;
                                    let excelQueryCellInfoArgs;
                                    if (pivotCell.axis === 'column') {
                                        excelHeaderQueryCellInfoArgs = {
                                            style: headerStyle,
                                            cell: pivotCell
                                        };
                                        this.parent.trigger(excelHeaderQueryCellInfo, excelHeaderQueryCellInfoArgs);
                                    }
                                    else {
                                        excelQueryCellInfoArgs = {
                                            style: styles,
                                            cell: pivotCell,
                                            column: undefined,
                                            data: pivotValues,
                                            value: cellValue
                                        };
                                        this.parent.trigger(excelQueryCellInfo, excelQueryCellInfoArgs);
                                    }
                                    lastCell.value = (pivotCell.axis === 'column') ? excelHeaderQueryCellInfoArgs.cell.formattedText : excelQueryCellInfoArgs.value;
                                    lastCell.style = (pivotCell.axis === 'column') ? excelHeaderQueryCellInfoArgs.style : excelQueryCellInfoArgs.style;
                                }
                            }
                            cCnt = cCnt + (pivotCell.colSpan ? (pivotCell.colSpan - 1) : 0);
                        }
                        else {
                            const pivotCell = { formattedText: '' };
                            let excelHeaderQueryCellInfoArgs;
                            if (pivotCell) {
                                excelHeaderQueryCellInfoArgs = {
                                    style: undefined,
                                    cell: pivotCell
                                };
                                this.parent.trigger(excelHeaderQueryCellInfo, excelHeaderQueryCellInfoArgs);
                            }
                            cells.push({
                                index: cCnt + 1, colSpan: 1, rowSpan: 1, value: pivotCell.formattedText,
                                style: excelHeaderQueryCellInfoArgs.style
                            });
                        }
                    }
                    this.rows.push({ index: this.actualrCnt, cells: cells });
                }
            }
            if (isFooterSet) {
                this.addHeaderAndFooter(exportProperties.footer, '', 'footer', exportProperties.footer.footerRows);
            }
            else if (!isFooterSet && footer !== '' && isNullOrUndefined(args.excelExportProperties)) {
                this.addHeaderAndFooter({}, footer, 'footer', undefined);
            }
            else if (!isNullOrUndefined(args.excelExportProperties) && !isNullOrUndefined(args.excelExportProperties.footer)) {
                this.addHeaderAndFooter(args.excelExportProperties.footer, '', 'footer', args.excelExportProperties.footer.footerRows);
            }
            const columns = [];
            for (let cCnt = 0; cCnt < colLen; cCnt++) {
                columns.push({ index: cCnt + 1, width: 100 });
            }
            if (maxLevel > 0) {
                columns[0].width = 100 + (maxLevel * 20);
            }
            workSheets.push({ columns: columns, rows: this.rows });
        }
        this.book = new Workbook({ worksheets: workSheets }, type === 'Excel' ? 'xlsx' : 'csv', undefined, this.parent.currencyCode);
        const fileExtension = fileName.split('.').pop();
        if (!isBlob) {
            this.book.save(fileExtension === 'xlsx' || fileExtension === 'csv' ?
                fileName : (fileName + (type === 'Excel' ? '.xlsx' : '.csv')));
        }
        else {
            this.blobData = this.book.saveAsBlob(fileExtension === 'xlsx' || type === 'Excel' ?
                'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' : 'text/csv');
        }
        const exportCompleteEventArgs = {
            type: type,
            promise: isBlob ? this.blobData : null
        };
        this.parent.trigger(exportComplete, exportCompleteEventArgs);
    }
    /**
     * To destroy the excel export module
     *
     * @returns {void}
     * @hidden
     */
    destroy() {
        if (this.engine) {
            this.engine = null;
        }
        if (this.blobData) {
            this.blobData = null;
        }
        if (this.book) {
            this.book = null;
        }
    }
}

/**
 * @hidden
 * `PDFExport` module is used to handle the PDF export action.
 */
class PDFExport {
    /**
     * Constructor for the PivotGrid PDF Export module.
     *
     * @param {PivotView} parent - Instance of pivot table.
     * @hidden
     */
    constructor(parent) {
        this.parent = parent;
    }
    /**
     * For internal use only - Get the module name.
     *
     * @returns {string} - string.
     * @private
     */
    getModuleName() {
        return 'pdfExport';
    }
    addPage(eventParams, pdfExportProperties) {
        pdfExportProperties = pdfExportProperties ? pdfExportProperties : this.exportProperties.pdfExportProperties;
        const documentSection = eventParams.document.sections.add();
        const documentHeight = eventParams.document.pageSettings.height;
        const documentWidth = eventParams.document.pageSettings.width;
        if (this.exportProperties.width || this.exportProperties.height) {
            eventParams.document.pageSettings.orientation = ((this.exportProperties.width > this.exportProperties.height)
                || (!this.exportProperties.height && (this.exportProperties.width > documentHeight)) || (!this.exportProperties.width
                && (documentWidth > this.exportProperties.height))) ? PdfPageOrientation.Landscape : PdfPageOrientation.Portrait;
            eventParams.document.pageSettings.size = new SizeF(this.exportProperties.width ? this.exportProperties.width :
                documentWidth, this.exportProperties.height ? this.exportProperties.height : documentHeight);
        }
        else {
            eventParams.document.pageSettings.orientation = (this.exportProperties.orientation === 0 || this.exportProperties.orientation)
                ? this.exportProperties.orientation : (!isNullOrUndefined(pdfExportProperties) &&
                !isNullOrUndefined(pdfExportProperties.pageOrientation)) ? (pdfExportProperties.pageOrientation === 'Landscape' ?
                PdfPageOrientation.Landscape : PdfPageOrientation.Portrait) : PdfPageOrientation.Landscape;
            if (!isNullOrUndefined(pdfExportProperties) && !isNullOrUndefined(pdfExportProperties.pageSize)) {
                eventParams.document.pageSettings.size = PivotUtil.getPageSize(pdfExportProperties.pageSize);
            }
        }
        if (!isNullOrUndefined(this.exportProperties.pdfMargins)) {
            const margins = eventParams.document.pageSettings.margins;
            margins.top = !isNullOrUndefined(this.exportProperties.pdfMargins.top) ? this.exportProperties.pdfMargins.top : margins.top;
            margins.bottom = !isNullOrUndefined(this.exportProperties.pdfMargins.bottom) ? this.exportProperties.pdfMargins.bottom :
                margins.bottom;
            margins.left = !isNullOrUndefined(this.exportProperties.pdfMargins.left) ? this.exportProperties.pdfMargins.left : margins.left;
            margins.right = !isNullOrUndefined(this.exportProperties.pdfMargins.right) ? this.exportProperties.pdfMargins.right :
                margins.right;
        }
        documentSection.setPageSettings(eventParams.document.pageSettings);
        const page = documentSection.pages.add();
        const header = (!isNullOrUndefined(pdfExportProperties) && !isNullOrUndefined(pdfExportProperties.header)
            && !isNullOrUndefined(pdfExportProperties.header.contents) && !isNullOrUndefined(pdfExportProperties.header.contents[0].value))
            ? pdfExportProperties.header.contents[0].value : this.exportProperties.header ? this.exportProperties.header : '';
        const footer = (!isNullOrUndefined(pdfExportProperties) && !isNullOrUndefined(pdfExportProperties.footer) &&
            !isNullOrUndefined(pdfExportProperties.footer.contents) && !isNullOrUndefined(pdfExportProperties.footer.contents[0].value)) ?
            pdfExportProperties.footer.contents[0].value : this.exportProperties.footer ? this.exportProperties.footer : '';
        const font = new PdfStandardFont(PdfFontFamily.TimesRoman, 15, PdfFontStyle.Regular);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const headerCondition = (!isNullOrUndefined(pdfExportProperties) && !isNullOrUndefined(pdfExportProperties.header)
            && !isNullOrUndefined(pdfExportProperties.header.contents) && !isNullOrUndefined(pdfExportProperties.header.contents[0].style));
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const footerCondition = (!isNullOrUndefined(pdfExportProperties) && !isNullOrUndefined(pdfExportProperties.footer)
            && !isNullOrUndefined(pdfExportProperties.footer.contents) && !isNullOrUndefined(pdfExportProperties.footer.contents[0].style));
        const headerColor = (headerCondition) ?
            this.hexDecToRgb(pdfExportProperties.header.contents[0].style.textBrushColor) : (new PdfColor(0, 0, 0));
        const brushHeader = (headerCondition) ? new PdfSolidBrush(new PdfColor(headerColor.r, headerColor.g, headerColor.b))
            : new PdfSolidBrush(new PdfColor(0, 0, 0));
        const footerColor = (footerCondition) ?
            this.hexDecToRgb(pdfExportProperties.footer.contents[0].style.textBrushColor) : (new PdfColor(0, 0, 0));
        const brushFooter = (footerCondition) ? new PdfSolidBrush(new PdfColor(footerColor.r, footerColor.g, footerColor.b))
            : new PdfSolidBrush(new PdfColor(0, 0, 0));
        const pen = new PdfPen(new PdfColor(0, 0, 0), .5);
        /** Header and Footer to be set */
        const headerTemplate = new PdfPageTemplateElement(new RectangleF(0, 0, page.graphics.clientSize.width, 20));
        headerTemplate.graphics.drawString(header, font, pen, brushHeader, 0, 0, new PdfStringFormat(PdfTextAlignment.Center));
        eventParams.document.template.top = headerTemplate;
        const footerTemplate = new PdfPageTemplateElement(new RectangleF(0, 0, page.graphics.clientSize.width, 20));
        footerTemplate.graphics.drawString(footer, font, pen, brushFooter, 0, 0, new PdfStringFormat(PdfTextAlignment.Center));
        eventParams.document.template.bottom = footerTemplate;
        return page;
    }
    hexDecToRgb(hexDec) {
        if (hexDec === null || hexDec === '' || hexDec.length !== 7) {
            throw new Error('please set valid hex value for color..');
        }
        hexDec = hexDec.substring(1);
        const bigint = parseInt(hexDec, 16);
        const r = (bigint >> 16) & 255;
        const g = (bigint >> 8) & 255;
        const b = bigint & 255;
        return { r: r, g: g, b: b };
    }
    getFontStyle(theme) {
        let fontType = PdfFontStyle.Regular;
        if (!isNullOrUndefined(theme) && theme.bold) {
            fontType |= PdfFontStyle.Bold;
        }
        if (!isNullOrUndefined(theme) && theme.italic) {
            fontType |= PdfFontStyle.Italic;
        }
        if (!isNullOrUndefined(theme) && theme.underline) {
            fontType |= PdfFontStyle.Underline;
        }
        if (!isNullOrUndefined(theme) && theme.strikeout) {
            fontType |= PdfFontStyle.Strikeout;
        }
        return fontType;
    }
    getBorderStyle(borderStyle) {
        const borders = new PdfBorders();
        if (!isNullOrUndefined(borderStyle)) {
            const borderWidth = borderStyle.width;
            // set border width
            const width = (!isNullOrUndefined(borderWidth) && typeof borderWidth === 'number') ? borderWidth * 0.75 : undefined;
            // set border color
            let color = new PdfColor(196, 196, 196);
            if (!isNullOrUndefined(borderStyle.color)) {
                const borderColor = this.hexDecToRgb(borderStyle.color);
                color = new PdfColor(borderColor.r, borderColor.g, borderColor.b);
            }
            const pen = new PdfPen(color, width);
            // set border dashStyle 'Solid <default>, Dash, Dot, DashDot, DashDotDot'
            if (!isNullOrUndefined(borderStyle.dashStyle)) {
                pen.dashStyle = this.getDashStyle(borderStyle.dashStyle);
            }
            borders.all = pen;
        }
        else {
            const pdfColor = new PdfColor(234, 234, 234);
            borders.all = new PdfPen(pdfColor);
        }
        return borders;
    }
    getDashStyle(dashType) {
        switch (dashType) {
            case 'Dash':
                return 1;
            case 'Dot':
                return 2;
            case 'DashDot':
                return 3;
            case 'DashDotDot':
                return 4;
            default:
                return 0;
        }
    }
    getStyle() {
        const border = new PdfBorders();
        if (!isNullOrUndefined(this.gridStyle)) {
            const fontFamily = !isNullOrUndefined(this.gridStyle.header.fontName) ?
                this.getFontFamily(this.gridStyle.header.fontName) : PdfFontFamily.Helvetica;
            const fontStyle = this.getFontStyle(this.gridStyle.header);
            const fontSize = !isNullOrUndefined(this.gridStyle.header.fontSize) ? this.gridStyle.header.fontSize : 10.5;
            let pdfColor = new PdfColor();
            if (!isNullOrUndefined(this.gridStyle.header.fontColor)) {
                const penBrushColor = this.hexDecToRgb(this.gridStyle.header.fontColor);
                pdfColor = new PdfColor(penBrushColor.r, penBrushColor.g, penBrushColor.b);
            }
            let font = new PdfStandardFont(fontFamily, fontSize, fontStyle);
            if (!isNullOrUndefined(this.gridStyle.header.font)) {
                font = this.gridStyle.header.font;
            }
            return {
                border: this.getBorderStyle(this.gridStyle.header.border), font: font, brush: new PdfSolidBrush(pdfColor)
            };
        }
        else {
            return {
                brush: new PdfSolidBrush(new PdfColor()),
                border: border, font: undefined
            };
        }
    }
    setRecordThemeStyle(row, border) {
        if (!isNullOrUndefined(this.gridStyle) && !isNullOrUndefined(this.gridStyle.record)) {
            const fontFamily = !isNullOrUndefined(this.gridStyle.record.fontName) ?
                this.getFontFamily(this.gridStyle.record.fontName) : PdfFontFamily.Helvetica;
            const fontSize = !isNullOrUndefined(this.gridStyle.record.fontSize) ? this.gridStyle.record.fontSize : 9.75;
            const fontStyle = this.getFontStyle(this.gridStyle.record);
            let font = new PdfStandardFont(fontFamily, fontSize, fontStyle);
            if (!isNullOrUndefined(this.gridStyle.record.font)) {
                font = this.gridStyle.record.font;
            }
            row.style.setFont(font);
            let pdfColor = new PdfColor();
            if (!isNullOrUndefined(this.gridStyle.record.fontColor)) {
                const penBrushColor = this.hexDecToRgb(this.gridStyle.record.fontColor);
                pdfColor = new PdfColor(penBrushColor.r, penBrushColor.g, penBrushColor.b);
            }
            row.style.setTextBrush(new PdfSolidBrush(pdfColor));
        }
        const borderRecord = this.gridStyle && this.gridStyle.record &&
            this.gridStyle.record.border ? this.getBorderStyle(this.gridStyle.record.border) : border;
        row.style.setBorder(borderRecord);
        return row;
    }
    /**
     * Method to perform pdf export.
     *
     * @param  {PdfExportProperties} pdfExportProperties - Defines the export properties of the Grid.
     * @param  {boolean} isMultipleExport - Define to enable multiple export.
     * @param  {Object} pdfDoc - Defined the PDF document if multiple export is enabled.
     * @param  {boolean} isBlob - If 'isBlob' set to true, then it will be returned as blob data.
     * @returns {Promise<any>}
     * @hidden
     */
    exportToPDF(pdfExportProperties, isMultipleExport, pdfDoc, isBlob) {
        this.engine = this.parent.dataType === 'olap' ? this.parent.olapEngineModule : this.parent.engineModule;
        this.gridStyle = this.exportProperties.style;
        const eventParams = this.applyEvent();
        if (!isNullOrUndefined(pdfDoc)) {
            eventParams.document = pdfDoc;
        }
        const headerStyle = this.getStyle();
        const fileName = this.exportProperties.fileName ? this.exportProperties.fileName : (!isNullOrUndefined(pdfExportProperties) && !isNullOrUndefined(pdfExportProperties.fileName)) ? pdfExportProperties.fileName : 'default';
        const indent = this.parent.renderModule.maxIndent ? this.parent.renderModule.maxIndent : 5;
        const firstColumnWidth = 100 + (indent * 20);
        let size = Math.floor((540 - firstColumnWidth) / 90) + 1;
        /** Fill data and export */
        let dataCollIndex = 0;
        let pivotValues = eventParams.args.pivotValues[dataCollIndex];
        if (this.exportProperties.columnSize || this.exportProperties.width || this.exportProperties.height) {
            size = this.exportProperties.columnSize > 0 ? this.exportProperties.columnSize : pivotValues[0].length;
        }
        const allowRepeatHeader = this.exportProperties.allowRepeatHeader ? this.exportProperties.allowRepeatHeader : true;
        for (let vLen = 0; allowRepeatHeader && size > 1 && vLen < pivotValues.length; vLen++) {
            for (let vCnt = size; pivotValues[vLen] && vCnt < pivotValues[vLen].length; vCnt += size) {
                pivotValues[vLen].splice(vCnt, 0, pivotValues[vLen][0]);
            }
        }
        let colLength = pivotValues && pivotValues.length > 0 ? pivotValues[0].length : 0;
        let integratedCnt = 0;
        do {
            if (!isNullOrUndefined(pdfExportProperties)) {
                this.exportProperties.header = (!isNullOrUndefined(pdfExportProperties.header) &&
                    !isNullOrUndefined(pdfExportProperties.header.contents) && !isNullOrUndefined(pdfExportProperties.header.contents[0].value))
                    ? pdfExportProperties.header.contents[0].value : this.exportProperties.header;
                this.exportProperties.footer = (!isNullOrUndefined(pdfExportProperties.footer) &&
                    !isNullOrUndefined(pdfExportProperties.footer.contents) && !isNullOrUndefined(pdfExportProperties.footer.contents[0].value))
                    ? pdfExportProperties.footer.contents[0].value : this.exportProperties.footer;
            }
            const page = this.addPage(eventParams, pdfExportProperties);
            const pdfGrid = new PdfGrid();
            const pageSize = size > 0 ? size : 5;
            if (pivotValues && pivotValues.length > 0) {
                pdfGrid.columns.add(pivotValues[0].length - integratedCnt >= pageSize ? pageSize : pivotValues[0].length - integratedCnt);
                const rowLen = pivotValues.length;
                let actualrCnt = 0;
                let maxLevel = 0;
                for (let rCnt = 0; rCnt < rowLen; rCnt++) {
                    if (pivotValues[rCnt]) {
                        const isColHeader = !(pivotValues[rCnt][0] && pivotValues[rCnt][0].axis === 'row');
                        const colLen = pivotValues[rCnt].length > (integratedCnt + pageSize) ? (integratedCnt + pageSize)
                            : pivotValues[rCnt].length;
                        if (isColHeader) {
                            pdfGrid.headers.add(1);
                        }
                        let pdfGridRow = !isColHeader ? pdfGrid.rows.addRow() : pdfGrid.headers.getHeader(actualrCnt);
                        if (isColHeader) {
                            pdfGridRow.style.setBorder(headerStyle.border);
                            if (headerStyle.font) {
                                pdfGridRow.style.setFont(headerStyle.font);
                            }
                            pdfGridRow.style.setTextBrush(headerStyle.brush);
                        }
                        else {
                            this.setRecordThemeStyle(pdfGridRow, headerStyle.border);
                        }
                        let localCnt = 0;
                        let isEmptyRow = true;
                        for (let cCnt = integratedCnt; cCnt < colLen; cCnt++) {
                            let isValueCell = false;
                            if (pivotValues[rCnt][cCnt]) {
                                const pivotCell = pivotValues[rCnt][cCnt];
                                let cellValue = pivotCell.formattedText;
                                cellValue = (this.parent.dataSourceSettings.rows.length === 0 || this.parent.dataSourceSettings.columns.length === 0) ? this.parent.getValuesHeader(pivotCell, 'value') : cellValue;
                                cellValue = pivotCell.type === 'grand sum' ? (this.parent.dataSourceSettings.rows.length === 0 || this.parent.dataSourceSettings.columns.length === 0) ? this.parent.getValuesHeader(pivotCell, 'grandTotal') :
                                    this.parent.localeObj.getConstant('grandTotal') : (pivotCell.type === 'sum' ?
                                    cellValue.toString().replace('Total', this.parent.localeObj.getConstant('total')) : cellValue);
                                if (!(pivotCell.level === -1 && !pivotCell.rowSpan)) {
                                    if (!(pivotCell.level === -1 && !pivotCell.rowSpan)) {
                                        pdfGridRow.cells.getCell(localCnt).columnSpan = pivotCell.colSpan ?
                                            (pageSize - localCnt < pivotCell.colSpan ? pageSize - localCnt : pivotCell.colSpan) : 1;
                                        if (isColHeader && pivotCell.rowSpan && pivotCell.rowSpan > 1) {
                                            pdfGridRow.cells.getCell(localCnt).rowSpan = pivotCell.rowSpan ? pivotCell.rowSpan : 1;
                                        }
                                        pdfGridRow.cells.getCell(localCnt).value = cellValue ? cellValue.toString() : '';
                                    }
                                    if (cellValue !== '') {
                                        isEmptyRow = false;
                                    }
                                }
                                maxLevel = pivotCell.level > maxLevel ? pivotCell.level : maxLevel;
                                isValueCell = pivotCell.axis === 'value';
                                cCnt = cCnt + (pdfGridRow.cells.getCell(localCnt).columnSpan ?
                                    (pdfGridRow.cells.getCell(localCnt).columnSpan - 1) : 0);
                                localCnt = localCnt + (pdfGridRow.cells.getCell(localCnt).columnSpan ?
                                    (pdfGridRow.cells.getCell(localCnt).columnSpan - 1) : 0);
                                if (pivotCell.style) {
                                    pdfGridRow = this.applyStyle(pdfGridRow, pivotCell, localCnt);
                                }
                                let args = {
                                    style: undefined,
                                    pivotCell: pivotCell,
                                    cell: pdfGridRow.cells.getCell(localCnt)
                                };
                                this.parent.trigger(onPdfCellRender, args);
                                if (pivotCell.axis === 'column') {
                                    args = {
                                        style: args.style,
                                        cell: args.cell,
                                        gridCell: args.pivotCell
                                    };
                                    this.parent.trigger(pdfHeaderQueryCellInfo, args);
                                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                    pdfGridRow.cells.getCell(localCnt).value = args.gridCell.formattedText ? args.gridCell
                                        .formattedText : cellValue;
                                }
                                else {
                                    args = {
                                        style: args.style,
                                        cell: args.cell,
                                        column: undefined,
                                        data: args.pivotCell,
                                        value: cellValue
                                    };
                                    this.parent.trigger(pdfQueryCellInfo, args);
                                    pdfGridRow.cells.getCell(localCnt).value = args.value ? args.value : cellValue;
                                }
                                if (args.style) {
                                    this.processCellStyle(pdfGridRow.cells.getCell(localCnt), args);
                                }
                            }
                            else {
                                let args = {
                                    style: undefined,
                                    pivotCell: undefined,
                                    cell: pdfGridRow.cells.getCell(localCnt)
                                };
                                this.parent.trigger(onPdfCellRender, args);
                                const pivotCell = { formattedText: '' };
                                if (pivotCell.axis === 'column') {
                                    args = {
                                        style: args.style,
                                        cell: args.cell,
                                        gridCell: args.pivotCell
                                    };
                                    this.parent.trigger(pdfHeaderQueryCellInfo, args);
                                }
                                if (args.style) {
                                    this.processCellStyle(pdfGridRow.cells.getCell(localCnt), args);
                                }
                                pdfGridRow.cells.getCell(localCnt).value = '';
                                if (cCnt === 0 && isColHeader && this.parent.dataSourceSettings.columns &&
                                    this.parent.dataSourceSettings.columns.length > 0) {
                                    pdfGrid.headers.getHeader(0).cells.getCell(0).rowSpan++;
                                }
                                else if (cCnt !== 0 && isColHeader && this.parent.dataSourceSettings.columns &&
                                    this.parent.dataSourceSettings.columns.length > 0 &&
                                    pdfGrid.headers.getHeader(0).cells.getCell(0).rowSpan <
                                        Object.keys(this.engine.headerContent).length) {
                                    pdfGrid.headers.getHeader(0).cells.getCell(0).rowSpan++;
                                }
                            }
                            const stringFormat = new PdfStringFormat();
                            if (this.parent.dataType === 'olap') {
                                const indent = (!isColHeader && localCnt === 0 &&
                                    pivotValues[rCnt][cCnt]) ?
                                    (this.parent.renderModule.indentCollection[pivotValues[rCnt][cCnt]
                                        .rowIndex]) : 0;
                                stringFormat.paragraphIndent = indent * 15;
                                maxLevel = maxLevel > indent ? maxLevel : indent;
                            }
                            else {
                                stringFormat.paragraphIndent = 0;
                                if ((!isColHeader && localCnt === 0 && pivotValues[rCnt][cCnt] &&
                                    pivotValues[rCnt][cCnt].level !== -1)) {
                                    const cell = pivotValues[rCnt][cCnt];
                                    const levelName = cell.valueSort ? cell.valueSort.levelName.toString() : '';
                                    const memberPos = cell.actualText ?
                                        cell.actualText.toString().split(this.parent.dataSourceSettings.valueSortSettings.headerDelimiter)
                                            .length : 0;
                                    const levelPosition = levelName.split(this.parent.dataSourceSettings.valueSortSettings.headerDelimiter).length -
                                        (memberPos ? memberPos - 1 : memberPos);
                                    const level = levelPosition ? (levelPosition - 1) : 0;
                                    stringFormat.paragraphIndent = level * 10;
                                }
                            }
                            stringFormat.alignment = isValueCell ? PdfTextAlignment.Right : PdfTextAlignment.Left;
                            stringFormat.lineAlignment = PdfVerticalAlignment.Middle;
                            pdfGridRow.cells.getCell(localCnt).style.stringFormat = stringFormat;
                            localCnt++;
                        }
                        if (isEmptyRow) {
                            pdfGridRow.height = 16;
                        }
                        actualrCnt++;
                    }
                }
                pdfGrid.columns.getColumn(0).width = 100 + (maxLevel * 20);
            }
            if (integratedCnt === 0 && this.parent.dataSourceSettings.columns && this.parent.dataSourceSettings.columns.length > 0) {
                pdfGrid.headers.getHeader(0).cells.getCell(0).rowSpan--;
            }
            pdfGrid.draw(page, new PointF(10, 20));
            integratedCnt = integratedCnt + pageSize;
            if (integratedCnt >= colLength && eventParams.args.pivotValues.length > (dataCollIndex + 1)) {
                dataCollIndex++;
                pivotValues = eventParams.args.pivotValues[dataCollIndex];
                colLength = pivotValues && pivotValues.length > 0 ? pivotValues[0].length : 0;
                integratedCnt = 0;
            }
        } while (integratedCnt < colLength);
        return new Promise((resolve) => {
            let blobData;
            if (isBlob || isMultipleExport) {
                if (isBlob) {
                    blobData = eventParams.document.save();
                }
            }
            else {
                eventParams.document.save(fileName + '.pdf');
                eventParams.document.destroy();
            }
            const exportCompleteEventArgs = {
                type: 'PDF',
                promise: isBlob ? blobData : null
            };
            this.parent.trigger(exportComplete, exportCompleteEventArgs);
            resolve(eventParams.document);
        });
    }
    /* eslint-enable  */
    applyStyle(pdfGridRow, pivotCell, localCnt) {
        let color = this.parent.conditionalFormattingModule.hexToRgb(pivotCell.style.backgroundColor);
        let brush = new PdfSolidBrush(new PdfColor(color.r, color.g, color.b));
        pdfGridRow.cells.getCell(localCnt).style.backgroundBrush = brush;
        const size = Number(pivotCell.style.fontSize.split('px')[0]);
        const font = new PdfStandardFont(PdfFontFamily.TimesRoman, size, PdfFontStyle.Regular);
        pdfGridRow.cells.getCell(localCnt).style.font = font;
        color = this.parent.conditionalFormattingModule.hexToRgb(pivotCell.style.color);
        brush = new PdfSolidBrush(new PdfColor(color.r, color.g, color.b));
        pdfGridRow.cells.getCell(localCnt).style.textBrush = brush;
        return pdfGridRow;
    }
    getFontFamily(family) {
        switch (family) {
            case 'TimesRoman':
                return 2;
            case 'Courier':
                return 1;
            case 'Symbol':
                return 3;
            case 'ZapfDingbats':
                return 4;
            default:
                return 0;
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    getFont(theme) {
        if (theme.style.font) {
            return theme.style.font;
        }
        const fontSize = (theme.cell.cellStyle.font && theme.cell.cellStyle.font.fontSize) ? theme.cell.cellStyle.font.fontSize :
            (!isNullOrUndefined(theme.style.fontSize)) ? (theme.style.fontSize * 0.75) : 9.75;
        const fontFamily = (!isNullOrUndefined(theme.style.fontFamily)) ?
            (this.getFontFamily(theme.style.fontFamily)) : PdfFontFamily.TimesRoman;
        let fontStyle = PdfFontStyle.Regular;
        if (!isNullOrUndefined(theme.style.bold) && theme.style.bold) {
            fontStyle |= PdfFontStyle.Bold;
        }
        if (!isNullOrUndefined(theme.style.italic) && theme.style.italic) {
            fontStyle |= PdfFontStyle.Italic;
        }
        if (!isNullOrUndefined(theme.style.underline) && theme.style.underline) {
            fontStyle |= PdfFontStyle.Underline;
        }
        if (!isNullOrUndefined(theme.style.strikeout) && theme.style.strikeout) {
            fontStyle |= PdfFontStyle.Strikeout;
        }
        return new PdfStandardFont(fontFamily, fontSize, fontStyle);
    }
    processCellStyle(gridCell, arg) {
        if (!isNullOrUndefined(arg.style.backgroundColor)) {
            const backColor = this.hexDecToRgb(arg.style.backgroundColor);
            gridCell.style.backgroundBrush = new PdfSolidBrush(new PdfColor(backColor.r, backColor.g, backColor.b));
        }
        if (!isNullOrUndefined(arg.style.textBrushColor)) {
            const textBrushColor = this.hexDecToRgb(arg.style.textBrushColor);
            gridCell.style.textBrush = new PdfSolidBrush(new PdfColor(textBrushColor.r, textBrushColor.g, textBrushColor.b));
        }
        if (!isNullOrUndefined(arg.style.textPenColor)) {
            const textColor = this.hexDecToRgb(arg.style.textPenColor);
            gridCell.style.textPen = new PdfPen(new PdfColor(textColor.r, textColor.g, textColor.b));
        }
        if (!isNullOrUndefined(arg.style.fontFamily) || !isNullOrUndefined(arg.style.fontSize) || !isNullOrUndefined(arg.style.bold) ||
            !isNullOrUndefined(arg.style.italic) || !isNullOrUndefined(arg.style.underline) || !isNullOrUndefined(arg.style.strikeout)) {
            gridCell.style.font = this.getFont(arg);
        }
        if (!isNullOrUndefined(arg.style.border)) {
            const border = new PdfBorders();
            const borderWidth = arg.style.border.width;
            // set border width
            const width = (!isNullOrUndefined(borderWidth) && typeof borderWidth === 'number') ? (borderWidth * 0.75) : (undefined);
            // set border color
            let color = new PdfColor(196, 196, 196);
            if (!isNullOrUndefined(arg.style.border.color)) {
                const borderColor = this.hexDecToRgb(arg.style.border.color);
                color = new PdfColor(borderColor.r, borderColor.g, borderColor.b);
            }
            const pen = new PdfPen(color, width);
            // set border dashStyle 'Solid <default>, Dash, Dot, DashDot, DashDotDot'
            if (!isNullOrUndefined(arg.style.border.dashStyle)) {
                pen.dashStyle = this.getDashStyle(arg.style.border.dashStyle);
            }
            border.all = pen;
            gridCell.style.borders = border;
        }
    }
    applyEvent() {
        /** Event trigerring */
        let clonedValues;
        const currentPivotValues = PivotExportUtil.getClonedPivotValues(this.engine.pivotValues);
        if (this.parent.exportAllPages && (this.parent.enableVirtualization || this.parent.enablePaging) && this.parent.dataType !== 'olap') {
            const pageSettings = this.engine.pageSettings;
            this.engine.pageSettings = null;
            this.engine.isPagingOrVirtualizationEnabled = false;
            this.engine.generateGridData(this.parent.dataSourceSettings, true);
            this.parent.applyFormatting(this.engine.pivotValues);
            clonedValues = PivotExportUtil.getClonedPivotValues(this.engine.pivotValues);
            this.engine.pivotValues = currentPivotValues;
            this.engine.pageSettings = pageSettings;
            this.engine.isPagingOrVirtualizationEnabled = true;
        }
        else {
            clonedValues = currentPivotValues;
        }
        const args = {
            pivotValues: [clonedValues]
        };
        this.parent.trigger(enginePopulated, args);
        this.document = new PdfDocument();
        return { document: this.document, args: args };
    }
    /**
     * To destroy the pdf export module.
     *
     * @returns {void}
     * @hidden
     */
    destroy() {
        if (this.engine) {
            this.engine = null;
        }
        if (this.exportProperties) {
            this.exportProperties = null;
        }
        if (this.document) {
            this.document = null;
        }
    }
}

/**
 * Module for Pager rendering
 */
/** @hidden */
class Pager$1 {
    constructor(parent) {
        this.parent = parent;
        this.parent.pagerModule = this;
        this.addEventListener();
    }
    /**
     * It returns the Module name.
     *
     * @returns {string} - string
     * @hidden
     */
    getModuleName() {
        return 'pager';
    }
    /**
     *
     * @hidden
     *
     */
    addEventListener() {
        if (this.parent.isDestroyed) {
            return;
        }
        this.parent.on(initPivotPager, this.createPager, this);
    }
    /**
     *
     * @hidden
     */
    removeEventListener() {
        if (this.parent.isDestroyed) {
            return;
        }
        if (isNullOrUndefined(this.parent.pagerSettings.template)) {
            this.unWireEvent();
        }
        this.parent.off(initPivotPager, this.createPager);
    }
    createPager() {
        if (select('#' + this.parent.element.id + 'pivot-pager', this.parent.element) !== null) {
            remove(select('#' + this.parent.element.id + 'pivot-pager', this.parent.element));
            this.destroy();
            this.addEventListener();
        }
        const tableWidth = (this.parent.grid ? this.parent.getGridWidthAsNumber() : this.parent.getWidthAsNumber());
        const pagerOptions = this.parent.pagerSettings;
        if (this.parent.enablePaging) {
            const pagerElement = createElement('div', {
                id: this.parent.element.id + 'pivot-pager',
                className: GRID_PAGER + ' ' + (((this.parent.isAdaptive || tableWidth < 650) ? DEVICE : '') + ' ' + (this.parent.enableRtl ? RTL : '') + ' ' + (this.parent.pagerSettings.position === 'Top' ? ' ' + GRID_PAGER_TOP : ' ' + GRID_PAGER_BOTTOM)
                    + ' ' + ((pagerOptions.enableCompactView || tableWidth < 400) ? COMPACT_VIEW : '')),
                styles: 'width:' + (this.parent.grid ? this.parent.getGridWidthAsNumber() : this.parent.getWidthAsNumber()) + 'px'
            });
            if (this.parent.showFieldList && select('#' + this.parent.element.id + '_PivotFieldList', this.parent.element) && pagerOptions.position === 'Top') {
                this.parent.element.insertBefore(pagerElement, select('#' + this.parent.element.id + '_PivotFieldList', this.parent.element));
            }
            else if (this.parent.showGroupingBar && select('#' + this.parent.element.id + ' .' + GRID_GROUPING_BAR_CLASS, this.parent.element) && pagerOptions.position === 'Top') {
                this.parent.element.insertBefore(pagerElement, select('#' + this.parent.element.id + ' .' + GRID_GROUPING_BAR_CLASS, this.parent.element));
            }
            else {
                if (this.parent.pagerSettings.position === 'Top') {
                    this.parent.element.insertBefore(pagerElement, select('#' + this.parent.element.id + '_grid', this.parent.element));
                }
                else {
                    this.parent.element.append(pagerElement);
                }
            }
            let _this = this;
            let tempFunc = function () {
                return _this.createPagerContainer();
            };
            this.pager = new Pager({
                enableRtl: this.parent.enableRtl,
                locale: this.parent.locale,
                template: pagerOptions.template === '' || pagerOptions.template ? pagerOptions.template : initializeCSPTemplate(tempFunc),
                cssClass: this.parent.cssClass
            });
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this.pager.isVue = this.parent.isVue;
            this.pager.appendTo('#' + this.parent.element.id + 'pivot-pager');
            if (isNullOrUndefined(pagerOptions.template)) {
                if (pagerOptions.showRowPager) {
                    if (!pagerOptions.enableCompactView && tableWidth > 400) {
                        this.rowPagerTextBox = new NumericTextBox({
                            min: 1,
                            max: this.parent.engineModule.rowPageCount,
                            showSpinButton: false,
                            format: '#',
                            validateDecimalOnType: true,
                            decimals: 0,
                            strictMode: true,
                            value: this.parent.pageSettings.currentRowPage,
                            enableRtl: this.parent.enableRtl,
                            locale: this.parent.locale,
                            width: tableWidth < 669 ? '50px' : '64px',
                            change: this.rowPageChange.bind(this),
                            cssClass: this.parent.cssClass
                        });
                        this.rowPagerTextBox.appendTo('#' + this.parent.element.id + '_row_textbox');
                    }
                    if (pagerOptions.showRowPageSize) {
                        const rowPages = this.parent.pagerSettings.rowPageSizes.slice(0);
                        if (this.parent.pagerSettings.rowPageSizes.indexOf(this.parent.pageSettings.rowPageSize) === -1) {
                            rowPages.push(this.parent.pageSettings.rowPageSize);
                            rowPages.sort(function (a, b) { return a - b; });
                        }
                        this.rowPageSizeDropDown = new DropDownList({
                            dataSource: rowPages,
                            value: this.parent.pageSettings.rowPageSize,
                            enableRtl: this.parent.enableRtl,
                            locale: this.parent.locale,
                            change: this.rowPageSizeChange.bind(this),
                            popupHeight: '300px',
                            popupWidth: '100%',
                            width: '64px',
                            cssClass: this.parent.cssClass
                        });
                        this.rowPageSizeDropDown.appendTo('#' + this.parent.element.id + '_' + 'row' + '_size_list');
                    }
                }
                if (pagerOptions.showColumnPager) {
                    if (!pagerOptions.enableCompactView && tableWidth > 400) {
                        this.columnPagerTextBox = new NumericTextBox({
                            min: 1,
                            max: this.parent.engineModule.columnPageCount,
                            showSpinButton: false,
                            format: '#',
                            validateDecimalOnType: true,
                            decimals: 0,
                            strictMode: true,
                            value: this.parent.pageSettings.currentColumnPage,
                            enableRtl: this.parent.enableRtl,
                            locale: this.parent.locale,
                            width: tableWidth < 669 ? '50px' : '64px',
                            change: this.columnPageChange.bind(this),
                            cssClass: this.parent.cssClass
                        });
                        this.columnPagerTextBox.appendTo('#' + this.parent.element.id + '_column_textbox');
                    }
                    if (pagerOptions.showColumnPageSize) {
                        const columnPages = this.parent.pagerSettings.columnPageSizes.slice(0);
                        if (this.parent.pagerSettings.columnPageSizes.indexOf(this.parent.pageSettings.columnPageSize) === -1) {
                            columnPages.push(this.parent.pageSettings.columnPageSize);
                            columnPages.sort(function (a, b) { return a - b; });
                        }
                        this.columnPageSizeDropDown = new DropDownList({
                            dataSource: columnPages,
                            value: this.parent.pageSettings.columnPageSize,
                            enableRtl: this.parent.enableRtl,
                            locale: this.parent.locale,
                            change: this.columnPageSizeChange.bind(this),
                            popupHeight: '300px',
                            popupWidth: '100%',
                            width: '64px',
                            cssClass: this.parent.cssClass
                        });
                        this.columnPageSizeDropDown.appendTo('#' + this.parent.element.id + '_' + 'column' + '_size_list');
                    }
                }
                this.unWireEvent();
                this.wireEvent();
            }
        }
    }
    wireEvent() {
        const elements = [].slice.call(this.parent.element.querySelectorAll('.' + FIRST_PAGER_ICON + ', .' + PREV_PAGER_ICON + ', .' + NEXT_PAGER_ICON + ', .' + LAST_PAGER_ICON));
        for (let i = 0; i < elements.length; i++) {
            EventHandler.add(elements[i], 'click', this.updatePageSettings, this);
        }
    }
    unWireEvent() {
        const elements = [].slice.call(this.parent.element.querySelectorAll('.' + FIRST_PAGER_ICON + ', .' + PREV_PAGER_ICON + ', .' + NEXT_PAGER_ICON + ', .' + LAST_PAGER_ICON));
        for (let i = 0; i < elements.length; i++) {
            EventHandler.remove(elements[i], 'click', this.updatePageSettings);
        }
    }
    columnPageChange(args) {
        this.parent.pageSettings.currentColumnPage = args.value;
    }
    rowPageChange(args) {
        this.parent.pageSettings.currentRowPage = args.value;
    }
    columnPageSizeChange(args) {
        this.parent.pageSettings.columnPageSize = Number(args.value);
    }
    rowPageSizeChange(args) {
        this.parent.pageSettings.rowPageSize = Number(args.value);
    }
    updatePageSettings(args) {
        const targetId = args.target.id;
        switch (targetId) {
            case this.parent.element.id + '_row_firstIcon':
                this.parent.pageSettings.currentRowPage = 1;
                break;
            case this.parent.element.id + '_row_prevIcon':
                this.parent.pageSettings.currentRowPage = this.parent.pageSettings.currentRowPage > 1
                    ? this.parent.pageSettings.currentRowPage - 1 : this.parent.pageSettings.currentRowPage;
                break;
            case this.parent.element.id + '_row_nextIcon':
                this.parent.pageSettings.currentRowPage = this.parent.pageSettings.currentRowPage < this.parent.engineModule.rowPageCount
                    ? this.parent.pageSettings.currentRowPage + 1 : this.parent.pageSettings.currentRowPage;
                break;
            case this.parent.element.id + '_row_lastIcon':
                this.parent.pageSettings.currentRowPage = this.parent.engineModule.rowPageCount;
                break;
            case this.parent.element.id + '_column_firstIcon':
                this.parent.pageSettings.currentColumnPage = 1;
                break;
            case this.parent.element.id + '_column_prevIcon':
                this.parent.pageSettings.currentColumnPage = this.parent.pageSettings.currentColumnPage > 1
                    ? this.parent.pageSettings.currentColumnPage - 1 : this.parent.pageSettings.currentColumnPage;
                break;
            case this.parent.element.id + '_column_nextIcon':
                this.parent.pageSettings.currentColumnPage = this.parent.pageSettings.currentColumnPage
                    < this.parent.engineModule.columnPageCount ? this.parent.pageSettings.currentColumnPage + 1
                    : this.parent.pageSettings.currentColumnPage;
                break;
            case this.parent.element.id + '_column_lastIcon':
                this.parent.pageSettings.currentColumnPage = this.parent.engineModule.columnPageCount;
                break;
        }
        if (targetId.indexOf('_row') !== -1) {
            this.parent.actionObj.actionName = rowPageNavigation;
        }
        else if (targetId.indexOf('_column') !== -1) {
            this.parent.actionObj.actionName = columnPageNavigation;
        }
    }
    createPagerContainer() {
        const tableWidth = (this.parent.grid ? this.parent.getGridWidthAsNumber() : this.parent.getWidthAsNumber());
        const pagerOptions = this.parent.pagerSettings;
        let rowMainDiv;
        let columnMainDiv;
        if (pagerOptions.showRowPager) {
            rowMainDiv = this.createPagerItems('row', pagerOptions, tableWidth);
        }
        if (pagerOptions.showColumnPager) {
            columnMainDiv = this.createPagerItems('column', pagerOptions, tableWidth);
        }
        const mainDivPagerSettings = createElement('div', {
            id: this.parent.element.id + '_' + 'mainDiv',
            className: (GRID_PAGER_DIV + ' ' + ((!pagerOptions.showRowPager || !pagerOptions.showColumnPager) ? GRID_PAGER_SINGLE_DIV : '') + ' ' + (pagerOptions.isInversed ? INVERSE : ''))
        });
        const vertiSeparator = createElement('div', {
            id: this.parent.element.id + '_' + 'vertical' + '_separator',
            className: (this.parent.isAdaptive || tableWidth < 650) ? PIVOT_H_SEPARATOR : PIVOT_V_SEPARATOR
        });
        if (pagerOptions.isInversed && pagerOptions.showColumnPager && pagerOptions.showRowPager) {
            mainDivPagerSettings.append(columnMainDiv, vertiSeparator, rowMainDiv);
        }
        else if (pagerOptions.showColumnPager && pagerOptions.showRowPager) {
            mainDivPagerSettings.append(rowMainDiv, vertiSeparator, columnMainDiv);
        }
        else if (pagerOptions.showRowPager && !pagerOptions.showColumnPager) {
            mainDivPagerSettings.append(rowMainDiv);
        }
        else if (!pagerOptions.showRowPager && pagerOptions.showColumnPager) {
            mainDivPagerSettings.append(columnMainDiv);
        }
        return mainDivPagerSettings.outerHTML;
    }
    createPagerItems(axis, pagerOptions, tableWidth) {
        const isSinglePagerEnabled = (!pagerOptions.showRowPager || !pagerOptions.showColumnPager);
        const pagerAxisMainDiv = createElement('div', {
            id: this.parent.element.id + '_' + axis + '_mainDiv',
            className: (axis === 'row' ? (PIVOT_ROW_PAGER_DIV + ' ' + (!pagerOptions.showRowPageSize ? PAGE_SIZE_DISABLE : '')) : (PIVOT_COLUMN_PAGER_DIV + ' ' + (!pagerOptions.showColumnPageSize ? PAGE_SIZE_DISABLE : '')))
        });
        const pagerIconContainer = createElement('div', {
            id: this.parent.element.id + '_' + axis + '_pagerSettings',
            className: (axis === 'row' ? PIVOT_ROW_PAGER_SETTINGS : PIVOT_COLUMN_PAGER_SETTINGS)
        });
        const isFirstDisable = (axis === 'column' && this.parent.pageSettings.currentColumnPage === 1) || (axis === 'row' && this.parent.pageSettings.currentRowPage === 1);
        const isLastDisable = (axis === 'column' && this.parent.pageSettings.currentColumnPage === this.parent.engineModule.columnPageCount) || (axis === 'row' && this.parent.pageSettings.currentRowPage === this.parent.engineModule.rowPageCount);
        const navIconContainer = createElement('div', {
            id: this.parent.element.id + '_' + axis + '_NavContainer',
            attrs: {
                class: PIVOT_PAGER_NAV_CONTAINER + ' ' + PIVOT_PAGER_CONTAINER
            }
        });
        const pageInfoContainer = createElement('div', {
            id: this.parent.element.id + '_' + axis + '_PageInfoContainer',
            attrs: {
                class: PIVOT_PAGER_INFO_CONTAINER + ' ' + PIVOT_PAGER_CONTAINER
            }
        });
        const firstIcon = createElement('div', {
            id: this.parent.element.id + '_' + axis + '_firstIcon',
            attrs: {
                class: PIVOT_FIRST_ICON_DEFAULT + (isFirstDisable ? (' ' + DISABLE_FIRST_PAGE + ' ' + ICON_DISABLE) : ' ' + PIVOT_FIRST_ICON_ENABLE),
                title: this.parent.localeObj.getConstant('gotofirstpage'),
                'aria-label': this.parent.localeObj.getConstant('gotofirstpage'),
                tabindex: '-1',
                role: 'button'
            }
        });
        const prevIcon = createElement('div', {
            id: this.parent.element.id + '_' + axis + '_prevIcon',
            attrs: {
                class: PIVOT_PREV_ICON_DEFAULT + (isFirstDisable ? (' ' + DISABLE_PREV_PAGE + ' ' + ICON_DISABLE) : ' ' + PIVOT_PREV_ICON_ENABLE),
                title: this.parent.localeObj.getConstant('gotopreviouspage'),
                'aria-label': this.parent.localeObj.getConstant('gotopreviouspage'),
                tabindex: '-1',
                role: 'button'
            }
        });
        const pagerString = createElement('span', {
            id: this.parent.element.id + '_' + axis + '_pagerString',
            className: axis === 'row' ? PIVOT_ROW_PAGER_STRING : PIVOT_COLUMN_PAGER_STRING
        });
        pagerString.innerText = axis === 'row' ? this.parent.localeObj.getConstant('rowPage') : this.parent.localeObj.getConstant('columnPage');
        const pagerTextBoxDiv = createElement('input', {
            id: this.parent.element.id + '_' + axis + '_textbox',
            className: axis === 'row' ? PIVOT_ROW_DROPDOWN : PIVOT_COLUMN_DROPDOWN
        });
        const mainOfStringDiv = createElement('div', {
            id: this.parent.element.id + '_' + axis + '_of_string_mainDiv',
            className: axis === 'row' ? PIVOT_ROW_OF_STRING_MAINDIV : PIVOT_COLUMN_OF_STRING_MAINDIV
        });
        const ofString = createElement('span', {
            id: this.parent.element.id + '_' + axis + '_ofString',
            className: axis === 'row' ? PIVOT_ROW_OF_STRING : PIVOT_COLUMN_OF_STRING
        });
        ofString.innerText = this.parent.localeObj.getConstant('of') + ' ';
        const pagerNumber = createElement('span', {
            id: this.parent.element.id + '_' + axis + '_pagerNumber',
            className: axis === 'row' ? PIVOT_ROW_PAGER_NUMBER : PIVOT_COLUMN_PAGER_NUMBER
        });
        pagerNumber.innerText = (axis === 'row' ? this.parent.engineModule.rowPageCount : this.parent.engineModule.columnPageCount).toString();
        const nextIcon = createElement('div', {
            id: this.parent.element.id + '_' + axis + '_nextIcon',
            attrs: {
                class: PIVOT_NEXT_ICON_DEFAULT + (isLastDisable ? (' ' + DISABLE_NEXT_PAGE + ' ' + ICON_DISABLE) : ' ' + PIVOT_NEXT_ICON_ENABLE),
                title: this.parent.localeObj.getConstant('gotonextpage'),
                'aria-label': this.parent.localeObj.getConstant('gotonextpage'),
                tabindex: '-1',
                role: 'button'
            }
        });
        const lastIcon = createElement('div', {
            id: this.parent.element.id + '_' + axis + '_lastIcon',
            attrs: {
                class: PIVOT_LAST_ICON_DEFAULT + (isLastDisable ? (' ' + DISABLE_LAST_PAGE + ' ' + ICON_DISABLE) : ' ' + PIVOT_LAST_ICON_ENABLE),
                title: this.parent.localeObj.getConstant('gotolastpage'),
                'aria-label': this.parent.localeObj.getConstant('gotolastpage'),
                tabindex: '-1',
                role: 'button'
            }
        });
        const pageSize = createElement('span', {
            id: this.parent.element.id + '_' + axis + '_size',
            className: axis === 'row' ? PIVOT_ROW_SIZE : PIVOT_COLUMN_SIZE
        });
        pageSize.innerText = axis === 'row' ? this.parent.localeObj.getConstant('rowPerPage') : this.parent.localeObj.getConstant('columnPerPage');
        const pageSizeDropDownMainDiv = createElement('div', {
            id: this.parent.element.id + '_' + axis + '_size_list_maindiv',
            className: PIVOT_PAGE_SIZE_LIST_MAINDIV + ' ' + PIVOT_PAGER_CONTAINER
        });
        const pageSizeDropDown = createElement('div', {
            id: this.parent.element.id + '_' + axis + '_size_list',
            className: axis === 'row' ? PIVOT_ROW_SIZE_LIST : PIVOT_COLUMN_SIZE_LIST
        });
        const pagerStringContainer = createElement('div', {
            id: this.parent.element.id + '_' + axis + '_text_div',
            className: PIVOT_TEXT_DIV
        });
        const pagerElementContainer = createElement('div', {
            id: this.parent.element.id + '_' + axis + '_text_div_1',
            className: PIVOT_TEXT_DIV_1
        });
        pageSizeDropDownMainDiv.append(pageSizeDropDown);
        if (pagerOptions.enableCompactView || tableWidth < 400) {
            navIconContainer.append(prevIcon, nextIcon);
            pagerIconContainer.append(navIconContainer);
        }
        else {
            mainOfStringDiv.append(ofString, pagerNumber);
            navIconContainer.append(firstIcon, prevIcon, nextIcon, lastIcon);
            pageInfoContainer.append(pagerTextBoxDiv, mainOfStringDiv);
            pagerIconContainer.append(navIconContainer, pageInfoContainer);
        }
        if ((axis === 'row' && pagerOptions.showRowPager) || (axis === 'column' && pagerOptions.showColumnPager)) {
            if (((axis === 'column' && !pagerOptions.showRowPager) || (axis === 'row' && !pagerOptions.showColumnPager)) && (isSinglePagerEnabled)) {
                pagerElementContainer.append(pageSize, pageSizeDropDownMainDiv);
            }
            if ((!pagerOptions.showColumnPager || !pagerOptions.showRowPager) && (isSinglePagerEnabled)) {
                if (axis === 'row') {
                    if (pagerOptions.showRowPageSize) {
                        pagerAxisMainDiv.append(pagerIconContainer, pagerString, pagerElementContainer);
                    }
                    else {
                        pagerAxisMainDiv.append(pagerIconContainer, pagerString);
                    }
                }
                if (axis === 'column') {
                    if (pagerOptions.showColumnPageSize) {
                        pagerAxisMainDiv.append(pagerIconContainer, pagerString, pagerElementContainer);
                    }
                    else {
                        pagerAxisMainDiv.append(pagerIconContainer, pagerString);
                    }
                }
            }
            else {
                if ((axis === 'row' && pagerOptions.showRowPageSize) || (axis === 'column' && pagerOptions.showColumnPageSize)) {
                    if (!pagerOptions.enableCompactView && tableWidth > 400) {
                        pagerStringContainer.append(pagerString, pageSize);
                        pagerElementContainer.append(pagerIconContainer, pageSizeDropDownMainDiv);
                    }
                    else {
                        pagerStringContainer.append(pagerString, pagerIconContainer);
                        pagerElementContainer.append(pageSize, pageSizeDropDownMainDiv);
                    }
                }
                else if ((axis === 'row' && !pagerOptions.showRowPageSize) || (axis === 'column' && !pagerOptions.showColumnPageSize)) {
                    pagerStringContainer.append(pagerString);
                    pagerElementContainer.append(pagerIconContainer);
                }
                pagerAxisMainDiv.append(pagerStringContainer, pagerElementContainer);
            }
        }
        return pagerAxisMainDiv;
    }
    /**
     * To destroy the pager.
     *
     * @returns {void}
     * @hidden
     */
    destroy() {
        this.removeEventListener();
        if (this.parent.pagerModule) {
            if (this.columnPagerTextBox) {
                this.columnPagerTextBox.destroy();
            }
            if (this.rowPagerTextBox) {
                this.rowPagerTextBox.destroy();
            }
            if (this.columnPageSizeDropDown) {
                this.columnPageSizeDropDown.destroy();
            }
            if (this.rowPageSizeDropDown) {
                this.rowPageSizeDropDown.destroy();
            }
            if (this.pager) {
                this.pager.destroy();
            }
            this.columnPagerTextBox = null;
            this.rowPagerTextBox = null;
            this.columnPageSizeDropDown = null;
            this.rowPageSizeDropDown = null;
            this.pager = null;
        }
        else {
            return;
        }
    }
}

/**
 * Action export
 */

/**
 * PivotGrid component exported items
 */

/**
 * Module to render Pivot Field List Dialog
 */
/** @hidden */
class DialogRenderer {
    /** Constructor for render module
     *
     * @param {PivotFieldList} parent - Instance of field list.
     */
    constructor(parent) {
        this.parent = parent;
    }
    /**
     * Initialize the field list layout rendering
     *
     * @returns {void}
     * @private
     */
    render() {
        const fieldListWrappper = createElement('div', {
            id: this.parent.element.id + '_Container',
            className: WRAPPER_CLASS + ' ' + (this.parent.dataType === 'olap' ? OLAP_WRAPPER_CLASS : ''),
            styles: 'width:' + this.parent.element.style.width
        });
        if (this.parent.isAdaptive) {
            addClass([fieldListWrappper], DEVICE);
        }
        else {
            removeClass([fieldListWrappper], DEVICE);
        }
        if (this.parent.enableRtl) {
            addClass([fieldListWrappper], RTL);
        }
        else {
            removeClass([fieldListWrappper], RTL);
        }
        if (this.parent.cssClass) {
            addClass([fieldListWrappper], this.parent.cssClass);
        }
        if (this.parent.enableFieldSearching) {
            addClass([fieldListWrappper], FIELD_LIST_SEARCH_MODE_CLASS);
        }
        else {
            removeClass([fieldListWrappper], FIELD_LIST_SEARCH_MODE_CLASS);
        }
        this.parentElement = createElement('div', { className: CONTAINER_CLASS });
        this.parent.element.appendChild(fieldListWrappper);
        if (this.parent.isAdaptive) {
            fieldListWrappper.removeAttribute('style');
            this.parentElement = createElement('div', { className: ADAPTIVE_CONTAINER_CLASS });
            this.renderAdaptiveLayout(fieldListWrappper);
        }
        if (this.parent.renderMode === 'Popup') {
            this.renderFieldListDialog(fieldListWrappper);
            this.unWireDialogEvent(this.parent.element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS));
            this.wireDialogEvent(this.parent.element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS));
        }
        else {
            this.renderStaticLayout(fieldListWrappper);
        }
    }
    renderStaticLayout(fieldListWrappper) {
        if (!this.parent.isAdaptive) {
            const layoutHeader = createElement('div', {
                className: FIELD_LIST_TITLE_CLASS
            });
            const headerContent = createElement('div', {
                className: FIELD_LIST_TITLE_CONTENT_CLASS
            });
            headerContent.innerText = this.parent.localeObj.getConstant('staticFieldList');
            layoutHeader.appendChild(headerContent);
            layoutHeader.appendChild(this.createCalculatedButton());
            addClass([fieldListWrappper], STATIC_FIELD_LIST_CLASS);
            fieldListWrappper.appendChild(layoutHeader);
            fieldListWrappper.appendChild(this.parentElement);
            addClass([fieldListWrappper], STATIC_FIELD_LIST_CLASS);
            if (this.parent.allowDeferLayoutUpdate) {
                fieldListWrappper.appendChild(this.createDeferUpdateButtons());
                this.renderDeferUpdateButtons();
            }
        }
    }
    renderDeferUpdateButtons() {
        if (this.parent.allowDeferLayoutUpdate) {
            this.deferUpdateCheckBox = new CheckBox({
                label: this.parent.localeObj.getConstant('deferLayoutUpdate'),
                checked: true,
                enableRtl: this.parent.enableRtl,
                enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
                locale: this.parent.locale,
                change: this.onCheckChange.bind(this),
                cssClass: this.parent.cssClass
            });
            this.deferUpdateCheckBox.isStringTemplate = true;
            this.deferUpdateCheckBox.appendTo('#' + this.parent.element.id + 'DeferUpdateCheckBox');
            this.deferUpdateApplyButton = new Button({
                cssClass: DEFER_APPLY_BUTTON + ' ' + DEFER_UPDATE_BUTTON + (this.parent.renderMode === 'Popup' ?
                    (' ' + BUTTON_FLAT_CLASS) : '') + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
                content: this.parent.localeObj.getConstant('apply'),
                enableRtl: this.parent.enableRtl,
                locale: this.parent.locale,
                enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
                isPrimary: true
            });
            this.deferUpdateApplyButton.isStringTemplate = true;
            this.deferUpdateApplyButton.appendTo('#' + this.parent.element.id + '_DeferUpdateButton1');
            this.deferUpdateApplyButton.element.onclick = this.parent.renderMode === 'Fixed' ? this.applyButtonClick.bind(this) :
                this.onDeferUpdateClick.bind(this);
        }
        this.deferUpdateCancelButton = new Button({
            cssClass: DEFER_CANCEL_BUTTON + ' ' + CANCEL_BUTTON_CLASS + (this.parent.renderMode === 'Popup' ?
                (' ' + BUTTON_FLAT_CLASS) : '') + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
            content: this.parent.allowDeferLayoutUpdate ? this.parent.localeObj.getConstant('cancel') :
                this.parent.localeObj.getConstant('close'),
            enableRtl: this.parent.enableRtl, isPrimary: !this.parent.allowDeferLayoutUpdate,
            locale: this.parent.locale, enableHtmlSanitizer: this.parent.enableHtmlSanitizer
        });
        this.deferUpdateCancelButton.isStringTemplate = true;
        this.deferUpdateCancelButton.appendTo('#' + this.parent.element.id + '_DeferUpdateButton2');
        this.deferUpdateCancelButton.element.onclick = this.onCloseFieldList.bind(this);
    }
    createDeferUpdateButtons() {
        const layoutFooter = createElement('div', {
            className: LAYOUT_FOOTER
        });
        if (this.parent.allowDeferLayoutUpdate) {
            const checkBoxLayout = createElement('div', {
                className: CHECKBOX_LAYOUT,
                attrs: { 'title': this.parent.localeObj.getConstant('deferLayoutUpdate') }
            });
            const deferUpdateCheckBox = createElement('input', {
                id: this.parent.element.id + 'DeferUpdateCheckBox'
            });
            checkBoxLayout.appendChild(deferUpdateCheckBox);
            layoutFooter.appendChild(checkBoxLayout);
        }
        const buttonLayout = createElement('div', {
            className: BUTTON_LAYOUT
        });
        if (this.parent.allowDeferLayoutUpdate) {
            const deferUpdateButton1 = createElement('button', {
                id: this.parent.element.id + '_DeferUpdateButton1', attrs: { 'type': 'button', 'title': this.parent.localeObj.getConstant('apply') }
            });
            buttonLayout.appendChild(deferUpdateButton1);
        }
        const deferUpdateButton2 = createElement('button', {
            id: this.parent.element.id + '_DeferUpdateButton2', attrs: { 'type': 'button', 'title': this.parent.localeObj.getConstant('cancel') }
        });
        buttonLayout.appendChild(deferUpdateButton2);
        layoutFooter.appendChild(buttonLayout);
        return layoutFooter;
    }
    onCheckChange(args) {
        if (args.checked) {
            this.parent.clonedDataSource = extend({}, this.parent.dataSourceSettings, null, true);
            if (this.parent.dataType === 'olap') {
                this.parent.clonedFieldListData = PivotUtil.cloneOlapFieldSettings(this.parent.olapEngineModule.fieldListData);
            }
            this.parent.clonedFieldList = PivotUtil.getClonedFieldList(this.parent.pivotFieldList);
        }
        this.parent.allowDeferLayoutUpdate = !this.parent.allowDeferLayoutUpdate;
        if (this.parent.renderMode === 'Fixed') {
            this.deferUpdateApplyButton.setProperties({ disabled: !this.parent.allowDeferLayoutUpdate });
            this.deferUpdateCancelButton.setProperties({ disabled: !this.parent.allowDeferLayoutUpdate });
        }
        else {
            if (this.parent.allowDeferLayoutUpdate) {
                this.deferUpdateApplyButton.element.style.display = '';
                this.deferUpdateCancelButton.setProperties({ content: this.parent.localeObj.getConstant('cancel') });
                this.deferUpdateCancelButton.isPrimary = false;
            }
            else {
                this.deferUpdateApplyButton.element.style.display = 'none';
                this.deferUpdateCancelButton.setProperties({ content: this.parent.localeObj.getConstant('close') });
                this.deferUpdateCancelButton.isPrimary = true;
            }
        }
        this.onCloseFieldList(null, true);
    }
    applyButtonClick() {
        if (this.parent.getModuleName() === 'pivotfieldlist' && this.parent.allowDeferLayoutUpdate) {
            this.parent.pivotChange = false;
        }
        this.parent.isDeferUpdateApplied = true;
        this.parent.updateDataSource(false);
        const parent = this.parent;
        parent.axisFieldModule.render();
        parent.clonedDataSource = extend({}, parent.dataSourceSettings, null, true);
        if (this.parent.dataType === 'olap') {
            this.parent.clonedFieldListData = PivotUtil.cloneOlapFieldSettings(this.parent.olapEngineModule.fieldListData);
        }
        parent.clonedFieldList = PivotUtil.getClonedFieldList(parent.pivotFieldList);
    }
    onCloseFieldList(args, isDeferLayoutEnabled) {
        if ((this.parent.allowDeferLayoutUpdate || isDeferLayoutEnabled) && (!this.parent.isPopupView ||
            (this.parent.pivotGridModule && this.parent.pivotGridModule.actionObj.actionName !== '') || this.parent.actionObj.actionName !== '')) {
            this.parent.
                setProperties({
                dataSourceSettings: this.parent.clonedDataSource.properties
            }, true);
            if (this.parent.dataType === 'olap') {
                this.parent.olapEngineModule.fieldList = PivotUtil.getClonedFieldList(this.parent.clonedFieldList);
                if (!this.parent.isPopupView) {
                    for (const name of Object.keys(this.parent.clonedFieldList)) {
                        const item = this.parent.clonedFieldList[name];
                        this.parent.olapEngineModule.updateFieldlistData(item.id, item.isSelected);
                    }
                }
                else if (this.parent.isPopupView && this.parent.clonedFieldListData &&
                    Object.keys(this.parent.clonedFieldListData).length > 0) {
                    this.parent.olapEngineModule.fieldListData = this.parent.clonedFieldListData;
                }
            }
            else {
                this.parent.engineModule.fieldList = PivotUtil.getClonedFieldList(this.parent.clonedFieldList);
            }
            this.parent.updateDataSource(false, true);
        }
        if (this.parent.allowDeferLayoutUpdate && this.parent.isPopupView && this.parent.pivotGridModule && !this.parent.isAdaptive) {
            this.parent.pivotGridModule.actionObj.actionName = '';
            this.parent.pivotGridModule.engineModule = this.parent.engineModule;
            this.parent.pivotGridModule.olapEngineModule = this.parent.olapEngineModule;
            this.parent.pivotGridModule.
                setProperties({
                dataSourceSettings: this.parent.clonedDataSource.properties
            }, true);
        }
        if (this.parent.renderMode === 'Popup' && !isDeferLayoutEnabled) {
            this.parent.dialogRenderer.fieldListDialog.hide();
            this.parent.actionObj.actionName = closeFieldlist;
        }
        else {
            this.parent.actionObj.actionName = actionDropped;
        }
        if (this.parent.actionObj.actionName) {
            this.parent.actionCompleteMethod();
        }
    }
    renderFieldListDialog(fieldListWrappper) {
        const toggleFieldList = createElement('div', {
            className: TOGGLE_FIELD_LIST_CLASS + ' ' + ICON + ' ' + TOGGLE_SELECT_CLASS,
            attrs: {
                'tabindex': '0',
                title: this.parent.localeObj.getConstant('fieldList'),
                'aria-disabled': 'false',
                'aria-label': this.parent.localeObj.getConstant('fieldList'),
                'role': 'button'
            }
        });
        this.parent.element.appendChild(toggleFieldList);
        if (this.parent.isAdaptive) {
            const headerTemplate = '<div class=' + TITLE_MOBILE_HEADER + '><span class="' + ICON + ' ' +
                BACK_ICON + '"></span><div class=' + TITLE_MOBILE_CONTENT + '>' + this.parent.localeObj.getConstant('fieldList') +
                '</div></div>';
            const buttons = [{
                    click: this.showFieldListDialog.bind(this),
                    buttonModel: {
                        cssClass: ADAPTIVE_FIELD_LIST_BUTTON_CLASS + ' ' + BUTTON_SMALL_CLASS + ' ' + BUTTON_ROUND_CLASS + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
                        iconCss: ICON + ' ' + ADD_ICON_CLASS,
                        isPrimary: true
                    }
                }, {
                    click: this.showCalculatedField.bind(this),
                    buttonModel: {
                        cssClass: ADAPTIVE_CALCULATED_FIELD_BUTTON_CLASS +
                            ' ' + BUTTON_SMALL_CLASS + ' ' + BUTTON_ROUND_CLASS + ' ' + ICON_DISABLE + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
                        iconCss: ICON + ' ' + ADD_ICON_CLASS, enableRtl: this.parent.enableRtl,
                        isPrimary: true
                    }
                }];
            this.fieldListDialog = new Dialog({
                animationSettings: { effect: this.parent.enableRtl ? 'SlideRight' : 'SlideLeft' },
                header: headerTemplate,
                content: this.parentElement,
                isModal: true,
                showCloseIcon: false,
                visible: false,
                allowDragging: false,
                closeOnEscape: false,
                enableRtl: this.parent.enableRtl,
                locale: this.parent.locale,
                enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
                width: '100%',
                height: '100%',
                position: { X: 'center', Y: 'center' },
                buttons: buttons,
                target: document.body,
                cssClass: this.parent.cssClass,
                close: this.removeFieldListIcon.bind(this),
                open: this.dialogOpen.bind(this)
            });
            this.fieldListDialog.isStringTemplate = true;
            this.fieldListDialog.appendTo(fieldListWrappper);
            // this.fieldListDialog.element.querySelector('.e-dlg-header').innerHTML = headerTemplate;
            setStyleAttribute(select('#' + fieldListWrappper.id + '_dialog-content', fieldListWrappper), {
                'padding': '0'
            });
            const footer = fieldListWrappper.querySelector('.' + FOOTER_CONTENT_CLASS);
            addClass([footer], FIELD_LIST_FOOTER_CLASS);
            removeClass([footer.querySelector('.' + ADAPTIVE_CALCULATED_FIELD_BUTTON_CLASS)], BUTTON_FLAT_CLASS);
            removeClass([footer.querySelector('.' + ADAPTIVE_FIELD_LIST_BUTTON_CLASS)], BUTTON_FLAT_CLASS);
            this.fieldListDialog.element.querySelector('.' + BACK_ICON).onclick =
                this.parent.allowDeferLayoutUpdate ? this.onDeferUpdateClick.bind(this) : this.onCloseFieldList.bind(this);
        }
        else {
            const template = this.createDeferUpdateButtons().outerHTML;
            const headerTemplate = '<div class=' + TITLE_HEADER_CLASS + '><div class=' +
                TITLE_CONTENT_CLASS + '>' + this.parent.localeObj.getConstant('fieldList') + '</div></div>';
            this.fieldListDialog = new Dialog({
                animationSettings: { effect: 'Zoom' },
                header: headerTemplate,
                content: this.parentElement,
                isModal: false,
                showCloseIcon: false,
                visible: false,
                allowDragging: true,
                enableRtl: this.parent.enableRtl,
                locale: this.parent.locale,
                enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
                width: this.parent.element.style.width,
                position: { X: 'center', Y: this.parent.element.offsetTop },
                footerTemplate: template,
                closeOnEscape: false,
                cssClass: this.parent.cssClass,
                target: !isNullOrUndefined(this.parent.target) ? ((typeof this.parent.target) === 'string') ?
                    document.querySelector(this.parent.target) : this.parent.target : document.body,
                close: this.removeFieldListIcon.bind(this)
            });
            this.fieldListDialog.isStringTemplate = true;
            this.fieldListDialog.appendTo(fieldListWrappper);
            // this.fieldListDialog.element.querySelector('.e-dlg-header').innerHTML = headerTemplate;
            // this.fieldListDialog.element.querySelector('.e-footer-content').innerHTML = template;
            this.renderDeferUpdateButtons();
            setStyleAttribute(select('#' + fieldListWrappper.id + '_title', fieldListWrappper), { 'width': '100%' });
            fieldListWrappper.querySelector('.' + TITLE_HEADER_CLASS).appendChild(this.createCalculatedButton());
        }
    }
    dialogOpen() {
        if (this.lastTabIndex === 4) {
            this.adaptiveElement.items[this.lastTabIndex].content = '';
            this.adaptiveElement.dataBind();
            this.parent.notify(initCalculatedField, {});
        }
        else {
            this.adaptiveElement.refresh();
        }
    }
    /**
     * Called internally if any of the field added to axis.
     *
     * @param {string[]} selectedNodes - selectedNodes
     * @returns {void}
     * @hidden
     */
    updateDataSource(selectedNodes) {
        const axis = ['filters', 'columns', 'rows', 'values'];
        for (const field of selectedNodes) {
            const fieldName = field;
            const droppedClass = axis[this.adaptiveElement.selectedItem];
            this.parent.pivotCommon.dataSourceUpdate.control = this.parent.getModuleName() === 'pivotview' ?
                this.parent : (this.parent.pivotGridModule ?
                this.parent.pivotGridModule : this.parent);
            this.parent.pivotCommon.dataSourceUpdate.updateDataSource(fieldName, droppedClass, -1);
        }
        this.parent.axisFieldModule.render();
        if (!this.parent.allowDeferLayoutUpdate) {
            this.parent.updateDataSource(true);
        }
        else {
            this.parent.triggerPopulateEvent();
        }
    }
    onDeferUpdateClick() {
        this.parent.updateDataSource();
        this.parent.dialogRenderer.fieldListDialog.hide();
    }
    renderAdaptiveLayout(fieldListWrappper) {
        const layoutFooter = createElement('div', {
            className: FIELD_LIST_FOOTER_CLASS
        });
        fieldListWrappper.appendChild(this.parentElement);
        const items = [
            {
                header: { 'text': this.parent.localeObj.getConstant('filters') },
                content: this.createAxisTable('filters')
            },
            {
                header: { 'text': this.parent.localeObj.getConstant('columns') },
                content: this.createAxisTable('columns')
            },
            {
                header: { 'text': this.parent.localeObj.getConstant('rows') },
                content: this.createAxisTable('rows')
            },
            {
                header: { 'text': this.parent.localeObj.getConstant('values') },
                content: this.createAxisTable('values')
            },
            {
                header: { 'text': this.parent.localeObj.getConstant('createCalculatedField') },
                content: 'Calculated Field Related UI'
            }
        ];
        if (!this.parent.allowCalculatedField) {
            items.pop();
        }
        this.adaptiveElement = new Tab({
            heightAdjustMode: 'Auto',
            items: items,
            height: '100%',
            enableRtl: this.parent.enableRtl,
            enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
            locale: this.parent.locale,
            selected: this.tabSelect.bind(this),
            cssClass: this.parent.cssClass
        });
        if (this.parent.renderMode === 'Fixed') {
            layoutFooter.appendChild(this.createAddButton());
            addClass([fieldListWrappper], STATIC_FIELD_LIST_CLASS);
            this.adaptiveElement.isStringTemplate = true;
            this.adaptiveElement.appendTo(this.parentElement);
            this.parentElement.appendChild(layoutFooter);
        }
        else {
            this.adaptiveElement.isStringTemplate = true;
            this.adaptiveElement.appendTo(this.parentElement);
        }
    }
    tabSelect(e) {
        const fieldWrapper = closest(this.parentElement, '.' + WRAPPER_CLASS);
        this.lastTabIndex = e.selectedIndex;
        if (fieldWrapper && fieldWrapper.querySelector('.' + ADAPTIVE_FIELD_LIST_BUTTON_CLASS)) {
            if (e.selectedIndex !== 4) {
                addClass([fieldWrapper.querySelector('.' + ADAPTIVE_CALCULATED_FIELD_BUTTON_CLASS)], ICON_DISABLE);
                removeClass([fieldWrapper.querySelector('.' + ADAPTIVE_FIELD_LIST_BUTTON_CLASS)], ICON_DISABLE);
            }
            else {
                removeClass([fieldWrapper.querySelector('.' + ADAPTIVE_CALCULATED_FIELD_BUTTON_CLASS)], ICON_DISABLE);
                addClass([fieldWrapper.querySelector('.' + ADAPTIVE_FIELD_LIST_BUTTON_CLASS)], ICON_DISABLE);
            }
        }
        if (e.selectedIndex === 4) {
            this.adaptiveElement.items[4].content = '';
            this.adaptiveElement.dataBind();
            this.parent.notify(initCalculatedField, {});
        }
        else {
            this.parent.axisFieldModule.render();
        }
    }
    createCalculatedButton() {
        const calculatedButton = createElement('button', {
            id: this.parent.element.id + '_CalculatedField',
            attrs: {
                'type': 'button',
                'tabindex': '0',
                'aria-disabled': 'false',
                'aria-label': this.parent.localeObj.getConstant('CalculatedField')
            }
        });
        const calculateField = new Button({
            cssClass: CALCULATED_FIELD_CLASS + ' ' + ICON_DISABLE + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
            content: this.parent.localeObj.getConstant('CalculatedField'),
            enableRtl: this.parent.enableRtl, locale: this.parent.locale, enableHtmlSanitizer: this.parent.enableHtmlSanitizer
        });
        calculateField.isStringTemplate = true;
        calculateField.appendTo(calculatedButton);
        if (this.parent.calculatedFieldModule) {
            removeClass([calculatedButton], ICON_DISABLE);
        }
        calculateField.element.onclick = this.showCalculatedField.bind(this);
        return calculatedButton;
    }
    createAddButton() {
        const footerContainer = createElement('div', {
            className: FIELD_LIST_FOOTER_CLASS + '-content'
        });
        const fieldListButton = createElement('div', {});
        const calculatedButton = createElement('div', {});
        const calculateField = new Button({
            cssClass: ADAPTIVE_CALCULATED_FIELD_BUTTON_CLASS +
                ' ' + BUTTON_SMALL_CLASS + ' ' + BUTTON_ROUND_CLASS + ' ' + ICON_DISABLE + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
            iconCss: ICON + ' ' + ADD_ICON_CLASS,
            enableRtl: this.parent.enableRtl, locale: this.parent.locale, enableHtmlSanitizer: this.parent.enableHtmlSanitizer
        });
        const fieldList = new Button({
            cssClass: ADAPTIVE_FIELD_LIST_BUTTON_CLASS + ' ' + BUTTON_SMALL_CLASS + ' ' + BUTTON_ROUND_CLASS + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
            iconCss: ICON + ' ' + ADD_ICON_CLASS,
            enableRtl: this.parent.enableRtl, locale: this.parent.locale, enableHtmlSanitizer: this.parent.enableHtmlSanitizer
        });
        fieldList.isStringTemplate = true;
        fieldList.appendTo(fieldListButton);
        calculateField.isStringTemplate = true;
        calculateField.appendTo(calculatedButton);
        footerContainer.appendChild(fieldListButton);
        footerContainer.appendChild(calculatedButton);
        calculateField.element.onclick = this.showCalculatedField.bind(this);
        fieldList.element.onclick = this.showFieldListDialog.bind(this);
        return footerContainer;
    }
    createAxisTable(axis) {
        const axisWrapper = createElement('div', {
            className: FIELD_LIST_CLASS + '-' + axis
        });
        const axisContent = createElement('div', { className: AXIS_CONTENT_CLASS + ' ' + 'e-' + axis });
        const axisPrompt = createElement('span', {
            className: AXIS_PROMPT_CLASS
        });
        axisPrompt.innerText = this.parent.localeObj.getConstant('addPrompt');
        axisWrapper.appendChild(axisContent);
        axisWrapper.appendChild(axisPrompt);
        return axisWrapper;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    showCalculatedField(event) {
        try {
            if (!this.parent.isAdaptive) {
                this.parent.actionObj.actionName = openCalculatedField;
                if (this.parent.actionBeginMethod()) {
                    return;
                }
                if (this.parent.dialogRenderer.fieldListDialog) {
                    this.parent.dialogRenderer.fieldListDialog.hide();
                    addClass([this.parent.element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS)], ICON_HIDDEN);
                }
            }
            this.parent.notify(initCalculatedField, {});
        }
        catch (execption) {
            this.parent.actionFailureMethod(execption);
        }
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    showFieldListDialog(event) {
        const activeindex = this.adaptiveElement.selectedItem;
        this.parent.treeViewModule.render(activeindex);
    }
    /**  @hidden */
    onShowFieldList() {
        this.parent.actionObj.actionName = showFieldList;
        if (this.parent.actionBeginMethod()) {
            return;
        }
        this.parent.actionObj.actionName = '';
        try {
            if (this.parent.allowDeferLayoutUpdate) {
                if (this.parent.isAdaptive) {
                    this.parent.axisFieldModule.render();
                }
                this.parent.clonedDataSource = extend({}, this.parent.dataSourceSettings, null, true);
                if (this.parent.dataType === 'olap') {
                    this.parent.clonedFieldListData = PivotUtil.cloneOlapFieldSettings(this.parent.olapEngineModule.fieldListData);
                }
                this.parent.clonedFieldList = PivotUtil.getClonedFieldList(this.parent.pivotFieldList);
            }
            addClass([this.parent.element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS)], ICON_HIDDEN);
            this.parent.dialogRenderer.fieldListDialog.show();
            this.parent.dialogRenderer.fieldListDialog.element.style.top =
                parseInt(this.parent.dialogRenderer.fieldListDialog.element.style.top, 10) < 0 ?
                    '0px' : this.parent.dialogRenderer.fieldListDialog.element.style.top;
        }
        catch (execption) {
            this.parent.actionFailureMethod(execption);
        }
    }
    removeFieldListIcon() {
        if (this.parent.isAdaptive && this.parent.allowCalculatedField && this.parent.calculatedFieldModule) {
            if (this.adaptiveElement && this.adaptiveElement.selectedItem === 4) {
                if (select('#' + this.parent.element.id + 'droppable', this.adaptiveElement.element)) {
                    this.parent.calculatedFieldModule.updateAdaptiveCalculatedField(false);
                }
                else {
                    this.parent.notify(initCalculatedField, { edit: false });
                }
            }
        }
        if (!document.getElementById(this.parent.element.id + 'calculateddialog')) {
            removeClass([this.parent.element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS)], ICON_HIDDEN);
        }
    }
    keyPress(e) {
        if (e.keyCode === 13 && e.target) {
            e.target.click();
            e.preventDefault();
            return;
        }
    }
    wireDialogEvent(element) {
        EventHandler.add(element, 'keydown', this.keyPress, this);
        EventHandler.add(element, 'click', this.onShowFieldList, this);
    }
    unWireDialogEvent(element) {
        EventHandler.remove(element, 'keydown', this.keyPress);
        EventHandler.remove(element, 'click', this.onShowFieldList);
    }
    /**
     * Destroys the Field Table component.
     *
     * @function destroy
     * @returns {void}
     * @hidden
     */
    destroy() {
        if (this.parent.renderMode === 'Popup') {
            this.unWireDialogEvent(this.parent.element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS));
        }
        if (this.deferUpdateCheckBox && !this.deferUpdateCheckBox.isDestroyed) {
            this.deferUpdateCheckBox.destroy();
            this.deferUpdateCheckBox = null;
        }
        if (this.deferUpdateApplyButton && !this.deferUpdateApplyButton.isDestroyed) {
            this.deferUpdateApplyButton.destroy();
            this.deferUpdateApplyButton = null;
        }
        if (this.deferUpdateCancelButton && !this.deferUpdateCancelButton.isDestroyed) {
            this.deferUpdateCancelButton.destroy();
            this.deferUpdateCancelButton = null;
        }
        if (this.parent.renderMode === 'Popup') {
            if (this.fieldListDialog && !this.fieldListDialog.isDestroyed) {
                this.fieldListDialog.destroy();
                this.fieldListDialog = null;
            }
            if (document.getElementById(this.parent.element.id + '_Container')) {
                remove(document.getElementById(this.parent.element.id + '_Container'));
            }
        }
    }
}

/**
 * Module to render Field List
 */
/** @hidden */
class TreeViewRenderer {
    /** Constructor for render module
     *
     * @param {PivotFieldList} parent - Instance of field list.
     */
    constructor(parent) {
        this.selectedNodes = [];
        this.isSearching = false;
        this.parentIDs = [];
        this.parent = parent;
        this.addEventListener();
    }
    /**
     * Initialize the field list tree rendering
     *
     * @param {number} axis - Axis position.
     * @returns {void}
     * @private
     */
    render(axis) {
        this.parentElement = this.parent.dialogRenderer.parentElement;
        this.fieldListSort = this.parent.pivotGridModule ?
            this.parent.pivotGridModule.defaultFieldListOrder : this.parent.defaultFieldListOrder;
        this.fieldListSort = this.fieldListSort === 'Ascending' ? 'Ascend' :
            this.fieldListSort === 'Descending' ? 'Descend' : 'None';
        if (!this.parent.isAdaptive) {
            const fieldTable = createElement('div', {
                className: FIELD_TABLE_CLASS + ' ' + (this.parent.dataType === 'olap' ? OLAP_FIELD_TABLE_CLASS : '')
            });
            const treeHeader = createElement('div', {
                className: FIELD_HEADER_CLASS
            });
            treeHeader.innerText = this.parent.localeObj.getConstant('allFields');
            const searchWrapper = createElement('div', {
                id: this.parent.element.id + '_SearchDiv', attrs: { 'tabindex': '-1' },
                className: FIELD_LIST_SEARCH_CLASS
            });
            const searchInput = createElement('input', { attrs: { 'type': 'text' } });
            searchWrapper.appendChild(searchInput);
            this.fieldSearch = new TextBox({
                placeholder: this.parent.localeObj.getConstant('search'),
                enableRtl: this.parent.enableRtl,
                locale: this.parent.locale,
                cssClass: FIELD_LIST_SEARCH_INPUT_CLASS + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
                input: this.textChange.bind(this),
                showClearButton: true
            });
            this.fieldSearch.isStringTemplate = true;
            this.fieldSearch.appendTo(searchInput);
            this.fieldSearch.addIcon('append', FIELD_LIST_SEARCH_ICON_CLASS + ' ' + ICON);
            const promptDiv = createElement('div', {
                className: EMPTY_MEMBER_CLASS + ' ' + ICON_DISABLE
            });
            promptDiv.innerText = this.parent.localeObj.getConstant('noMatches');
            const treeOuterDiv = createElement('div', {
                className: FIELD_LIST_TREE_OUTER_DIV_CLASS + ' ' + TREE_CONTAINER
            });
            this.treeViewElement = createElement('div', {
                id: this.parent.element.id + '_TreeView',
                className: FIELD_LIST_CLASS + ' ' + (this.parent.dataType === 'olap' ? OLAP_FIELD_LIST_CLASS : '')
            });
            const fieldHeaderWrappper = createElement('div', { className: FIELD_HEADER_CONTAINER_CLASS });
            fieldHeaderWrappper.appendChild(treeHeader);
            fieldTable.appendChild(fieldHeaderWrappper);
            this.updateSortElements(fieldHeaderWrappper);
            if (this.parent.enableFieldSearching) {
                fieldTable.appendChild(searchWrapper);
                fieldTable.appendChild(promptDiv);
            }
            treeOuterDiv.appendChild(this.treeViewElement);
            fieldTable.appendChild(treeOuterDiv);
            this.parentElement.appendChild(fieldTable);
            if (this.parent.renderMode === 'Fixed') {
                const centerDiv = createElement('div', { className: STATIC_CENTER_DIV_CLASS });
                const axisHeader = createElement('div', {
                    className: STATIC_CENTER_HEADER_CLASS
                });
                axisHeader.innerText = this.parent.localeObj.getConstant('centerHeader');
                this.parentElement.appendChild(centerDiv);
                this.parentElement.appendChild(axisHeader);
            }
            this.renderTreeView();
        }
        else {
            this.renderTreeDialog(axis);
        }
    }
    updateSortElements(headerWrapper) {
        const options = { 'None': 'sortNone', 'Ascend': 'sortAscending', 'Descend': 'sortDescending' };
        const keys = Object.keys(options);
        for (const option of keys) {
            const spanElement = createElement('span', {
                attrs: {
                    'tabindex': '0',
                    'aria-disabled': 'false',
                    'aria-label': 'Sort ' + option,
                    'data-sort': option,
                    'title': this.parent.localeObj.getConstant(options[option]),
                    'role': 'button'
                },
                className: ICON + ' ' + 'e-sort-' + option.toLowerCase() + ' ' +
                    (this.fieldListSort === option ? 'e-selected' : '')
            });
            headerWrapper.appendChild(spanElement);
            this.unWireFieldListEvent(spanElement);
            this.wireFieldListEvent(spanElement);
        }
    }
    renderTreeView() {
        this.fieldTable = new TreeView({
            fields: { dataSource: this.getTreeData(), id: 'id', text: 'caption', isChecked: 'isSelected', parentID: 'pid', iconCss: 'spriteCssClass' },
            nodeChecked: this.nodeStateChange.bind(this),
            cssClass: FIELD_LIST_TREE_CLASS + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
            showCheckBox: true,
            allowDragAndDrop: true,
            sortOrder: 'None',
            autoCheck: false,
            loadOnDemand: this.parent.dataType === 'olap' ? false : true,
            enableRtl: this.parent.enableRtl,
            locale: this.parent.locale,
            enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
            nodeDragStart: this.dragStart.bind(this),
            nodeDragStop: this.dragStop.bind(this),
            drawNode: this.updateTreeNode.bind(this),
            nodeExpanding: this.updateNodeIcon.bind(this),
            nodeCollapsed: this.updateNodeIcon.bind(this),
            nodeSelected: (args) => {
                removeClass([args.node], 'e-active');
                args.cancel = true;
            }
        });
        this.treeViewElement.innerHTML = '';
        this.fieldTable.isStringTemplate = true;
        this.fieldTable.appendTo(this.treeViewElement);
        const dragEle = this.parent.renderMode === 'Fixed' ? this.parent.element : this.parentElement;
        if (!isNullOrUndefined(dragEle.querySelector('.' + FIELD_LIST_CLASS))) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            dragEle.querySelector('.' + FIELD_LIST_CLASS).ej2_instances[0].dragObj.enableAutoScroll = false;
        }
    }
    updateNodeIcon(args) {
        if (this.parent.dataType === 'olap') {
            if (args.node && args.node.querySelector('.e-list-icon') &&
                (args.node.querySelector('.e-list-icon').className.indexOf('e-folderCDB-icon') > -1)) {
                const node = args.node.querySelector('.e-list-icon');
                removeClass([node], 'e-folderCDB-icon');
                addClass([node], 'e-folderCDB-open-icon');
            }
            else if (args.node && args.node.querySelector('.e-list-icon') &&
                (args.node.querySelector('.e-list-icon').className.indexOf('e-folderCDB-open-icon') > -1)) {
                const node = args.node.querySelector('.e-list-icon');
                removeClass([node], 'e-folderCDB-open-icon');
                addClass([node], 'e-folderCDB-icon');
            }
        }
    }
    updateTreeNode(args) {
        let allowDrag = false;
        if (this.parent.dataType === 'olap') {
            allowDrag = this.updateOlapTreeNode(args);
        }
        else {
            if (args.nodeData.hasChildren) {
                allowDrag = false;
                args.node.querySelector('.e-checkbox-wrapper').style.display = 'none';
                addClass([args.node], FIELD_TREE_PARENT);
            }
            else {
                allowDrag = true;
            }
        }
        if (!isNullOrUndefined(args.nodeData.pid)) {
            addClass([args.node], FIELD_TREE_CHILD);
        }
        const liTextElement = args.node.querySelector('.' + TEXT_CONTENT_CLASS);
        if (args.node.querySelector('.e-list-icon') && liTextElement) {
            const liIconElement = args.node.querySelector('.e-list-icon');
            liTextElement.insertBefore(liIconElement, args.node.querySelector('.e-list-text'));
        }
        if (allowDrag && !this.parent.isAdaptive) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const field = PivotUtil.getFieldInfo(args.nodeData.id, this.parent);
            allowDrag = false;
            const dragElement = createElement('span', {
                attrs: {
                    'tabindex': '-1',
                    title: (field.fieldItem ? field.fieldItem.allowDragAndDrop ?
                        this.parent.localeObj.getConstant('drag') : '' : this.parent.localeObj.getConstant('drag')),
                    'aria-disabled': 'false'
                },
                className: ICON + ' ' + DRAG_CLASS + ' ' +
                    (field.fieldItem ? field.fieldItem.allowDragAndDrop ? '' : DRAG_DISABLE_CLASS : '')
            });
            if (args.node.querySelector('.e-checkbox-wrapper') &&
                !args.node.querySelector('.cls.DRAG_CLASS') && liTextElement) {
                liTextElement.insertBefore(dragElement, args.node.querySelector('.e-checkbox-wrapper'));
            }
        }
        if (args.node.querySelector('.' + NODE_CHECK_CLASS)) {
            addClass([args.node.querySelector('.' + LIST_TEXT_CLASS)], LIST_SELECT_CLASS);
        }
        if (this.parent.enableFieldSearching && this.isSearching) {
            const liElement = args.node;
            if (this.parent.dataType === 'olap') {
                const id = liElement.getAttribute('data-uid');
                const searchItem = this.parent.pivotCommon.eventBase.searchListItem;
                for (let i = 0; i < this.parentIDs.length; i++) {
                    if (id === this.parentIDs[i]) {
                        addClass([liElement], ICON_DISABLE);
                    }
                    for (const li2 of searchItem) {
                        const parentID = this.parent.pivotCommon.eventBase.getParentIDs(this.fieldTable, li2.getAttribute('data-uid'), []);
                        if (PivotUtil.inArray(id, parentID) > -1) {
                            removeClass([liElement], ICON_DISABLE);
                            break;
                        }
                    }
                }
            }
            else {
                for (let i = 0; i < this.nonSearchList.length; i++) {
                    if (liElement.textContent === this.nonSearchList[i].textContent) {
                        addClass([liElement], ICON_DISABLE);
                        break;
                    }
                    else {
                        if (liElement.innerText === this.nonSearchList[i].textContent) {
                            addClass([liElement], ICON_DISABLE);
                            break;
                        }
                    }
                }
            }
        }
    }
    updateOlapTreeNode(args) {
        let allowDrag = false;
        if (this.parent.dataType === 'olap') {
            if (args.node && args.node.querySelector('.e-calcMemberGroupCDB,.e-measureGroupCDB-icon,.e-folderCDB-icon,.e-folderCDB-open-icon,.e-dimensionCDB-icon,.e-kpiCDB-icon')) {
                args.node.querySelector('.e-checkbox-wrapper').style.display = 'none';
            }
            if (args.node && args.node.querySelector('.e-list-icon') &&
                (args.node.querySelector('.e-list-icon').className.indexOf('e-level-members') > -1)) {
                if (this.parent.isAdaptive) {
                    args.node.querySelector('.e-checkbox-wrapper').style.display = 'none';
                }
                else {
                    args.node.querySelector('.e-checkbox-wrapper').style.visibility = 'hidden';
                }
            }
            if (args.node && (args.node.querySelector('.e-hierarchyCDB-icon,.e-attributeCDB-icon,.e-namedSetCDB-icon') ||
                args.node.querySelector('.e-measure-icon,.e-kpiGoal-icon,.e-kpiStatus-icon,.e-kpiTrend-icon,.e-kpiValue-icon') ||
                args.node.querySelector('.e-calc-measure-icon,.e-calc-dimension-icon'))) {
                if (args.node.querySelector('.e-measure-icon')) {
                    args.node.querySelector('.e-list-icon').style.display = 'none';
                    allowDrag = true;
                }
                else {
                    allowDrag = true;
                }
            }
        }
        else {
            allowDrag = true;
        }
        return allowDrag;
    }
    renderTreeDialog(axis) {
        const fieldListDialog = createElement('div', {
            id: this.parent.element.id + '_FieldListTreeView',
            className: ADAPTIVE_FIELD_LIST_DIALOG_CLASS + ' ' + (this.parent.dataType === 'olap' ? 'e-olap-editor-dialog' : '')
        });
        this.parentElement.appendChild(fieldListDialog);
        this.fieldDialog = new Dialog({
            animationSettings: { effect: 'Fade' },
            allowDragging: false,
            header: this.parent.localeObj.getConstant('adaptiveFieldHeader'),
            content: this.createTreeView(this.getTreeData(axis)),
            isModal: true,
            visible: true,
            showCloseIcon: false,
            enableRtl: this.parent.enableRtl,
            enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
            locale: this.parent.locale,
            width: '320px',
            height: '350px',
            position: { X: 'center', Y: 'center' },
            buttons: [{
                    click: this.closeTreeDialog.bind(this),
                    buttonModel: {
                        cssClass: CANCEL_BUTTON_CLASS + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''), content: this.parent.localeObj.getConstant('cancel')
                    }
                }, {
                    click: this.onFieldAdd.bind(this),
                    buttonModel: {
                        cssClass: OK_BUTTON_CLASS + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''), content: this.parent.localeObj.getConstant('add'),
                        isPrimary: true
                    }
                }],
            closeOnEscape: false,
            cssClass: this.parent.cssClass,
            target: this.parentElement.parentElement,
            close: this.dialogClose.bind(this)
        });
        this.fieldDialog.isStringTemplate = true;
        this.fieldDialog.appendTo(fieldListDialog);
        // this.fieldDialog.element.querySelector('.e-dlg-header').innerText = this.parent.localeObj.getConstant('adaptiveFieldHeader');
    }
    dialogClose() {
        if (document.getElementById(this.parent.element.id + '_FieldListTreeView')) {
            remove(document.getElementById(this.parent.element.id + '_FieldListTreeView'));
        }
    }
    createTreeView(treeData) {
        const editorTreeWrapper = createElement('div', {
            id: this.parent.element.id + 'EditorDiv',
            className: EDITOR_TREE_WRAPPER_CLASS
        });
        const searchWrapper = createElement('div', {
            id: this.parent.element.id + '_SearchDiv', attrs: { 'tabindex': '-1' },
            className: EDITOR_SEARCH_WRAPPER_CLASS
        });
        const editorSearch = createElement('input', { attrs: { 'type': 'text' } });
        searchWrapper.appendChild(editorSearch);
        const treeOuterDiv = createElement('div', { className: FIELD_LIST_TREE_OUTER_DIV_CLASS });
        const treeViewContainer = createElement('div', {
            className: EDITOR_TREE_CONTAINER_CLASS + ' ' + (this.parent.dataType === 'olap' ? 'e-olap-field-list-tree' : '')
        });
        editorTreeWrapper.appendChild(searchWrapper);
        this.editorSearch = new MaskedTextBox({
            showClearButton: true,
            placeholder: this.parent.localeObj.getConstant('search'),
            enableRtl: this.parent.enableRtl,
            locale: this.parent.locale,
            cssClass: EDITOR_SEARCH_CLASS + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
            change: this.textChange.bind(this)
        });
        this.editorSearch.isStringTemplate = true;
        this.editorSearch.appendTo(editorSearch);
        const promptDiv = createElement('div', {
            className: EMPTY_MEMBER_CLASS + ' ' + ICON_DISABLE
        });
        promptDiv.innerText = this.parent.localeObj.getConstant('noMatches');
        editorTreeWrapper.appendChild(promptDiv);
        treeOuterDiv.appendChild(treeViewContainer);
        editorTreeWrapper.appendChild(treeOuterDiv);
        this.fieldTable = new TreeView({
            fields: { dataSource: treeData, id: 'id', text: 'caption', isChecked: 'isSelected', parentID: 'pid', iconCss: 'spriteCssClass' },
            showCheckBox: true,
            autoCheck: false,
            loadOnDemand: this.parent.dataType === 'olap' ? false : true,
            sortOrder: this.parent.dataType === 'olap' ? 'None' : 'Ascending',
            enableRtl: this.parent.enableRtl,
            locale: this.parent.locale,
            enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
            cssClass: this.parent.cssClass,
            nodeChecked: this.addNode.bind(this),
            drawNode: this.updateTreeNode.bind(this),
            nodeExpanding: this.updateNodeIcon.bind(this),
            nodeCollapsed: this.updateNodeIcon.bind(this),
            nodeSelected: (args) => {
                removeClass([args.node], 'e-active');
                args.cancel = true;
            }
        });
        this.fieldTable.isStringTemplate = true;
        this.fieldTable.appendTo(treeViewContainer);
        return editorTreeWrapper;
    }
    textChange(e) {
        this.parent.pivotCommon.eventBase.searchTreeNodes(e, this.fieldTable, true);
        let promptDiv;
        let treeOuterDiv;
        if (this.parent.isAdaptive) {
            promptDiv = this.fieldDialog.element.querySelector('.' + EMPTY_MEMBER_CLASS);
        }
        else {
            promptDiv = this.parentElement.querySelector('.' + EMPTY_MEMBER_CLASS);
            treeOuterDiv = this.parentElement.querySelector('.' + TREE_CONTAINER);
        }
        const liList = [].slice.call(this.fieldTable.element.querySelectorAll('li'));
        const disabledList = [].slice.call(this.fieldTable.element.querySelectorAll('li.' + ICON_DISABLE));
        if (liList.length === disabledList.length) {
            removeClass([promptDiv], ICON_DISABLE);
            if (!this.parent.isAdaptive) {
                addClass([treeOuterDiv], ICON_DISABLE);
                removeClass([treeOuterDiv], FIELD_LIST_TREE_OUTER_DIV_SEARCH_CLASS);
            }
        }
        else {
            addClass([promptDiv], ICON_DISABLE);
            if (!this.parent.isAdaptive) {
                removeClass([treeOuterDiv], ICON_DISABLE);
                addClass([treeOuterDiv], FIELD_LIST_TREE_OUTER_DIV_SEARCH_CLASS);
            }
        }
        this.isSearching = disabledList.length > 0 ? true : false;
        this.nonSearchList = disabledList;
        if (this.parent.dataType === 'olap') {
            this.parentIDs = [];
            for (let i = 0; i < liList.length; i++) {
                if (liList[i].classList.contains('e-level-1')) {
                    const id = liList[i].getAttribute('data-uid');
                    this.parentIDs.push(id);
                }
            }
        }
    }
    dragStart(args) {
        if (args.event.target.classList.contains(DRAG_CLASS) &&
            !args.event.target.classList.contains(DRAG_DISABLE_CLASS)) {
            const fieldInfo = PivotUtil.getFieldInfo(args.draggedNode.getAttribute('data-uid'), this.parent);
            const dragEventArgs = {
                fieldName: fieldInfo.fieldName, fieldItem: fieldInfo.fieldItem, axis: fieldInfo.axis,
                dataSourceSettings: this.parent.dataSourceSettings, cancel: false
            };
            const control = this.parent.isPopupView ? this.parent.pivotGridModule : this.parent;
            control.trigger(fieldDragStart, dragEventArgs, (observedArgs) => {
                if (!observedArgs.cancel) {
                    this.parent.isDragging = true;
                    addClass([args.draggedNode.querySelector('.' + LIST_TEXT_CLASS)], SELECTED_NODE_CLASS);
                    let data;
                    if (this.parent.dataType === 'olap') {
                        data = this.parent.olapEngineModule.fieldList[args.draggedNode.getAttribute('data-uid')];
                    }
                    else {
                        data = this.parent.engineModule.fieldList[args.draggedNode.getAttribute('data-uid')];
                    }
                    const axis = [ROW_AXIS_CLASS, COLUMN_AXIS_CLASS, FILTER_AXIS_CLASS];
                    if (data && data.aggregateType === 'CalculatedField') {
                        for (const axisContent of axis) {
                            addClass([this.parentElement.querySelector('.' + axisContent)], NO_DRAG_CLASS);
                        }
                    }
                    const dragItem = args.clonedNode;
                    if (dragItem && (this.parent.getModuleName() === 'pivotfieldlist' &&
                        this.parent.renderMode) === 'Popup') {
                        dragItem.style.zIndex = (this.parent.dialogRenderer.fieldListDialog.zIndex + 1).toString();
                    }
                }
                else {
                    this.parent.isDragging = false;
                    args.cancel = true;
                }
            });
        }
        else {
            this.parent.isDragging = false;
            args.cancel = true;
        }
    }
    // private getFieldDragArgs(args: DragAndDropEventArgs): FieldDragStartEventArgs {
    //     let fieldInfo: FieldItemInfo = PivotUtil.getFieldInfo(args.draggedNode.getAttribute('data-uid'), this.parent);
    //     let dragEventArgs: any = {
    //         fieldName: fieldInfo.fieldName, fieldItem: fieldInfo.fieldItem, axis: fieldInfo.axis,
    //         dataSourceSettings: this.parent.dataSourceSettings, cancel: false
    //     }
    //     let treeModule: TreeViewRenderer = this;
    //     let control: PivotView | PivotFieldList = this.parent.isPopupView ? this.parent.pivotGridModule : this.parent;
    //     control.trigger(events.fieldDragStart, dragEventArgs);
    //     return dragEventArgs;
    // }
    // private getFieldDragEventArgs(dragEventArgs: FieldDragStartEventArgs): FieldDragStartEventArgs | Deferred {
    //     let callbackPromise: Deferred = new Deferred();
    //     let control: PivotView | PivotFieldList = this.parent.isPopupView ? this.parent.pivotGridModule : this.parent;
    //     control.trigger(events.fieldDragStart, dragEventArgs, (observedArgs: FieldDragStartEventArgs) => {
    //         callbackPromise.resolve(observedArgs);
    //     });
    //     return callbackPromise;
    // }
    dragStop(args) {
        args.cancel = true;
        this.parent.isDragging = false;
        const axis = [ROW_AXIS_CLASS, COLUMN_AXIS_CLASS, FILTER_AXIS_CLASS];
        for (const axisElement of axis) {
            removeClass([this.parentElement.querySelector('.' + axisElement)], NO_DRAG_CLASS);
        }
        removeClass([args.draggedNode.querySelector('.' + LIST_TEXT_CLASS)], SELECTED_NODE_CLASS);
        if (this.parent.pivotCommon.filterDialog.dialogPopUp) {
            this.parent.pivotCommon.filterDialog.dialogPopUp.close();
        }
        const fieldName = args.draggedNodeData.id.toString();
        if (!this.isNodeDropped(args, fieldName)) {
            return;
        }
        const list = this.parent.pivotFieldList;
        const selectedNode = list[fieldName];
        this.parent.pivotCommon.dataSourceUpdate.control = this.parent.getModuleName() === 'pivotview' ? this.parent :
            (this.parent.pivotGridModule ? this.parent.pivotGridModule : this.parent);
        if (this.parent.pivotCommon.nodeStateModified.onStateModified(args, fieldName)) {
            if (this.parent.allowDeferLayoutUpdate) {
                selectedNode.isSelected = true;
                this.updateDataSource();
            }
            else {
                this.parent.updateDataSource();
            }
            const parent = this.parent;
            //setTimeout(() => {
            parent.axisFieldModule.render();
            //});
        }
    }
    isNodeDropped(args, targetID) {
        let isDropped = true;
        if (args.draggedNodeData.isChecked === 'true') {
            const target = this.getButton(targetID);
            const axisPanel = closest(target, '.' + DROPPABLE_CLASS);
            const droppableElement = closest(args.target, '.' + DROPPABLE_CLASS);
            if (target && axisPanel === droppableElement) {
                const pivotButtons = [].slice.call(axisPanel.querySelectorAll('.' + PIVOT_BUTTON_CLASS));
                const dropTarget = closest(args.target, '.' + PIVOT_BUTTON_WRAPPER_CLASS);
                let sourcePosition;
                let dropPosition = -1;
                for (let i = 0, n = pivotButtons.length; i < n; i++) {
                    if (pivotButtons[i].id === target.id) {
                        sourcePosition = i;
                    }
                    if (dropTarget) {
                        const droppableButton = dropTarget.querySelector('.' + PIVOT_BUTTON_CLASS);
                        if (pivotButtons[i].id === droppableButton.id) {
                            dropPosition = i;
                        }
                    }
                }
                if (sourcePosition === dropPosition || (sourcePosition === (pivotButtons.length - 1) && dropPosition === -1)) {
                    const parentElement = document.getElementById(this.parent.element.id + '_Container');
                    removeClass([].slice.call(parentElement.querySelectorAll('.' + DROP_INDICATOR_CLASS)), INDICATOR_HOVER_CLASS);
                    isDropped = false;
                }
            }
        }
        return isDropped;
    }
    getButton(fieldName) {
        const wrapperElement = document.getElementById(this.parent.element.id + '_Container');
        const pivotButtons = [].slice.call(wrapperElement.querySelectorAll('.' + PIVOT_BUTTON_CLASS));
        let buttonElement;
        for (let i = 0, n = pivotButtons.length; i < n; i++) {
            if (pivotButtons[i].getAttribute('data-uid') === fieldName) {
                buttonElement = pivotButtons[i];
                break;
            }
        }
        return buttonElement;
    }
    nodeStateChange(args) {
        if (!args.isInteracted) {
            return;
        }
        const node = closest(args.node, '.' + TEXT_CONTENT_CLASS);
        if (!isNullOrUndefined(node)) {
            const li = closest(node, 'li');
            const id = li.getAttribute('data-uid');
            if (this.parent.pivotCommon.filterDialog.dialogPopUp) {
                this.parent.pivotCommon.filterDialog.dialogPopUp.close();
            }
            const list = this.parent.pivotFieldList;
            const selectedNode = list[id];
            const fieldInfo = PivotUtil.getFieldInfo(id, this.parent);
            const control = this.parent.isPopupView ? this.parent.pivotGridModule : this.parent;
            const parentNode = node.closest('.' + FIELD_TREE_PARENT);
            if (args.action === 'check') {
                const eventdrop = {
                    fieldName: id, dropField: fieldInfo.fieldItem,
                    dataSourceSettings: PivotUtil.getClonedDataSourceSettings(this.parent.dataSourceSettings),
                    dropAxis: (selectedNode.type === 'number' || (selectedNode.type === 'CalculatedField' &&
                        selectedNode.formula && selectedNode.formula.indexOf('Measure') > -1 &&
                        this.parent.dataType === 'olap')) ? 'values' : 'rows',
                    dropPosition: fieldInfo.position, draggedAxis: 'fieldlist', cancel: false
                };
                control.trigger(fieldDrop, eventdrop, (observedArgs) => {
                    if (!observedArgs.cancel) {
                        addClass([node.querySelector('.' + LIST_TEXT_CLASS)], LIST_SELECT_CLASS);
                        if (parentNode) {
                            addClass([parentNode.querySelector('.' + LIST_TEXT_CLASS)], LIST_SELECT_CLASS);
                        }
                        this.updateSelectedNodes(li, args.action);
                        const addNode = this.parent.pivotCommon.dataSourceUpdate.getNewField(id, fieldInfo.fieldItem);
                        this.updateReportSettings(addNode, observedArgs);
                        this.updateNodeStateChange(id, args, selectedNode);
                    }
                    else {
                        this.updateCheckState(selectedNode, args.action);
                    }
                });
            }
            else {
                const removeFieldArgs = {
                    cancel: false, fieldName: id,
                    dataSourceSettings: PivotUtil.getClonedDataSourceSettings(this.parent.dataSourceSettings),
                    fieldItem: fieldInfo.fieldItem, axis: fieldInfo.axis
                };
                control.trigger(fieldRemove, removeFieldArgs, (observedArgs) => {
                    if (!observedArgs.cancel) {
                        removeClass([node.querySelector('.' + LIST_TEXT_CLASS)], LIST_SELECT_CLASS);
                        if (parentNode && isNullOrUndefined(parentNode.querySelector('.' + FIELD_TREE_CHILD + ' .' + NODE_CHECK_CLASS))) {
                            removeClass([parentNode.querySelector('.' + LIST_TEXT_CLASS)], LIST_SELECT_CLASS);
                        }
                        this.updateSelectedNodes(li, args.action);
                        this.parent.pivotCommon.dataSourceUpdate.removeFieldFromReport(id);
                        if (this.parent.dataType === 'pivot' && this.parent.showValuesButton && this.parent.dataSourceSettings.values.length > 1 &&
                            fieldInfo && fieldInfo.position < this.parent.dataSourceSettings.valueIndex &&
                            ((this.parent.dataSourceSettings.valueAxis === 'row' && fieldInfo.axis === 'rows') ||
                                (this.parent.dataSourceSettings.valueAxis === 'column' && fieldInfo.axis === 'columns'))) {
                            control.setProperties({ dataSourceSettings: { valueIndex: this.parent.dataSourceSettings.valueIndex - 1 } }, true);
                        }
                        if (this.parent.dataType === 'olap' && this.parent.dataSourceSettings.values.length === 0) {
                            this.parent.pivotCommon.dataSourceUpdate.removeFieldFromReport('[Measures]');
                        }
                        this.updateNodeStateChange(id, args, selectedNode);
                    }
                    else {
                        this.updateCheckState(selectedNode, args.action);
                    }
                });
            }
        }
    }
    updateReportSettings(newField, dropArgs) {
        let dropPosition = dropArgs.dropPosition;
        const dropClass = dropArgs.dropAxis;
        if (this.parent.dataType === 'pivot' && this.parent.showValuesButton && this.parent.dataSourceSettings.values.length > 1) {
            const dropAxisFields = (this.parent.dataSourceSettings.valueAxis === 'row' &&
                dropClass === 'rows') ? this.parent.dataSourceSettings.rows : (this.parent.dataSourceSettings.valueAxis === 'column' && dropClass === 'columns') ?
                this.parent.dataSourceSettings.columns : undefined;
            if (!isNullOrUndefined(dropAxisFields)) {
                if (dropPosition === -1 && this.parent.dataSourceSettings.valueIndex === -1) {
                    this.parent.setProperties({ dataSourceSettings: { valueIndex: dropAxisFields.length } }, true);
                }
                else if (dropPosition > -1 && dropPosition <= this.parent.dataSourceSettings.valueIndex) {
                    this.parent.setProperties({ dataSourceSettings: { valueIndex: this.parent.dataSourceSettings.valueIndex + 1 } }, true);
                }
                else if (this.parent.dataSourceSettings.valueIndex > -1 && dropPosition > this.parent.dataSourceSettings.valueIndex) {
                    dropPosition = dropPosition - 1;
                }
            }
        }
        switch (dropClass) {
            case 'filters':
                if (dropPosition !== -1) {
                    this.parent.dataSourceSettings.filters.splice(dropPosition, 0, newField);
                }
                else {
                    this.parent.dataSourceSettings.filters.push(newField);
                }
                break;
            case 'rows':
                if (dropPosition !== -1) {
                    this.parent.dataSourceSettings.rows.splice(dropPosition, 0, newField);
                }
                else {
                    this.parent.dataSourceSettings.rows.push(newField);
                }
                break;
            case 'columns':
                if (dropPosition !== -1) {
                    this.parent.dataSourceSettings.columns.splice(dropPosition, 0, newField);
                }
                else {
                    this.parent.dataSourceSettings.columns.push(newField);
                }
                break;
            case 'values':
                if (dropPosition !== -1) {
                    this.parent.dataSourceSettings.values.splice(dropPosition, 0, newField);
                }
                else {
                    this.parent.dataSourceSettings.values.push(newField);
                }
                if (this.parent.dataType === 'olap' && this.parent.olapEngineModule &&
                    !(this.parent.olapEngineModule).isMeasureAvail && !(this.parent.dataSourceSettings.values.length > 1)) {
                    const measureField = {
                        name: '[Measures]', caption: 'Measures', baseField: undefined, baseItem: undefined
                    };
                    const fieldAxis = this.parent.dataSourceSettings.valueAxis === 'row' ?
                        this.parent.dataSourceSettings.rows : this.parent.dataSourceSettings.columns;
                    fieldAxis.push(measureField);
                }
                break;
        }
    }
    updateCheckState(selectedNode, action) {
        const chkState = this.fieldTable.element.querySelectorAll('.e-checkbox-wrapper');
        const innerText = this.fieldTable.element.querySelectorAll('.e-list-text');
        for (let i = 0; i < chkState.length; i++) {
            if (selectedNode.caption === innerText[i].textContent) {
                if (action === 'check') {
                    this.fieldTable.uncheckAll([selectedNode['id']]);
                }
                else {
                    this.fieldTable.checkAll([selectedNode['id']]);
                }
            }
        }
    }
    updateNodeStateChange(id, args, selectedNode) {
        if (!this.parent.allowDeferLayoutUpdate) {
            this.parent.updateDataSource(true);
        }
        else {
            selectedNode.isSelected = args.action === 'check';
            if (this.parent.dataType === 'olap') {
                this.parent.olapEngineModule.updateFieldlistData(id, args.action === 'check');
            }
            this.updateDataSource();
        }
        const selectedLi = this.treeViewElement.querySelector('[data-uid="' + id + '"]');
        selectedLi.focus();
        removeClass([selectedLi], 'e-hover');
        const parent = this.parent;
        setTimeout(() => {
            parent.axisFieldModule.render();
        });
    }
    updateSelectedNodes(li, state) {
        if (li && li.querySelector('ul')) {
            for (const element of [].slice.call(li.querySelectorAll('li'))) {
                if (state === 'check') {
                    addClass([element.querySelector('.' + LIST_TEXT_CLASS)], LIST_SELECT_CLASS);
                }
                else {
                    removeClass([element.querySelector('.' + LIST_TEXT_CLASS)], LIST_SELECT_CLASS);
                }
            }
        }
    }
    updateDataSource() {
        if (this.parent.isPopupView) {
            if (this.parent.dataType === 'olap') {
                this.parent.pivotGridModule.olapEngineModule = this.parent.olapEngineModule;
            }
            else {
                this.parent.pivotGridModule.engineModule = this.parent.engineModule;
            }
            // eslint-disable-next-line max-len
            this.parent.pivotGridModule.setProperties({ dataSourceSettings: this.parent.dataSourceSettings.properties }, true);
            this.parent.pivotGridModule.notify(uiUpdate, this);
        }
        else {
            this.parent.triggerPopulateEvent();
        }
    }
    addNode(args) {
        if (!args.isInteracted) {
            return;
        }
        const fieldList = this.parent.pivotFieldList;
        const selectedNode = fieldList[args.data[0].id.toString()];
        const fieldInfo = PivotUtil.getFieldInfo(selectedNode.id.toString(), this.parent);
        const control = this.parent.isPopupView ? this.parent.pivotGridModule : this.parent;
        if (args.action === 'check') {
            const axis = ['filters', 'columns', 'rows', 'values'];
            const eventdrop = {
                fieldName: fieldInfo.fieldName, dropField: fieldInfo.fieldItem,
                dataSourceSettings: PivotUtil.getClonedDataSourceSettings(this.parent.dataSourceSettings),
                dropAxis: axis[this.parent.dialogRenderer.adaptiveElement.selectedItem], draggedAxis: 'fieldlist', cancel: false
            };
            control.trigger(fieldDrop, eventdrop, (observedArgs) => {
                if (!observedArgs.cancel) {
                    this.selectedNodes.push(selectedNode.id.toString());
                }
                else {
                    this.updateCheckState(selectedNode, args.action);
                }
            });
        }
        else {
            const removeFieldArgs = {
                cancel: false, fieldName: fieldInfo.fieldName,
                dataSourceSettings: PivotUtil.getClonedDataSourceSettings(this.parent.dataSourceSettings),
                fieldItem: fieldInfo.fieldItem, axis: fieldInfo.axis
            };
            control.trigger(fieldRemove, removeFieldArgs, (observedArgs) => {
                if (!observedArgs.cancel) {
                    let count = this.selectedNodes.length;
                    while (count--) {
                        if (this.selectedNodes[count] === selectedNode.id.toString()) {
                            this.selectedNodes.splice(count, 1);
                            break;
                        }
                    }
                }
                else {
                    this.updateCheckState(selectedNode, args.action);
                }
            });
        }
    }
    refreshTreeView() {
        if (this.fieldTable) {
            const treeData = this.getUpdatedData();
            this.fieldTable.fields = {
                dataSource: treeData, id: 'id', text: 'caption', isChecked: 'isSelected', parentID: 'pid', iconCss: 'spriteCssClass'
            };
            this.fieldTable.dataBind();
        }
    }
    getUpdatedData() {
        const treeData = this.getTreeData();
        const expandedNodes = this.fieldTable.expandedNodes;
        this.updateExpandedNodes(treeData, expandedNodes);
        return this.applySorting(treeData, this.fieldListSort);
    }
    getTreeData(axis) {
        let data = [];
        if (this.parent.dataType === 'olap') {
            data = this.getOlapTreeData(axis);
        }
        else {
            const keys = this.parent.pivotFieldList ? Object.keys(this.parent.pivotFieldList) : [];
            const treeDataInfo = {};
            for (const key of keys) {
                const member = this.parent.pivotFieldList[key];
                treeDataInfo[key] = { id: member.id, pid: member.pid, caption: member.caption, isSelected: member.isSelected };
                if (!isNullOrUndefined(member.pid) && !treeDataInfo[key].hasChildren) {
                    const parentId = member.pid + '_group_name';
                    treeDataInfo[key].pid = parentId;
                    treeDataInfo[parentId] = {
                        id: parentId, caption: member.pid,
                        isSelected: treeDataInfo[parentId] && treeDataInfo[parentId].isSelected
                            ? treeDataInfo[parentId].isSelected : member.isSelected, hasChildren: true
                    };
                }
            }
            if (this.parent.isAdaptive) {
                const fields = [this.parent.dataSourceSettings.filters, this.parent.dataSourceSettings.columns,
                    this.parent.dataSourceSettings.rows,
                    this.parent.dataSourceSettings.values];
                const currentFieldSet = fields[axis];
                let len = keys.length;
                while (len--) {
                    treeDataInfo[keys[len]].isSelected = false;
                }
                for (const item of currentFieldSet) {
                    treeDataInfo[item.name].isSelected = true;
                }
            }
            const members = Object.keys(treeDataInfo);
            for (const member of members) {
                const obj = treeDataInfo[member];
                data.push(obj);
            }
        }
        return data;
    }
    getOlapTreeData(axis) {
        let data = [];
        const fieldListData = this.parent.olapEngineModule.fieldListData ? this.parent.olapEngineModule.fieldListData : [];
        if (this.parent.isAdaptive) {
            const fields = [
                this.parent.dataSourceSettings.filters, this.parent.dataSourceSettings.columns,
                this.parent.dataSourceSettings.rows, this.parent.dataSourceSettings.values
            ];
            const currentFieldSet = fields[axis];
            let i = 0;
            while (i < fieldListData.length) {
                const item = fieldListData[i];
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                let framedSet;
                if (axis === 3) {
                    if (item.id.toLowerCase() !== '[measures]' &&
                        (item.id.toLowerCase().indexOf('[measures]') === 0 ||
                            (item.spriteCssClass && item.spriteCssClass.indexOf('e-measureCDB') !== -1)) ||
                        (item.id.toLowerCase() === '[calculated members].[_0]' ||
                            (item.spriteCssClass && item.spriteCssClass.indexOf('e-calc-measure-icon') !== -1))) {
                        framedSet = {
                            id: item.id, caption: item.caption, hasChildren: item.hasChildren,
                            type: item.type, aggregateType: item.aggregateType,
                            isSelected: item.isSelected, pid: item.pid, spriteCssClass: item.spriteCssClass
                        };
                        framedSet.isSelected = false;
                        if (framedSet.spriteCssClass && framedSet.spriteCssClass.indexOf('e-measureCDB') !== -1) {
                            framedSet.spriteCssClass = framedSet.spriteCssClass.replace('e-folderCDB-icon', 'e-measureGroupCDB-icon');
                            framedSet.pid = undefined;
                        }
                        for (const field of currentFieldSet) {
                            if (framedSet.id === field.name) {
                                framedSet.isSelected = true;
                                break;
                            }
                        }
                        data.push(framedSet);
                    }
                }
                else {
                    if (!(item.id.toLowerCase().indexOf('[measures]') === 0) &&
                        !(item.spriteCssClass && item.spriteCssClass.indexOf('e-measureCDB') !== -1) &&
                        !(item.spriteCssClass && item.spriteCssClass.indexOf('e-calc-measure-icon') !== -1)) {
                        framedSet = {
                            id: item.id, caption: item.caption, hasChildren: item.hasChildren,
                            type: item.type, aggregateType: item.aggregateType,
                            isSelected: item.isSelected, pid: item.pid, spriteCssClass: item.spriteCssClass
                        };
                        framedSet.isSelected = false;
                        for (const item of currentFieldSet) {
                            if (framedSet.id === item.name) {
                                framedSet.isSelected = true;
                                break;
                            }
                        }
                        data.push(framedSet);
                    }
                }
                i++;
            }
        }
        else {
            data = isNullOrUndefined(this.parent.olapEngineModule.fieldListData) ? [] :
                PivotUtil.getClonedData(this.parent.olapEngineModule.fieldListData);
        }
        return data;
    }
    updateExpandedNodes(data, expandedNodes) {
        if (expandedNodes.length > 0) {
            let i = 0;
            for (const field of data) {
                if (expandedNodes.indexOf(field.id) > -1) {
                    i++;
                    field.expanded = true;
                    field.spriteCssClass = (field.spriteCssClass &&
                        field.spriteCssClass.toString().indexOf('e-folderCDB-icon') > -1 ?
                        field.spriteCssClass.toString().replace('e-folderCDB-icon', 'e-folderCDB-open-icon') :
                        field.spriteCssClass);
                    if (i === (expandedNodes.length)) {
                        break;
                    }
                }
            }
        }
    }
    updateSorting(args) {
        const target = args.target;
        const option = target.getAttribute('data-sort');
        this.parent.actionObj.actionName = sortFieldTree;
        if (this.parent.actionBeginMethod()) {
            return;
        }
        try {
            if (target.className.indexOf('e-selected') === -1) {
                switch (option) {
                    case 'None':
                        this.fieldListSort = 'None';
                        addClass([target], 'e-selected');
                        removeClass([this.parentElement.querySelector('.e-sort-ascend')], 'e-selected');
                        removeClass([this.parentElement.querySelector('.e-sort-descend')], 'e-selected');
                        break;
                    case 'Ascend':
                        this.fieldListSort = 'Ascend';
                        addClass([target], 'e-selected');
                        removeClass([this.parentElement.querySelector('.e-sort-none')], 'e-selected');
                        removeClass([this.parentElement.querySelector('.e-sort-descend')], 'e-selected');
                        break;
                    case 'Descend':
                        this.fieldListSort = 'Descend';
                        addClass([target], 'e-selected');
                        removeClass([this.parentElement.querySelector('.e-sort-ascend')], 'e-selected');
                        removeClass([this.parentElement.querySelector('.e-sort-none')], 'e-selected');
                        break;
                }
                this.refreshTreeView();
            }
        }
        catch (execption) {
            this.parent.actionFailureMethod(execption);
        }
        this.parent.actionObj.actionName = this.parent.getActionCompleteName();
        if (this.parent.actionObj.actionName) {
            this.parent.actionCompleteMethod();
        }
    }
    applySorting(treeData, sortOrder) {
        if (treeData.length > 0) {
            if (this.parent.dataType === 'olap') {
                let measure;
                let calcMember;
                if (this.parent.dataSourceSettings.calculatedFieldSettings.length > 0 &&
                    treeData[0].id.toLowerCase() === '[calculated members].[_0]') {
                    calcMember = treeData[0];
                    measure = treeData[1];
                    treeData.splice(0, 2);
                }
                else {
                    measure = treeData[0];
                    treeData.splice(0, 1);
                }
                treeData = sortOrder === 'Ascend' ?
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    (treeData.sort((a, b) => (a.caption > b.caption) ? 1 : ((b.caption > a.caption) ? -1 : 0))) :
                    sortOrder === 'Descend' ?
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        (treeData.sort((a, b) => (a.caption < b.caption) ? 1 : ((b.caption < a.caption) ? -1 : 0))) :
                        treeData;
                if (calcMember) {
                    treeData.splice(0, 0, calcMember, measure);
                }
                else {
                    treeData.splice(0, 0, measure);
                }
            }
            else {
                this.fieldTable.sortOrder = ((sortOrder === 'Ascend' ? 'Ascending' : (sortOrder === 'Descend' ? 'Descending' : 'None')));
            }
        }
        return treeData;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onFieldAdd(e) {
        this.parent.dialogRenderer.updateDataSource(this.selectedNodes);
        this.closeTreeDialog();
    }
    closeTreeDialog() {
        this.selectedNodes = [];
        this.fieldDialog.hide();
    }
    keyPress(e) {
        if (e.keyCode === 13 && e.target) {
            e.target.click();
            e.preventDefault();
            return;
        }
    }
    wireFieldListEvent(element) {
        EventHandler.add(element, 'keydown', this.keyPress, this);
        EventHandler.add(element, 'click', this.updateSorting, this);
    }
    unWireFieldListEvent(element) {
        EventHandler.remove(element, 'keydown', this.keyPress);
        EventHandler.remove(element, 'click', this.updateSorting);
    }
    /**
     * @hidden
     */
    addEventListener() {
        this.parent.on(treeViewUpdate, this.refreshTreeView, this);
    }
    /**
     * @hidden
     */
    removeEventListener() {
        if (this.parent.isDestroyed) {
            return;
        }
        this.parent.off(treeViewUpdate, this.refreshTreeView);
    }
    /**
     * To destroy the tree view event listener
     *
     * @returns {void}
     * @hidden
     */
    destroy() {
        this.removeEventListener();
        if (this.fieldTable && !this.fieldTable.isDestroyed) {
            this.fieldTable.destroy();
            this.fieldTable = null;
        }
        if (this.fieldDialog && !this.fieldDialog.isDestroyed) {
            this.fieldDialog.destroy();
            this.fieldDialog = null;
        }
        if (this.editorSearch && !this.editorSearch.isDestroyed) {
            this.editorSearch.destroy();
            this.editorSearch = null;
        }
        if (this.fieldSearch && !this.fieldSearch.isDestroyed) {
            this.fieldSearch.destroy();
            this.fieldSearch = null;
        }
    }
}

/**
 * Module to render Axis Field Table
 */
/** @hidden */
class AxisTableRenderer {
    /** Constructor for render module */
    constructor(parent) {
        this.parent = parent;
    }
    /**
     * Initialize the axis table rendering
     *
     * @returns {void}
     * @private
     */
    render() {
        if (!this.parent.isAdaptive) {
            const axisTable = createElement('div', {
                className: AXIS_TABLE_CLASS + ' ' + (this.parent.dataType === 'olap' ? OLAP_AXIS_TABLE_CLASS : '')
            });
            this.leftAxisPanel = createElement('div', { className: LEFT_AXIS_PANEL_CLASS });
            this.rightAxisPanel = createElement('div', { className: RIGHT_AXIS_PANEL_CLASS });
            this.parent.dialogRenderer.parentElement.appendChild(axisTable);
            axisTable.appendChild(this.leftAxisPanel);
            axisTable.appendChild(this.rightAxisPanel);
            this.axisTable = axisTable;
            this.renderAxisTable();
        }
        this.parent.axisFieldModule.render();
    }
    renderAxisTable() {
        const fieldLabels = ['filters', 'rows', 'columns', 'values'];
        for (let len = 0, lnt = fieldLabels.length; len < lnt; len++) {
            const axis = createElement('div', {
                className: FIELD_LIST_CLASS + '-' + fieldLabels[len]
            });
            const axisTitleWrapper = createElement('div', {
                className: AXIS_ICON_CLASS + '-container'
            });
            const axisTitle = createElement('div', {
                className: AXIS_HEADER_CLASS,
                attrs: { title: this.parent.localeObj.getConstant(fieldLabels[len]) }
            });
            axisTitle.innerText = this.parent.localeObj.getConstant(fieldLabels[len]);
            axisTitleWrapper.appendChild(this.getIconupdate(fieldLabels[len]));
            axisTitleWrapper.appendChild(axisTitle);
            const axisContent = createElement('div', { className: AXIS_CONTENT_CLASS + ' ' + 'e-' + fieldLabels[len] });
            let localePrompt;
            if (fieldLabels[len] === 'rows') {
                localePrompt = this.parent.localeObj.getConstant('dropRowPrompt');
            }
            else if (fieldLabels[len] === 'columns') {
                localePrompt = this.parent.localeObj.getConstant('dropColPrompt');
            }
            else if (fieldLabels[len] === 'values') {
                localePrompt = this.parent.localeObj.getConstant('dropValPrompt');
            }
            else {
                localePrompt = this.parent.localeObj.getConstant('dropFilterPrompt');
            }
            const axisPrompt = createElement('span', {
                className: AXIS_PROMPT_CLASS
            });
            axisPrompt.innerText = localePrompt;
            let droppable = new Droppable(axisContent, {}); /* eslint-disable-line */
            axis.appendChild(axisTitleWrapper);
            axis.appendChild(axisContent);
            axis.appendChild(axisPrompt);
            if (len <= 1) {
                this.leftAxisPanel.appendChild(axis);
            }
            else {
                this.rightAxisPanel.appendChild(axis);
            }
            this.unWireEvent(axisContent);
            this.wireEvent(axisContent);
        }
    }
    getIconupdate(axis) {
        const axisWrapper = createElement('span', {
            attrs: { 'tabindex': '-1', 'aria-disabled': 'false' },
            className: AXIS_ICON_CLASS + '-icon-container'
        });
        const axisElement = createElement('span', {
            attrs: {
                'tabindex': '-1', 'aria-disabled': 'false'
            },
            className: ICON + ' ' + AXIS_ICON_CLASS + '-' + axis
        });
        axisWrapper.appendChild(axisElement);
        return axisWrapper;
    }
    wireEvent(element) {
        EventHandler.add(element, 'mouseover', this.updateDropIndicator, this);
        EventHandler.add(element, 'mouseleave', this.updateDropIndicator, this);
    }
    unWireEvent(element) {
        EventHandler.remove(element, 'mouseover', this.updateDropIndicator);
        EventHandler.remove(element, 'mouseleave', this.updateDropIndicator);
    }
    updateDropIndicator(e) {
        const parentElement = this.parent.dialogRenderer.parentElement;
        if (this.parent.isDragging && e.target.classList.contains(AXIS_CONTENT_CLASS) && e.type === 'mouseover') {
            removeClass([].slice.call(parentElement.querySelectorAll('.' + DROP_INDICATOR_CLASS)), INDICATOR_HOVER_CLASS);
            removeClass([].slice.call(parentElement.querySelectorAll('.' + DROP_INDICATOR_CLASS + '-last')), INDICATOR_HOVER_CLASS);
            const element = [].slice.call(e.target.querySelectorAll('.' + PIVOT_BUTTON_WRAPPER_CLASS));
            if (element.length > 0) {
                addClass([element[element.length - 1].querySelector('.' + DROP_INDICATOR_CLASS + '-last')], INDICATOR_HOVER_CLASS);
            }
        }
        else if (!this.parent.isDragging || (!e.target.classList.contains(DROPPABLE_CLASS) && e.type === 'mouseleave')) {
            removeClass([].slice.call(parentElement.querySelectorAll('.' + DROP_INDICATOR_CLASS)), INDICATOR_HOVER_CLASS);
            removeClass([].slice.call(parentElement.querySelectorAll('.' + DROP_INDICATOR_CLASS + '-last')), INDICATOR_HOVER_CLASS);
        }
    }
}

/**
 * Module to render Pivot button
 */
/** @hidden */
class PivotButton {
    /**
     * Constructor for render module.
     *
     * @param {PivotView | PivotFieldList} parent - Component instance.
     */
    constructor(parent) {
        this.parent = parent;
        this.menuOption = new AggregateMenu(this.parent);
        this.parent.pivotButtonModule = this;
        this.addEventListener();
        if (this.parent instanceof PivotFieldList) {
            this.axisField = new AxisFieldRenderer(this.parent);
        }
        this.isDestroyed = false;
    }
    renderPivotButton(args) {
        const field = extend([], args.field, null, true);
        const axis = args.axis;
        let axisElement;
        let valuePos = -1;
        const showValuesButton = (this.parent.dataType === 'pivot' ? (this.parent.getModuleName() === 'pivotfieldlist' &&
            this.parent.pivotGridModule) ?
            this.parent.pivotGridModule.showValuesButton : this.parent.showValuesButton : false);
        if (((this.parent.dataSourceSettings.valueAxis === 'row' && args.axis === 'rows') ||
            (this.parent.dataSourceSettings.valueAxis === 'column' && args.axis === 'columns')) && showValuesButton && this.parent.dataSourceSettings.values.length > 1) {
            if (isNullOrUndefined(PivotUtil.getFieldByName('[Measures]', field))) {
                const measureField = PivotUtil.getFieldByName('[Measures]', this.parent.dataSourceSettings.fieldMapping);
                const valueField = {
                    name: '[Measures]', caption: this.parent.localeObj.getConstant('values'),
                    axis: args.axis,
                    showRemoveIcon: (measureField && 'showRemoveIcon' in measureField) ? measureField.showRemoveIcon : true,
                    allowDragAndDrop: (measureField && 'allowDragAndDrop' in measureField) ? measureField.allowDragAndDrop : true
                };
                if ((this.parent.dataSourceSettings.valueIndex === -1 || this.parent.dataSourceSettings.valueIndex > field.length)) {
                    valuePos = field.length;
                    field.push(valueField);
                    this.parent.setProperties({ dataSourceSettings: { valueIndex: -1 } }, true);
                }
                else {
                    valuePos = this.parent.dataSourceSettings.valueIndex;
                    field.splice(valuePos, 0, valueField);
                }
            }
        }
        this.parentElement = this.parent.getModuleName() === 'pivotview' ? this.parent.element :
            document.getElementById(this.parent.element.id + '_Container');
        if (this.parent.getModuleName() === 'pivotfieldlist') {
            this.parentElement = document.getElementById(this.parent.element.id + '_Container');
            if (this.parentElement.querySelector('.' + FIELD_LIST_CLASS + '-' + axis)) {
                const axisPrompt = this.parentElement.querySelector('.' + FIELD_LIST_CLASS + '-' + axis)
                    .querySelector('.' + AXIS_PROMPT_CLASS);
                if (field.length === 0) {
                    removeClass([axisPrompt], ICON_DISABLE);
                }
                else {
                    addClass([axisPrompt], ICON_DISABLE);
                }
                axisElement =
                    this.parentElement.querySelector('.' + FIELD_LIST_CLASS + '-' + axis).querySelector('.' + AXIS_CONTENT_CLASS);
            }
            else {
                return;
            }
        }
        else {
            this.parentElement = this.parent.element;
            axisElement = this.parentElement.querySelector('.e-group-' + axis);
        }
        if (axisElement) {
            if (this.parent.getModuleName() === 'pivotview' && field.length === 0) { // eslint-disable-next-line @typescript-eslint/no-explicit-any
                for (const element of this.parentElement.querySelectorAll('.e-group-' + axis)) {
                    if (!element.classList.contains(GROUP_CHART_VALUE) && !element.classList.contains(GROUP_CHART_COLUMN)) {
                        const axisPrompt = createElement('span', {
                            className: AXIS_PROMPT_CLASS
                        });
                        axisPrompt.innerText = (this.parent.groupingBarSettings.allowDragAndDrop ? axis === 'rows' ? this.parent.localeObj.getConstant('rowAxisPrompt') :
                            axis === 'columns' ? this.parent.localeObj.getConstant('columnAxisPrompt') :
                                axis === 'values' ? this.parent.localeObj.getConstant('valueAxisPrompt') :
                                    axis === 'filters' ? this.parent.localeObj.getConstant('filterAxisPrompt') :
                                        this.parent.localeObj.getConstant('allFields') : '');
                        element.appendChild(axisPrompt);
                    }
                }
            }
            else {
                for (let i = 0, cnt = field.length; i < cnt; i++) { // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    for (let element of (this.parent.getModuleName() === 'pivotfieldlist' ? [axisElement] : this.parentElement.querySelectorAll('.e-group-' + axis))) {
                        element = element;
                        const isMeasureAvail = (this.parent.dataType === 'olap' && (field[i].name.toLowerCase() === '[measures]' || axis === 'values'));
                        const isMeasureFieldsAvail = (this.parent.dataType === 'olap' && axis === 'values');
                        if (!element.classList.contains(GROUP_CHART_VALUE) && !element.classList.contains(GROUP_CHART_COLUMN)) {
                            const buttonWrapper = createElement('div', {
                                className: PIVOT_BUTTON_WRAPPER_CLASS + (i === 0 && axis !== 'all-fields' ? ' e-first-btn' : ''),
                                attrs: { 'data-tag': axis + ':' + field[i].name }
                            });
                            let buttonCaption = field[i].caption ? field[i].caption : field[i].name;
                            buttonCaption = this.parent.enableHtmlSanitizer ?
                                SanitizeHtmlHelper.sanitize(buttonCaption) : buttonCaption;
                            const buttonElement = createElement('div', {
                                id: this.parent.element.id + '_' + field[i].name, className: PIVOT_BUTTON_CLASS + ' ' + field[i].name.replace(/[^A-Z0-9]/ig, ''),
                                attrs: {
                                    'data-uid': field[i].name,
                                    'tabindex': (this.parent.getModuleName() === 'pivotview' && this.parent.grid && axis === 'rows' && !element.classList.contains(GROUP_CHART_ROW)) ? '-1' : '0',
                                    'isvalue': (i === valuePos || isMeasureAvail && !isMeasureFieldsAvail) ? 'true' : 'false',
                                    'aria-disabled': 'false', 'aria-label': buttonCaption,
                                    'data-type': (this.parent.dataType === 'olap' ? isMeasureFieldsAvail ? 'isMeasureFieldsAvail' : isMeasureAvail ? 'isMeasureAvail' : field[i].type : field[i].type),
                                    'data-caption': buttonCaption,
                                    'data-basefield': this.parent.enableHtmlSanitizer ? SanitizeHtmlHelper.sanitize(field[i].baseField) : field[i].baseField,
                                    'data-baseitem': this.parent.enableHtmlSanitizer ? SanitizeHtmlHelper.sanitize(field[i].baseItem) : field[i].baseItem,
                                    'role': 'button'
                                }
                            });
                            const dropIndicatorElement = createElement('span', {
                                attrs: { 'tabindex': '-1', 'aria-disabled': 'false' },
                                className: DROP_INDICATOR_CLASS
                            });
                            const dropLastIndicatorElement = createElement('span', {
                                attrs: { 'tabindex': '-1', 'aria-disabled': 'false' },
                                className: DROP_INDICATOR_CLASS + '-last'
                            });
                            const dragWrapper = this.createButtonDragIcon(field[i], buttonElement);
                            const contentElement = this.createButtonText(field, i, axis, valuePos);
                            buttonElement.appendChild(contentElement);
                            if (axis !== 'all-fields') {
                                if (!isMeasureAvail && !field[i].isNamedSet && !field[i].isCalculatedField) {
                                    if (['filters', 'values'].indexOf(axis) === -1 && valuePos !== i &&
                                        !(this.parent.dataType === 'olap' && ((this.parent.getModuleName() === 'pivotview' &&
                                            this.parent.enableVirtualization) || (this.parent.getModuleName() === 'pivotfieldlist' &&
                                            this.parent.pivotGridModule !== undefined &&
                                            this.parent.pivotGridModule.enableVirtualization)))) {
                                        this.createSortOption(buttonElement, field[i].name, field[i]);
                                    }
                                    if (axis !== 'values' && valuePos !== i) {
                                        this.createFilterOption(buttonElement, field[i].name, axis, field[i]);
                                    }
                                    if (axis === 'values') {
                                        this.getTypeStatus(field, i, buttonElement);
                                    }
                                }
                                if ((field[i].isCalculatedField || field[i].type === 'CalculatedField')) {
                                    const calcElement = createElement('span', {
                                        attrs: { 'tabindex': '-1', 'aria-disabled': 'false', 'title': this.parent.localeObj.getConstant('editCalculatedField') },
                                        className: ICON + ' ' + CALC_EDIT
                                    });
                                    if (this.parent.allowCalculatedField && this.parent.calculatedFieldModule &&
                                        (field[i].showEditIcon || field[i].showEditIcon === undefined)) {
                                        removeClass([calcElement], ICON_DISABLE);
                                    }
                                    else {
                                        addClass([calcElement], ICON_DISABLE);
                                    }
                                    buttonElement.appendChild(calcElement);
                                }
                                const removeElement = createElement('span', {
                                    attrs: { 'tabindex': '-1', 'aria-disabled': 'false', 'title': this.parent.localeObj.getConstant('remove') },
                                    className: ICON + ' ' + REMOVE_CLASS
                                });
                                if (this.parent.getModuleName() === 'pivotview') {
                                    if ((this.parent.groupingBarSettings.showRemoveIcon &&
                                        (field[i].showRemoveIcon || field[i].showRemoveIcon === undefined))) {
                                        removeClass([removeElement], ICON_DISABLE);
                                    }
                                    else {
                                        addClass([removeElement], ICON_DISABLE);
                                    }
                                }
                                else {
                                    if (field[i].showRemoveIcon || field[i].showRemoveIcon === undefined) {
                                        removeClass([removeElement], ICON_DISABLE);
                                    }
                                    else {
                                        addClass([removeElement], ICON_DISABLE);
                                    }
                                }
                                buttonElement.appendChild(removeElement);
                                buttonWrapper.appendChild(dropIndicatorElement);
                                buttonWrapper.appendChild(buttonElement);
                                buttonWrapper.appendChild(dropLastIndicatorElement);
                            }
                            else {
                                buttonWrapper.appendChild(dropIndicatorElement);
                                buttonWrapper.appendChild(buttonElement);
                            }
                            element.appendChild(buttonWrapper);
                            const pivotButton = new Button({
                                enableRtl: this.parent.enableRtl, locale: this.parent.locale,
                                enableHtmlSanitizer: this.parent.enableHtmlSanitizer, cssClass: this.parent.cssClass
                            });
                            pivotButton.isStringTemplate = true;
                            pivotButton.appendTo(buttonElement);
                            this.unWireEvent(buttonWrapper, i === valuePos && axis !== 'all-fields' ? 'values' : axis, isMeasureAvail);
                            this.wireEvent(buttonWrapper, i === valuePos && axis !== 'all-fields' ? 'values' : axis, isMeasureAvail);
                            if ((this.parent.getModuleName() === 'pivotview' && !this.parent.isAdaptive) ||
                                this.parent.getModuleName() === 'pivotfieldlist') {
                                this.createDraggable(field[i], this.parent.getModuleName() === 'pivotview' ? contentElement : dragWrapper);
                                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                buttonElement.querySelector('.' + BUTTON_DRAGGABLE).ej2_instances[0].enableAutoScroll = false;
                            }
                        }
                    }
                }
                if (axis === 'values') { // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    for (const element of this.parentElement.querySelectorAll('.e-group-' + axis)) {
                        if (element.classList.contains(GROUP_CHART_VALUE) && this.parent.pivotChartModule) {
                            const valueData = field.map((item) => {
                                return { text: item.caption ? item.caption : item.name, value: item.name };
                            });
                            const parent = this.parent;
                            if (this.valueFiedDropDownList && element.querySelector('.' + GROUP_CHART_VALUE_DROPDOWN_DIV)) {
                                this.valueFiedDropDownList.dataSource = valueData;
                                this.valueFiedDropDownList.value = !parent.chartSettings.enableMultipleAxis ?
                                    parent.pivotChartModule.currentMeasure : valueData[0].value;
                            }
                            else {
                                const ddlDiv = createElement('div', { className: GROUP_CHART_VALUE_DROPDOWN_DIV });
                                element.appendChild(ddlDiv);
                                this.valueFiedDropDownList = new DropDownList({
                                    dataSource: valueData,
                                    enableRtl: this.parent.enableRtl,
                                    locale: this.parent.locale,
                                    value: !parent.chartSettings.enableMultipleAxis ?
                                        parent.pivotChartModule.currentMeasure : valueData[0].value,
                                    width: 200,
                                    fields: { value: 'value', text: 'text' },
                                    cssClass: GROUP_CHART_VALUE_DROPDOWN + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
                                    change: (args) => {
                                        if (args.e && args.e !== null) {
                                            parent.chartSettings.value = args.value;
                                        }
                                    }
                                });
                                this.valueFiedDropDownList.isStringTemplate = true;
                                this.valueFiedDropDownList.appendTo(ddlDiv);
                            }
                        }
                    }
                }
                else if (axis === 'columns') {
                    let availColindex = undefined; // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    for (const element of this.parentElement.querySelectorAll('.e-group-' + axis)) {
                        if (element.classList.contains(GROUP_CHART_COLUMN) && this.parent.pivotChartModule) {
                            const currentMeasure = this.parent.pivotChartModule.currentMeasure;
                            const delimiter = this.parent.chartSettings.columnDelimiter ? this.parent.chartSettings.columnDelimiter : '-';
                            const columnHeader = (this.parent.chartSettings.columnHeader && this.parent.chartSettings.columnHeader !== '') ?
                                this.parent.chartSettings.columnHeader.split(delimiter).join(' - ') : '';
                            const engineModule = this.parent.dataType === 'olap' ? this.parent.olapEngineModule : this.parent.engineModule;
                            const pivotValues = engineModule.pivotValues;
                            const totColIndex = this.parent.pivotChartModule.getColumnTotalIndex(pivotValues);
                            const rKeys = Object.keys(pivotValues);
                            const columnData = [];
                            let firstValueRow = false;
                            for (const rKey of rKeys) {
                                if (firstValueRow) {
                                    break;
                                }
                                const rowIndex = Number(rKey);
                                if (pivotValues[rowIndex][0] && pivotValues[rowIndex][0].axis === 'row' &&
                                    (this.parent.dataSourceSettings.rows.length === 0 ? true : pivotValues[rowIndex][0].type !== 'grand sum')) {
                                    const firstRowCell = pivotValues[rowIndex][0];
                                    const tupInfo = this.parent.dataType === 'olap' ?
                                        engineModule.tupRowInfo[firstRowCell.ordinal] : undefined;
                                    const rows = pivotValues[rowIndex];
                                    const cKeys = Object.keys(rows);
                                    for (const cKey of cKeys) {
                                        const cellIndex = Number(cKey);
                                        const cell = pivotValues[rowIndex][cellIndex]; // eslint-disable-next-line @typescript-eslint/no-explicit-any
                                        const actualText = (this.parent.dataType === 'olap' && tupInfo && tupInfo.measureName) ?
                                            tupInfo.measureName : cell.actualText;
                                        if (!totColIndex[cell.colIndex] && cell.axis === 'value' && firstRowCell.type !== 'header' &&
                                            actualText !== '' && actualText === currentMeasure) {
                                            firstValueRow = true;
                                            const columnSeries = this.parent.dataType === 'olap' ? cell.columnHeaders.toString().split(/~~|::/).join(' - ')
                                                : cell.columnHeaders.toString().split(this.parent.dataSourceSettings.valueSortSettings.headerDelimiter).join(' - ');
                                            columnData.push({ value: columnSeries, text: columnSeries, title: { ['title']: columnSeries } });
                                            if (columnSeries === columnHeader) {
                                                availColindex = columnData.length;
                                            }
                                        }
                                    }
                                }
                            }
                            if (this.columnFieldDropDownList && element.querySelector('.' + GROUP_CHART_COLUMN_DROPDOWN_DIV)) {
                                this.columnFieldDropDownList.dataSource = columnData;
                                if (availColindex !== undefined) {
                                    this.columnFieldDropDownList.value = columnData[availColindex - 1].value;
                                }
                                else {
                                    this.columnFieldDropDownList.value = columnData[0].value;
                                }
                            }
                            else {
                                const ddlDiv = createElement('div', { className: GROUP_CHART_COLUMN_DROPDOWN_DIV });
                                element.appendChild(ddlDiv);
                                this.columnFieldDropDownList = new DropDownList({
                                    dataSource: columnData,
                                    enableRtl: this.parent.enableRtl,
                                    locale: this.parent.locale,
                                    value: availColindex ? columnData[availColindex - 1].value : (columnData[0] ? columnData[0].value : ''),
                                    width: '200',
                                    fields: { value: 'value', text: 'text', htmlAttributes: 'title' },
                                    cssClass: GROUP_CHART_COLUMN_DROPDOWN + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
                                    change: (args) => {
                                        if (args.e && args.e !== null) {
                                            const delimiter = this.parent.chartSettings.columnDelimiter ? this.parent.chartSettings.columnDelimiter : '-';
                                            this.parent.chartSettings.columnHeader = args.value.split(' - ').join(delimiter);
                                        }
                                    }
                                });
                                this.columnFieldDropDownList.isStringTemplate = true;
                                this.columnFieldDropDownList.appendTo(ddlDiv);
                            }
                        }
                    }
                }
            }
        }
        else {
            return;
        }
    }
    createButtonText(field, i, axis, valuePos) {
        let aggregation;
        let filterMem;
        if (axis === 'filters') {
            filterMem = this.updateButtontext(field[i].name);
        }
        let engineModule;
        if (this.parent.dataType === 'olap') {
            engineModule = this.parent.olapEngineModule;
        }
        else {
            engineModule = this.parent.engineModule;
        }
        if (engineModule.fieldList[field[i].name] !== undefined) {
            aggregation = engineModule.fieldList[field[i].name].aggregateType;
            if ((aggregation !== 'DistinctCount') && (engineModule.fieldList[field[i].name].type !== 'number' || engineModule.fieldList[field[i].name].type === 'include' ||
                engineModule.fieldList[field[i].name].type === 'exclude')) {
                aggregation = 'Count';
            }
            else {
                aggregation = aggregation === undefined ? 'Sum' :
                    engineModule.fieldList[field[i].name].aggregateType;
            }
        }
        let text = field[i].caption ? field[i].caption : field[i].name;
        text = this.parent.enableHtmlSanitizer ? SanitizeHtmlHelper.sanitize(text) : text;
        const buttonText = createElement('span', {
            attrs: {
                title: axis === 'filters' ? (this.parent.dataType === 'olap' && engineModule.fieldList[field[i].name].type === 'CalculatedField') ?
                    text : (text + ' (' + filterMem + ')') : (this.parent.dataType === 'olap' ?
                    text : (((!this.parent.dataSourceSettings.showAggregationOnValueField || axis !== 'values' || aggregation === 'CalculatedField') ?
                    text : this.parent.localeObj.getConstant(aggregation) + ' ' + this.parent.localeObj.getConstant('of') + ' ' + text))),
                'tabindex': '-1', 'aria-disabled': 'false', 'oncontextmenu': 'return false;',
                'data-type': valuePos === i ? '' : aggregation
            },
            className: PIVOT_BUTTON_CONTENT_CLASS + ' ' +
                (this.parent.getModuleName() === 'pivotview' ?
                    this.parent.groupingBarSettings.allowDragAndDrop && (field[i].allowDragAndDrop || field[i].allowDragAndDrop === undefined) ? '' : DRAG_DISABLE_CLASS : '')
        });
        buttonText.innerText = axis === 'filters' ? (this.parent.dataType === 'olap' && engineModule.fieldList[field[i].name].type === 'CalculatedField') ?
            text : (text + ' (' + filterMem + ')') : (this.parent.dataType === 'olap' ?
            text : (!this.parent.dataSourceSettings.showAggregationOnValueField || axis !== 'values' || aggregation === 'CalculatedField' ?
            text : this.parent.localeObj.getConstant(aggregation) + ' ' + this.parent.localeObj.getConstant('of') + ' ' + text));
        return buttonText;
    }
    getTypeStatus(field, i, buttonElement) {
        let engineModule;
        if (this.parent.dataType === 'olap') {
            engineModule = this.parent.olapEngineModule;
        }
        else {
            engineModule = this.parent.engineModule;
        }
        const fieldListItem = engineModule.fieldList[field[i].name];
        if (fieldListItem.aggregateType !== 'CalculatedField' && this.validateDropdown(fieldListItem.type)) {
            this.createSummaryType(buttonElement, field[i].name, field[i]);
        }
    }
    validateDropdown(type) {
        const aggregateType = this.parent.aggregateTypes;
        if (type !== 'number') {
            return (aggregateType.indexOf('Count') > -1 || aggregateType.indexOf('DistinctCount') > -1);
        }
        else {
            for (let i = 0; i < aggregateType.length; i++) {
                if (this.parent.getAllSummaryType().indexOf(aggregateType[i]) > -1) {
                    return true;
                }
            }
            return false;
        }
    }
    createSummaryType(pivotButton, fieldName, field) {
        const spanElement = createElement('span', {
            attrs: { 'tabindex': '-1', 'aria-disabled': 'false', 'title': this.parent.localeObj.getConstant('format') },
            className: ICON + ' ' + AXISFIELD_ICON_CLASS
        });
        if (this.parent.getModuleName() === 'pivotview') {
            if (this.parent.groupingBarSettings.showValueTypeIcon && field.showValueTypeIcon) {
                removeClass([spanElement], ICON_DISABLE);
            }
            else {
                addClass([spanElement], ICON_DISABLE);
            }
        }
        else {
            if (field.showValueTypeIcon) {
                removeClass([spanElement], ICON_DISABLE);
            }
            else {
                addClass([spanElement], ICON_DISABLE);
            }
        }
        pivotButton.appendChild(spanElement);
        return spanElement;
    }
    createMenuOption(args) {
        this.menuOption.render(args, this.parentElement);
        this.parent.pivotButtonModule = this;
    }
    openCalculatedFieldDialog(args) {
        const fieldName = args.target.parentElement.getAttribute('data-uid');
        const fieldInfo = PivotUtil.getFieldInfo(fieldName, this.parent);
        this.parent.actionObj.actionName = editCalculatedField;
        this.parent.actionObj.fieldInfo = fieldInfo;
        if (this.parent.actionBeginMethod()) {
            return;
        }
        try {
            if (this.parent.getModuleName() === 'pivotview') {
                if (this.parent.isAdaptive && (this.parent.showFieldList &&
                    this.parent.pivotFieldListModule &&
                    !this.parent.pivotFieldListModule.isDestroyed)) {
                    this.parent.pivotFieldListModule.element
                        .querySelector('.' + TOGGLE_FIELD_LIST_CLASS).click();
                    this.parent.pivotFieldListModule.dialogRenderer.adaptiveElement.select(4);
                    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                    this.parent.pivotFieldListModule.calculatedFieldModule
                        .updateAdaptiveCalculatedField(true, fieldName);
                }
                else {
                    if (!this.parent.isAdaptive) {
                        this.parent.calculatedFieldModule.buttonCall = true;
                    }
                    this.parent.notify(initCalculatedField, { edit: true, fieldName: fieldName });
                }
            }
            else if (this.parent.getModuleName() === 'pivotfieldlist') {
                if (this.parent.isAdaptive) {
                    this.parent.dialogRenderer.adaptiveElement.select(4);
                    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
                    this.parent.calculatedFieldModule
                        .updateAdaptiveCalculatedField(true, fieldName);
                    this.parent.calculatedFieldModule.buttonCall = true;
                }
                else {
                    if (this.parent.dialogRenderer.fieldListDialog) {
                        this.parent.dialogRenderer.fieldListDialog.hide();
                        addClass([this.parent.element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS)], ICON_HIDDEN);
                    }
                    this.parent.notify(initCalculatedField, { edit: true, fieldName: fieldName });
                    if (this.parent.calculatedFieldModule) {
                        this.parent.calculatedFieldModule.buttonCall = true;
                    }
                }
            }
        }
        catch (execption) {
            this.parent.actionFailureMethod(execption);
        }
    }
    createDraggable(field, target) {
        this.draggable = new Draggable(target, {
            clone: true,
            enableTailMode: true,
            enableAutoScroll: true,
            helper: this.createDragClone.bind(this),
            dragStart: this.onDragStart.bind(this),
            drag: this.onDragging.bind(this),
            dragStop: this.onDragStop.bind(this),
            abort: (this.parent.getModuleName() === 'pivotview' ?
                !(this.parent.groupingBarSettings.allowDragAndDrop && field.allowDragAndDrop) ?
                    '.' + PIVOT_BUTTON_CLASS : '' : !field.allowDragAndDrop ? '.' + PIVOT_BUTTON_CLASS : '')
        });
    }
    createButtonDragIcon(field, pivotButton) {
        const dragWrapper = createElement('span', {
            attrs: { 'tabindex': '-1', 'aria-disabled': 'false' }
        });
        const dragElement = createElement('span', {
            attrs: {
                'tabindex': '-1', 'aria-disabled': 'false', 'title': this.parent.localeObj.getConstant('drag')
            },
            className: ICON + ' ' + DRAG_CLASS + ' ' + ((field.allowDragAndDrop || field.allowDragAndDrop === undefined) ? '' : DRAG_DISABLE_CLASS)
        });
        dragWrapper.appendChild(dragElement);
        if (this.parent.getModuleName() === 'pivotfieldlist') {
            pivotButton.appendChild(dragWrapper);
        }
        return dragWrapper;
    }
    createSortOption(pivotButton, fieldName, field) {
        let sortCLass;
        let spanElement;
        let engineModule;
        if (this.parent.dataType === 'olap') {
            engineModule = this.parent.olapEngineModule;
        }
        else {
            engineModule = this.parent.engineModule;
        }
        if (!this.parent.allowDeferLayoutUpdate) {
            sortCLass = engineModule.fieldList[fieldName].sort === 'Descending' ? SORT_DESCEND_CLASS : '';
        }
        else {
            sortCLass = '';
            for (let i = 0; i < this.parent.dataSourceSettings.sortSettings.length; i++) {
                if (this.parent.dataSourceSettings.sortSettings[i].name === fieldName) {
                    sortCLass = this.parent.dataSourceSettings.sortSettings[i].order === 'Descending' ? SORT_DESCEND_CLASS : '';
                }
            }
        }
        if (engineModule.fieldList[fieldName].sort === 'None') {
            spanElement = createElement('span', {
                attrs: { 'tabindex': '-1', 'aria-disabled': 'false', 'title': this.parent.localeObj.getConstant('sort') },
                className: ICON
            });
        }
        else {
            spanElement = createElement('span', {
                attrs: { 'tabindex': '-1', 'aria-disabled': 'false', 'title': this.parent.localeObj.getConstant('sort') },
                className: ICON + ' ' + SORT_CLASS + ' ' + sortCLass
            });
        }
        if (this.parent.dataSourceSettings.enableSorting) {
            if (this.parent.getModuleName() === 'pivotview') {
                if (field.showSortIcon && this.parent.groupingBarSettings.showSortIcon) {
                    removeClass([spanElement], ICON_DISABLE);
                }
                else {
                    addClass([spanElement], ICON_DISABLE);
                }
            }
            else {
                if (field.showSortIcon) {
                    removeClass([spanElement], ICON_DISABLE);
                }
                else {
                    addClass([spanElement], ICON_DISABLE);
                }
            }
        }
        else {
            addClass([spanElement], ICON_DISABLE);
        }
        pivotButton.appendChild(spanElement);
        return spanElement;
    }
    createFilterOption(pivotButton, fieldName, axis, field) {
        let filterCLass;
        let engineModule;
        if (this.parent.dataType === 'olap') {
            engineModule = this.parent.olapEngineModule;
        }
        else {
            engineModule = this.parent.engineModule;
        }
        if (!this.parent.allowDeferLayoutUpdate) {
            engineModule.fieldList[fieldName].filter = engineModule.fieldList[fieldName].filter === null ?
                [] : engineModule.fieldList[fieldName].filter;
            filterCLass = engineModule.fieldList[fieldName].filter.length === 0 ?
                !engineModule.fieldList[fieldName].isExcelFilter ? FILTER_CLASS : FILTERED_CLASS : FILTERED_CLASS;
        }
        else {
            filterCLass = FILTER_CLASS;
            for (let i = 0; i < this.parent.dataSourceSettings.filterSettings.length; i++) {
                if (this.parent.dataSourceSettings.filterSettings[i].name === fieldName) {
                    filterCLass = FILTERED_CLASS;
                }
            }
        }
        const spanElement = createElement('span', {
            attrs: {
                'tabindex': '-1', 'aria-disabled': 'false', 'title': this.parent.localeObj.getConstant('filter')
            },
            className: FILTER_COMMON_CLASS + ' ' + ICON + ' ' + filterCLass
        });
        if ((((this.parent.dataSourceSettings.allowLabelFilter || this.parent.dataSourceSettings.allowValueFilter) &&
            axis !== 'filters') || this.parent.dataSourceSettings.allowMemberFilter)) {
            removeClass([spanElement], ICON_DISABLE);
        }
        else {
            addClass([spanElement], ICON_DISABLE);
        }
        if (this.parent.getModuleName() === 'pivotview') {
            if ((((this.parent.dataSourceSettings.allowLabelFilter || this.parent.dataSourceSettings.allowValueFilter) &&
                axis !== 'filters') || this.parent.dataSourceSettings.allowMemberFilter) &&
                this.parent.groupingBarSettings.showFilterIcon && field.showFilterIcon) {
                removeClass([spanElement], ICON_DISABLE);
            }
            else {
                addClass([spanElement], ICON_DISABLE);
            }
        }
        else {
            if (field.showFilterIcon && (((this.parent.dataSourceSettings.allowLabelFilter ||
                this.parent.dataSourceSettings.allowValueFilter) && axis !== 'filters') ||
                this.parent.dataSourceSettings.allowMemberFilter)) {
                removeClass([spanElement], ICON_DISABLE);
            }
            else {
                addClass([spanElement], ICON_DISABLE);
            }
        }
        pivotButton.appendChild(spanElement);
        return spanElement;
    }
    // To update button text
    updateButtontext(fieldName) {
        let engineModule;
        if (this.parent.dataType === 'olap') {
            engineModule = this.parent.olapEngineModule;
        }
        else {
            engineModule = this.parent.engineModule;
        }
        const filterCount = engineModule.fieldList[fieldName].filter.length;
        const filterType = engineModule.fieldList[fieldName].filterType;
        const memLen = engineModule.fieldList[fieldName].dateMember.length;
        let filterMem;
        const firstNode = engineModule.fieldList[fieldName].filter[0];
        if (this.parent.dataType === 'olap') {
            filterMem = this.updateOlapButtonText(engineModule, fieldName, firstNode, filterCount);
        }
        else if (filterType === 'include') {
            if (filterCount === 1) {
                filterMem = firstNode;
            }
            else if (filterCount > 1) {
                if (filterCount === memLen) {
                    filterMem = this.parent.localeObj.getConstant('all');
                }
                else {
                    filterMem = this.parent.localeObj.getConstant('multipleItems');
                }
            }
        }
        else if (filterType === 'exclude') {
            if (filterCount === 1) {
                if (memLen === 2) {
                    if (firstNode !== engineModule.fieldList[fieldName].dateMember[0].actualText) {
                        filterMem = firstNode;
                    }
                    else {
                        filterMem = engineModule.fieldList[fieldName].dateMember[0].actualText;
                    }
                }
                else {
                    filterMem = this.parent.localeObj.getConstant('multipleItems');
                }
            }
            else if (filterCount > 1) {
                let j;
                const allNodes = Object.keys(engineModule.fieldList[fieldName].members);
                const filteredItems = engineModule.fieldList[fieldName].filter;
                if (filterCount === (allNodes.length - 1)) {
                    // eslint-disable-next-line no-labels
                    loop: for (j = 0; j < allNodes.length; j++) {
                        const test = allNodes[j];
                        const x = filteredItems.indexOf(test);
                        if (x === -1) {
                            filterMem = allNodes[j];
                            // eslint-disable-next-line no-labels
                            break loop;
                        }
                    }
                }
                else {
                    filterMem = this.parent.localeObj.getConstant('multipleItems');
                }
            }
        }
        else {
            filterMem = this.parent.localeObj.getConstant('all');
        }
        return filterMem;
    }
    updateOlapButtonText(engineModule, fieldName, firstNode, filterCount) {
        let filterMem;
        const filterItems = engineModule.fieldList[fieldName].actualFilter;
        if (filterItems.length > 0) {
            const cMembers = engineModule.fieldList[fieldName].members;
            const actualFilterItems = [];
            if (engineModule.fieldList[fieldName].filterMembers.length > 0) {
                let dummyfilterItems = {};
                for (const item of filterItems) {
                    dummyfilterItems[item] = item;
                    if (cMembers[item]) {
                        dummyfilterItems = this.parent.pivotCommon.eventBase.getParentNode(fieldName, item, dummyfilterItems);
                    }
                }
                const updatedFilterItems = dummyfilterItems ? Object.keys(dummyfilterItems) : [];
                for (const item of updatedFilterItems) {
                    if (cMembers[item].isSelected) {
                        if (!(cMembers[item].parent && cMembers[cMembers[item].parent].isSelected)) {
                            actualFilterItems.push(item);
                        }
                    }
                }
                firstNode = actualFilterItems.length === 1 ? cMembers[actualFilterItems[0]].caption : firstNode;
            }
            filterCount = actualFilterItems.length === 0 ? filterCount : actualFilterItems.length;
        }
        if (filterCount === 0) {
            filterMem = (engineModule.fieldList[fieldName].allMember ?
                engineModule.fieldList[fieldName].allMember : this.parent.localeObj.getConstant('all'));
        }
        else if (filterCount === 1) {
            filterMem = firstNode;
        }
        else if (filterCount > 1) {
            filterMem = this.parent.localeObj.getConstant('multipleItems');
        }
        return filterMem;
    }
    createDragClone(args) {
        const element = closest(args.element, '.' + PIVOT_BUTTON_CLASS);
        const cloneElement = createElement('div', {
            id: this.parent.element.id + '_DragClone',
            className: DRAG_CLONE_CLASS + (this.parent.cssClass ? (' ' + this.parent.cssClass) : '')
        });
        const contentElement = createElement('span', {
            className: TEXT_CONTENT_CLASS
        });
        contentElement.innerText = this.parent.enableHtmlSanitizer ? SanitizeHtmlHelper.sanitize(element.textContent) : element.textContent;
        cloneElement.appendChild(contentElement);
        document.body.appendChild(cloneElement);
        return cloneElement;
    }
    onDragStart(e) {
        const element = closest(e.element, '.' + PIVOT_BUTTON_CLASS);
        const dragItem = document.getElementById(this.parent.element.id + '_DragClone');
        const fieldInfo = PivotUtil.getFieldInfo(element.getAttribute('data-uid'), this.parent);
        const dragEventArgs = {
            fieldName: fieldInfo.fieldName,
            fieldItem: fieldInfo.fieldItem,
            axis: fieldInfo.axis,
            dataSourceSettings: PivotUtil.getClonedDataSourceSettings(this.parent.dataSourceSettings),
            cancel: false
        };
        const control = this.parent.getModuleName() === 'pivotfieldlist' &&
            this.parent.isPopupView ? this.parent.pivotGridModule : this.parent;
        control.trigger(fieldDragStart, dragEventArgs, (observedArgs) => {
            if (!observedArgs.cancel) {
                this.parent.isDragging = true;
                let engineModule;
                if (this.parent.dataType === 'olap') {
                    engineModule = this.parent.olapEngineModule;
                }
                else {
                    engineModule = this.parent.engineModule;
                }
                const data = engineModule.fieldList[element.getAttribute('data-uid')];
                const axis = [ROW_AXIS_CLASS, COLUMN_AXIS_CLASS, FILTER_AXIS_CLASS];
                addClass([element], SELECTED_NODE_CLASS);
                if (dragItem && (this.parent.getModuleName() === 'pivotfieldlist' &&
                    this.parent.renderMode) === 'Popup') {
                    const fieldListPopup = this.parent;
                    dragItem.style.zIndex = (fieldListPopup.dialogRenderer.fieldListDialog.zIndex + 1).toString();
                }
                if (data && data.aggregateType === 'CalculatedField') {
                    for (const axisContent of axis) {
                        addClass([this.parentElement.querySelector('.' + axisContent)], NO_DRAG_CLASS);
                    }
                }
            }
            else {
                this.parent.isDragging = false;
                this.draggable.intDestroy(e.event);
                detach(dragItem);
            }
        });
    }
    onDragging(e) {
        this.draggable.setProperties({ cursorAt: { top: (!isNullOrUndefined(e.event.targetTouches) || Browser.isDevice) ? 60 : -20 } });
    }
    onDragStop(args) {
        this.parent.isDragging = false;
        if (args.target && args.element && (closest(args.element, '.' + GROUP_ALL_FIELDS_CLASS) &&
            !closest(args.target, '.' + DROPPABLE_CLASS))) {
            args.cancel = true;
        }
        const element = closest(args.element, '.' + PIVOT_BUTTON_CLASS);
        removeClass([].slice.call(this.parentElement.querySelectorAll('.' + PIVOT_BUTTON_CLASS)), SELECTED_NODE_CLASS);
        removeClass([].slice.call(this.parentElement.querySelectorAll('.' + DROP_INDICATOR_CLASS)), INDICATOR_HOVER_CLASS);
        const axis = [ROW_AXIS_CLASS, COLUMN_AXIS_CLASS, FILTER_AXIS_CLASS];
        for (const axisContent of axis) {
            removeClass([this.parentElement.querySelector('.' + axisContent)], NO_DRAG_CLASS);
        }
        if (this.parent.pivotCommon.filterDialog.dialogPopUp) {
            this.parent.pivotCommon.filterDialog.dialogPopUp.close();
        }
        if (document.getElementById(this.parent.element.id + '_DragClone')) {
            remove(document.getElementById(this.parent.element.id + '_DragClone'));
        }
        document.body.style.cursor = 'auto';
        if (!this.isButtonDropped(args.target, element) || args.cancel) {
            return;
        }
        this.parent.pivotCommon.dataSourceUpdate.control = this.parent.getModuleName() === 'pivotview' ? this.parent :
            (this.parent.pivotGridModule ? this.parent.pivotGridModule : this.parent);
        if (this.parent.pivotCommon.nodeStateModified.onStateModified(args, element.getAttribute('data-uid'))) {
            this.updateDataSource(); // eslint-disable-next-line @typescript-eslint/no-this-alias
            const thisObj = this;
            thisObj.parent.axisFieldModule.render();
        }
    }
    isButtonDropped(dropTarget, target) {
        const axisPanel = closest(target, '.' + DROPPABLE_CLASS);
        const droppableElement = closest(dropTarget, '.' + DROPPABLE_CLASS);
        let isDropped = true;
        if (axisPanel && axisPanel === droppableElement) {
            const pivotButtons = [].slice.call(axisPanel.querySelectorAll('.' + PIVOT_BUTTON_CLASS));
            const droppableTarget = closest(dropTarget, '.' + PIVOT_BUTTON_WRAPPER_CLASS);
            let sourcePosition;
            let droppedPosition = -1;
            for (let i = 0, n = pivotButtons.length; i < n; i++) {
                if (pivotButtons[i].id === target.id) {
                    sourcePosition = i;
                }
                if (droppableTarget) {
                    const droppableButton = droppableTarget.querySelector('.' + PIVOT_BUTTON_CLASS);
                    if (pivotButtons[i].id === droppableButton.id) {
                        droppedPosition = i;
                    }
                }
            }
            if (sourcePosition === droppedPosition || (sourcePosition === (pivotButtons.length - 1) && droppedPosition === -1)) {
                removeClass([].slice.call(this.parentElement.querySelectorAll('.' + DROP_INDICATOR_CLASS)), INDICATOR_HOVER_CLASS);
                isDropped = false;
            }
        }
        return isDropped;
    }
    updateSorting(args) {
        const buttonElement = closest(args.target, '.' + PIVOT_BUTTON_CLASS);
        const fieldInfo = PivotUtil.getFieldInfo((buttonElement ? buttonElement.getAttribute('data-uid') : ''), this.parent);
        if (!(args.target.classList.contains(FILTER_COMMON_CLASS)) &&
            !(args.target.classList.contains(REMOVE_CLASS)) &&
            !(args.target.classList.contains(DRAG_CLASS)) &&
            (buttonElement && fieldInfo.fieldItem && (fieldInfo.fieldItem.showSortIcon ||
                isNullOrUndefined(fieldInfo.fieldItem.showSortIcon)) && !fieldInfo.fieldItem.isCalculatedField)) {
            this.parent.actionObj.actionName = sortField;
            this.parent.actionObj.fieldInfo = fieldInfo;
            if (this.parent.actionBeginMethod()) {
                return;
            }
            try {
                if ((this.parent instanceof PivotFieldList || this.parent.groupingBarSettings.showSortIcon) &&
                    this.parent.dataSourceSettings.enableSorting &&
                    !(this.parent.dataType === 'olap' && ((this.parent.getModuleName() === 'pivotfieldlist' &&
                        this.parent.pivotGridModule !== undefined &&
                        this.parent.pivotGridModule.enableVirtualization) ||
                        (this.parent.getModuleName() === 'pivotview' && this.parent.enableVirtualization)))) {
                    this.parent.pivotCommon.eventBase.updateSorting(args);
                    if (this.parent.staticPivotGridModule) {
                        this.parent.staticPivotGridModule.actionObj = this.parent.actionObj;
                    }
                    if (!this.parent.allowDeferLayoutUpdate || this.parent.getModuleName() !== 'pivotfieldlist') {
                        const actionInfo = {
                            sortInfo: this.parent.lastSortInfo
                        };
                        this.parent.actionObj.actionInfo = actionInfo;
                        this.updateDataSource(true);
                    } // eslint-disable-next-line @typescript-eslint/no-this-alias
                    const thisObj = this;
                    if (thisObj.parent instanceof PivotFieldList) {
                        thisObj.axisField.render();
                    }
                }
            }
            catch (execption) {
                this.parent.actionFailureMethod(execption);
            }
        }
    }
    /**
     *
     * @param {boolean} isRefreshGrid - It contains isRefreshGrid
     * @returns {void}
     * @hidden */
    updateDataSource(isRefreshGrid) {
        if (!this.parent.allowDeferLayoutUpdate || this.parent.getModuleName() === 'pivotview') {
            this.parent.updateDataSource(isRefreshGrid);
        }
        else {
            if (this.parent.getModuleName() === 'pivotfieldlist' && this.parent.isPopupView && this.parent.pivotGridModule) {
                if (this.parent.dataType === 'olap') {
                    this.parent.pivotGridModule.olapEngineModule = this.parent.olapEngineModule;
                }
                else {
                    this.parent.pivotGridModule.engineModule = this.parent.engineModule;
                }
                this.parent.pivotGridModule.notify(uiUpdate, this);
                this.parent.pivotGridModule.setProperties({
                    dataSourceSettings: this.parent.dataSourceSettings.properties
                }, true);
            }
            else {
                this.parent.triggerPopulateEvent();
            }
        }
    }
    updateFiltering(args) {
        const pivotObj = this.parent.pivotGridModule ? this.parent.pivotGridModule : this.parent;
        const fieldName = args.target.parentElement.getAttribute('data-uid');
        const fieldInfo = PivotUtil.getFieldInfo(fieldName, this.parent);
        this.parent.actionObj.actionName = filterField;
        this.parent.actionObj.fieldInfo = fieldInfo;
        if (this.parent.actionBeginMethod()) {
            return;
        }
        try {
            if (pivotObj.getModuleName() === 'pivotfieldlist') {
                showSpinner(pivotObj.fieldListSpinnerElement);
            }
            else {
                pivotObj.showWaitingPopup();
            }
            pivotObj.mouseEventArgs = args;
            pivotObj.filterTargetID = this.parent.pivotCommon.moduleName !== 'pivotfieldlist' ?
                this.parent.element : document.getElementById(this.parent.pivotCommon.parentID + '_Container');
            if (pivotObj.dataSourceSettings.mode === 'Server') {
                if (this.parent.engineModule.fieldList[fieldName].members &&
                    Object.keys(this.parent.engineModule.fieldList[fieldName].members).length > 0) {
                    this.updateFilterEvents();
                }
                else {
                    pivotObj.getEngine('fetchFieldMembers', null, null, null, null, null, fieldName);
                }
            }
            else {
                this.updateFilterEvents();
            }
        }
        catch (execption) {
            this.parent.actionFailureMethod(execption);
        }
    }
    /**
     *
     * @returns {void}
     * @hidden */
    updateFilterEvents() {
        const pivotObj = this.parent.pivotGridModule ? this.parent.pivotGridModule : this.parent;
        this.parent.pivotCommon.eventBase.updateFiltering(pivotObj.mouseEventArgs);
        const target = pivotObj.mouseEventArgs.target;
        this.fieldName = target.parentElement.getAttribute('data-uid');
        if (this.parent.pivotCommon.filterDialog.dialogPopUp) {
            this.bindDialogEvents();
        }
        if (pivotObj.getModuleName() === 'pivotfieldlist') {
            hideSpinner(pivotObj.fieldListSpinnerElement);
        }
        else {
            pivotObj.hideWaitingPopup();
        }
    }
    bindDialogEvents() {
        if (this.parent.pivotCommon.filterDialog.allowExcelLikeFilter && this.parent.pivotCommon.filterDialog.tabObj) {
            this.index = this.parent.pivotCommon.filterDialog.tabObj.selectedItem;
            this.updateDialogButtonEvents();
            this.parent.pivotCommon.filterDialog.dialogPopUp.buttons = this.buttonModel();
            this.parent.pivotCommon.filterDialog.dialogPopUp.dataBind();
            this.parent.pivotCommon.filterDialog.tabObj.selected = this.tabSelect.bind(this);
        }
        else if (this.parent.dataSourceSettings.allowMemberFilter) {
            this.index = 0;
            this.updateDialogButtonEvents();
        }
    }
    buttonModel() {
        return [
            {
                buttonModel: {
                    cssClass: 'e-clear-filter-button' + (this.parent.pivotCommon.filterDialog.allowExcelLikeFilter ? '' : ' ' + ICON_DISABLE) + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
                    iconCss: 'e-icons e-clear-filter-icon', enableRtl: this.parent.enableRtl,
                    content: this.parent.localeObj.getConstant('clearFilter'), disabled: (this.parent.pivotCommon.filterDialog.filterObject ? false : true)
                },
                click: this.ClearFilter.bind(this)
            },
            {
                buttonModel: {
                    cssClass: OK_BUTTON_CLASS + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''), content: this.parent.localeObj.getConstant('ok'), isPrimary: true
                },
                click: (this.index === 0 ? this.updateFilterState.bind(this, this.fieldName) : this.updateCustomFilter.bind(this))
            },
            {
                click: this.parent.pivotCommon.filterDialog.closeFilterDialog.bind(this.parent.pivotCommon.filterDialog),
                buttonModel: { cssClass: CANCEL_BUTTON_CLASS + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''), content: this.parent.localeObj.getConstant('cancel') }
            }
        ];
    }
    tabSelect(e) {
        this.index = e.selectedIndex;
        this.updateDialogButtonEvents();
        removeClass([].slice.call(this.parent.pivotCommon.filterDialog.dialogPopUp.element.querySelectorAll('.e-selected-tab')), 'e-selected-tab');
        if (e.selectedIndex > 0) {
            addClass([this.parent.pivotCommon.filterDialog.dialogPopUp.element.querySelector('.e-filter-div-content' + '.' + (e.selectedIndex === 1 && this.parent.dataSourceSettings.allowLabelFilter ? 'e-label-filter' : 'e-value-filter'))], 'e-selected-tab');
        }
        if (e.selectedIndex === 0) {
            this.parent.pivotCommon.filterDialog.updateCheckedState();
        }
        else {
            this.parent.pivotCommon.filterDialog.dialogPopUp.buttons[0].buttonModel.disabled = false;
            this.parent.pivotCommon.filterDialog.dialogPopUp.element.querySelector('.' + OK_BUTTON_CLASS).removeAttribute('disabled');
        }
    }
    updateDialogButtonEvents() {
        this.parent.pivotCommon.filterDialog.dialogPopUp.buttons = this.buttonModel();
        this.parent.pivotCommon.filterDialog.dialogPopUp.dataBind();
    }
    updateCustomFilter() {
        const dialogElement = this.parent.pivotCommon.filterDialog.dialogPopUp.element.querySelector('.e-selected-tab');
        const fieldName = dialogElement.getAttribute('data-fieldname');
        const levelName = dialogElement.getAttribute('data-selectedField');
        const filterType = dialogElement.getAttribute('data-type');
        const measure = dialogElement.getAttribute('data-measure');
        const operator = dialogElement.getAttribute('data-operator');
        const operand1 = dialogElement.getAttribute('data-value1');
        const operand2 = dialogElement.getAttribute('data-value2');
        const type = ((filterType === 'value') ? 'Value' : (filterType === 'date') ? 'Date' :
            (filterType === 'number') ? 'Number' : 'Label');
        let filterItem = {
            name: fieldName,
            type: type,
            measure: measure,
            condition: operator,
            value1: filterType === 'date' ? new Date(operand1) : operand1,
            value2: filterType === 'date' ? new Date(operand2) : operand2
        };
        let filterObject;
        if (this.parent.dataType === 'olap') {
            filterItem.selectedField = levelName;
            this.removeDataSourceSettings(fieldName, levelName, type);
            const filterItems = this.parent.dataSourceSettings.filterSettings;
            for (const item of filterItems) {
                if (item.name === fieldName && item.selectedField === levelName) {
                    filterObject = item;
                }
            }
        }
        else {
            filterObject = PivotUtil.getFilterItemByName(fieldName, this.parent.dataSourceSettings.filterSettings);
        }
        if ((isNullOrUndefined(operand1) || operand1 === '') ||
            (['Between', 'NotBetween'].indexOf(operator) > -1 && (isNullOrUndefined(operand2) || operand2 === ''))) {
            const inputElementString = (type.toLowerCase() + ((isNullOrUndefined(operand1) || operand1 === '') ? '_input_option_1' : '_input_option_2'));
            const focusElement = select('#' + this.parent.element.id + '_' + inputElementString, dialogElement);
            addClass([focusElement], EMPTY_FIELD);
            focusElement.focus();
            return;
        }
        const filterEventArgs = {
            cancel: false,
            filterSettings: filterItem,
            dataSourceSettings: PivotUtil.getClonedDataSourceSettings(this.parent.dataSourceSettings)
        };
        const control = this.parent.getModuleName() === 'pivotfieldlist' &&
            this.parent.isPopupView ? this.parent.pivotGridModule : this.parent;
        control.trigger(memberFiltering, filterEventArgs, (observedArgs) => {
            if (!observedArgs.cancel) {
                filterItem = observedArgs.filterSettings;
                if (filterObject) {
                    // this.removeDataSourceSettings(fieldName);
                    filterObject = filterObject.properties ?
                        filterObject.properties : filterObject;
                    filterObject.type = filterItem.type;
                    filterObject.measure = filterItem.measure;
                    filterObject.condition = filterItem.condition;
                    filterObject.value1 = filterItem.value1;
                    filterObject.value2 = filterItem.value2;
                    if (this.parent.dataType === 'olap') {
                        filterObject.selectedField = filterItem.selectedField;
                    }
                }
                else {
                    this.parent.dataSourceSettings.filterSettings.push(filterItem);
                }
            }
            if (type !== 'Value') {
                this.parent.lastFilterInfo = PivotUtil.getFilterItemByName(fieldName, this.parent.dataSourceSettings.filterSettings);
            }
            this.parent.pivotCommon.filterDialog.dialogPopUp.close();
            if (!observedArgs.cancel) {
                this.refreshPivotButtonState(fieldName, true);
                this.updateDataSource(true);
            }
        });
    }
    ClearFilter() {
        const dialogElement = this.parent.pivotCommon.filterDialog.dialogPopUp.element;
        const fieldName = dialogElement.getAttribute('data-fieldname');
        const tabElement = dialogElement.querySelector('.e-selected-tab');
        this.parent.pivotCommon.filterDialog.dialogPopUp.close();
        if (this.parent.dataType === 'olap' && tabElement) {
            const levelName = tabElement.getAttribute('data-selectedField');
            this.removeDataSourceSettings(fieldName, levelName);
        }
        else {
            this.removeDataSourceSettings(fieldName);
        }
        const filterObject = PivotUtil.getFilterItemByName(fieldName, this.parent.dataSourceSettings.filterSettings);
        this.refreshPivotButtonState(fieldName, filterObject ? true : false);
        this.updateDataSource(true);
    }
    removeButton(args) {
        const target = args.target;
        const fieldName = target.parentElement.getAttribute('data-uid');
        const fieldInfo = PivotUtil.getFieldInfo(fieldName, this.parent);
        this.parent.actionObj.actionName = removeField;
        this.parent.actionObj.fieldInfo = fieldInfo;
        if (this.parent.actionBeginMethod()) {
            return;
        }
        const removeFieldArgs = {
            cancel: false, fieldName: fieldName,
            dataSourceSettings: PivotUtil.getClonedDataSourceSettings(this.parent.dataSourceSettings),
            fieldItem: fieldInfo.fieldItem, axis: fieldInfo.axis
        };
        try {
            const control = this.parent.getModuleName() === 'pivotfieldlist' &&
                this.parent.isPopupView ? this.parent.pivotGridModule : this.parent;
            control.trigger(fieldRemove, removeFieldArgs, (observedArgs) => {
                if (!observedArgs.cancel) {
                    if (target.parentElement.getAttribute('isvalue') === 'true') {
                        this.parent.setProperties({ dataSourceSettings: { values: [] } }, true);
                        if (this.parent.dataType === 'olap') {
                            this.parent.pivotCommon.dataSourceUpdate.removeFieldFromReport('[Measures]');
                        }
                    }
                    else {
                        this.parent.pivotCommon.dataSourceUpdate.removeFieldFromReport(fieldName);
                        if (this.parent.dataType === 'pivot' && this.parent.showValuesButton && this.parent.dataSourceSettings.values.length > 1 &&
                            fieldInfo.position < this.parent.dataSourceSettings.valueIndex && ((this.parent.dataSourceSettings.valueAxis === 'row' &&
                            observedArgs.axis === 'rows') || (this.parent.dataSourceSettings.valueAxis === 'column' && observedArgs.axis === 'columns'))) {
                            this.parent.setProperties({
                                dataSourceSettings: { valueIndex: this.parent.dataSourceSettings.valueIndex - 1 }
                            }, true);
                        }
                        if (this.parent.dataType === 'olap' && this.parent.dataSourceSettings.values.length === 0) {
                            this.parent.pivotCommon.dataSourceUpdate.removeFieldFromReport('[Measures]');
                        }
                    }
                    if (this.parent.getModuleName() === 'pivotfieldlist') {
                        this.parent.axisFieldModule.render();
                    }
                    this.updateDataSource();
                }
            });
        }
        catch (execption) {
            this.parent.actionFailureMethod(execption);
        }
    }
    /**
     *
     * @param {NodeCheckEventArgs} args - It contains args value.
     * @returns {void}
     * @hidden */
    nodeStateModified(args) {
        const target = closest(args.node, 'li');
        const fieldName = target.getAttribute('data-fieldname');
        if (target.getAttribute('data-memberId') === 'all') {
            this.parent.pivotCommon.filterDialog.memberTreeView.nodeChecked = null;
            if (args.action === 'check') {
                this.parent.pivotCommon.filterDialog.memberTreeView.checkAll();
            }
            else {
                this.parent.pivotCommon.filterDialog.memberTreeView.uncheckAll();
            }
            if (this.parent.dataType === 'olap' && this.parent.olapEngineModule &&
                !this.parent.olapEngineModule.fieldList[fieldName].isHierarchy) {
                this.updateNodeStates(this.parent.pivotCommon.filterDialog.memberTreeView.getAllCheckedNodes(), fieldName);
            }
            this.checkedStateAll(args.action);
            this.parent.pivotCommon.filterDialog.memberTreeView.nodeChecked = this.nodeStateModified.bind(this);
        }
        else {
            if (this.parent.dataType === 'olap' && this.parent.olapEngineModule &&
                !this.parent.olapEngineModule.fieldList[fieldName].isHierarchy) {
                // let st1: number = new Date().getTime();
                const checkedNodes = this.parent.pivotCommon.filterDialog.memberTreeView.getAllCheckedNodes();
                // let st2: number = (new Date().getTime() - st1) / 1000;
                // console.log('getAllCheckedNodes:' + st2);
                this.updateNodeStates(checkedNodes, fieldName);
            }
            const pos = this.parent.pivotCommon.currentTreeItemsPos[target.getAttribute('data-memberId')].index;
            if (this.parent.pivotCommon.currentTreeItems[pos]) {
                this.parent.pivotCommon.currentTreeItems[pos].isSelected = args.action === 'check';
                this.parent.pivotCommon.currentTreeItemsPos[target.getAttribute('data-memberId')].isSelected = args.action === 'check';
            }
        }
        this.parent.pivotCommon.filterDialog.updateCheckedState();
    }
    checkedStateAll(state) {
        const searchItemObj = {};
        /* eslint-disable @typescript-eslint/no-explicit-any */
        for (const item of this.parent.pivotCommon.searchTreeItems) {
            item.isSelected = state === 'check';
            searchItemObj[item.htmlAttributes['data-memberId']] = item.htmlAttributes['data-memberId'];
        }
        for (const item of this.parent.pivotCommon.currentTreeItems) {
            if (searchItemObj[item.htmlAttributes['data-memberId']] !== undefined) {
                item.isSelected = state === 'check';
                this.parent.pivotCommon.currentTreeItemsPos[item.htmlAttributes['data-memberId']].isSelected = state === 'check';
            }
        } /* eslint-enable @typescript-eslint/no-explicit-any */
    }
    updateNodeStates(checkedNodes, fieldName) {
        const fieldList = this.parent.pivotCommon.engineModule.fieldList[fieldName];
        const currentMembers = fieldList.members;
        const searchMembers = fieldList.currrentMembers;
        if (fieldList.searchMembers.length > 0) {
            const members = Object.keys(searchMembers);
            for (const member of members) {
                if (searchMembers[member]) {
                    searchMembers[member].isSelected = false;
                }
                if (currentMembers[member]) {
                    currentMembers[member].isSelected = false;
                    if (this.parent.pivotCommon.filterDialog.memberTreeView.element.querySelector('li[data-memberId="' + member + '"]')) {
                        const element = this.parent.pivotCommon.filterDialog.memberTreeView.element.querySelector('li[data-memberId="' + member + '"]');
                        if (element && !element.querySelector('ul')) {
                            this.parent.pivotCommon.eventBase.updateChildNodeStates(fieldList.filterMembers, fieldName, member, false);
                        }
                    }
                }
            }
            for (const node of checkedNodes) {
                if (currentMembers[node]) {
                    if (this.parent.pivotCommon.filterDialog.memberTreeView.element.querySelector('li[data-memberId="' + node + '"]')) {
                        const element = this.parent.pivotCommon.filterDialog.memberTreeView.element.querySelector('li[data-memberId="' + node + '"]');
                        if (element && !element.querySelector('ul')) {
                            currentMembers[node].isSelected = true;
                            this.parent.pivotCommon.eventBase.updateChildNodeStates(fieldList.filterMembers, fieldName, node, true);
                        }
                    }
                }
                if (searchMembers[node]) {
                    searchMembers[node].isSelected = true;
                }
            }
        }
        else {
            const members = Object.keys(currentMembers);
            for (const member of members) {
                if (currentMembers[member].isSelected) {
                    currentMembers[member].isSelected = false;
                }
            }
            for (const node of checkedNodes) {
                if (currentMembers[node]) {
                    currentMembers[node].isSelected = true;
                    this.parent.pivotCommon.eventBase.updateChildNodeStates(fieldList.filterMembers, fieldName, node, true);
                }
            }
        }
    }
    updateFilterState(fieldName) {
        let isNodeUnChecked = false;
        let filterItem = { items: [], name: fieldName, type: 'Include' };
        const engineModule = this.parent.dataType === 'olap' ? this.parent.olapEngineModule : this.parent.engineModule;
        if (this.parent.dataType === 'olap' && engineModule &&
            !engineModule.fieldList[fieldName].isHierarchy) {
            const cMembers = engineModule.fieldList[fieldName].members;
            const sMembers = engineModule.fieldList[fieldName].currrentMembers;
            filterItem.items = this.parent.pivotCommon.filterDialog.memberTreeView.getAllCheckedNodes();
            filterItem.levelCount = engineModule.fieldList[fieldName].levelCount;
            isNodeUnChecked = (filterItem.items.length ===
                this.parent.pivotCommon.filterDialog.memberTreeView.fields.dataSource.length ?
                false : true);
            if (engineModule.fieldList[fieldName].searchMembers.length > 0 && !isNodeUnChecked) {
                const cNodeLength = Object.keys(cMembers).length;
                const sNodeLength = Object.keys(sMembers).length;
                isNodeUnChecked = cNodeLength === sNodeLength && cNodeLength === filterItem.items.length ? false : true;
            }
            const filterItems = filterItem.items;
            for (const node of filterItems) {
                if (engineModule.fieldList[fieldName].searchMembers.length > 0 && sMembers[node]) {
                    sMembers[node].isSelected = true;
                }
                else if (cMembers[node]) {
                    cMembers[node].isSelected = true;
                }
            }
        }
        else {
            for (const item of this.parent.pivotCommon.searchTreeItems) {
                if (item.isSelected) {
                    if (this.parent.pivotCommon.isDateField) {
                        filterItem.items.push(item.name);
                    }
                    else { // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        filterItem.items.push(item.htmlAttributes['data-memberId']);
                    }
                }
            }
            isNodeUnChecked = (filterItem.items.length === this.parent.pivotCommon.currentTreeItems.length ?
                false : true);
        }
        if (this.parent.dataType === 'olap') {
            this.removeDataSourceSettings(fieldName);
        }
        if (this.parent.allowDeferLayoutUpdate) {
            engineModule.fieldList[filterItem.name].filterType = filterItem.type.toLowerCase();
            engineModule.fieldList[filterItem.name].filter = [];
            for (let i = 0; i < filterItem.items.length; i++) {
                engineModule.fieldList[filterItem.name].filter.push(filterItem.items[i]);
            }
        }
        const filterEventArgs = {
            filterSettings: filterItem,
            dataSourceSettings: PivotUtil.getClonedDataSourceSettings(this.parent.dataSourceSettings),
            cancel: false
        };
        const control = this.parent.getModuleName() === 'pivotfieldlist' &&
            this.parent.isPopupView ? this.parent.pivotGridModule : this.parent;
        control.trigger(memberFiltering, filterEventArgs, (observedArgs) => {
            filterItem = observedArgs.filterSettings;
            if (!observedArgs.cancel) {
                const filterObject = PivotUtil.getFilterItemByName(fieldName, this.parent.dataSourceSettings.filterSettings);
                if (filterObject) {
                    for (let i = 0; i < this.parent.dataSourceSettings.filterSettings.length; i++) {
                        if (this.parent.dataSourceSettings.filterSettings[i].name === fieldName) {
                            this.parent.dataSourceSettings.filterSettings.splice(i, 1);
                            break;
                        }
                    }
                }
                this.parent.dataSourceSettings.filterSettings.push(filterItem);
            }
            this.parent.pivotCommon.filterDialog.dialogPopUp.close();
            if (!observedArgs.cancel) {
                this.refreshPivotButtonState(fieldName, isNodeUnChecked);
                if (!isNodeUnChecked) {
                    this.removeDataSourceSettings(fieldName);
                    filterItem = {};
                }
                this.parent.lastFilterInfo = filterItem;
                const actionInfo = {
                    filterInfo: this.parent.lastFilterInfo
                };
                this.parent.actionObj.actionInfo = actionInfo;
                this.updateDataSource(true); // eslint-disable-next-line @typescript-eslint/no-this-alias
                const thisObj = this;
                //setTimeout(() => {
                if (thisObj.parent instanceof PivotFieldList) {
                    thisObj.axisField.render();
                }
                //});
            }
            const pivotButtons = [].slice.call(this.parentElement.querySelectorAll('.e-pivot-button'));
            for (const item of pivotButtons) {
                if (item.getAttribute('data-uid') === fieldName) {
                    item.focus();
                    break;
                }
            }
        });
    }
    refreshPivotButtonState(fieldName, isFiltered) {
        const pivotButtons = [].slice.call(this.parentElement.querySelectorAll('.e-pivot-button'));
        let selectedButton;
        for (const item of pivotButtons) {
            if (item.getAttribute('data-uid') === fieldName) {
                selectedButton = item.querySelector('.' + FILTER_COMMON_CLASS);
                break;
            }
        }
        if (isFiltered) {
            removeClass([selectedButton], FILTER_CLASS);
            addClass([selectedButton], FILTERED_CLASS);
        }
        else {
            removeClass([selectedButton], FILTERED_CLASS);
            addClass([selectedButton], FILTER_CLASS);
        }
    }
    removeDataSourceSettings(fieldName, selectedField, type) {
        const filterSettings = this.parent.dataSourceSettings.filterSettings;
        for (let len = 0, lnt = filterSettings.length; len < lnt; len++) {
            if (this.parent.dataType === 'olap' && selectedField) {
                if (!type && filterSettings[len].name === fieldName &&
                    filterSettings[len].selectedField === selectedField) {
                    filterSettings.splice(len, 1);
                    break;
                }
                else if (type) {
                    if (filterSettings[len].type !== type &&
                        filterSettings[len].name === fieldName) {
                        filterSettings.splice(len, 1);
                        lnt--;
                        len--;
                    }
                }
            }
            else {
                if (filterSettings[len].name === fieldName) {
                    filterSettings.splice(len, 1);
                    if (this.parent.dataType !== 'olap') {
                        break;
                    }
                    lnt--;
                    len--;
                }
            }
        }
    }
    updateDropIndicator(e) {
        if (this.parent.isDragging) {
            removeClass([].slice.call(this.parentElement.querySelectorAll('.' + DROP_INDICATOR_CLASS + '-last')), INDICATOR_HOVER_CLASS);
            removeClass([].slice.call(this.parentElement.querySelectorAll('.' + DROP_INDICATOR_CLASS)), INDICATOR_HOVER_CLASS);
            if (closest(e.target, '.' + DROPPABLE_CLASS)) {
                const element = closest(e.target, '.' + PIVOT_BUTTON_WRAPPER_CLASS);
                addClass([element.querySelector('.' + DROP_INDICATOR_CLASS)], INDICATOR_HOVER_CLASS);
            }
        }
    }
    wireEvent(element, axis, isMeasureAvail) {
        EventHandler.add(element, 'mouseover', this.updateDropIndicator, this);
        if (!isMeasureAvail) {
            if (['filters', 'values'].indexOf(axis) === -1 && element.querySelector('.' + PIVOT_BUTTON_CLASS) !== null) {
                EventHandler.add(element.querySelector('.' + PIVOT_BUTTON_CLASS), 'click', this.updateSorting, this);
            }
            if (axis !== 'values' && element.querySelector('.' + FILTER_COMMON_CLASS) !== null) {
                EventHandler.add(element.querySelector('.' + FILTER_COMMON_CLASS), 'click', this.updateFiltering, this);
            }
            if (axis === 'values' && element.querySelector('.' + AXISFIELD_ICON_CLASS) !== null) {
                EventHandler.add(element.querySelector('.' + AXISFIELD_ICON_CLASS), 'click', this.createMenuOption, this);
            }
        }
        if (element.querySelector('.' + CALC_EDIT) !== null) {
            EventHandler.add(element.querySelector('.' + CALC_EDIT), 'click', this.openCalculatedFieldDialog, this);
        }
        if (element.querySelector('.' + REMOVE_CLASS) !== null) {
            EventHandler.add(element.querySelector('.' + REMOVE_CLASS), 'click', this.removeButton, this);
        }
    }
    unWireEvent(element, axis, isMeasureAvail) {
        EventHandler.remove(element, 'mouseover', this.updateDropIndicator);
        if (!isMeasureAvail) {
            if (['filters', 'values'].indexOf(axis) === -1 && element.querySelector('.' + PIVOT_BUTTON_CLASS) !== null) {
                EventHandler.remove(element.querySelector('.' + PIVOT_BUTTON_CLASS), 'click', this.updateSorting);
            }
            if (axis !== 'values' && element.querySelector('.' + FILTER_COMMON_CLASS) !== null) {
                EventHandler.remove(element.querySelector('.' + FILTER_COMMON_CLASS), 'click', this.updateFiltering);
            }
            if (axis === 'values' && element.querySelector('.' + AXISFIELD_ICON_CLASS) !== null) {
                EventHandler.remove(element.querySelector('.' + AXISFIELD_ICON_CLASS), 'click', this.createMenuOption);
            }
        }
        if (element.querySelector('.' + CALC_EDIT) !== null) {
            EventHandler.remove(element.querySelector('.' + CALC_EDIT), 'click', this.openCalculatedFieldDialog);
        }
        if (element.querySelector('.' + REMOVE_CLASS) !== null) {
            EventHandler.remove(element.querySelector('.' + REMOVE_CLASS), 'click', this.removeButton);
        }
    }
    /**
     *
     * @returns {void}
     * @hidden
     */
    addEventListener() {
        this.handlers = {
            load: this.renderPivotButton
        };
        if (this.parent.isDestroyed) {
            return;
        }
        this.parent.on(pivotButtonUpdate, this.handlers.load, this);
    }
    /**
     *
     * @returns {void}
     * @hidden
     */
    removeEventListener() {
        if (this.parent.isDestroyed) {
            return;
        }
        this.parent.off(pivotButtonUpdate, this.handlers.load);
    }
    /**
     * To destroy the pivot button event listener
     *
     * @returns {void}
     * @hidden
     */
    destroy() {
        if (this.menuOption) {
            this.menuOption.destroy();
        }
        if (this.valueFiedDropDownList && !this.valueFiedDropDownList.isDestroyed) {
            this.valueFiedDropDownList.destroy();
            this.valueFiedDropDownList = null;
        }
        if (this.columnFieldDropDownList && !this.columnFieldDropDownList.isDestroyed) {
            this.columnFieldDropDownList.destroy();
            this.columnFieldDropDownList = null;
        }
        if (this.draggable && !this.draggable.isDestroyed) {
            this.draggable.destroy();
            this.draggable = null;
        }
        if (this.axisField) {
            this.axisField = null;
        }
        this.removeEventListener();
        this.isDestroyed = true;
    }
}

/**
 * Module to render Axis Fields
 */
/** @hidden */
class AxisFieldRenderer {
    /** Constructor for render module */
    constructor(parent) {
        this.parent = parent;
    }
    /**
     * Initialize the pivot button rendering
     *
     * @returns {void}
     * @private
     */
    render() {
        if (!this.parent.pivotButtonModule || (this.parent.pivotButtonModule && this.parent.pivotButtonModule.isDestroyed)) {
            new PivotButton(this.parent);
        }
        this.createPivotButtons();
    }
    createPivotButtons() {
        const rows = this.parent.dataSourceSettings.rows;
        const columns = this.parent.dataSourceSettings.columns;
        const values = this.parent.dataSourceSettings.values;
        const filters = this.parent.dataSourceSettings.filters;
        const fields = [rows, columns, values, filters];
        const parentElement = this.parent.dialogRenderer.parentElement;
        if (parentElement.querySelector('.' + FIELD_LIST_CLASS + '-filters')) {
            parentElement.querySelector('.' + FIELD_LIST_CLASS + '-filters').querySelector('.' + AXIS_CONTENT_CLASS).innerHTML = '';
        }
        if (parentElement.querySelector('.' + FIELD_LIST_CLASS + '-rows')) {
            parentElement.querySelector('.' + FIELD_LIST_CLASS + '-rows').querySelector('.' + AXIS_CONTENT_CLASS).innerHTML = '';
        }
        if (parentElement.querySelector('.' + FIELD_LIST_CLASS + '-columns')) {
            parentElement.querySelector('.' + FIELD_LIST_CLASS + '-columns').querySelector('.' + AXIS_CONTENT_CLASS).innerHTML = '';
        }
        if (parentElement.querySelector('.' + FIELD_LIST_CLASS + '-values')) {
            parentElement.querySelector('.' + FIELD_LIST_CLASS + '-values').querySelector('.' + AXIS_CONTENT_CLASS).innerHTML = '';
        }
        if ((this.parent.dataType === 'pivot' && this.parent.dataSourceSettings.dataSource && this.parent.dataSourceSettings.dataSource.length > 0) ||
            (this.parent.dataType === 'olap' && this.parent.dataSourceSettings.url && this.parent.dataSourceSettings.url !== '') ||
            (this.parent.dataSourceSettings.mode === 'Server' && this.parent.dataSourceSettings.url !== '')) {
            const axis = ['rows', 'columns', 'values', 'filters'];
            for (let len = 0, lnt = fields.length; len < lnt; len++) {
                if (fields[len]) {
                    const args = {
                        field: fields[len],
                        axis: axis[len].toString()
                    };
                    this.parent.notify(pivotButtonUpdate, args);
                }
            }
        }
    }
}

/**
 * Module to render Pivot Table component
 */
/** @hidden */
class Render$1 {
    /** Constructor for render module
     *
     * @param {PivotFieldList} parent - Instance of field list.
     */
    constructor(parent) {
        this.parent = parent;
        this.parent.dialogRenderer = new DialogRenderer(this.parent);
        this.parent.treeViewModule = new TreeViewRenderer(this.parent);
        this.parent.axisTableModule = new AxisTableRenderer(this.parent);
        this.parent.axisFieldModule = new AxisFieldRenderer(this.parent);
    }
    /**
     * Initialize the pivot table rendering
     *
     * @returns {void}
     * @private
     */
    render() {
        this.parent.dialogRenderer.render();
        if (!this.parent.isAdaptive) {
            this.parent.treeViewModule.render();
        }
        this.parent.axisTableModule.render();
    }
}

var __decorate$4 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Represents the PivotFieldList component.
 * ```html
 * <div id="pivotfieldlist"></div>
 * <script>
 *  var pivotfieldlistObj = new PivotFieldList({ });
 *  pivotfieldlistObj.appendTo("#pivotfieldlist");
 * </script>
 * ```
 */
let PivotFieldList = class PivotFieldList extends Component {
    /**
     * Constructor for creating the widget
     *
     * @param  {PivotFieldListModel} options - options
     * @param  {string|HTMLElement} element - element
     */
    constructor(options, element) {
        super(options, element);
        /** @hidden */
        this.pivotChange = false;
        this.isRequiredUpdate = true;
        /** @hidden */
        this.lastSortInfo = {};
        /** @hidden */
        this.lastFilterInfo = {};
        /** @hidden */
        this.lastAggregationInfo = {};
        /** @hidden */
        this.lastCalcFieldInfo = {};
        /** @hidden */
        this.isPopupView = false;
        /** @hidden */
        this.enableValueSorting = false;
        this.request = new XMLHttpRequest();
        this.remoteData = [];
        /** @hidden */
        this.actionObj = {};
        /** @hidden */
        this.destroyEngine = false;
        /** @hidden */
        this.defaultFieldListOrder = 'None';
        /** @hidden */
        this.isDeferUpdateApplied = false;
    }
    /**
     * To provide the array of modules needed for control rendering
     *
     * @returns {ModuleDeclaration[]} - ModuleDeclaration[]
     * @hidden
     */
    requiredModules() {
        const modules = [];
        if (this.allowCalculatedField) {
            modules.push({ args: [this], member: 'calculatedField' });
        }
        return modules;
    }
    /**
     * @returns {AggregateTypes[]}- AggregateTypes[]
     * @hidden
     */
    getAllSummaryType() {
        return ['Sum', 'Count', 'DistinctCount', 'Product', 'Min', 'Max', 'Avg', 'Median', 'Index',
            'PopulationVar', 'SampleVar', 'PopulationStDev', 'SampleStDev', 'RunningTotals', 'PercentageOfGrandTotal',
            'PercentageOfColumnTotal', 'PercentageOfRowTotal', 'PercentageOfParentColumnTotal', 'PercentageOfParentRowTotal',
            'DifferenceFrom', 'PercentageOfDifferenceFrom', 'PercentageOfParentTotal'];
    }
    /**
     * For internal use only - Initialize the event handler;
     *
     * @private
     */
    preRender() {
        if (this.dataSourceSettings && this.dataSourceSettings.providerType === 'SSAS') {
            this.olapEngineModule = new OlapEngine();
            this.dataType = 'olap';
        }
        else {
            this.engineModule = new PivotEngine();
            this.dataType = 'pivot';
        }
        this.isAdaptive = Browser.isDevice;
        this.globalize = new Internationalization(this.locale);
        this.renderModule = new Render$1(this);
        this.defaultLocale = {
            staticFieldList: 'Pivot Field List',
            fieldList: 'Field List',
            dropFilterPrompt: 'Drop filter here',
            dropColPrompt: 'Drop column here',
            dropRowPrompt: 'Drop row here',
            dropValPrompt: 'Drop value here',
            addPrompt: 'Add field here',
            adaptiveFieldHeader: 'Choose field',
            centerHeader: 'Drag fields between axes below:',
            add: 'add',
            drag: 'Drag',
            filter: 'Filter',
            filtered: 'Filtered',
            sort: 'Sort',
            remove: 'Remove',
            filters: 'Filters',
            rows: 'Rows',
            columns: 'Columns',
            values: 'Values',
            CalculatedField: 'Calculated Field',
            createCalculatedField: 'Create Calculated Field',
            fieldName: 'Enter the field name',
            error: 'Error',
            invalidFormula: 'Invalid formula.',
            dropText: 'Example: ("Sum(Order_Count)" + "Sum(In_Stock)") * 250',
            dropTextMobile: 'Add fields and edit formula here.',
            dropAction: 'Calculated field cannot be place in any other region except value axis.',
            search: 'Search',
            close: 'Close',
            cancel: 'Cancel',
            delete: 'Delete',
            alert: 'Alert',
            warning: 'Warning',
            ok: 'OK',
            allFields: 'All Fields',
            formula: 'Formula',
            fieldExist: 'A field already exists in this name. Please enter a different name.',
            confirmText: 'A calculation field already exists in this name. Do you want to replace it?',
            noMatches: 'No matches',
            format: 'Summaries values by',
            edit: 'Edit',
            clear: 'Clear',
            clearCalculatedField: 'Clear edited field info',
            editCalculatedField: 'Edit calculated field',
            sortAscending: 'Sort ascending order',
            sortDescending: 'Sort descending order',
            sortNone: 'Sort data order',
            formulaField: 'Drag and drop fields to formula',
            dragField: 'Drag field to formula',
            clearFilter: 'Clear',
            by: 'by',
            enterValue: 'Enter value',
            chooseDate: 'Enter date',
            all: 'All',
            multipleItems: 'Multiple items',
            Equals: 'Equals',
            DoesNotEquals: 'Does Not Equal',
            BeginWith: 'Begins With',
            DoesNotBeginWith: 'Does Not Begin With',
            EndsWith: 'Ends With',
            DoesNotEndsWith: 'Does Not End With',
            Contains: 'Contains',
            DoesNotContains: 'Does Not Contain',
            GreaterThan: 'Greater Than',
            GreaterThanOrEqualTo: 'Greater Than Or Equal To',
            LessThan: 'Less Than',
            LessThanOrEqualTo: 'Less Than Or Equal To',
            Between: 'Between',
            NotBetween: 'Not Between',
            Before: 'Before',
            BeforeOrEqualTo: 'Before Or Equal To',
            After: 'After',
            AfterOrEqualTo: 'After Or Equal To',
            member: 'Member',
            label: 'Label',
            date: 'Date',
            value: 'Value',
            labelTextContent: 'Show the items for which the label',
            dateTextContent: 'Show the items for which the date',
            valueTextContent: 'Show the items for which',
            And: 'and',
            Sum: 'Sum',
            Count: 'Count',
            DistinctCount: 'Distinct Count',
            Product: 'Product',
            Avg: 'Avg',
            Median: 'Median',
            Min: 'Min',
            Max: 'Max',
            Index: 'Index',
            SampleStDev: 'Sample StDev',
            PopulationStDev: 'Population StDev',
            SampleVar: 'Sample Var',
            PopulationVar: 'Population Var',
            RunningTotals: 'Running Totals',
            DifferenceFrom: 'Difference From',
            PercentageOfDifferenceFrom: '% of Difference From',
            PercentageOfGrandTotal: '% of Grand Total',
            PercentageOfColumnTotal: '% of Column Total',
            PercentageOfRowTotal: '% of Row Total',
            PercentageOfParentTotal: '% of Parent Total',
            PercentageOfParentColumnTotal: '% of Parent Column Total',
            PercentageOfParentRowTotal: '% of Parent Row Total',
            MoreOption: 'More...',
            Years: 'Years',
            Quarters: 'Quarters',
            Months: 'Months',
            Days: 'Days',
            Hours: 'Hours',
            Minutes: 'Minutes',
            Seconds: 'Seconds',
            apply: 'Apply',
            valueFieldSettings: 'Value field settings',
            sourceName: 'Field name :',
            sourceCaption: 'Field caption',
            summarizeValuesBy: 'Summarize values by',
            baseField: 'Base field',
            baseItem: 'Base item',
            example: 'e.g:',
            editorDataLimitMsg: ' more items. Search to refine further.',
            deferLayoutUpdate: 'Defer Layout Update',
            null: 'null',
            undefined: 'undefined',
            groupOutOfRange: 'Out of Range',
            fieldDropErrorAction: 'The field you are moving cannot be placed in that area of the report',
            memberType: 'Field Type',
            selectedHierarchy: 'Parent Hierarchy',
            formatString: 'Format',
            expressionField: 'Expression',
            olapDropText: 'Example: [Measures].[Order Quantity] + ([Measures].[Order Quantity] * 0.10)',
            customFormat: 'Enter custom format string',
            numberFormatString: 'Example: C, P, 0000 %, ###0.##0#, etc.',
            Measure: 'Measure',
            Dimension: 'Dimension',
            Standard: 'Standard',
            Currency: 'Currency',
            Percent: 'Percent',
            Custom: 'Custom',
            blank: '(Blank)',
            fieldTooltip: 'Drag and drop fields to create an expression. ' +
                'And, if you want to edit the existing calculated fields! ' +
                'You can achieve it by simply selecting the field under "Calculated Members".',
            fieldTitle: 'Field Name',
            QuarterYear: 'Quarter Year',
            caption: 'Field Caption',
            copy: 'Copy',
            of: 'of',
            group: 'Group',
            removeCalculatedField: 'Are you sure you want to delete this calculated field?',
            yes: 'Yes',
            no: 'No',
            None: 'None'
        };
        this.localeObj = new L10n(this.getModuleName(), this.defaultLocale, this.locale);
        this.isDragging = false;
        this.captionData = [];
        this.wireEvent();
    }
    frameCustomProperties(fieldListData, fieldList) {
        if (this.pivotGridModule) {
            this.pivotGridModule.updatePageSettings(false);
        }
        const pageSettings = this.pivotGridModule ? this.pivotGridModule.pageSettings : this.pageSettings;
        const isPaging = this.pivotGridModule ? this.pivotGridModule.enablePaging : false;
        const isVirtualization = this.pivotGridModule ? this.pivotGridModule.enableVirtualization : false;
        const enableHtmlSanitizer = this.pivotGridModule ? this.pivotGridModule.enableHtmlSanitizer : this.enableHtmlSanitizer;
        const localeObj = this.pivotGridModule ? this.pivotGridModule.localeObj :
            (this.staticPivotGridModule ? this.staticPivotGridModule.localeObj : this.localeObj);
        const isDrillThrough = this.pivotGridModule ?
            (this.pivotGridModule.allowDrillThrough || this.pivotGridModule.editSettings.allowEditing) : true;
        const enableValueSorting = this.pivotGridModule ? this.pivotGridModule.enableValueSorting : undefined;
        let customProperties;
        if (this.dataType === 'olap') {
            customProperties = {
                mode: '',
                savedFieldList: fieldList ? fieldList : undefined,
                savedFieldListData: fieldListData ? fieldListData : undefined,
                pageSettings: pageSettings,
                enableValueSorting: enableValueSorting,
                isDrillThrough: isDrillThrough,
                localeObj: localeObj,
                enableVirtualization: isVirtualization
            };
        }
        else {
            customProperties = {
                mode: '',
                savedFieldList: undefined,
                pageSettings: pageSettings,
                enableValueSorting: enableValueSorting,
                isDrillThrough: isDrillThrough,
                localeObj: localeObj,
                clonedReport: this.clonedReport,
                globalize: this.globalize,
                currenyCode: this.currencyCode,
                enablePaging: isPaging,
                enableVirtualization: isVirtualization,
                enableHtmlSanitizer: enableHtmlSanitizer
            };
        }
        return customProperties;
    }
    /**
     * Initialize the control rendering
     *
     * @returns {void}
     * @private
     */
    render() {
        if (this.dataType === 'pivot' && this.dataSourceSettings.url && this.dataSourceSettings.url !== '') {
            if (this.dataSourceSettings.mode === 'Server') {
                this.guid = PivotUtil.generateUUID();
                this.getEngine('initialRender', null, null, null, null, null, null);
            }
            else {
                const request = new Fetch(this.dataSourceSettings.url, 'GET');
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                request.send().then((response) => typeof (response) === 'string' ? response : response.text())
                    .then(this.onReadyStateChange.bind(this));
            }
        }
        else {
            this.initialLoad();
        }
    }
    /**
     *
     * @hidden
     *
     */
    getEngine(action, drillItem, sortItem, aggField, cField, filterItem, memberName, rawDataArgs, editArgs) {
        this.currentAction = action;
        if (this.pivotGridModule) {
            this.pivotGridModule.updatePageSettings(false);
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const customProperties = {
            pageSettings: this.pivotGridModule ? JSON.parse(this.pivotGridModule.getPersistData()).pageSettings : undefined,
            enableValueSorting: this.pivotGridModule ? this.pivotGridModule.enableValueSorting : undefined,
            enableDrillThrough: this.pivotGridModule ?
                (this.pivotGridModule.allowDrillThrough || this.pivotGridModule.editSettings.allowEditing) : true,
            locale: JSON.stringify(PivotUtil.getLocalizedObject(this))
        };
        this.request.open('POST', this.dataSourceSettings.url, true);
        const params = {
            request: this.request,
            dataSourceSettings: JSON.parse(this.getPersistData()).dataSourceSettings,
            action: action,
            customProperties: {},
            internalProperties: customProperties,
            drillItem: drillItem,
            sortItem: sortItem,
            aggregatedItem: aggField,
            calculatedItem: cField,
            filterItem: filterItem,
            memberName: memberName,
            fetchRawDataArgs: rawDataArgs,
            editArgs: editArgs,
            hash: this.guid,
            isGroupingUpdated: (this.currentAction === 'onRefresh' && this.dataSourceSettings.groupSettings.length > 0) ? true :
                ((this.pivotGridModule && this.pivotGridModule.groupingModule) ? this.pivotGridModule.groupingModule.isUpdate : false)
        };
        this.trigger(beforeServiceInvoke, params, (observedArgs) => {
            this.request = observedArgs.request;
            params.internalProperties = observedArgs.internalProperties;
            params.customProperties = observedArgs.customProperties;
            params.dataSourceSettings = observedArgs.dataSourceSettings;
            params.calculatedItem = observedArgs.calculatedItem;
            params.drillItem = observedArgs.drillItem;
            params.editArgs = observedArgs.editArgs;
            params.fetchRawDataArgs = observedArgs.fetchRawDataArgs;
            params.filterItem = observedArgs.filterItem;
            params.hash = observedArgs.hash;
            params.memberName = observedArgs.memberName;
            params.sortItem = observedArgs.sortItem;
        });
        this.request.withCredentials = false;
        this.request.onreadystatechange = this.onSuccess.bind(this);
        this.request.setRequestHeader('Content-type', 'application/json');
        this.request.send(JSON.stringify(params));
    }
    onSuccess() {
        if (this.request.readyState === XMLHttpRequest.DONE) {
            try {
                /* eslint-disable @typescript-eslint/no-explicit-any */
                const engine = JSON.parse(this.request.responseText);
                if (this.currentAction === 'fetchFieldMembers') {
                    const currentMembers = JSON.parse(engine.members);
                    const dateMembers = [];
                    const formattedMembers = {};
                    const members = {};
                    /* eslint-enable @typescript-eslint/no-explicit-any */
                    for (let i = 0; i < currentMembers.length; i++) {
                        dateMembers.push({
                            formattedText: currentMembers[i].FormattedText,
                            actualText: currentMembers[i].ActualText
                        });
                        formattedMembers[currentMembers[i].FormattedText] = {};
                        members[currentMembers[i].ActualText] = {};
                    }
                    this.engineModule.fieldList[engine.memberName].dateMember = dateMembers;
                    this.engineModule.fieldList[engine.memberName].formattedMembers = formattedMembers;
                    this.engineModule.fieldList[engine.memberName].members = members;
                    this.pivotButtonModule.updateFilterEvents();
                }
                else {
                    const fList = PivotUtil.formatFieldList(JSON.parse(engine.fieldList));
                    if (this.engineModule.fieldList) {
                        const keys = Object.keys(this.engineModule.fieldList);
                        for (let i = 0; i < keys.length; i++) {
                            if (this.engineModule.fieldList[keys[i]] && fList[keys[i]]) {
                                fList[keys[i]].dateMember = this.engineModule.fieldList[keys[i]].dateMember;
                                fList[keys[i]].formattedMembers = this.engineModule.fieldList[keys[i]].formattedMembers;
                                fList[keys[i]].members = this.engineModule.fieldList[keys[i]].members;
                            }
                        }
                    }
                    this.engineModule.fieldList = fList;
                    this.engineModule.fields = JSON.parse(engine.fields);
                    this.engineModule.rowCount = JSON.parse(engine.pivotCount).RowCount;
                    this.engineModule.columnCount = JSON.parse(engine.pivotCount).ColumnCount;
                    this.engineModule.rowStartPos = JSON.parse(engine.pivotCount).RowStartPosition;
                    this.engineModule.colStartPos = JSON.parse(engine.pivotCount).ColumnStartPosition;
                    this.engineModule.rowFirstLvl = JSON.parse(engine.pivotCount).RowFirstLevel;
                    this.engineModule.colFirstLvl = JSON.parse(engine.pivotCount).ColumnFirstLevel;
                    let rowPos;
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    const pivotValues = PivotUtil.formatPivotValues(JSON.parse(engine.pivotValue));
                    for (let rCnt = 0; rCnt < pivotValues.length; rCnt++) {
                        if (pivotValues[rCnt] && pivotValues[rCnt][0] && pivotValues[rCnt][0].axis === 'row') {
                            rowPos = rCnt;
                            break;
                        }
                    }
                    this.engineModule.headerContent = PivotUtil.frameContent(pivotValues, 'header', rowPos, this);
                    this.engineModule.pageSettings = this.pivotGridModule ? this.pivotGridModule.pageSettings : undefined;
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    const valueSort = JSON.parse(engine.dataSourceSettings).ValueSortSettings;
                    this.engineModule.valueSortSettings = {
                        headerText: valueSort.HeaderText,
                        headerDelimiter: valueSort.HeaderDelimiter,
                        sortOrder: valueSort.SortOrder,
                        columnIndex: valueSort.ColumnIndex
                    };
                    this.engineModule.pivotValues = pivotValues;
                }
            }
            catch (error) {
                this.engineModule.pivotValues = [];
            }
            if (this.currentAction !== 'fetchFieldMembers') {
                this.initEngine();
                if (this.calculatedFieldModule && this.calculatedFieldModule.isRequireUpdate) {
                    this.calculatedFieldModule.endDialog();
                    this.calculatedFieldModule.isRequireUpdate = false;
                }
                if (this.pivotGridModule && this.pivotGridModule.calculatedFieldModule &&
                    this.pivotGridModule.calculatedFieldModule.isRequireUpdate) {
                    this.pivotGridModule.calculatedFieldModule.endDialog();
                    this.pivotGridModule.calculatedFieldModule.isRequireUpdate = false;
                }
            }
        }
    }
    onReadyStateChange(result) {
        let dataSource = [];
        if (this.dataSourceSettings.type === 'CSV') {
            const jsonObject = result.split(/\r?\n|\r/);
            for (let i = 0; i < jsonObject.length; i++) {
                if (!isNullOrUndefined(jsonObject[i]) && jsonObject[i] !== '') {
                    dataSource.push(jsonObject[i].split(','));
                }
            }
        }
        else {
            try {
                dataSource = JSON.parse(result);
            }
            catch (error) {
                dataSource = [];
            }
        }
        if (dataSource && dataSource.length > 0) {
            this.setProperties({ dataSourceSettings: { dataSource: dataSource } }, true);
        }
        this.initialLoad();
    }
    initialLoad() {
        const loadArgs = {
            dataSourceSettings: this.dataSourceSettings,
            defaultFieldListOrder: this.defaultFieldListOrder
        };
        this.trigger(load, loadArgs, (observedArgs) => {
            this.dataSourceSettings = observedArgs.dataSourceSettings;
            this.defaultFieldListOrder = loadArgs.defaultFieldListOrder;
            addClass([this.element], ROOT);
            if (this.enableRtl) {
                addClass([this.element], RTL);
            }
            else {
                removeClass([this.element], RTL);
            }
            if (this.isAdaptive) {
                addClass([this.element], DEVICE);
            }
            else {
                removeClass([this.element], DEVICE);
            }
            if (this.cssClass) {
                addClass([this.element], this.cssClass);
            }
            this.notify(initialLoad, {});
        });
    }
    /**
     *
     * Binding events to the Pivot Field List element.
     *
     * @hidden
     */
    wireEvent() {
        this.on(initialLoad, this.generateData, this);
        this.on(dataReady, this.fieldListRender, this);
    }
    /**
     *
     * Unbinding events from the element on widget destroy.
     *
     * @hidden
     */
    unWireEvent() {
        if (this.pivotGridModule && this.pivotGridModule.isDestroyed) {
            return;
        }
        this.off(initialLoad, this.generateData);
        this.off(dataReady, this.fieldListRender);
    }
    /**
     * Get the properties to be maintained in the persisted state.
     *
     * @returns {string}
     */
    getPersistData() {
        const keyEntity = ['dataSourceSettings'];
        return this.addOnPersist(keyEntity);
    }
    /**
     * Get component name.
     *
     * @returns string
     * @private
     */
    getModuleName() {
        return 'pivotfieldlist';
    }
    /**
     * Called internally if any of the property value changed.
     *
     * @hidden
     */
    onPropertyChanged(newProp, oldProp) {
        let requireRefresh = false;
        for (const prop of Object.keys(newProp)) {
            switch (prop) {
                case 'locale':
                    super.refresh();
                    break;
                case 'dataSourceSettings':
                    if ((!isNullOrUndefined(newProp.dataSourceSettings.dataSource) && !(newProp.dataSourceSettings.groupSettings
                        && newProp.dataSourceSettings.groupSettings.length > 0)) || (this.dataType === 'olap' && !isNullOrUndefined(newProp.dataSourceSettings.url))) {
                        if (this.dataType !== 'olap') {
                            if (!isNullOrUndefined(this.savedDataSourceSettings)) {
                                PivotUtil.updateDataSourceSettings(this.staticPivotGridModule, this.savedDataSourceSettings);
                                this.savedDataSourceSettings = undefined;
                            }
                            if (newProp.dataSourceSettings.dataSource && (newProp.dataSourceSettings.dataSource.length === 0)
                                && !isNullOrUndefined(this.staticPivotGridModule)) {
                                this.savedDataSourceSettings =
                                    PivotUtil.getClonedDataSourceSettings(this.staticPivotGridModule.dataSourceSettings);
                                this.staticPivotGridModule.setProperties({ dataSourceSettings: { rows: [] } }, true);
                                this.staticPivotGridModule.setProperties({ dataSourceSettings: { columns: [] } }, true);
                                this.staticPivotGridModule.setProperties({ dataSourceSettings: { values: [] } }, true);
                                this.staticPivotGridModule.setProperties({ dataSourceSettings: { filters: [] } }, true);
                            }
                        }
                        if (this.dataType === 'pivot') {
                            this.engineModule.fieldList = null;
                            this.engineModule.isEmptyData = true;
                            this.engineModule.data = [];
                        }
                        else if (this.dataType === 'olap') {
                            this.olapEngineModule.fieldList = {};
                            this.olapEngineModule.fieldListData = undefined;
                            this.olapEngineModule.isEmptyData = true;
                        }
                        if (!isNullOrUndefined(this.staticPivotGridModule)) {
                            this.staticPivotGridModule.pivotValues = [];
                        }
                        this.initialLoad();
                    }
                    if (PivotUtil.isButtonIconRefesh(prop, oldProp, newProp)) {
                        if (this.isPopupView && this.pivotGridModule &&
                            this.pivotGridModule.showGroupingBar && this.pivotGridModule.groupingBarModule) {
                            const filters = PivotUtil.cloneFieldSettings(this.dataSourceSettings.filters);
                            const values = PivotUtil.cloneFieldSettings(this.dataSourceSettings.values);
                            const rows = PivotUtil.cloneFieldSettings(this.dataSourceSettings.rows);
                            const columns = PivotUtil.cloneFieldSettings(this.dataSourceSettings.columns);
                            this.pivotGridModule.setProperties({ dataSourceSettings: { rows: rows, columns: columns, values: values,
                                    filters: filters } }, true);
                            this.pivotGridModule.axisFieldModule.render();
                        }
                        else if (!this.isPopupView && this.staticPivotGridModule && !this.staticPivotGridModule.isDestroyed) {
                            const pivot = this.staticPivotGridModule;
                            if (pivot.showGroupingBar && pivot.groupingBarModule) {
                                pivot.axisFieldModule.render();
                            }
                            if (pivot.showFieldList && pivot.pivotFieldListModule) {
                                const rows = PivotUtil.cloneFieldSettings(pivot.dataSourceSettings.rows);
                                const columns = PivotUtil.cloneFieldSettings(pivot.dataSourceSettings.columns);
                                const values = PivotUtil.cloneFieldSettings(pivot.dataSourceSettings.values);
                                const filters = PivotUtil.cloneFieldSettings(pivot.dataSourceSettings.filters);
                                pivot.pivotFieldListModule.setProperties({ dataSourceSettings: { rows: rows, columns: columns, values: values,
                                        filters: filters } }, true);
                                pivot.pivotFieldListModule.axisFieldModule.render();
                                if (pivot.pivotFieldListModule.treeViewModule.fieldTable && !pivot.isAdaptive) {
                                    pivot.pivotFieldListModule.notify(treeViewUpdate, {});
                                }
                            }
                        }
                        this.axisFieldModule.render();
                        if (this.treeViewModule.fieldTable && !this.isAdaptive) {
                            this.notify(treeViewUpdate, {});
                        }
                    }
                    break;
                case 'aggregateTypes':
                    if (this.axisFieldModule) {
                        this.axisFieldModule.render();
                    }
                    if (this.pivotGridModule && this.pivotGridModule.axisFieldModule) {
                        this.pivotGridModule.setProperties({ aggregateTypes: newProp.aggregateTypes }, true);
                        this.pivotGridModule.axisFieldModule.render();
                    }
                    break;
                case 'showValuesButton':
                    if (this.axisFieldModule) {
                        this.axisFieldModule.render();
                    }
                    if (this.pivotGridModule && this.pivotGridModule.showGroupingBar &&
                        this.pivotGridModule.groupingBarModule && this.pivotGridModule.axisFieldModule) {
                        this.pivotGridModule.setProperties({ showValuesButton: newProp.showValuesButton }, true);
                        this.pivotGridModule.axisFieldModule.render();
                    }
                    break;
                case 'enableRtl':
                    if (this.enableRtl) {
                        addClass([this.element], RTL);
                    }
                    else {
                        removeClass([this.element], RTL);
                    }
                    requireRefresh = true;
                    break;
                case 'enableFieldSearching':
                    this.refresh();
            }
            if (requireRefresh) {
                this.fieldListRender();
            }
        }
    }
    initEngine() {
        if (this.dataType === 'pivot') {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const data = !isNullOrUndefined(this.dataSourceSettings.dataSource) ? this.dataSourceSettings.dataSource[0]
                : !isNullOrUndefined(this.engineModule.data) ? this.engineModule.data[0] : undefined;
            if (data && this.pivotCommon) {
                const isArray = Object.prototype.toString.call(data) === '[object Array]';
                if (isArray && this.dataSourceSettings.type === 'JSON') {
                    this.pivotCommon.errorDialog.createErrorDialog(this.localeObj.getConstant('error'), this.localeObj.getConstant('invalidJSON'));
                    return;
                }
                else if (!isArray && this.dataSourceSettings.type === 'CSV') {
                    this.pivotCommon.errorDialog.createErrorDialog(this.localeObj.getConstant('error'), this.localeObj.getConstant('invalidCSV'));
                    return;
                }
            }
        }
        const args = {
            dataSourceSettings: PivotUtil.getClonedDataSourceSettings(this.dataSourceSettings)
        };
        const control = this.isPopupView ? this.pivotGridModule : this;
        control.trigger(enginePopulating, args, (observedArgs) => {
            PivotUtil.updateDataSourceSettings(this, observedArgs.dataSourceSettings);
            if (this.dataType === 'pivot') {
                if (this.dataSourceSettings.groupSettings && this.dataSourceSettings.groupSettings.length > 0) {
                    const pivotDataSet = this.dataSourceSettings.dataSource;
                    this.clonedDataSet = (this.clonedDataSet ? this.clonedDataSet : PivotUtil.getClonedData(pivotDataSet));
                    const dataSourceSettings = JSON.parse(this.getPersistData()).dataSourceSettings;
                    dataSourceSettings.dataSource = [];
                    this.clonedReport = this.clonedReport ? this.clonedReport : dataSourceSettings;
                }
                const customProperties = this.frameCustomProperties();
                customProperties.enableValueSorting = this.staticPivotGridModule ?
                    this.staticPivotGridModule.enableValueSorting : this.enableValueSorting;
                if (this.dataSourceSettings.mode !== 'Server') {
                    this.engineModule.renderEngine(this.dataSourceSettings, customProperties, this.aggregateCellInfo
                        ? this.getValueCellInfo.bind(this) : undefined, this.onHeadersSort ? this.getHeaderSortInfo.bind(this) : undefined);
                }
                this.pivotFieldList = this.engineModule.fieldList;
                const eventArgs = {
                    pivotFieldList: this.pivotFieldList,
                    pivotValues: this.engineModule.pivotValues
                };
                // eslint-disable-next-line @typescript-eslint/no-this-alias
                const this$ = this;
                control.trigger(enginePopulated, eventArgs, (observedArgs) => {
                    this$.pivotFieldList = observedArgs.pivotFieldList;
                    this$.engineModule.pivotValues = observedArgs.pivotValues;
                    this$.notify(dataReady, {});
                    this$.trigger(dataBound);
                });
            }
            else if (this.dataType === 'olap') {
                this.olapEngineModule.renderEngine(this.dataSourceSettings, this.frameCustomProperties(this.olapEngineModule.fieldListData, this.olapEngineModule.fieldList), this.onHeadersSort ?
                    this.getHeaderSortInfo.bind(this) : undefined);
                this.pivotFieldList = this.olapEngineModule.fieldList;
                const eventArgs = {
                    pivotFieldList: this.pivotFieldList,
                    pivotValues: this.olapEngineModule.pivotValues
                };
                // eslint-disable-next-line @typescript-eslint/no-this-alias
                const this$ = this;
                control.trigger(enginePopulated, eventArgs, (observedArgs) => {
                    this$.pivotFieldList = observedArgs.pivotFieldList;
                    this$.olapEngineModule.pivotValues = observedArgs.pivotValues;
                    this$.notify(dataReady, {});
                    this$.trigger(dataBound);
                });
            }
        });
        if (this.defaultFieldListOrder !== 'None') {
            if (this.treeViewModule.fieldTable && !this.isAdaptive) {
                this.notify(treeViewUpdate, {});
            }
        }
    }
    generateData() {
        this.pivotFieldList = {};
        if (this.dataSourceSettings && (this.dataSourceSettings.dataSource || this.dataSourceSettings.url)) {
            if ((this.dataSourceSettings.url !== '' && this.dataType === 'olap') ||
                this.dataSourceSettings.dataSource.length > 0) {
                if (this.dataType === 'pivot') {
                    this.engineModule.data = this.dataSourceSettings.dataSource;
                }
                this.initEngine();
            }
            else if (this.dataSourceSettings.dataSource instanceof DataManager) {
                if (this.dataType === 'pivot' && this.remoteData.length > 0) {
                    this.engineModule.data = this.remoteData;
                    this.initEngine();
                }
                else {
                    setTimeout(this.getData.bind(this), 100);
                }
            }
            else {
                this.notify(dataReady, {});
            }
        }
        else {
            this.notify(dataReady, {});
            this.trigger(dataBound);
        }
    }
    getValueCellInfo(aggregateObj) {
        const args = aggregateObj;
        this.trigger(aggregateCellInfo, args);
        return args;
    }
    getHeaderSortInfo(sortingObj) {
        const args = sortingObj;
        this.trigger(onHeadersSort, args);
        return args;
    }
    getData() {
        this.dataSourceSettings.dataSource.executeQuery(new Query()).then(this.executeQuery.bind(this));
    }
    executeQuery(e) {
        this.engineModule.data = e.result;
        this.initEngine();
    }
    fieldListRender() {
        this.element.innerHTML = '';
        let showDialog;
        if (this.renderMode === 'Popup' && this.dialogRenderer.fieldListDialog && !this.dialogRenderer.fieldListDialog.isDestroyed) {
            showDialog = this.dialogRenderer.fieldListDialog.visible;
            this.dialogRenderer.fieldListDialog.destroy();
            remove(document.getElementById(this.element.id + '_Container'));
        }
        this.renderModule.render();
        if (this.renderMode === 'Popup') {
            this.fieldListSpinnerElement = this.dialogRenderer.fieldListDialog.element;
            if (showDialog) {
                this.dialogRenderer.fieldListDialog.show();
            }
        }
        else {
            this.fieldListSpinnerElement = this.element.querySelector('.e-pivotfieldlist-container');
        }
        if (this.spinnerTemplate) {
            createSpinner({
                target: this.fieldListSpinnerElement, template: this.spinnerTemplate,
                cssClass: this.cssClass ? this.cssClass : undefined
            }, this.createElement);
        }
        else {
            createSpinner({ target: this.fieldListSpinnerElement, cssClass: this.cssClass ? this.cssClass : undefined }, this.createElement);
        }
        const args = {
            pivotEngine: this.dataType === 'olap' ? this.olapEngineModule : this.engineModule,
            dataSourceSettings: this.dataSourceSettings,
            id: this.element.id,
            element: document.getElementById(this.element.id + '_Container'),
            moduleName: this.getModuleName(),
            enableRtl: this.enableRtl,
            enableHtmlSanitizer: this.enableHtmlSanitizer,
            isAdaptive: this.isAdaptive,
            renderMode: this.renderMode,
            localeObj: this.localeObj,
            dataType: this.dataType,
            cssClass: this.cssClass
        };
        this.pivotCommon = new PivotCommon(args);
        this.pivotCommon.control = this;
        if (this.allowDeferLayoutUpdate) {
            this.clonedDataSource = extend({}, this.dataSourceSettings, null, true);
            if (this.dataType === 'olap') {
                this.clonedFieldListData = PivotUtil.cloneOlapFieldSettings(this.olapEngineModule.fieldListData);
            }
            this.clonedFieldList = PivotUtil.getClonedFieldList(this.pivotFieldList);
        }
    }
    getFieldCaption(dataSourceSettings) {
        this.getFields(dataSourceSettings);
        const engineModule = this.dataType === 'olap' ? this.olapEngineModule : this.engineModule;
        if (this.captionData.length > 0 && engineModule && engineModule.fieldList) {
            let lnt = this.captionData.length;
            while (lnt--) {
                if (this.captionData[lnt]) {
                    for (const obj of this.captionData[lnt]) {
                        if (obj) {
                            if (engineModule.fieldList[obj.name]) {
                                if (obj.caption) {
                                    engineModule.fieldList[obj.name].caption = obj.caption;
                                }
                                else {
                                    engineModule.fieldList[obj.name].caption = obj.name;
                                }
                            }
                        }
                    }
                }
            }
        }
        else {
            return;
        }
    }
    getFields(dataSourceSettings) {
        this.captionData =
            [dataSourceSettings.rows, dataSourceSettings.columns, dataSourceSettings.values,
                dataSourceSettings.filters];
    }
    /**
     * Updates the PivotEngine using dataSource from Pivot Field List component.
     *
     * @function updateDataSource
     * @returns {void}
     * @hidden
     */
    updateDataSource(isTreeViewRefresh, isEngineRefresh) {
        if (this.pivotGridModule) {
            this.pivotGridModule.showWaitingPopup();
        }
        showSpinner(this.fieldListSpinnerElement);
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const pivot = this;
        const control = pivot.isPopupView ? pivot.pivotGridModule : pivot;
        //setTimeout(() => {
        let isOlapDataRefreshed = false;
        const pageSettings = pivot.pivotGridModule && (pivot.pivotGridModule.enableVirtualization
            || pivot.pivotGridModule.enablePaging) ? pivot.pivotGridModule.pageSettings : undefined;
        const isCalcChange = Object.keys(pivot.lastCalcFieldInfo).length > 0 ? true : false;
        const isSorted = Object.keys(pivot.lastSortInfo).length > 0 ? true : false;
        const isAggChange = Object.keys(pivot.lastAggregationInfo).length > 0 ? true : false;
        const isFiltered = Object.keys(pivot.lastFilterInfo).length > 0 ? true : false;
        const args = {
            dataSourceSettings: PivotUtil.getClonedDataSourceSettings(pivot.dataSourceSettings)
        };
        control.trigger(enginePopulating, args, (observedArgs) => {
            if (!(pageSettings && (isSorted || isFiltered || isAggChange || isCalcChange))) {
                PivotUtil.updateDataSourceSettings(pivot, observedArgs.dataSourceSettings);
                PivotUtil.updateDataSourceSettings(pivot.pivotGridModule, observedArgs.dataSourceSettings);
            }
            if (isNullOrUndefined(isEngineRefresh)) {
                if (pivot.dataType === 'pivot') {
                    const customProperties = pivot.frameCustomProperties();
                    if (!isSorted) {
                        customProperties.enableValueSorting = pivot.staticPivotGridModule ?
                            pivot.staticPivotGridModule.enableValueSorting : pivot.enableValueSorting;
                    }
                    else {
                        if (pivot.pivotGridModule) {
                            pivot.pivotGridModule.setProperties({ dataSourceSettings: { valueSortSettings: { headerText: '' } } }, true);
                        }
                        pivot.setProperties({ dataSourceSettings: { valueSortSettings: { headerText: '' } } }, true);
                        customProperties.enableValueSorting = false;
                    }
                    customProperties.savedFieldList = pivot.pivotFieldList;
                    if (pageSettings && (isSorted || isFiltered || isAggChange || isCalcChange) && !pivot.allowDeferLayoutUpdate) {
                        if (isSorted) {
                            pivot.pivotGridModule.setProperties({ dataSourceSettings: { valueSortSettings: { headerText: '' } } }, true);
                            if (control.dataSourceSettings.mode === 'Server') {
                                control.getEngine('onSort', null, pivot.lastSortInfo, null, null, null, null);
                            }
                            else {
                                pivot.engineModule.onSort(pivot.lastSortInfo);
                            }
                            pivot.lastSortInfo = {};
                        }
                        if (isFiltered) {
                            if (control.dataSourceSettings.mode === 'Server') {
                                control.getEngine('onFilter', null, null, null, null, pivot.lastFilterInfo, null);
                            }
                            else {
                                pivot.engineModule.onFilter(pivot.lastFilterInfo, pivot.dataSourceSettings);
                            }
                            pivot.lastFilterInfo = {};
                        }
                        if (isAggChange) {
                            if (control.dataSourceSettings.mode === 'Server') {
                                control.getEngine('onAggregation', null, null, pivot.lastAggregationInfo, null, null, null);
                            }
                            else {
                                pivot.engineModule.onAggregation(pivot.lastAggregationInfo);
                            }
                            pivot.lastAggregationInfo = {};
                        }
                        if (isCalcChange) {
                            if (control.dataSourceSettings.mode === 'Server') {
                                control.getEngine('onCalcOperation', null, null, null, pivot.lastCalcFieldInfo, null, null);
                            }
                            else {
                                pivot.engineModule.onCalcOperation(pivot.lastCalcFieldInfo, pivot.dataSourceSettings);
                            }
                            pivot.lastCalcFieldInfo = {};
                        }
                    }
                    else {
                        if (pivot.dataSourceSettings.mode === 'Server') {
                            if (isSorted) {
                                control.getEngine('onSort', null, pivot.lastSortInfo, null, null, null, null);
                            }
                            else if (isAggChange) {
                                control.getEngine('onAggregation', null, null, pivot.lastAggregationInfo, null, null, null);
                            }
                            else if (isCalcChange) {
                                control.getEngine('onCalcOperation', null, null, null, pivot.lastCalcFieldInfo, null, null);
                            }
                            else if (isFiltered) {
                                control.getEngine('onFilter', null, null, null, null, pivot.lastFilterInfo, null);
                            }
                            else {
                                control.getEngine('onDrop', null, null, null, null, null, null);
                            }
                        }
                        else {
                            pivot.engineModule.renderEngine(pivot.dataSourceSettings, customProperties, pivot.aggregateCellInfo ? pivot.getValueCellInfo.bind(pivot) : undefined, pivot.onHeadersSort ? pivot.getHeaderSortInfo.bind(pivot) : undefined);
                        }
                        pivot.lastSortInfo = {};
                        pivot.lastAggregationInfo = {};
                        pivot.lastCalcFieldInfo = {};
                        pivot.lastFilterInfo = {};
                    }
                }
                else {
                    isOlapDataRefreshed = pivot.updateOlapDataSource(pivot, isSorted, isCalcChange, isOlapDataRefreshed);
                }
                pivot.getFieldCaption(pivot.dataSourceSettings);
            }
            else {
                pivot.axisFieldModule.render();
                pivot.isRequiredUpdate = false;
            }
            pivot.enginePopulatedEventMethod(pivot, isTreeViewRefresh, isOlapDataRefreshed);
        });
        //});
    }
    enginePopulatedEventMethod(pivot, isTreeViewRefresh, isOlapDataRefreshed) {
        const control = pivot.isPopupView ? pivot.pivotGridModule : pivot;
        const eventArgs = {
            dataSourceSettings: pivot.dataSourceSettings,
            pivotFieldList: pivot.dataType === 'pivot' ? pivot.engineModule.fieldList : pivot.olapEngineModule.fieldList,
            pivotValues: pivot.dataType === 'pivot' ? pivot.engineModule.pivotValues : pivot.olapEngineModule.pivotValues
        };
        control.trigger(enginePopulated, eventArgs, (observedArgs) => {
            pivot.dataSourceSettings = observedArgs.dataSourceSettings;
            pivot.pivotCommon.dataSourceSettings = pivot.dataSourceSettings;
            pivot.pivotFieldList = observedArgs.pivotFieldList;
            if (pivot.dataType === 'olap') {
                pivot.olapEngineModule.pivotValues = observedArgs.pivotValues;
                pivot.pivotCommon.engineModule = pivot.olapEngineModule;
            }
            else {
                pivot.engineModule.pivotValues = observedArgs.pivotValues;
                pivot.pivotCommon.engineModule = pivot.engineModule;
            }
            if (!isTreeViewRefresh && pivot.treeViewModule.fieldTable && !pivot.isAdaptive) {
                pivot.notify(treeViewUpdate, {});
            }
            if (pivot.isRequiredUpdate) {
                if (pivot.allowDeferLayoutUpdate) {
                    pivot.clonedDataSource = extend({}, pivot.dataSourceSettings, null, true);
                    if (this.dataType === 'olap') {
                        this.clonedFieldListData = PivotUtil.cloneOlapFieldSettings(this.olapEngineModule.fieldListData);
                    }
                    pivot.clonedFieldList = PivotUtil.getClonedFieldList(pivot.pivotFieldList);
                }
                pivot.updateView(pivot.pivotGridModule);
            }
            else if (this.isPopupView && pivot.allowDeferLayoutUpdate) {
                pivot.pivotGridModule.engineModule = pivot.engineModule;
                pivot.pivotGridModule.setProperties({
                    dataSourceSettings: pivot.dataSourceSettings.properties
                }, true);
                pivot.pivotGridModule.notify(uiUpdate, pivot);
                hideSpinner(pivot.fieldListSpinnerElement);
            }
            if (this.isPopupView && pivot.pivotGridModule &&
                pivot.pivotGridModule.allowDeferLayoutUpdate && !pivot.isRequiredUpdate) {
                hideSpinner(pivot.fieldListSpinnerElement);
                pivot.pivotGridModule.hideWaitingPopup();
            }
            pivot.isRequiredUpdate = true;
            if (!pivot.pivotGridModule || isOlapDataRefreshed) {
                hideSpinner(pivot.fieldListSpinnerElement);
            }
            else {
                pivot.pivotGridModule.fieldListSpinnerElement = pivot.fieldListSpinnerElement;
            }
        });
        const actionName = this.getActionCompleteName();
        this.actionObj.actionName = actionName;
        if (this.actionObj.actionName) {
            this.actionCompleteMethod();
        }
    }
    updateOlapDataSource(pivot, isSorted, isCalcChange, isOlapDataRefreshed) {
        const customProperties = pivot.frameCustomProperties(pivot.olapEngineModule.fieldListData, pivot.olapEngineModule.fieldList);
        customProperties.savedFieldList = pivot.pivotFieldList;
        if (isCalcChange || isSorted) {
            pivot.olapEngineModule.savedFieldList = pivot.pivotFieldList;
            pivot.olapEngineModule.savedFieldListData = pivot.olapEngineModule.fieldListData;
            if (isCalcChange) {
                pivot.olapEngineModule.updateCalcFields(pivot.dataSourceSettings, pivot.lastCalcFieldInfo);
                pivot.lastCalcFieldInfo = {};
                isOlapDataRefreshed = pivot.olapEngineModule.dataFields[pivot.lastCalcFieldInfo.name] ? false : true;
                if (pivot.pivotGridModule) {
                    pivot.pivotGridModule.hideWaitingPopup();
                }
            }
            else {
                pivot.olapEngineModule.onSort(pivot.dataSourceSettings);
            }
        }
        else {
            pivot.olapEngineModule.renderEngine(pivot.dataSourceSettings, customProperties, pivot.onHeadersSort
                ? pivot.getHeaderSortInfo.bind(pivot) : undefined);
        }
        pivot.lastSortInfo = {};
        pivot.lastAggregationInfo = {};
        pivot.lastCalcFieldInfo = {};
        pivot.lastFilterInfo = {};
        return isOlapDataRefreshed;
    }
    /**
     * Updates the Pivot Field List component using dataSource from PivotView component.
     *
     * @function update
     * @param {PivotView} control - Pass the instance of pivot table component.
     * @returns {void}
     */
    update(control) {
        if (control) {
            this.clonedDataSet = control.clonedDataSet;
            this.clonedReport = control.clonedReport;
            this.setProperties({ dataSourceSettings: control.dataSourceSettings, showValuesButton: control.showValuesButton }, true);
            this.engineModule = control.engineModule;
            this.olapEngineModule = control.olapEngineModule;
            this.dataType = control.dataType;
            this.pivotFieldList = this.dataType === 'olap' ? control.olapEngineModule.fieldList : control.engineModule.fieldList;
            if (this.isPopupView) {
                this.pivotGridModule = control;
            }
            else {
                this.staticPivotGridModule = control;
            }
            this.getFieldCaption(control.dataSourceSettings);
            this.pivotCommon.engineModule = this.dataType === 'olap' ? this.olapEngineModule : this.engineModule;
            this.pivotCommon.dataSourceSettings = this.dataSourceSettings;
            this.pivotCommon.control = this;
            if (this.treeViewModule.fieldTable && !this.isAdaptive) {
                this.notify(treeViewUpdate, {});
            }
            this.axisFieldModule.render();
            if (!this.isPopupView && this.allowDeferLayoutUpdate) {
                this.clonedDataSource = extend({}, this.dataSourceSettings, null, true);
                if (this.dataType === 'olap') {
                    this.clonedFieldListData = PivotUtil.cloneOlapFieldSettings(this.olapEngineModule.fieldListData);
                }
                this.clonedFieldList = PivotUtil.getClonedFieldList(this.pivotFieldList);
            }
        }
    }
    /**
     * Updates the PivotView component using dataSource from Pivot Field List component.
     *
     * @function updateView
     * @param {PivotView} control - Pass the instance of pivot table component.
     * @returns {void}
     */
    updateView(control) {
        if (control) {
            if (control.element.querySelector('.e-spin-hide') &&
                (!(this.allowDeferLayoutUpdate && !this.isDeferUpdateApplied) || control.isInitial)) {
                control.showWaitingPopup();
            }
            control.clonedDataSet = this.clonedDataSet;
            control.clonedReport = this.clonedReport;
            control.setProperties({ dataSourceSettings: this.dataSourceSettings, showValuesButton: this.showValuesButton }, true);
            control.engineModule = this.engineModule;
            control.olapEngineModule = this.olapEngineModule;
            control.dataType = this.dataType;
            if (!this.pivotChange) {
                control.pivotValues = this.dataType === 'olap' ? this.olapEngineModule.pivotValues : this.engineModule.pivotValues;
            }
            const eventArgs = {
                dataSourceSettings: PivotUtil.getClonedDataSourceSettings(control.dataSourceSettings),
                pivotValues: control.pivotValues
            };
            control.trigger(fieldListRefreshed, eventArgs);
            if (!this.isPopupView) {
                this.staticPivotGridModule = control;
                control.isStaticRefresh = true;
            }
            this.isDeferUpdateApplied = false;
            if (this.staticPivotGridModule) {
                this.staticPivotGridModule.isServerWaitingPopup = true;
            }
            control.dataBind();
        }
    }
    /**
     * Called internally to trigger populate event.
     *
     * @hidden
     */
    triggerPopulateEvent() {
        const control = this.isPopupView ? this.pivotGridModule : this;
        const eventArgs = {
            dataSourceSettings: this.dataSourceSettings,
            pivotFieldList: this.dataType === 'olap' ? this.olapEngineModule.fieldList : this.engineModule.fieldList,
            pivotValues: this.dataType === 'olap' ? this.olapEngineModule.pivotValues : this.engineModule.pivotValues
        };
        control.trigger(enginePopulated, eventArgs, (observedArgs) => {
            this.dataSourceSettings = observedArgs.dataSourceSettings;
            this.pivotFieldList = observedArgs.pivotFieldList;
            if (this.dataType === 'olap') {
                this.olapEngineModule.pivotValues = observedArgs.pivotValues;
            }
            else {
                this.engineModule.pivotValues = observedArgs.pivotValues;
            }
        });
    }
    /** @hidden */
    actionBeginMethod() {
        const eventArgs = {
            dataSourceSettings: PivotUtil.getClonedDataSourceSettings(this.dataSourceSettings),
            actionName: this.actionObj.actionName,
            fieldInfo: this.actionObj.fieldInfo,
            cancel: false
        };
        const control = this.isPopupView ? this.pivotGridModule : this;
        control.trigger(actionBegin, eventArgs);
        return eventArgs.cancel;
    }
    /** @hidden */
    actionCompleteMethod() {
        const eventArgs = {
            dataSourceSettings: PivotUtil.getClonedDataSourceSettings(this.dataSourceSettings),
            actionName: this.actionObj.actionName,
            fieldInfo: this.actionObj.fieldInfo,
            actionInfo: this.actionObj.actionInfo
        };
        const control = this.isPopupView ? this.pivotGridModule : this;
        control.trigger(actionComplete, eventArgs);
        this.actionObj.actionName = '';
        this.actionObj.actionInfo = undefined;
        this.actionObj.fieldInfo = undefined;
    }
    /** @hidden */
    actionFailureMethod(error) {
        const eventArgs = {
            actionName: this.actionObj.actionName,
            errorInfo: error
        };
        const control = this.isPopupView ? this.pivotGridModule : this;
        control.trigger(actionFailure, eventArgs);
    }
    /** @hidden */
    getActionCompleteName() {
        const actionName = (this.actionObj.actionName === openCalculatedField) ? calculatedFieldApplied :
            (this.actionObj.actionName === editCalculatedField) ? calculatedFieldEdited :
                (this.actionObj.actionName === sortField) ? fieldSorted : (this.actionObj.actionName === filterField)
                    ? fieldFiltered : (this.actionObj.actionName === removeField) ? fieldRemoved
                    : (this.actionObj.actionName === aggregateField) ? fieldAggregated :
                        this.actionObj.actionName === sortFieldTree ? fieldTreeSorted : this.actionObj.actionName;
        return actionName;
    }
    /**
     * Destroys the Field Table component.
     *
     * @function destroy
     * @returns {void}
     */
    destroy() {
        this.unWireEvent();
        if (this.engineModule && !this.destroyEngine) {
            this.engineModule.fieldList = {};
            this.engineModule.rMembers = null;
            this.engineModule.cMembers = null;
            this.engineModule.valueMatrix = null;
            this.engineModule.indexMatrix = null;
            this.engineModule = {};
        }
        if (this.olapEngineModule && !this.destroyEngine) {
            this.olapEngineModule.fieldList = {};
            this.olapEngineModule = {};
        }
        if (this.pivotFieldList) {
            this.pivotFieldList = {};
        }
        if (this.captionData) {
            this.captionData = null;
        }
        if (this.contextMenuModule) {
            this.contextMenuModule.destroy();
        }
        if (this.treeViewModule) {
            this.treeViewModule.destroy();
        }
        if (this.pivotButtonModule) {
            this.pivotButtonModule.destroy();
        }
        if (this.pivotCommon) {
            this.pivotCommon.destroy();
        }
        if (this.dialogRenderer) {
            this.dialogRenderer.destroy();
        }
        if (this.calculatedFieldModule) {
            this.calculatedFieldModule.destroy();
        }
        super.destroy();
        if (this.contextMenuModule) {
            this.contextMenuModule = null;
        }
        if (this.treeViewModule) {
            this.treeViewModule = null;
        }
        if (this.pivotButtonModule) {
            this.pivotButtonModule = null;
        }
        if (this.pivotCommon) {
            this.pivotCommon = null;
        }
        if (this.dialogRenderer) {
            this.dialogRenderer = null;
        }
        if (this.calculatedFieldModule) {
            this.calculatedFieldModule = null;
        }
        if (this.axisFieldModule) {
            this.axisFieldModule = null;
        }
        if (this.axisTableModule) {
            this.axisTableModule = null;
        }
        if (this.renderModule) {
            this.renderModule = null;
        }
        if (this.clonedDataSet) {
            this.clonedDataSet = null;
        }
        if (this.clonedReport) {
            this.clonedReport = null;
        }
        if (this.clonedFieldList) {
            this.clonedFieldList = null;
        }
        if (this.clonedFieldListData) {
            this.clonedFieldListData = null;
        }
        if (this.localeObj) {
            this.localeObj = null;
        }
        if (this.defaultLocale) {
            this.defaultLocale = null;
        }
        this.element.innerHTML = '';
        removeClass([this.element], ROOT);
        removeClass([this.element], RTL);
        removeClass([this.element], DEVICE);
    }
};
__decorate$4([
    Complex({}, DataSourceSettings)
], PivotFieldList.prototype, "dataSourceSettings", void 0);
__decorate$4([
    Property('Popup')
], PivotFieldList.prototype, "renderMode", void 0);
__decorate$4([
    Property()
], PivotFieldList.prototype, "target", void 0);
__decorate$4([
    Property('')
], PivotFieldList.prototype, "cssClass", void 0);
__decorate$4([
    Property(false)
], PivotFieldList.prototype, "enableHtmlSanitizer", void 0);
__decorate$4([
    Property(false)
], PivotFieldList.prototype, "allowCalculatedField", void 0);
__decorate$4([
    Property(false)
], PivotFieldList.prototype, "enableFieldSearching", void 0);
__decorate$4([
    Property(false)
], PivotFieldList.prototype, "showValuesButton", void 0);
__decorate$4([
    Property(false)
], PivotFieldList.prototype, "allowDeferLayoutUpdate", void 0);
__decorate$4([
    Property(1000)
], PivotFieldList.prototype, "maxNodeLimitInMemberEditor", void 0);
__decorate$4([
    Property(true)
], PivotFieldList.prototype, "loadOnDemandInMemberEditor", void 0);
__decorate$4([
    Property()
], PivotFieldList.prototype, "spinnerTemplate", void 0);
__decorate$4([
    Property(['Sum', 'Count', 'DistinctCount', 'Product', 'Min', 'Max', 'Avg', 'Median', 'Index', 'PopulationVar', 'SampleVar', 'PopulationStDev', 'SampleStDev', 'RunningTotals', 'PercentageOfGrandTotal', 'PercentageOfColumnTotal', 'PercentageOfRowTotal', 'PercentageOfParentColumnTotal', 'PercentageOfParentRowTotal', 'DifferenceFrom', 'PercentageOfDifferenceFrom', 'PercentageOfParentTotal'])
], PivotFieldList.prototype, "aggregateTypes", void 0);
__decorate$4([
    Property('USD')
], PivotFieldList.prototype, "currencyCode", void 0);
__decorate$4([
    Event()
], PivotFieldList.prototype, "load", void 0);
__decorate$4([
    Event()
], PivotFieldList.prototype, "enginePopulating", void 0);
__decorate$4([
    Event()
], PivotFieldList.prototype, "memberFiltering", void 0);
__decorate$4([
    Event()
], PivotFieldList.prototype, "enginePopulated", void 0);
__decorate$4([
    Event()
], PivotFieldList.prototype, "onFieldDropped", void 0);
__decorate$4([
    Event()
], PivotFieldList.prototype, "fieldDrop", void 0);
__decorate$4([
    Event()
], PivotFieldList.prototype, "fieldDragStart", void 0);
__decorate$4([
    Event()
], PivotFieldList.prototype, "aggregateCellInfo", void 0);
__decorate$4([
    Event()
], PivotFieldList.prototype, "memberEditorOpen", void 0);
__decorate$4([
    Event()
], PivotFieldList.prototype, "calculatedFieldCreate", void 0);
__decorate$4([
    Event()
], PivotFieldList.prototype, "aggregateMenuOpen", void 0);
__decorate$4([
    Event()
], PivotFieldList.prototype, "fieldRemove", void 0);
__decorate$4([
    Event()
], PivotFieldList.prototype, "dataBound", void 0);
__decorate$4([
    Event()
], PivotFieldList.prototype, "created", void 0);
__decorate$4([
    Event()
], PivotFieldList.prototype, "destroyed", void 0);
__decorate$4([
    Event()
], PivotFieldList.prototype, "beforeServiceInvoke", void 0);
__decorate$4([
    Event()
], PivotFieldList.prototype, "actionBegin", void 0);
__decorate$4([
    Event()
], PivotFieldList.prototype, "actionComplete", void 0);
__decorate$4([
    Event()
], PivotFieldList.prototype, "actionFailure", void 0);
__decorate$4([
    Event()
], PivotFieldList.prototype, "onHeadersSort", void 0);
PivotFieldList = __decorate$4([
    NotifyPropertyChanges
], PivotFieldList);

/**
 * Base export
 */
/** @hidden */

/**
 * Models
 */
/** @hidden */

/**
 * PivotGrid component exported items
 */
/** @hidden */

/**
 * Module to render Calculated Field Dialog
 */
const COUNT = 'Count';
const AVG = 'Avg';
const MEDIAN = 'Median';
const MIN = 'Min';
const MAX = 'Max';
const SUM = 'Sum';
const DISTINCTCOUNT = 'DistinctCount';
const PRODUCT = 'Product';
const STDEV = 'SampleStDev';
const STDEVP = 'PopulationStDev';
const VAR = 'SampleVar';
const VARP = 'PopulationVar';
const CALC = 'CalculatedField';
const AGRTYPE = 'AggregateType';
/** @hidden */
class CalculatedField {
    /**
     * Constructor for calculatedfield module.
     *
     * @param {PivotView | PivotFieldList} parent - It represent the parent.
     */
    constructor(parent) {
        /** @hidden */
        this.isFormula = false;
        /** @hidden */
        this.isRequireUpdate = false;
        this.formatTypes = ['Standard', 'Currency', 'Percent', 'Custom', 'None'];
        this.parent = parent;
        this.existingReport = null;
        this.parent.calculatedFieldModule = this;
        this.removeEventListener();
        this.addEventListener();
        this.parentID = this.parent.element.id;
        this.dialog = null;
        this.inputObj = null;
        this.treeObj = null;
        this.droppable = null;
        this.menuObj = null;
        this.newFields = null;
        this.isFieldExist = true;
        this.formulaText = null;
        this.fieldText = null;
        this.formatText = null;
        this.formatType = null;
        this.fieldType = null;
        this.parentHierarchy = null;
        this.isEdit = false;
        this.currentFieldName = null;
        this.confirmPopUp = null;
    }
    /**
     * To get module name.
     *
     * @returns {string} - It returns the Module name.
     */
    getModuleName() {
        return 'calculatedField';
    }
    keyActionHandler(e) {
        const node = e.currentTarget.querySelector('.e-node-focus');
        if (node) {
            switch (e.action) {
                case 'moveRight':
                case 'shiftE':
                    if (this.parent.dataType === 'pivot') {
                        this.displayMenu(node);
                    }
                    break;
                case 'delete':
                    if (node.tagName === 'LI' && !node.querySelector('.e-list-icon.e-format') && !node.querySelector('.e-list-icon').classList.contains('.e-icons') && (node.querySelector('.' + GRID_REMOVE) &&
                        node.querySelector('.' + GRID_REMOVE).classList.contains('e-list-icon'))) {
                        this.createConfirmDialog(this.parent.localeObj.getConstant('alert'), this.parent.localeObj.getConstant('removeCalculatedField'), {}, true, node);
                    }
                    break;
                case 'enter':
                    {
                        let field = node.getAttribute('data-field');
                        const type = node.getAttribute('data-type');
                        const dropField = select('#' + this.parentID + 'droppable', this.dialog.element);
                        if (this.parent.dataType === 'pivot') {
                            if (dropField.value === '') {
                                if (type === CALC) {
                                    dropField.value = node.getAttribute('data-uid');
                                }
                                else {
                                    dropField.value = '"' + type + '(' + field + ')' + '"';
                                }
                            }
                            else if (dropField.value !== '') {
                                if (type === CALC) {
                                    dropField.value = dropField.value + node.getAttribute('data-uid');
                                }
                                else {
                                    dropField.value = dropField.value + '"' + type + '(' + field + ')' + '"';
                                }
                            }
                        }
                        else {
                            if (this.parent.olapEngineModule && this.parent.olapEngineModule.fieldList[field] &&
                                this.parent.olapEngineModule.fieldList[field].isCalculatedField) {
                                field = this.parent.olapEngineModule.fieldList[field].tag;
                            }
                            if (dropField.value === '') {
                                dropField.value = field;
                            }
                            else if (dropField.value !== '') {
                                dropField.value = dropField.value + field;
                            }
                        }
                    }
                    break;
            }
        }
    }
    /**
     * Trigger while click treeview icon.
     *
     * @param  {NodeClickEventArgs} e - Click event argument.
     * @returns {void}
     */
    fieldClickHandler(e) {
        const node = closest(e.event.target, 'li');
        if (e.event.target.classList.contains(FORMAT) ||
            e.event.target.classList.contains(CALC_EDIT) ||
            e.event.target.classList.contains(CALC_EDITED) ||
            e.event.target.classList.contains(GRID_REMOVE)) {
            if (!this.parent.isAdaptive) {
                this.displayMenu(node, e.node, e.event.target);
            }
            else if (this.parent.dataType === 'olap' && this.parent.isAdaptive) {
                if (node.tagName === 'LI' && node.querySelector('.e-list-edit-icon').classList.contains(CALC_EDIT) && e.event.target.classList.contains(CALC_EDIT)) {
                    this.isEdit = true;
                    this.currentFieldName = node.getAttribute('data-field');
                    this.fieldText = node.getAttribute('data-caption');
                    this.formulaText = node.getAttribute('data-formula');
                    this.formatType = node.getAttribute('data-formatString');
                    this.formatText = this.formatType === 'Custom' ? node.getAttribute('data-customformatstring') : null;
                    this.fieldType = node.getAttribute('data-membertype');
                    this.parentHierarchy = this.fieldType === 'Dimension' ? node.getAttribute('data-hierarchy') : null;
                    addClass([node.querySelector('.e-list-edit-icon')], CALC_EDITED);
                    removeClass([node.querySelector('.e-list-edit-icon')], CALC_EDIT);
                    this.renderMobileLayout(this.parent.dialogRenderer.adaptiveElement);
                }
                else if (node.tagName === 'LI' && node.querySelector('.e-list-edit-icon').classList.contains(CALC_EDITED) && e.event.target.classList.contains(CALC_EDITED)) {
                    this.isEdit = false;
                    this.fieldText = this.formatText = this.formulaText = this.currentFieldName = null;
                    this.parentHierarchy = this.fieldType = this.formatType = null;
                    addClass([node.querySelector('.e-list-edit-icon')], CALC_EDIT);
                    removeClass([node.querySelector('.e-list-edit-icon')], CALC_EDITED);
                }
                else if (node.tagName === 'LI' && node.querySelector('.' + GRID_REMOVE).classList.contains('e-icons') && e.event.target.classList.contains(GRID_REMOVE)) {
                    this.createConfirmDialog(this.parent.localeObj.getConstant('alert'), this.parent.localeObj.getConstant('removeCalculatedField'), {}, true, e.node);
                }
            }
        }
    }
    /**
     * Trigger while click treeview icon.
     *
     * @param  {AccordionClickArgs} e - Click event argument.
     * @returns {void}
     */
    accordionClickHandler(e) {
        if (e.item && e.item.iconCss.indexOf('e-list-icon') !== -1 &&
            closest(e.originalEvent.target, '.e-acrdn-header-icon')) {
            const node = closest(e.originalEvent.target, '.e-acrdn-header').querySelector('.' + CALCCHECK);
            const fieldName = node.getAttribute('data-field');
            const captionName = node.getAttribute('data-caption');
            const formatObj = PivotUtil.getFieldByName(fieldName, this.parent.dataSourceSettings.formatSettings);
            const optionElement = closest(e.originalEvent.target, '.e-acrdn-header-icon');
            if (formatObj) {
                const pivotFormat = this.getFormat(formatObj.format);
                const formatString = (pivotFormat ? this.formatTypes.indexOf(pivotFormat) > -1 ?
                    formatObj.format : 'Custom' : 'None');
                this.formatType = formatString;
            }
            if (optionElement.querySelector('.' + CALC_EDIT) && e.originalEvent.target.classList.contains(CALC_EDIT)) {
                this.isEdit = true;
                this.currentFieldName = fieldName;
                this.fieldText = captionName ? captionName : fieldName;
                this.formulaText = this.parent.engineModule.fieldList[fieldName].formula;
                this.formatText = formatObj ? formatObj.format : '';
                addClass([optionElement.querySelector('.e-list-icon')], CALC_EDITED);
                removeClass([optionElement.querySelector('.e-list-icon')], CALC_EDIT);
                this.renderMobileLayout(this.parent.dialogRenderer.adaptiveElement);
            }
            else if (optionElement.querySelector('.' + CALC_EDITED) &&
                e.originalEvent.target.classList.contains(CALC_EDITED)) {
                this.isEdit = false;
                this.fieldText = this.formatText = this.formulaText = this.currentFieldName = null;
                addClass([optionElement.querySelector('.e-list-icon')], CALC_EDIT);
                removeClass([optionElement.querySelector('.e-list-icon')], CALC_EDITED);
            }
            else if (optionElement.querySelector('.' + GRID_REMOVE) &&
                e.originalEvent.target.classList.contains(GRID_REMOVE)) {
                this.createConfirmDialog(this.parent.localeObj.getConstant('alert'), this.parent.localeObj.getConstant('removeCalculatedField'), {}, true, node);
            }
        }
    }
    accordionCreated() {
        const allElement = this.accordion.element.querySelectorAll('.e-acrdn-item');
        for (let i = 0; i < allElement.length; i++) {
            if (allElement[i].querySelector('.' + CALC_EDIT) || allElement[i].querySelector('.' + CALC_EDITED)) {
                const element = createElement('span', {
                    className: 'e-list-icon ' + GRID_REMOVE + ' e-icons'
                });
                append([element], allElement[i].querySelector('.e-acrdn-header-icon'));
                addClass([allElement[i]], SELECT_CLASS);
            }
        }
    }
    clearFormula() {
        if (this.treeObj && this.treeObj.element.querySelector('li')) {
            removeClass(this.treeObj.element.querySelectorAll('li'), 'e-active');
            this.displayMenu(this.treeObj.element.querySelector('li'));
        }
    }
    /**
     * To display context menu.
     *
     * @param  {HTMLElement} node - It contains the value of node.
     * @param  {HTMLElement} treeNode - It contains the value of tree Node.
     * @param  {HTMLElement} target - It represent the target.
     * @returns {void}
     */
    displayMenu(node, treeNode, target) {
        const edit = target ? target.classList.contains(CALC_EDIT) : true;
        const edited = target ? target.classList.contains(CALC_EDITED) : true;
        try {
            if (this.parent.dataType === 'pivot' && node.querySelector('.e-list-icon.e-format') &&
                node.querySelector('.e-list-icon.e-format').classList.contains(ICON) &&
                !node.querySelector('.e-list-icon').classList.contains(CALC_EDITED) &&
                !node.querySelector('.e-list-icon').classList.contains(GRID_REMOVE) &&
                !node.querySelector('.e-list-icon').classList.contains(CALC_EDIT) && node.tagName === 'LI') {
                if (this.menuObj && !this.menuObj.isDestroyed) {
                    this.menuObj.destroy();
                }
                this.curMenu = node.querySelector('.' + LIST_TEXT_CLASS);
                this.openContextMenu(node);
            }
            else if (node.tagName === 'LI' && (node.querySelector('.' + CALC_EDIT) &&
                node.querySelector('.' + CALC_EDIT).classList.contains('e-list-icon') && edit ||
                (this.parent.dataType === 'olap' && node.getAttribute('data-type') === CALC && node.classList.contains('e-active') && ((target && !target.classList.contains(GRID_REMOVE)) || !target)))) {
                this.isEdit = true;
                const fieldName = node.getAttribute('data-field');
                const caption = node.getAttribute('data-caption');
                this.currentFieldName = fieldName;
                this.inputObj.value = caption;
                this.inputObj.dataBind();
                const formatString = node.getAttribute('data-formatString');
                const dialogElement = this.dialog.element;
                const ddlFormatTypes = getInstance(select('#' + this.parentID + 'Format_Div', dialogElement), DropDownList);
                const customFormat = getInstance(select('#' + this.parentID + 'Custom_Format_Element', dialogElement), MaskedTextBox);
                const customFormatString = node.getAttribute('data-customformatstring');
                if (this.parent.dataType === 'olap') {
                    const memberType = node.getAttribute('data-membertype');
                    const parentHierarchy = node.getAttribute('data-hierarchy');
                    const expression = node.getAttribute('data-formula');
                    const fieldTitle = select('#' + this.parentID + '_' + 'FieldNameTitle', dialogElement);
                    const memberTypeDrop = getInstance(select('#' + this.parentID + 'Member_Type_Div', dialogElement), DropDownList);
                    const hierarchyDrop = getInstance(select('#' + this.parentID + 'Hierarchy_List_Div', dialogElement), DropDownList);
                    fieldTitle.innerText = this.parent.localeObj.getConstant('caption');
                    select('#' + this.parentID + 'droppable', document).value = expression;
                    memberTypeDrop.readonly = true;
                    memberTypeDrop.value = memberType;
                    memberTypeDrop.dataBind();
                    if (memberType === 'Dimension') {
                        hierarchyDrop.value = parentHierarchy;
                    }
                }
                else {
                    addClass(this.treeObj.element.querySelectorAll('.' + CALC_EDITED), CALC_EDIT);
                    removeClass(this.treeObj.element.querySelectorAll('.' + CALC_EDITED), CALC_EDITED);
                    addClass([node.querySelector('.e-list-icon')], CALC_EDITED);
                    removeClass([node.querySelector('.e-list-icon')], CALC_EDIT);
                    node.querySelector('.' + CALC_EDITED).setAttribute('title', this.parent.localeObj.getConstant('clearCalculatedField'));
                    select('#' + this.parentID + 'droppable', document).value = node.getAttribute('data-uid');
                }
                if (formatString !== '') {
                    ddlFormatTypes.value = formatString;
                    ddlFormatTypes.dataBind();
                }
                customFormat.value = customFormatString;
                customFormat.dataBind();
            }
            else if (node.tagName === 'LI' && (node.querySelector('.' + CALC_EDITED) &&
                node.querySelector('.' + CALC_EDITED).classList.contains('e-list-icon') && edited ||
                (this.parent.dataType === 'olap' && !node.classList.contains('e-active')))) {
                this.isEdit = false;
                this.inputObj.value = '';
                this.inputObj.dataBind();
                const dialogElement = this.dialog.element;
                const customFormat = getInstance(select('#' + this.parentID + 'Custom_Format_Element', dialogElement), MaskedTextBox);
                customFormat.value = '';
                customFormat.dataBind();
                if (this.parent.dataType === 'olap') {
                    const hierarchyDrop = getInstance(select('#' + this.parentID + 'Hierarchy_List_Div', dialogElement), DropDownList);
                    const ddlFormatTypes = getInstance(select('#' + this.parentID + 'Format_Div', dialogElement), DropDownList);
                    const memberTypeDrop = getInstance(select('#' + this.parentID + 'Member_Type_Div', dialogElement), DropDownList);
                    const fieldTitle = select('#' + this.parentID + '_' + 'FieldNameTitle', dialogElement);
                    fieldTitle.innerText = this.parent.localeObj.getConstant('fieldTitle');
                    hierarchyDrop.index = 0;
                    hierarchyDrop.dataBind();
                    ddlFormatTypes.index = 0;
                    ddlFormatTypes.dataBind();
                    memberTypeDrop.index = 0;
                    memberTypeDrop.readonly = false;
                    memberTypeDrop.dataBind();
                }
                else {
                    addClass(this.treeObj.element.querySelectorAll('.' + CALC_EDITED), CALC_EDIT);
                    removeClass(this.treeObj.element.querySelectorAll('.' + CALC_EDITED), CALC_EDITED);
                    node.querySelector('.' + CALC_EDIT).setAttribute('title', this.parent.localeObj.getConstant('edit'));
                }
                select('#' + this.parentID + 'droppable', document).value = '';
            }
            else if (node.tagName === 'LI' && (node.querySelector('.' + GRID_REMOVE) &&
                node.querySelector('.' + GRID_REMOVE).classList.contains('e-list-icon')) && !edit && !edited) {
                this.parent.actionObj.actionName = removeField;
                if (this.parent.actionBeginMethod()) {
                    return;
                }
                const dropField = select('#' + this.parentID + 'droppable', document);
                const field = {
                    name: this.isEdit ? this.currentFieldName : this.inputObj.value,
                    caption: this.inputObj.value,
                    formula: dropField.value
                };
                this.createConfirmDialog(this.parent.localeObj.getConstant('alert'), this.parent.localeObj.getConstant('removeCalculatedField'), field, true, treeNode);
            }
        }
        catch (execption) {
            this.parent.actionFailureMethod(execption);
        }
    }
    removeCalcField(node) {
        const dataSourceSettings = this.parent.dataSourceSettings;
        const fieldName = node.getAttribute('data-field');
        const calcfields = dataSourceSettings.calculatedFieldSettings;
        let engineModule;
        if (this.parent.dataType === 'pivot') {
            if (!this.parent.isAdaptive) {
                this.treeObj.removeNodes([node]);
            }
            else {
                const index = parseInt(node.getAttribute('id').split(this.parentID + '_')[1], 10);
                if (typeof index === 'number') {
                    this.accordion.hideItem(index);
                }
            }
        }
        for (let i = 0; i < calcfields.length; i++) {
            if (calcfields[i] && calcfields[i].name === fieldName) {
                calcfields.splice(i, 1);
                break;
            }
        }
        if (this.parent.dataType === 'olap') {
            engineModule = this.parent.olapEngineModule;
            const fields = engineModule.fieldListData ? engineModule.fieldListData : [];
            for (const item of Object.keys(fields)) { // eslint-disable-next-line @typescript-eslint/no-explicit-any
                if (fields[item].name === fieldName) {
                    const index = parseInt(item, 10);
                    if (typeof (index) === 'number') {
                        fields.splice(index, 1);
                        break;
                    }
                }
            }
            const parentID = this.treeObj.getNode(node).parentID;
            this.treeObj.removeNodes([node]);
            if (calcfields.length <= 0) {
                this.treeObj.removeNodes([parentID]);
            }
        }
        else {
            engineModule = this.parent.engineModule;
        }
        if (engineModule.fields) {
            for (let i = 0; i < engineModule.fields.length; i++) {
                if (engineModule.fields[i] === fieldName) {
                    engineModule.fields.splice(i, 1);
                    break;
                }
            }
        }
        if (engineModule.savedFieldList && engineModule.savedFieldList[fieldName]) {
            delete engineModule.savedFieldList[fieldName];
        }
        if (engineModule.fieldList && engineModule.fieldList[fieldName]) {
            delete engineModule.fieldList[fieldName];
        }
        const formatFields = dataSourceSettings.formatSettings;
        for (let i = 0; i < formatFields.length; i++) {
            if (formatFields[i] && formatFields[i].name === fieldName) {
                formatFields.splice(i, 1);
                break;
            }
        }
        const fields = [dataSourceSettings.values, dataSourceSettings.rows, dataSourceSettings.columns, dataSourceSettings.filters];
        for (let i = 0, n = fields.length; i < n; i++) {
            for (let j = 0, length = fields[i].length; j < length; j++) {
                if (fields[i][j].name === fieldName) {
                    fields[i].splice(j, 1);
                    break;
                }
            }
        }
        if (this.isEdit && this.currentFieldName === fieldName) {
            this.isEdit = false;
            this.inputObj.value = '';
            this.currentFieldName = this.formatText = this.fieldText = this.formatType = null;
            this.formulaText = this.fieldType = this.parentHierarchy = null;
        }
        if (!this.parent.allowDeferLayoutUpdate || this.parent.getModuleName() !== 'pivotfieldlist') {
            this.parent.updateDataSource();
        }
        this.closeErrorDialog();
    }
    /**
     * To set position for context menu.
     *
     * @param {HTMLElement} node - It contains the value of node.
     * @returns {void}
     */
    openContextMenu(node) {
        const fieldName = node.getAttribute('data-field');
        const type = this.parent.engineModule.fieldList[fieldName].type !== 'number' ? 'string' : 'number';
        const validSummaryTypes = (type === 'string' ? this.getValidSummaryType().slice(0, 2) : this.getValidSummaryType());
        const eventArgs = {
            cancel: false, fieldName: fieldName,
            aggregateTypes: [...this.getMenuItems(type)]
        };
        const control = this.parent.getModuleName() === 'pivotfieldlist' && this.parent.isPopupView ?
            this.parent.pivotGridModule : this.parent;
        control.trigger(aggregateMenuOpen, eventArgs, (observedArgs) => {
            if (!observedArgs.cancel) {
                const duplicateTypes = [];
                const items = [];
                for (const option of observedArgs.aggregateTypes) {
                    if (validSummaryTypes.indexOf(option) > -1 && duplicateTypes.indexOf(option) === -1) {
                        duplicateTypes.push(option);
                        items.push({
                            id: this.parent.element.id + 'Calc_' + option,
                            text: this.parent.localeObj.getConstant(option)
                        });
                    }
                }
                this.createMenu(items, node);
                const pos = node.getBoundingClientRect();
                const offset = window.scrollY || document.documentElement.scrollTop;
                if (this.parent.enableRtl) {
                    this.menuObj.open(pos.top + offset, pos.left - 100);
                }
                else {
                    this.menuObj.open(pos.top + offset, pos.left + 150);
                } /* eslint-enable security/detect-non-literal-fs-filename */
            }
        });
    }
    /**
     * Triggers while select menu.
     *
     * @param  {MenuEventArgs} menu - It represent the menu.
     * @returns {void}
     */
    selectContextMenu(menu) {
        if (menu.element.textContent !== null) {
            const field = closest(this.curMenu, '.e-list-item').getAttribute('data-caption');
            closest(this.curMenu, '.e-list-item').setAttribute('data-type', menu.element.id.split('_').pop());
            this.curMenu.textContent = field + ' (' + menu.element.textContent + ')';
            addClass([this.curMenu.parentElement.parentElement], ['e-node-focus', 'e-hover']);
            this.curMenu.parentElement.parentElement.setAttribute('tabindex', '0');
            this.curMenu.parentElement.parentElement.focus();
        }
    }
    /**
     * To create context menu.
     *
     * @param {MenuItemModel[]} menuItems - It represent the menuItems.
     * @param {HTMLElement} node - It represent the node data.
     * @returns {void}
     */
    createMenu(menuItems, node) {
        const menuOptions = {
            cssClass: this.parentID + 'calculatedmenu' + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
            items: menuItems,
            enableRtl: this.parent.enableRtl,
            locale: this.parent.locale,
            // beforeOpen: this.beforeMenuOpen.bind(this),
            select: this.selectContextMenu.bind(this),
            onClose: () => {
                this.treeObj.element.focus();
                addClass([node], ['e-hover', 'e-node-focus']);
            }
        };
        let contextMenu;
        if (select('#' + this.parentID + 'CalcContextmenu', document)) {
            contextMenu = select('#' + this.parentID + 'CalcContextmenu', document);
        }
        else {
            contextMenu = createElement('ul', {
                id: this.parentID + 'CalcContextmenu'
            });
        }
        this.dialog.element.appendChild(contextMenu);
        this.menuObj = new ContextMenu$1(menuOptions);
        this.menuObj.isStringTemplate = true;
        this.menuObj.appendTo(contextMenu);
    }
    /**
     * Triggers while click OK button.
     *
     * @returns {void}
     */
    applyFormula() {
        const currentObj = this;
        let isExist = false;
        removeClass([document.getElementById(this.parentID + 'ddlelement')], EMPTY_FIELD);
        this.newFields =
            extend([], this.parent.dataSourceSettings.calculatedFieldSettings, null, true);
        const eventArgs = {
            fieldName: this.isEdit ? this.currentFieldName : this.inputObj.value,
            calculatedField: this.getCalculatedFieldInfo(),
            calculatedFieldSettings: PivotUtil.cloneCalculatedFieldSettings(this.parent.dataSourceSettings.calculatedFieldSettings),
            cancel: false
        };
        const control = this.parent.getModuleName() === 'pivotfieldlist' &&
            this.parent.isPopupView ? this.parent.pivotGridModule : this.parent;
        control.trigger(calculatedFieldCreate, eventArgs, (observedArgs) => {
            if (!observedArgs.cancel) {
                const calcInfo = observedArgs.calculatedField;
                if (!this.isEdit) {
                    if (currentObj.parent.dataType === 'olap') {
                        const field = calcInfo.name;
                        if (currentObj.parent.olapEngineModule.fieldList[field] &&
                            currentObj.parent.olapEngineModule.fieldList[field].type !== 'CalculatedField') {
                            isExist = true;
                        }
                    }
                    else {
                        for (const key of Object.keys(currentObj.parent.engineModule.fieldList)) {
                            if (calcInfo.name && calcInfo.name === key &&
                                currentObj.parent.engineModule.fieldList[key].aggregateType !== 'CalculatedField') {
                                isExist = true;
                            }
                        }
                    }
                }
                if (isExist) {
                    currentObj.parent.pivotCommon.errorDialog.createErrorDialog(currentObj.parent.localeObj.getConstant('error'), currentObj.parent.localeObj.getConstant('fieldExist'));
                    return;
                }
                this.existingReport = extend({}, this.parent.dataSourceSettings, null, true);
                const report = this.parent.dataSourceSettings;
                if (!isNullOrUndefined(calcInfo.name) && calcInfo.name !== '' &&
                    !isNullOrUndefined(calcInfo.caption) && calcInfo.caption !== '' && calcInfo.formula && calcInfo.formula !== '') {
                    let field;
                    if (this.parent.dataType === 'olap') {
                        field = {
                            name: calcInfo.name,
                            formula: calcInfo.formula,
                            formatString: calcInfo.formatString
                        };
                        if (!isNullOrUndefined(calcInfo.hierarchyUniqueName)) {
                            field.hierarchyUniqueName = calcInfo.hierarchyUniqueName;
                        }
                        this.isFieldExist = false;
                        if (!this.isEdit) {
                            for (let i = 0; i < report.calculatedFieldSettings.length; i++) {
                                if (report.calculatedFieldSettings[i].name === field.name) {
                                    this.createConfirmDialog(currentObj.parent.localeObj.getConstant('alert'), currentObj.parent.localeObj.getConstant('confirmText'), calcInfo);
                                    return;
                                }
                            }
                        }
                        else {
                            for (let i = 0; i < report.calculatedFieldSettings.length; i++) {
                                if (report.calculatedFieldSettings[i].name === field.name && this.isEdit) {
                                    report.calculatedFieldSettings[i].hierarchyUniqueName = calcInfo.hierarchyUniqueName;
                                    this.parent.olapEngineModule.fieldList[field.name].caption = calcInfo.caption;
                                    report.calculatedFieldSettings[i].formatString = field.formatString;
                                    report.calculatedFieldSettings[i].formula = field.formula;
                                    field = report.calculatedFieldSettings[i];
                                    this.isFieldExist = true;
                                    break;
                                }
                            }
                            const axisFields = [report.rows, report.columns, report.values, report.filters];
                            let isFieldExist = false;
                            for (const fields of axisFields) {
                                for (const item of fields) {
                                    if (item.isCalculatedField && field.name !== null &&
                                        item.name === field.name && this.isEdit) {
                                        item.caption = calcInfo.caption;
                                        this.isFieldExist = true;
                                        isFieldExist = true;
                                        break;
                                    }
                                }
                                if (isFieldExist) {
                                    break;
                                }
                            }
                        }
                        if (!this.isFieldExist) {
                            report.calculatedFieldSettings.push(field);
                        }
                        this.parent.lastCalcFieldInfo = field;
                    }
                    else {
                        field = {
                            name: calcInfo.name,
                            caption: calcInfo.caption,
                            type: 'CalculatedField'
                        };
                        const cField = {
                            name: calcInfo.name,
                            formula: calcInfo.formula
                        };
                        if (!isNullOrUndefined(calcInfo.formatString)) {
                            cField.formatString = calcInfo.formatString;
                        }
                        this.isFieldExist = true;
                        if (!this.isEdit) {
                            for (let i = 0; i < report.values.length; i++) {
                                if (report.values[i].type === CALC && report.values[i].name === field.name) {
                                    for (let j = 0; j < report.calculatedFieldSettings.length; j++) {
                                        if (report.calculatedFieldSettings[j].name === field.name) {
                                            this.createConfirmDialog(currentObj.parent.localeObj.getConstant('alert'), currentObj.parent.localeObj.getConstant('confirmText'), calcInfo);
                                            return;
                                        }
                                    }
                                    this.isFieldExist = false;
                                }
                            }
                        }
                        else {
                            for (let i = 0; i < report.values.length; i++) {
                                if (report.values[i].type === CALC && field.name !== null &&
                                    report.values[i].name === field.name && this.isEdit) {
                                    for (let j = 0; j < report.calculatedFieldSettings.length; j++) {
                                        if (report.calculatedFieldSettings[j].name === field.name) {
                                            report.values[i].caption = calcInfo.caption;
                                            this.currentFormula = report.calculatedFieldSettings[j].formula;
                                            report.calculatedFieldSettings[j].formula = calcInfo.formula;
                                            this.parent.engineModule.fieldList[field.name].caption = calcInfo.caption;
                                            this.updateFormatSettings(report, field.name, calcInfo.formatString);
                                            this.isFieldExist = false;
                                        }
                                    }
                                }
                            }
                        }
                        if (this.isFieldExist) {
                            report.values.push(field);
                            report.calculatedFieldSettings.push(cField);
                            this.updateFormatSettings(report, field.name, calcInfo.formatString);
                        }
                        this.parent.lastCalcFieldInfo = cField;
                    }
                    this.addFormula(report, field.name);
                }
                else {
                    if (isNullOrUndefined(calcInfo.name) || calcInfo.name === '' ||
                        isNullOrUndefined(calcInfo.caption) || calcInfo.caption === '') {
                        this.inputObj.value = '';
                        addClass([document.getElementById(this.parentID + 'ddlelement')], EMPTY_FIELD);
                        document.getElementById(this.parentID + 'ddlelement').focus();
                    }
                    else {
                        this.parent.pivotCommon.errorDialog.createErrorDialog(this.parent.localeObj.getConstant('error'), this.parent.localeObj.getConstant('invalidFormula'));
                    }
                }
            }
            else {
                this.endDialog();
                this.parent.lastCalcFieldInfo = {};
                this.isFormula = false;
            }
        });
    }
    getCalculatedFieldInfo() {
        const dropField = select('#' + this.parentID + 'droppable', document);
        const dialogElement = this.parent.isAdaptive ?
            this.parent.dialogRenderer.adaptiveElement.element : this.dialog.element;
        const customFormat = getInstance(select('#' + this.parentID + 'Custom_Format_Element', dialogElement), MaskedTextBox);
        const field = {
            name: this.isEdit ? this.currentFieldName : this.inputObj.value,
            caption: this.inputObj.value,
            formula: dropField.value
        };
        const ddlFormatTypes = getInstance(select('#' + this.parentID + 'Format_Div', dialogElement), DropDownList);
        field.formatString = (ddlFormatTypes.value === 'Custom' ? customFormat.value : (ddlFormatTypes.value === 'None' ? null : ddlFormatTypes.value));
        if (this.parent.dataType === 'olap') {
            const memberTypeDrop = getInstance(select('#' + this.parentID + 'Member_Type_Div', dialogElement), DropDownList);
            const hierarchyDrop = getInstance(select('#' + this.parentID + 'Hierarchy_List_Div', dialogElement), DropDownList);
            if (memberTypeDrop.value === 'Dimension') {
                field.hierarchyUniqueName = hierarchyDrop.value;
            }
        }
        return field;
    }
    updateFormatSettings(report, fieldName, formatString) {
        const newFormat = { name: fieldName, format: formatString, useGrouping: true };
        let isFormatExist = false;
        for (let i = 0; i < report.formatSettings.length; i++) {
            if (report.formatSettings[i].name === fieldName) {
                if (formatString === 'undefined' || formatString === undefined || formatString === '') {
                    report.formatSettings.splice(i, 1);
                    isFormatExist = true;
                    break;
                }
                else {
                    const formatObj = report.formatSettings[i].properties ?
                        report.formatSettings[i].properties : report.formatSettings[i];
                    formatObj.format = formatString;
                    report.formatSettings.splice(i, 1, formatObj);
                    isFormatExist = true;
                    break;
                }
            }
        }
        if (!isFormatExist && formatString !== '' && !isNullOrUndefined(formatString)) {
            report.formatSettings.push(newFormat);
        }
    }
    addFormula(report, field) {
        this.isFormula = true;
        this.field = field;
        if (this.parent.dataSourceSettings.mode === 'Server') {
            PivotUtil.updateDataSourceSettings(this.parent, PivotUtil.getClonedDataSourceSettings(report));
        }
        else {
            this.parent.setProperties({ dataSourceSettings: report }, true);
        }
        if (this.parent.getModuleName() === 'pivotfieldlist' && this.parent.allowDeferLayoutUpdate) {
            this.parent.isRequiredUpdate = false;
        }
        try {
            const actionInfo = {
                calculatedFieldInfo: this.parent.lastCalcFieldInfo
            };
            this.parent.actionObj.actionInfo = actionInfo;
            const actionName = (this.parent.actionObj.actionName === editCalculatedField) ?
                calculatedFieldEdited : calculatedFieldApplied;
            this.parent.actionObj.actionName = actionName;
            this.parent.updateDataSource(false);
            const pivot = (this.parent.getModuleName() === 'pivotfieldlist' && this.parent.pivotGridModule) ?
                this.parent.pivotGridModule : this.parent;
            if (pivot && pivot.dataSourceSettings.mode !== 'Server') {
                this.endDialog();
            }
            else {
                this.isRequireUpdate = true;
            }
            if (this.parent.getModuleName() === 'pivotfieldlist' &&
                this.parent.renderMode === 'Fixed' && this.parent.allowDeferLayoutUpdate) {
                this.parent.pivotChange = true;
            }
        }
        catch (exception) {
            this.showError();
        }
    }
    /**
     *
     * @returns {void}
     * @hidden */
    endDialog() {
        this.isEdit = false;
        if (this.dialog) {
            this.dialog.close();
        }
        else {
            this.inputObj.value = '';
            this.currentFieldName = this.formatText = this.fieldText = this.formatType = null;
            this.formulaText = this.fieldType = this.parentHierarchy = null;
            const dialogElement = this.parent.isAdaptive ?
                this.parent.dialogRenderer.parentElement : this.dialog.element;
            this.parent.dialogRenderer.parentElement.querySelector('.' + CALCINPUT).value = '';
            select('#' + this.parentID + 'droppable', this.parent.dialogRenderer.parentElement).value = '';
            select('#' + this.parentID + 'Custom_Format_Element', this.parent.dialogRenderer.parentElement).value = '';
            if (this.parent.dataType === 'olap') {
                const memberTypeDrop = getInstance(select('#' + this.parentID + 'Member_Type_Div', dialogElement), DropDownList);
                const hierarchyDrop = getInstance(select('#' + this.parentID + 'Hierarchy_List_Div', dialogElement), DropDownList);
                memberTypeDrop.index = 0;
                memberTypeDrop.readonly = false;
                memberTypeDrop.dataBind();
                hierarchyDrop.index = 0;
                hierarchyDrop.enabled = false;
                hierarchyDrop.dataBind();
            }
            const customFormat = getInstance(select('#' + this.parentID + 'Custom_Format_Element', dialogElement), MaskedTextBox);
            const ddlFormatTypes = getInstance(select('#' + this.parentID + 'Format_Div', dialogElement), DropDownList);
            ddlFormatTypes.index = this.parent.dataType === 'olap' ? 0 : 4;
            ddlFormatTypes.dataBind();
            customFormat.enabled = false;
            customFormat.dataBind();
        }
    }
    /**
     *
     * @returns {void}
     * @hidden */
    showError() {
        if (this.parent.engineModule.fieldList[this.field]) {
            delete this.parent.engineModule.fieldList[this.field];
        }
        this.parent.pivotCommon.errorDialog.createErrorDialog(this.parent.localeObj.getConstant('error'), this.parent.localeObj.getConstant('invalidFormula'));
        this.parent.setProperties({ dataSourceSettings: this.existingReport }, true);
        if (this.isEdit) {
            const calcFields = this.parent.dataSourceSettings.calculatedFieldSettings;
            for (let i = 0; calcFields && i < calcFields.length; i++) {
                if (calcFields[i].name === this.field) {
                    calcFields[i].formula = this.currentFormula;
                    break;
                }
            }
        }
        else if (this.parent.engineModule.fields) {
            for (let i = 0; i < this.parent.engineModule.fields.length; i++) {
                if (this.parent.engineModule.fields[i] === this.field) {
                    this.parent.engineModule.fields.splice(i, 1);
                    break;
                }
            }
        }
        this.parent.lastCalcFieldInfo = {};
        this.parent.updateDataSource(false);
        this.isFormula = false;
    }
    /**
     * To get treeview data
     *
     * @param  {PivotView | PivotFieldList} parent - It represent the parent.
     * @returns {any} - Field List Data.
     */
    getFieldListData(parent) {
        let fields = [];
        if (this.parent.dataType === 'olap') {
            fields =
                PivotUtil.getClonedData(parent.olapEngineModule.fieldListData ?
                    parent.olapEngineModule.fieldListData : []);
            for (const item of fields) {
                if (item.spriteCssClass &&
                    (item.spriteCssClass.indexOf('e-attributeCDB-icon') > -1 ||
                        item.spriteCssClass.indexOf('e-level-members') > -1)) {
                    item.hasChildren = true;
                }
                else if (item.spriteCssClass &&
                    (item.spriteCssClass.indexOf('e-namedSetCDB-icon') > -1)) {
                    item.hasChildren = false;
                }
                else if (item.spriteCssClass &&
                    (item.spriteCssClass.indexOf('e-calcMemberGroupCDB') > -1)) {
                    item.expanded = this.isEdit;
                }
            }
        }
        else {
            for (const key of (parent.engineModule.fieldList ? Object.keys(parent.engineModule.fieldList) : [])) {
                let type = null;
                let typeVal = null;
                const field = parent.engineModule.fieldList[key];
                if ((field.type !== 'number' || parent.engineModule.fieldList[key].type === 'include' || parent.engineModule.fieldList[key].type === 'exclude') && field.aggregateType !== 'DistinctCount') {
                    typeVal = COUNT;
                }
                else {
                    typeVal = field.aggregateType !== undefined ?
                        (field.aggregateType) : SUM;
                }
                type = this.parent.localeObj.getConstant(typeVal);
                fields.push({
                    index: field.index,
                    name: (this.parent.enableHtmlSanitizer ?
                        SanitizeHtmlHelper.sanitize(field.caption) : field.caption) + ' (' + type + ')',
                    type: typeVal,
                    icon: FORMAT + ' ' + ICON,
                    formula: (this.parent.enableHtmlSanitizer ?
                        SanitizeHtmlHelper.sanitize(field.formula) : field.formula),
                    field: (this.parent.enableHtmlSanitizer ?
                        SanitizeHtmlHelper.sanitize(key) : key),
                    caption: this.parent.enableHtmlSanitizer ?
                        SanitizeHtmlHelper.sanitize(field.caption ? field.caption : key) : field.caption ? field.caption : key
                });
            }
        }
        return fields;
    }
    /**
     * Trigger while drop node in formula field.
     *
     * @param {DragAndDropEventArgs} args - It contains the value of args.
     * @returns {void}
     */
    fieldDropped(args) {
        args.cancel = true;
        const dropField = select('#' + this.parentID + 'droppable', this.dialog.element);
        removeClass([dropField], 'e-copy-drop');
        removeClass([args.draggedNode.querySelector('.' + LIST_TEXT_CLASS)], SELECTED_NODE_CLASS);
        let field = args.draggedNode.getAttribute('data-field');
        if (this.parent.dataType === 'olap') {
            if (this.parent.olapEngineModule.fieldList[field] &&
                this.parent.olapEngineModule.fieldList[field].isCalculatedField) {
                field = this.parent.olapEngineModule.fieldList[field].tag;
            }
            if (args.target.id === this.parentID + 'droppable' && dropField.value === '') {
                dropField.value = field;
                dropField.focus();
            }
            else if (args.target.id === (this.parentID + 'droppable') && dropField.value !== '') {
                const currentValue = dropField.value;
                const cursorPos = dropField.selectionStart;
                const textAfterText = currentValue.substring(cursorPos, currentValue.length);
                const textBeforeText = currentValue.substring(0, cursorPos);
                const textCovered = textBeforeText + field;
                dropField.value = textBeforeText + field + textAfterText;
                dropField.focus();
                dropField.setSelectionRange(textCovered.length, textCovered.length);
            }
            else {
                args.cancel = true;
            }
        }
        else {
            const type = args.draggedNode.getAttribute('data-type');
            if (args.target.id === this.parentID + 'droppable' && dropField.value === '') {
                if (type === CALC) {
                    dropField.value = args.draggedNodeData.id.toString();
                }
                else {
                    dropField.value = '"' + type + '(' + field + ')' + '"';
                }
                dropField.focus();
            }
            else if (args.target.id === (this.parentID + 'droppable') && dropField.value !== '') {
                let textCovered;
                const cursorPos = dropField.selectionStart;
                const currentValue = dropField.value;
                const textBeforeText = currentValue.substring(0, cursorPos);
                const textAfterText = currentValue.substring(cursorPos, currentValue.length);
                if (type === CALC) {
                    textCovered = textBeforeText + args.draggedNodeData.id.toString();
                    dropField.value = textBeforeText + args.draggedNodeData.id.toString() + textAfterText;
                }
                else {
                    textCovered = textBeforeText + '"' + type + '(' + field + ')' + '"';
                    dropField.value = textBeforeText + '"' + type + '(' + field + ')' + '"' + textAfterText;
                }
                dropField.focus();
                dropField.setSelectionRange(textCovered.length, textCovered.length);
            }
            else {
                args.cancel = true;
            }
        }
    }
    /**
     * To create dialog.
     *
     * @returns {void}
     */
    createDialog() {
        if (select('#' + this.parentID + 'calculateddialog', document) !== null) {
            remove(select('#' + this.parentID + 'calculateddialog', document));
            while (!isNullOrUndefined(document.querySelector('.' + this.parentID + 'calculatedmenu'))) {
                remove(document.querySelector('.' + this.parentID + 'calculatedmenu'));
            }
        }
        this.parent.element.appendChild(createElement('div', {
            id: this.parentID + 'calculateddialog',
            className: CALCDIALOG + ' ' + (this.parent.dataType === 'olap' ? OLAP_CALCDIALOG : '')
        }));
        const calcButtons = [
            {
                click: this.applyFormula.bind(this),
                buttonModel: {
                    content: this.parent.localeObj.getConstant('ok'),
                    isPrimary: true,
                    cssClass: this.parent.cssClass
                }
            },
            {
                click: this.cancelClick.bind(this),
                buttonModel: {
                    content: this.parent.localeObj.getConstant('cancel'),
                    cssClass: this.parent.cssClass
                }
            }
        ];
        if (this.parent.dataType === 'olap') {
            const clearButton = {
                click: this.clearFormula.bind(this),
                buttonModel: {
                    cssClass: 'e-calc-clear-btn' + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
                    content: this.parent.localeObj.getConstant('clear')
                }
            };
            calcButtons.splice(0, 0, clearButton);
        }
        this.dialog = new Dialog({
            allowDragging: true,
            position: { X: 'center', Y: 'center' },
            buttons: calcButtons,
            close: this.closeDialog.bind(this),
            beforeOpen: this.beforeOpen.bind(this),
            open: () => {
                if (select('#' + this.parentID + 'ddlelement', this.dialog.element)) {
                    select('#' + this.parentID + 'ddlelement', this.dialog.element).focus();
                }
            },
            animationSettings: { effect: 'Zoom' },
            width: '25%',
            isModal: true,
            closeOnEscape: true,
            enableRtl: this.parent.enableRtl,
            locale: this.parent.locale,
            enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
            showCloseIcon: true,
            header: this.parent.localeObj.getConstant('createCalculatedField'),
            target: document.body,
            cssClass: this.parent.cssClass
        });
        this.dialog.isStringTemplate = true;
        this.dialog.appendTo('#' + this.parentID + 'calculateddialog');
    }
    cancelClick() {
        this.dialog.close();
        this.isEdit = false;
    }
    beforeOpen() {
        // this.dialog.element.querySelector('.e-dlg-header').innerText = this.parent.localeObj.getConstant('createCalculatedField');
        this.dialog.element.querySelector('.e-dlg-header').
            setAttribute('title', this.parent.localeObj.getConstant('createCalculatedField'));
    }
    closeDialog() {
        if (this.parent.getModuleName() === 'pivotfieldlist') {
            this.parent.axisFieldModule.render();
            if (this.parent.renderMode !== 'Fixed') {
                addClass([this.parent.element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS)], ICON_HIDDEN);
                this.parent.dialogRenderer.fieldListDialog.show();
            }
        }
        this.destroy();
        if (!isNullOrUndefined(document.getElementById(this.parentID + 'calculateddialog'))) {
            remove(document.getElementById(this.parentID + 'calculateddialog'));
        }
        if (!isNullOrUndefined(document.querySelector('.' + this.parentID + 'calculatedmenu'))) {
            remove(document.querySelector('.' + this.parentID + 'calculatedmenu'));
        }
        const timeOut = ((this.parent.getModuleName() === 'pivotview') ||
            ((this.parent.getModuleName() === 'pivotfieldlist') &&
                this.parent.renderMode === 'Fixed')) ? 0 : 500;
        if (this.buttonCall) {
            this.buttonCall = false;
            setTimeout(this.setFocus.bind(this), timeOut);
        }
    }
    setFocus() {
        let parentElement;
        if (this.parent.getModuleName() === 'pivotview' && this.parent.element) {
            parentElement = this.parent.element;
        }
        else if (document.getElementById(this.parent.element.id + '_Container')) {
            parentElement = document.getElementById(this.parent.element.id + '_Container');
        }
        if (parentElement) {
            const pivotButtons = [].slice.call(parentElement.querySelectorAll('.e-pivot-button'));
            for (const item of pivotButtons) {
                if (item.getAttribute('data-uid') === this.currentFieldName) {
                    item.focus();
                    break;
                }
            }
        }
    }
    /**
     * To render dialog elements.
     *
     * @returns {void}
     */
    renderDialogElements() {
        const outerDiv = createElement('div', {
            id: this.parentID + 'outerDiv',
            className: (this.parent.dataType === 'olap' ? OLAP_CALCOUTERDIV + ' ' : '') + CALCOUTERDIV
        });
        const olapFieldTreeDiv = createElement('div', { id: this.parentID + 'Olap_Tree_Div', className: 'e-olap-field-tree-div' });
        const pivotCalcDiv = createElement('div', { id: this.parentID + 'Pivot_Calc_Div', className: 'e-pivot-calculated-div' });
        if (this.parent.getModuleName() === 'pivotfieldlist' && this.parent.
            dialogRenderer.parentElement.querySelector('.' + FORMULA) !== null && this.parent.isAdaptive) {
            const accordDiv = createElement('div', { id: this.parentID + 'accordDiv', className: CALCACCORD });
            outerDiv.appendChild(accordDiv);
            const buttonDiv = createElement('div', { id: this.parentID + 'buttonDiv', className: CALCBUTTONDIV });
            const addBtn = createElement('button', {
                id: this.parentID + 'addBtn',
                className: CALCADDBTN, attrs: { 'type': 'button' }
            });
            addBtn.innerText = this.parent.localeObj.getConstant('add');
            const cancelBtn = createElement('button', {
                id: this.parentID + 'cancelBtn',
                className: CALCCANCELBTN, attrs: { 'type': 'button' }
            });
            cancelBtn.innerText = this.parent.localeObj.getConstant('cancel');
            buttonDiv.appendChild(cancelBtn);
            buttonDiv.appendChild(addBtn);
            outerDiv.appendChild(buttonDiv);
        }
        else {
            if (!this.parent.isAdaptive && this.parent.dataType === 'olap') {
                const formulaTitle = createElement('div', {
                    className: PIVOT_FIELD_TITLE_CLASS, id: this.parentID + '_' + 'FieldNameTitle'
                });
                formulaTitle.innerText = this.parent.localeObj.getConstant('fieldTitle');
                pivotCalcDiv.appendChild(formulaTitle);
            }
            const inputDiv = createElement('div', { id: this.parentID + 'innerDiv', className: CALCINPUTDIV });
            const inputObj = createElement('input', {
                id: this.parentID + 'ddlelement',
                attrs: { 'type': 'text' },
                className: CALCINPUT
            });
            inputDiv.appendChild(inputObj);
            if (this.parent.dataType === 'olap' && !this.parent.isAdaptive) {
                pivotCalcDiv.appendChild(inputDiv);
            }
            else {
                outerDiv.appendChild(inputDiv);
            }
            const wrapDiv = createElement('div', { id: this.parentID + 'control_container', className: TREEVIEWOUTER });
            if (!this.parent.isAdaptive) {
                const fieldTitle = createElement('div', {
                    className: PIVOT_ALL_FIELD_TITLE_CLASS
                });
                fieldTitle.innerText = (this.parent.dataType === 'olap' ? this.parent.localeObj.getConstant('allFields') :
                    this.parent.localeObj.getConstant('formulaField'));
                if (this.parent.dataType === 'olap') {
                    const headerWrapperDiv = createElement('div', { className: PIVOT_ALL_FIELD_TITLE_CLASS + '-container' });
                    headerWrapperDiv.appendChild(fieldTitle);
                    const spanElement = createElement('span', {
                        attrs: {
                            'tabindex': '0',
                            'aria-disabled': 'false',
                            'aria-label': this.parent.localeObj.getConstant('fieldTooltip'),
                            'role': 'button'
                        },
                        className: ICON + ' ' + CALC_INFO
                    });
                    headerWrapperDiv.appendChild(spanElement);
                    const tooltip = new Tooltip({
                        content: this.parent.localeObj.getConstant('fieldTooltip'),
                        position: (this.parent.enableRtl ? 'RightCenter' : 'LeftCenter'),
                        target: '.' + CALC_INFO,
                        offsetY: (this.parent.enableRtl ? -10 : -10),
                        locale: this.parent.locale,
                        enableRtl: this.parent.enableRtl,
                        enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
                        width: 220,
                        cssClass: this.parent.cssClass
                    });
                    tooltip.appendTo(headerWrapperDiv);
                    wrapDiv.appendChild(headerWrapperDiv);
                }
                else {
                    outerDiv.appendChild(fieldTitle);
                }
            }
            const treeOuterDiv = createElement('div', { className: TREEVIEW + '-outer-div' });
            wrapDiv.appendChild(treeOuterDiv);
            treeOuterDiv.appendChild(createElement('div', { id: this.parentID + 'tree', className: TREEVIEW }));
            if (this.parent.dataType === 'olap' && !this.parent.isAdaptive) {
                olapFieldTreeDiv.appendChild(wrapDiv);
            }
            else {
                outerDiv.appendChild(wrapDiv);
            }
            if (!this.parent.isAdaptive) {
                const formulaTitle = createElement('div', {
                    className: PIVOT_FORMULA_TITLE_CLASS
                });
                formulaTitle.innerText = (this.parent.dataType === 'olap' ? this.parent.localeObj.getConstant('expressionField') :
                    this.parent.localeObj.getConstant('formula'));
                if (this.parent.dataType === 'olap') {
                    pivotCalcDiv.appendChild(formulaTitle);
                }
                else {
                    outerDiv.appendChild(formulaTitle);
                }
            }
            const dropDiv = createElement('textarea', {
                id: this.parentID + 'droppable',
                className: FORMULA + ' e-control e-textbox e-input',
                attrs: {
                    'placeholder': this.parent.isAdaptive ? this.parent.localeObj.getConstant('dropTextMobile') :
                        (this.parent.dataType === 'olap' ? this.parent.localeObj.getConstant('olapDropText') :
                            this.parent.localeObj.getConstant('dropText'))
                }
            });
            if (this.parent.dataType === 'olap' && !this.parent.isAdaptive) {
                pivotCalcDiv.appendChild(dropDiv);
            }
            else {
                outerDiv.appendChild(dropDiv);
            }
            if (this.parent.isAdaptive) {
                const buttonDiv = createElement('div', { id: this.parentID + 'buttonDiv', className: CALCBUTTONDIV });
                const okBtn = createElement('button', {
                    id: this.parentID + 'okBtn',
                    className: CALCOKBTN, attrs: { 'type': 'button' }
                });
                okBtn.innerText = this.parent.localeObj.getConstant('apply');
                buttonDiv.appendChild(okBtn);
                outerDiv.appendChild(buttonDiv);
            }
            if (this.parent.dataType === 'olap') {
                if (!this.parent.isAdaptive) {
                    const memberTypeTitle = createElement('div', {
                        className: OLAP_MEMBER_TITLE_CLASS
                    });
                    memberTypeTitle.innerText = this.parent.localeObj.getConstant('memberType');
                    pivotCalcDiv.appendChild(memberTypeTitle);
                }
                const memberTypeDrop = createElement('div', { id: this.parentID + 'Member_Type_Div', className: CALC_MEMBER_TYPE_DIV });
                if (this.parent.isAdaptive) {
                    outerDiv.appendChild(memberTypeDrop);
                }
                else {
                    pivotCalcDiv.appendChild(memberTypeDrop);
                    const hierarchyTitle = createElement('div', {
                        className: OLAP_HIERARCHY_TITLE_CLASS
                    });
                    hierarchyTitle.innerText = this.parent.localeObj.getConstant('selectedHierarchy');
                    pivotCalcDiv.appendChild(hierarchyTitle);
                }
                const hierarchyDrop = createElement('div', {
                    id: this.parentID + 'Hierarchy_List_Div', className: CALC_HIERARCHY_LIST_DIV
                });
                if (this.parent.isAdaptive) {
                    outerDiv.appendChild(hierarchyDrop);
                }
                else {
                    pivotCalcDiv.appendChild(hierarchyDrop);
                }
            }
            if (!this.parent.isAdaptive) {
                const formatTitle = createElement('div', {
                    className: PIVOT_FORMAT_TITLE_CLASS
                });
                formatTitle.innerText = this.parent.localeObj.getConstant('formatString');
                pivotCalcDiv.appendChild(formatTitle);
            }
            const ddlFormatTypes = createElement('div', {
                id: this.parentID + 'Format_Div', className: CALC_FORMAT_TYPE_DIV
            });
            if (this.parent.isAdaptive) {
                outerDiv.appendChild(ddlFormatTypes);
            }
            else {
                pivotCalcDiv.appendChild(ddlFormatTypes);
            }
            const customFormatDiv = createElement('div', {
                id: this.parentID + 'custom_Format_Div',
                className: PIVOT_CALC_CUSTOM_FORMAT_INPUTDIV
            });
            const customFormatObj = createElement('input', {
                id: this.parentID + 'Custom_Format_Element',
                attrs: { 'type': 'text' },
                className: CALC_FORMAT_INPUT
            });
            customFormatDiv.appendChild(customFormatObj);
            pivotCalcDiv.appendChild(customFormatDiv);
            if (this.parent.isAdaptive) {
                outerDiv.appendChild(customFormatDiv);
            }
            else {
                pivotCalcDiv.appendChild(customFormatDiv);
            }
            if (this.parent.getModuleName() === 'pivotfieldlist' && this.parent.
                dialogRenderer.parentElement.querySelector('.' + FORMULA) === null && this.parent.isAdaptive) {
                const okBtn = outerDiv.querySelector('.' + CALCOKBTN);
                outerDiv.appendChild(okBtn);
            }
            else {
                if (this.parent.dataType === 'olap') {
                    outerDiv.appendChild(olapFieldTreeDiv);
                }
                outerDiv.appendChild(pivotCalcDiv);
            }
        }
        return outerDiv;
    }
    /**
     * To create calculated field adaptive layout.
     *
     * @param {boolean} isEdit - It contains the value of isEdit
     * @returns {void}
     */
    renderAdaptiveLayout(isEdit) {
        const dialogElement = this.parent.dialogRenderer.adaptiveElement;
        if (isEdit) {
            if (select('#' + this.parentID + 'droppable', dialogElement.element)) {
                this.formulaText = select('#' + this.parentID + 'droppable', document).value;
                this.fieldText = this.inputObj.value;
            }
            if (dialogElement.element.querySelector('.' + CALC_MEMBER_TYPE_DIV)) {
                const memberTypeDrop = getInstance(select('#' + this.parentID + 'Member_Type_Div', dialogElement.element), DropDownList);
                this.fieldType = memberTypeDrop.value;
            }
            if (dialogElement.element.querySelector('.' + CALC_HIERARCHY_LIST_DIV)) {
                const hierarchyDrop = getInstance(select('#' + this.parentID + 'Hierarchy_List_Div', dialogElement.element), DropDownList);
                this.parentHierarchy = this.fieldType === 'Dimension' ? hierarchyDrop.value : null;
            }
            if (dialogElement.element.querySelector('.' + CALC_FORMAT_TYPE_DIV)) {
                const ddlFormatTypes = getInstance(select('#' + this.parentID + 'Format_Div', dialogElement.element), DropDownList);
                this.formatType = ddlFormatTypes.value;
            }
            if (dialogElement.element.querySelector('.' + CALC_FORMAT_INPUT)) {
                const customFormat = getInstance(select('#' + this.parentID + 'Custom_Format_Element', dialogElement.element), MaskedTextBox);
                this.formatText = (this.parent.dataType === 'olap' ? this.formatType : this.getFormat(this.formatType)) === 'Custom' ? customFormat.value : null;
            }
        }
        else {
            this.currentFieldName = this.formulaText = this.fieldText = this.formatText = null;
            this.fieldType = this.formatType = this.parentHierarchy = null;
        }
        this.renderMobileLayout(dialogElement);
    }
    /**
     * To update calculated field info in adaptive layout.
     *
     * @param {boolean} isEdit - isEdit.
     * @param {string} fieldName - fieldName.
     * @returns {void}
     * @hidden
     */
    updateAdaptiveCalculatedField(isEdit, fieldName) {
        const dialogElement = this.parent.dialogRenderer.adaptiveElement.element;
        this.isEdit = isEdit;
        const calcInfo = (isEdit ? (this.parent.dataType === 'pivot' ?
            this.parent.engineModule.fieldList[fieldName] : this.parent.olapEngineModule.fieldList[fieldName]) :
            {
                id: null, caption: null, formula: null, fieldType: 'Measure',
                formatString: (this.parent.dataType === 'pivot' ? null : 'Standard'), parentHierarchy: null
            });
        this.currentFieldName = calcInfo.id;
        if (select('#' + this.parentID + 'droppable', document)) {
            this.formulaText = select('#' + this.parentID + 'droppable', document).value = calcInfo.formula;
            this.fieldText = this.inputObj.value = calcInfo.caption;
            this.inputObj.dataBind();
        }
        if (dialogElement.querySelector('.' + CALC_MEMBER_TYPE_DIV)) {
            const memberTypeDrop = getInstance(select('#' + this.parentID + 'Member_Type_Div', dialogElement), DropDownList);
            this.fieldType = memberTypeDrop.value = calcInfo.fieldType;
            memberTypeDrop.readonly = isEdit ? true : false;
            memberTypeDrop.dataBind();
        }
        if (dialogElement.querySelector('.' + CALC_HIERARCHY_LIST_DIV)) {
            const hierarchyDrop = getInstance(select('#' + this.parentID + 'Hierarchy_List_Div', dialogElement), DropDownList);
            if (this.fieldType === 'Dimension') {
                this.parentHierarchy = hierarchyDrop.value = calcInfo.parentHierarchy;
            }
            else {
                this.parentHierarchy = null;
                hierarchyDrop.index = 0;
            }
            hierarchyDrop.dataBind();
        }
        if (dialogElement.querySelector('.' + CALC_FORMAT_TYPE_DIV)) {
            const ddlFormatTypes = getInstance(select('#' + this.parentID + 'Format_Div', dialogElement), DropDownList);
            this.formatType = ddlFormatTypes.value = (this.formatTypes.indexOf(calcInfo.formatString) > -1 ? calcInfo.formatString : 'Custom');
        }
        if (dialogElement.querySelector('.' + CALC_FORMAT_INPUT)) {
            const customFormat = getInstance(select('#' + this.parentID + 'Custom_Format_Element', dialogElement), MaskedTextBox);
            const formatObj = PivotUtil.getFieldByName(fieldName, this.parent.dataSourceSettings.formatSettings);
            if (this.parent.dataType === 'pivot') {
                this.formatText = customFormat.value = formatObj ? formatObj.format : null;
            }
            else {
                this.formatText = customFormat.value = (this.formatType === 'Custom' ? calcInfo.formatString : null);
            }
            customFormat.dataBind();
        }
    }
    /**
     * To create treeview.
     *
     * @returns {void}
     */
    createDropElements() {
        const dialogElement = (this.parent.isAdaptive ?
            this.parent.dialogRenderer.parentElement : this.dialog.element);
        const fData = [];
        const fieldData = [];
        for (const format of this.formatTypes) {
            fData.push({ value: (this.parent.dataType === 'pivot' ? this.getFormat(format) : format), text: this.parent.localeObj.getConstant(format) });
        }
        if (this.parent.dataType === 'olap') {
            const mData = [];
            const memberTypeData = ['Measure', 'Dimension'];
            for (const type of memberTypeData) {
                mData.push({ value: type, text: this.parent.localeObj.getConstant(type) });
            }
            const fields = PivotUtil.getClonedData(this.parent.olapEngineModule.fieldListData);
            for (const item of fields) {
                if (item.spriteCssClass &&
                    (item.spriteCssClass.indexOf('e-attributeCDB-icon') > -1 ||
                        item.spriteCssClass.indexOf('e-hierarchyCDB-icon') > -1)) {
                    fieldData.push({ value: item.id, text: item.caption });
                }
            }
            const memberTypeObj = new DropDownList({
                dataSource: mData, enableRtl: this.parent.enableRtl, locale: this.parent.locale,
                fields: { value: 'value', text: 'text' },
                value: this.fieldType !== null ? this.fieldType : mData[0].value,
                readonly: this.isEdit,
                cssClass: MEMBER_OPTIONS_CLASS + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''), width: '100%',
                change: (args) => {
                    hierarchyListObj.enabled = args.value === 'Dimension' ? true : false;
                    this.fieldType = args.value;
                    this.formulaText = select('#' + this.parentID + 'droppable', document).value;
                    hierarchyListObj.dataBind();
                }
            });
            memberTypeObj.isStringTemplate = true;
            memberTypeObj.appendTo(select('#' + this.parentID + 'Member_Type_Div', dialogElement));
            const hierarchyListObj = new DropDownList({
                dataSource: fieldData, enableRtl: this.parent.enableRtl, locale: this.parent.locale,
                allowFiltering: true,
                enabled: memberTypeObj.value === 'Dimension' ? true : false,
                filterBarPlaceholder: this.parent.localeObj.getConstant('example') + ' ' + fieldData[0].text.toString(),
                fields: { value: 'value', text: 'text' },
                value: this.parentHierarchy !== null && memberTypeObj.value === 'Dimension' ?
                    this.parentHierarchy : fieldData[0].value,
                cssClass: MEMBER_OPTIONS_CLASS + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''), width: '100%',
                change: (args) => {
                    this.parentHierarchy = args.value;
                    this.formulaText = select('#' + this.parentID + 'droppable', document).value;
                }
            });
            hierarchyListObj.isStringTemplate = true;
            hierarchyListObj.appendTo(select('#' + this.parentID + 'Hierarchy_List_Div', dialogElement));
        }
        const formatStringObj = new DropDownList({
            dataSource: fData, enableRtl: this.parent.enableRtl, locale: this.parent.locale,
            fields: { value: 'value', text: 'text' },
            value: this.parent.isAdaptive && this.formatType !== null ? this.formatType
                : this.parent.dataType === 'olap' ? fData[0].value : fData[4].value,
            cssClass: MEMBER_OPTIONS_CLASS + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''), width: '100%',
            change: (args) => {
                customerFormatObj.enabled = args.value === 'Custom' ? true : false;
                this.formatType = args.value;
                this.formulaText = select('#' + this.parentID + 'droppable', document).value;
                customerFormatObj.dataBind();
            }
        });
        formatStringObj.isStringTemplate = true;
        formatStringObj.appendTo(select('#' + this.parentID + 'Format_Div', dialogElement));
        const customerFormatObj = new MaskedTextBox({
            placeholder: this.parent.localeObj.getConstant('customFormat'),
            locale: this.parent.locale, enableRtl: this.parent.enableRtl,
            value: this.formatText !== null && formatStringObj.value === 'Custom' ? this.formatText : null,
            enabled: formatStringObj.value === 'Custom' ? true : false,
            change: (args) => {
                this.formatText = args.value;
                this.formulaText = select('#' + this.parentID + 'droppable', document).value;
            },
            cssClass: this.parent.cssClass
        });
        customerFormatObj.isStringTemplate = true;
        customerFormatObj.appendTo('#' + this.parentID + 'Custom_Format_Element');
    }
    getFormat(pivotFormat) {
        let format = pivotFormat;
        switch (format) {
            case 'Standard':
                format = 'N';
                break;
            case 'Currency':
                format = 'C';
                break;
            case 'Percent':
                format = 'P';
                break;
            case 'N':
                format = 'Standard';
                break;
            case 'C':
                format = 'Currency';
                break;
            case 'P':
                format = 'Percent';
                break;
        }
        return format;
    }
    /**
     * To create treeview.
     *
     * @returns {void}
     */
    createTreeView() {
        if (this.parent.dataType === 'olap') {
            this.treeObj = new TreeView({
                fields: { dataSource: this.getFieldListData(this.parent), id: 'id', text: 'caption', parentID: 'pid', iconCss: 'spriteCssClass' },
                allowDragAndDrop: true,
                enableRtl: this.parent.enableRtl,
                enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
                locale: this.parent.locale,
                nodeDragStart: this.dragStart.bind(this),
                nodeDragging: (e) => {
                    if (e.event.target && e.event.target.classList.contains(FORMULA)) {
                        removeClass([e.clonedNode], NO_DRAG_CLASS);
                        addClass([e.event.target], 'e-copy-drop');
                    }
                    else {
                        addClass([e.clonedNode], NO_DRAG_CLASS);
                        removeClass([e.event.target], 'e-copy-drop');
                        e.dropIndicator = 'e-no-drop';
                        addClass([e.clonedNode.querySelector('.' + ICON)], 'e-icon-expandable');
                        removeClass([e.clonedNode.querySelector('.' + ICON)], 'e-list-icon');
                    }
                },
                nodeClicked: this.fieldClickHandler.bind(this),
                nodeSelected: (args) => {
                    if (args.node.getAttribute('data-type') === CALC) {
                        this.displayMenu(args.node);
                    }
                    else {
                        removeClass([args.node], 'e-active');
                        args.cancel = true;
                    }
                },
                nodeDragStop: this.fieldDropped.bind(this),
                drawNode: this.drawTreeNode.bind(this),
                nodeExpanding: this.updateNodeIcon.bind(this),
                nodeCollapsed: this.updateNodeIcon.bind(this),
                sortOrder: 'None',
                cssClass: this.parent.cssClass
            });
        }
        else {
            this.treeObj = new TreeView({
                fields: { dataSource: this.getFieldListData(this.parent), id: 'formula', text: 'name', iconCss: 'icon' },
                allowDragAndDrop: true,
                enableRtl: this.parent.enableRtl,
                enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
                locale: this.parent.locale,
                cssClass: this.parent.cssClass,
                nodeCollapsing: this.nodeCollapsing.bind(this),
                nodeDragStart: this.dragStart.bind(this),
                nodeClicked: this.fieldClickHandler.bind(this),
                nodeDragStop: this.fieldDropped.bind(this),
                drawNode: this.drawTreeNode.bind(this),
                keyPress: (args) => {
                    if (args.event.keyCode === 39) {
                        args.cancel = true;
                    }
                },
                sortOrder: 'Ascending'
            });
        }
        this.treeObj.isStringTemplate = true;
        this.treeObj.appendTo('#' + this.parentID + 'tree');
    }
    updateNodeIcon(args) {
        if (args.node && args.node.querySelector('.e-list-icon') &&
            args.node.querySelector('.e-icon-expandable.e-process') &&
            (args.node.querySelector('.e-list-icon').className.indexOf('e-folderCDB-icon') > -1)) {
            const node = args.node.querySelector('.e-list-icon');
            removeClass([node], 'e-folderCDB-icon');
            addClass([node], 'e-folderCDB-open-icon');
        }
        else if (args.node && args.node.querySelector('.e-list-icon') &&
            args.node.querySelector('.e-icon-expandable') &&
            (args.node.querySelector('.e-list-icon').className.indexOf('e-folderCDB-open-icon') > -1)) {
            const node = args.node.querySelector('.e-list-icon');
            removeClass([node], 'e-folderCDB-open-icon');
            addClass([node], 'e-folderCDB-icon');
        }
        else {
            const curTreeData = this.treeObj.fields.dataSource;
            const fieldListData = curTreeData;
            let childNodes = [];
            for (const item of fieldListData) {
                if (item.pid === args.nodeData.id.toString()) {
                    childNodes.push(item);
                }
            }
            if (childNodes.length === 0) {
                this.parent.olapEngineModule.calcChildMembers = [];
                this.parent.olapEngineModule.getCalcChildMembers(this.parent.dataSourceSettings, args.nodeData.id.toString());
                childNodes = this.parent.olapEngineModule.calcChildMembers;
                this.parent.olapEngineModule.calcChildMembers = [];
                for (const node of childNodes) {
                    node.pid = args.nodeData.id.toString();
                    node.hasChildren = false;
                    node.spriteCssClass = 'e-level-members';
                    node.caption = (node.caption === '' ? this.parent.localeObj.getConstant('blank') : node.caption);
                    curTreeData.push(node);
                }
                this.treeObj.addNodes(childNodes, args.node);
            }
            else {
                return;
            }
        }
    }
    nodeCollapsing(args) {
        args.cancel = true;
    }
    dragStart(args) {
        let isDrag = false;
        const dragItem = args.clonedNode;
        if (dragItem && ((this.parent.dataType === 'olap' &&
            (dragItem.querySelector('.e-calc-dimension-icon,.e-calc-measure-icon,.e-measure-icon') ||
                dragItem.querySelector('.e-dimensionCDB-icon,.e-attributeCDB-icon,.e-hierarchyCDB-icon') ||
                dragItem.querySelector('.e-level-members,.e-namedSetCDB-icon'))) || (this.parent.dataType === 'pivot' &&
            args.event.target.classList.contains(DRAG_CLASS)))) {
            isDrag = true;
        }
        if (isDrag) {
            addClass([args.draggedNode.querySelector('.' + LIST_TEXT_CLASS)], SELECTED_NODE_CLASS);
            addClass([dragItem], PIVOTCALC);
            dragItem.style.zIndex = (this.dialog.zIndex + 1).toString();
            dragItem.style.display = 'inline';
        }
        else {
            args.cancel = true;
        }
    }
    /**
     * Trigger before treeview text append.
     *
     * @param {DrawNodeEventArgs} args - args.
     * @returns {void}
     */
    drawTreeNode(args) {
        if (this.parent.dataType === 'olap') {
            if (args.node.querySelector('.e-measure-icon')) {
                args.node.querySelector('.e-list-icon').style.display = 'none';
            }
            const field = args.nodeData;
            args.node.setAttribute('data-field', field.id);
            args.node.setAttribute('data-caption', field.caption);
            const liTextElement = args.node.querySelector('.' + TEXT_CONTENT_CLASS);
            if (args.nodeData && args.nodeData.type === CALC &&
                liTextElement && args.node.querySelector('.e-list-icon.e-calc-member')) {
                args.node.setAttribute('data-type', field.type);
                args.node.setAttribute('data-membertype', field.fieldType);
                args.node.setAttribute('data-hierarchy', field.parentHierarchy ? field.parentHierarchy : '');
                args.node.setAttribute('data-formula', field.formula);
                const formatString = (field.formatString ? this.formatTypes.indexOf(field.formatString) > -1 ?
                    field.formatString : 'Custom' : 'None');
                args.node.setAttribute('data-formatString', formatString);
                args.node.setAttribute('data-customformatstring', (formatString === 'Custom' ? field.formatString : ''));
                const removeElement = createElement('span', {
                    className: GRID_REMOVE + ' e-icons e-list-icon'
                });
                liTextElement.classList.add('e-calcfieldmember');
                if (this.parent.isAdaptive) {
                    const editElement = createElement('span', {
                        className: 'e-list-edit-icon' + (this.isEdit && this.currentFieldName === field.id ?
                            ' e-edited ' : ' e-edit ') + ICON
                    });
                    const editWrapper = createElement('div', { className: 'e-list-header-icon' });
                    editWrapper.appendChild(editElement);
                    editWrapper.appendChild(removeElement);
                    liTextElement.appendChild(editWrapper);
                }
                else {
                    liTextElement.appendChild(removeElement);
                }
            }
            if (this.parent.isAdaptive) {
                const liTextElement = args.node.querySelector('.' + TEXT_CONTENT_CLASS);
                if (args.node && args.node.querySelector('.e-list-icon') && liTextElement) {
                    const liIconElement = args.node.querySelector('.e-list-icon');
                    liTextElement.insertBefore(liIconElement, args.node.querySelector('.e-list-text'));
                }
                if (args.node && args.node.querySelector('.e-calcMemberGroupCDB,.e-measureGroupCDB-icon,.e-folderCDB-icon')) {
                    args.node.querySelector('.e-checkbox-wrapper').style.display = 'none';
                }
                if (args.node && args.node.querySelector('.e-level-members')) {
                    args.node.querySelector('.e-list-icon').style.display = 'none';
                }
            }
        }
        else {
            const field = args.nodeData.field;
            args.node.setAttribute('data-field', field);
            args.node.setAttribute('data-caption', args.nodeData.caption);
            args.node.setAttribute('data-type', args.nodeData.type);
            const formatObj = PivotUtil.getFieldByName(field, this.parent.dataSourceSettings.formatSettings);
            args.node.setAttribute('data-formatString', formatObj ? formatObj.format : '');
            if (formatObj) {
                const pivotFormat = this.getFormat(formatObj.format);
                const formatString = (pivotFormat ? this.formatTypes.indexOf(pivotFormat) > -1 ?
                    formatObj.format : 'Custom' : 'None');
                args.node.setAttribute('data-customformatstring', (formatString === 'Custom' ? pivotFormat : ''));
                args.node.setAttribute('data-formatString', formatObj ? formatString : '');
            }
            const dragElement = createElement('span', {
                attrs: { 'tabindex': '-1', 'aria-disabled': 'false', 'title': this.parent.localeObj.getConstant('dragField') },
                className: ICON + ' e-drag'
            });
            const spaceElement = createElement('div', {
                className: ' e-iconspace'
            });
            prepend([dragElement], args.node.querySelector('.' + TEXT_CONTENT_CLASS));
            append([spaceElement, args.node.querySelector('.' + FORMAT)], args.node.querySelector('.' + TEXT_CONTENT_CLASS));
            if (this.getMenuItems(this.parent.engineModule.fieldList[field].type).length <= 0) {
                removeClass([args.node.querySelector('.' + FORMAT)], ICON);
            }
            else {
                args.node.querySelector('.' + FORMAT).setAttribute('title', this.parent.localeObj.getConstant('format'));
            }
            if (this.parent.engineModule.fieldList[field].aggregateType === CALC) {
                args.node.querySelector('.' + FORMAT).setAttribute('title', this.parent.localeObj.getConstant('remove'));
                addClass([args.node.querySelector('.' + FORMAT)], GRID_REMOVE);
                addClass([args.node.querySelector('.' + 'e-iconspace')], [CALC_EDIT, ICON, 'e-list-icon']);
                args.node.querySelector('.' + CALC_EDIT).setAttribute('title', this.parent.localeObj.getConstant('edit'));
                args.node.querySelector('.' + CALC_EDIT).setAttribute('aria-disabled', 'false');
                args.node.querySelector('.' + CALC_EDIT).setAttribute('tabindex', '-1');
                removeClass([args.node.querySelector('.' + FORMAT)], FORMAT);
                removeClass([args.node.querySelector('.e-iconspace')], 'e-iconspace');
            }
        }
    }
    /**
     * To create radio buttons.
     *
     * @param {string} key - key.
     * @returns {HTMLElement} - createTypeContainer
     */
    createTypeContainer(key) {
        const wrapDiv = createElement('div', { id: this.parentID + 'control_container', className: TREEVIEWOUTER });
        const type = this.getMenuItems(this.parent.engineModule.fieldList[key].type);
        for (let i = 0; i < type.length; i++) {
            const input = createElement('input', {
                id: this.parentID + 'radio' + key + type[i],
                attrs: { 'type': 'radio', 'data-ftxt': key, 'data-value': type[i] },
                className: CALCRADIO
            });
            wrapDiv.appendChild(input);
        }
        return wrapDiv;
    }
    getMenuItems(fieldType, summaryType) {
        const menuItems = !isNullOrUndefined(summaryType) ? summaryType : this.parent.aggregateTypes;
        const type = [];
        const menuTypes = this.getValidSummaryType();
        for (let i = 0; i < menuItems.length; i++) {
            if ((menuTypes.indexOf(menuItems[i]) > -1) && (type.indexOf(menuItems[i]) < 0)) {
                if (((menuItems[i] === COUNT || menuItems[i] === DISTINCTCOUNT) && fieldType !== 'number')
                    || (fieldType === 'number')) {
                    type.push(menuItems[i]);
                }
            }
        }
        return type;
    }
    getValidSummaryType() {
        return [COUNT, DISTINCTCOUNT,
            SUM, AVG, MEDIAN,
            MIN, MAX, PRODUCT,
            STDEV, STDEVP,
            VAR, VARP];
    }
    /**
     * To get Accordion Data.
     *
     * @param  {PivotView | PivotFieldList} parent - parent.
     * @returns {AccordionItemModel[]} - Accordion Data.
     */
    getAccordionData(parent) {
        const data = [];
        const keys = Object.keys(parent.engineModule.fieldList);
        for (let index = 0, i = keys.length; index < i; index++) {
            const key = keys[index];
            data.push({
                header: '<input id=' + this.parentID + '_' + index + ' class=' + CALCCHECK + ' type="checkbox" data-field=' +
                    key + ' data-caption="' + this.parent.engineModule.fieldList[key].caption + '" data-type=' +
                    this.parent.engineModule.fieldList[key].type + '/>',
                content: (this.parent.engineModule.fieldList[key].aggregateType === CALC ||
                    (this.getMenuItems(this.parent.engineModule.fieldList[key].type).length < 1)) ? '' :
                    this.createTypeContainer(key).outerHTML,
                iconCss: this.parent.engineModule.fieldList[key].aggregateType === CALC ? 'e-list-icon' + ' ' +
                    (this.isEdit && this.currentFieldName === key ? 'e-edited' : 'e-edit') : ''
            });
        }
        return data;
    }
    /**
     * To render mobile layout.
     *
     * @param {Tab} tabObj - tabObj
     * @returns {void}
     */
    renderMobileLayout(tabObj) {
        tabObj.items[4].content = this.renderDialogElements().outerHTML;
        tabObj.dataBind();
        if (this.parent.isAdaptive && this.parent.
            dialogRenderer.parentElement.querySelector('.' + FORMULA) !== null) {
            this.createDropElements();
        }
        const cancelBtn = new Button({ cssClass: FLAT + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''), isPrimary: true, locale: this.parent.locale, enableRtl: this.parent.enableRtl, enableHtmlSanitizer: this.parent.enableHtmlSanitizer });
        cancelBtn.isStringTemplate = true;
        cancelBtn.appendTo('#' + this.parentID + 'cancelBtn');
        if (cancelBtn.element) {
            cancelBtn.element.onclick = this.cancelBtnClick.bind(this);
        }
        if (this.parent.
            dialogRenderer.parentElement.querySelector('.' + FORMULA) !== null && this.parent.isAdaptive) {
            const okBtn = new Button({ cssClass: FLAT + ' ' + OUTLINE_CLASS + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''), isPrimary: true, locale: this.parent.locale, enableRtl: this.parent.enableRtl, enableHtmlSanitizer: this.parent.enableHtmlSanitizer });
            okBtn.isStringTemplate = true;
            okBtn.appendTo('#' + this.parentID + 'okBtn');
            this.inputObj = new MaskedTextBox({
                placeholder: this.parent.localeObj.getConstant('fieldName'),
                locale: this.parent.locale, enableRtl: this.parent.enableRtl,
                change: (args) => {
                    this.fieldText = args.value;
                    this.formulaText = select('#' + this.parentID + 'droppable', document).value;
                },
                cssClass: this.parent.cssClass
            });
            this.inputObj.isStringTemplate = true;
            this.inputObj.appendTo('#' + this.parentID + 'ddlelement');
            if (this.formulaText !== null && select('#' + this.parentID + 'droppable', this.parent.dialogRenderer.parentElement) !== null) {
                const drop = select('#' + this.parentID + 'droppable', this.parent.dialogRenderer.parentElement);
                drop.value = this.formulaText;
            }
            if (this.fieldText !== null && this.parent.
                dialogRenderer.parentElement.querySelector('.' + CALCINPUT) !== null) {
                this.parent.
                    dialogRenderer.parentElement.querySelector('.' + CALCINPUT).value = this.fieldText;
                this.inputObj.value = this.fieldText;
            }
            if (okBtn.element) {
                okBtn.element.onclick = this.applyFormula.bind(this);
            }
        }
        else if (this.parent.isAdaptive) {
            const addBtn = new Button({ cssClass: FLAT + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''), isPrimary: true, locale: this.parent.locale, enableRtl: this.parent.enableRtl, enableHtmlSanitizer: this.parent.enableHtmlSanitizer });
            addBtn.isStringTemplate = true;
            addBtn.appendTo('#' + this.parentID + 'addBtn');
            if (this.parent.dataType === 'olap') {
                this.treeObj = new TreeView({
                    fields: { dataSource: this.getFieldListData(this.parent), id: 'id', text: 'caption', parentID: 'pid', iconCss: 'spriteCssClass' },
                    showCheckBox: true,
                    autoCheck: false,
                    sortOrder: 'None',
                    enableRtl: this.parent.enableRtl,
                    locale: this.parent.locale,
                    enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
                    nodeClicked: this.fieldClickHandler.bind(this),
                    drawNode: this.drawTreeNode.bind(this),
                    nodeExpanding: this.updateNodeIcon.bind(this),
                    nodeCollapsed: this.updateNodeIcon.bind(this),
                    nodeSelected: (args) => {
                        removeClass([args.node], 'e-active');
                        args.cancel = true;
                    },
                    cssClass: this.parent.cssClass
                });
                this.treeObj.isStringTemplate = true;
                this.treeObj.appendTo('#' + this.parentID + 'accordDiv');
            }
            else {
                this.accordion = new Accordion({
                    items: this.getAccordionData(this.parent),
                    enableRtl: this.parent.enableRtl,
                    locale: this.parent.locale,
                    enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
                    expanding: this.accordionExpand.bind(this),
                    clicked: this.accordionClickHandler.bind(this),
                    created: this.accordionCreated.bind(this)
                });
                this.accordion.isStringTemplate = true;
                this.accordion.appendTo('#' + this.parentID + 'accordDiv');
                this.updateType();
            }
            if (addBtn.element) {
                addBtn.element.onclick = this.addBtnClick.bind(this);
            }
        }
    }
    accordionExpand(args) {
        if (args.element.querySelectorAll('.e-radio-wrapper').length === 0) {
            const keys = Object.keys(this.parent.engineModule.fieldList);
            for (let index = 0, i = keys.length; index < i; index++) {
                const key = keys[index];
                const type = this.parent.engineModule.fieldList[key].type !== 'number' ? [COUNT, DISTINCTCOUNT] :
                    [SUM, COUNT, AVG, MEDIAN, MIN, MAX, DISTINCTCOUNT, PRODUCT, STDEV, STDEVP, VAR, VARP];
                let radiobutton;
                if (key === args.element.querySelector('[data-field').getAttribute('data-field')) {
                    for (let i = 0; i < type.length; i++) {
                        radiobutton = new RadioButton({
                            label: this.parent.localeObj.getConstant(type[i]),
                            name: AGRTYPE + key,
                            checked: args.element.querySelector('[data-type').getAttribute('data-type') === type[i],
                            change: this.onChange.bind(this),
                            locale: this.parent.locale, enableRtl: this.parent.enableRtl,
                            enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
                            cssClass: this.parent.cssClass
                        });
                        radiobutton.isStringTemplate = true;
                        radiobutton.appendTo('#' + this.parentID + 'radio' + key + type[i]);
                    }
                }
            }
        }
    }
    onChange(args) {
        const type = args.event.target.parentElement.querySelector('.e-label')
            .innerText;
        const field = args.event.target.closest('.e-acrdn-item').
            querySelector('[data-field').getAttribute('data-caption');
        args.event.target.
            closest('.e-acrdn-item').querySelector('.e-label').
            innerText = field + ' (' + type + ')';
        args.event.target.closest('.e-acrdn-item').
            querySelector('[data-type').setAttribute('data-type', args.event.target.getAttribute('data-value'));
    }
    updateType() {
        const keys = Object.keys(this.parent.engineModule.fieldList);
        for (let index = 0, i = keys.length; index < i; index++) {
            const key = keys[index];
            let type = null;
            if ((this.parent.engineModule.fieldList[key].type !== 'number' ||
                this.parent.engineModule.fieldList[key].type === 'include' ||
                this.parent.engineModule.fieldList[key].type === 'exclude') &&
                (this.parent.engineModule.fieldList[key].aggregateType !== 'DistinctCount')) {
                type = COUNT;
            }
            else {
                type = this.parent.engineModule.fieldList[key].aggregateType !== undefined ?
                    this.parent.engineModule.fieldList[key].aggregateType : SUM;
            }
            const checkbox = new CheckBox({
                label: this.parent.engineModule.fieldList[key].caption + ' (' + this.parent.localeObj.getConstant(type) + ')',
                locale: this.parent.locale, enableRtl: this.parent.enableRtl, enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
                cssClass: this.parent.cssClass
            });
            checkbox.isStringTemplate = true;
            checkbox.appendTo('#' + this.parentID + '_' + index);
            select('#' + this.parentID + '_' + index, document).setAttribute('data-field', key);
            select('#' + this.parentID + '_' + index, document).setAttribute('data-type', type);
        }
    }
    /**
     * Trigger while click cancel button.
     *
     * @returns {void}
     */
    cancelBtnClick() {
        this.renderMobileLayout(this.parent.dialogRenderer.adaptiveElement);
    }
    /**
     * Trigger while click add button.
     *
     * @returns {void}
     */
    addBtnClick() {
        let fieldText = '';
        let field = null;
        let type = null;
        if (this.parent.dataType === 'pivot') {
            const node = document.querySelectorAll('.e-accordion .e-check');
            for (let i = 0; i < node.length; i++) {
                field = node[i].parentElement.querySelector('[data-field]').getAttribute('data-field');
                type = node[i].parentElement.querySelector('[data-field]').getAttribute('data-type');
                if (type.indexOf(CALC) === -1) {
                    fieldText = fieldText + ('"' + type + '(' + field + ')' + '"');
                }
                else {
                    for (let j = 0; j < this.parent.dataSourceSettings.calculatedFieldSettings.length; j++) {
                        if (this.parent.dataSourceSettings.calculatedFieldSettings[j].name === field) {
                            fieldText = fieldText + this.parent.dataSourceSettings.calculatedFieldSettings[j].formula;
                            break;
                        }
                    }
                }
            }
        }
        else {
            const nodes = this.treeObj.getAllCheckedNodes();
            const olapEngine = this.parent.olapEngineModule;
            for (const item of nodes) {
                fieldText = fieldText + (olapEngine.fieldList[item] &&
                    olapEngine.fieldList[item].type === CALC ? olapEngine.fieldList[item].tag : item);
            }
        }
        this.formulaText = this.formulaText !== null ? (this.formulaText + fieldText) : fieldText;
        this.renderMobileLayout(this.parent.dialogRenderer.adaptiveElement);
    }
    /**
     * To create calculated field dialog elements.
     *
     * @param {any} args - It contains the args value.
     * @param {boolean} args.edit - It contains the value of edit under args.
     * @param {string} args.fieldName - It contains the value of fieldName under args.
     * @returns {void}
     * @hidden
     */
    createCalculatedFieldDialog(args) {
        if (this.parent.isAdaptive && this.parent.getModuleName() === 'pivotfieldlist') {
            this.renderAdaptiveLayout(args && args.edit !== undefined ? args.edit : true);
            this.isEdit = (args && args.edit !== undefined ? args.edit : this.isEdit);
        }
        else if (!this.parent.isAdaptive) {
            this.isEdit = (args && args.edit !== undefined ? args.edit : false);
            this.renderDialogLayout();
            if (args && args.edit) {
                const target = this.treeObj.element.querySelector('li[data-field="' + args.fieldName + '"]');
                if (target) {
                    addClass([target], ['e-active', 'e-node-focus']);
                    target.setAttribute('aria-selected', 'true');
                    target.id = this.treeObj.element.id + '_active';
                    if (this.parent.dataType === 'pivot') { // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        const e = { event: { target: target.querySelector('.e-list-icon.e-edit.e-icons') } };
                        this.fieldClickHandler(e);
                    }
                    else {
                        this.displayMenu(target);
                    }
                }
            }
            this.dialog.element.style.top = parseInt(this.dialog.element.style.top, 10) < 0 ? '0px' : this.dialog.element.style.top;
        }
    }
    /**
     * To create calculated field desktop layout.
     *
     * @returns {void}
     */
    renderDialogLayout() {
        this.newFields =
            extend([], this.parent.dataSourceSettings.calculatedFieldSettings, null, true);
        this.createDialog();
        this.dialog.content = this.renderDialogElements();
        this.dialog.refresh();
        this.inputObj = new MaskedTextBox({
            placeholder: this.parent.localeObj.getConstant('fieldName'),
            locale: this.parent.locale, enableRtl: this.parent.enableRtl,
            cssClass: this.parent.cssClass
        });
        this.inputObj.isStringTemplate = true;
        this.inputObj.appendTo('#' + this.parentID + 'ddlelement');
        this.createDropElements();
        this.createTreeView();
        this.droppable = new Droppable(select('#' + this.parentID + 'droppable'));
        this.keyboardEvents = new KeyboardEvents(this.parent.calculatedFieldModule.dialog.element, {
            keyAction: this.keyActionHandler.bind(this),
            keyConfigs: { moveRight: 'rightarrow', enter: 'enter', shiftE: 'shift+E', delete: 'delete' },
            eventName: 'keydown'
        });
    }
    createConfirmDialog(title, description, calcInfo, isRemove, node) {
        const errorDialog = createElement('div', {
            id: this.parentID + '_CalculatedFieldErrorDialog',
            className: ERROR_DIALOG_CLASS
        });
        this.parent.element.appendChild(errorDialog);
        this.confirmPopUp = new Dialog({
            animationSettings: { effect: 'Fade' },
            allowDragging: false,
            showCloseIcon: true,
            enableRtl: this.parent.enableRtl,
            locale: this.parent.locale,
            enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
            width: 'auto',
            height: 'auto',
            position: { X: 'center', Y: 'center' },
            buttons: [
                {
                    click: isRemove ? this.removeCalcField.bind(this, node) : this.replaceFormula.bind(this, calcInfo),
                    buttonModel: {
                        cssClass: OK_BUTTON_CLASS + ' ' + FLAT_CLASS + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
                        content: isRemove ? this.parent.localeObj.getConstant('yes') : this.parent.localeObj.getConstant('ok'), isPrimary: true
                    }
                },
                {
                    click: this.closeErrorDialog.bind(this),
                    buttonModel: {
                        cssClass: CANCEL_BUTTON_CLASS + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
                        content: isRemove ? this.parent.localeObj.getConstant('no') : this.parent.localeObj.getConstant('cancel'), isPrimary: true
                    }
                }
            ],
            header: title,
            content: description,
            isModal: true,
            visible: true,
            closeOnEscape: true,
            target: document.body,
            cssClass: this.parent.cssClass,
            close: this.removeErrorDialog.bind(this)
        });
        this.confirmPopUp.isStringTemplate = true;
        this.confirmPopUp.appendTo(errorDialog);
        // this.confirmPopUp.element.querySelector('.e-dlg-header').innerText = title;
    }
    replaceFormula(calcInfo) {
        const report = this.parent.dataSourceSettings;
        if (this.parent.dataType === 'olap') {
            for (let j = 0; j < report.calculatedFieldSettings.length; j++) {
                if (report.calculatedFieldSettings[j].name === calcInfo.name) {
                    if (!isNullOrUndefined(calcInfo.hierarchyUniqueName)) {
                        report.calculatedFieldSettings[j].hierarchyUniqueName = calcInfo.hierarchyUniqueName;
                    }
                    report.calculatedFieldSettings[j].formatString = calcInfo.formatString;
                    report.calculatedFieldSettings[j].formula = calcInfo.formula;
                    this.parent.lastCalcFieldInfo = report.calculatedFieldSettings[j];
                    break;
                }
            }
        }
        else {
            for (let i = 0; i < report.values.length; i++) {
                if (report.values[i].type === CALC && report.values[i].name === calcInfo.name) {
                    for (let j = 0; j < report.calculatedFieldSettings.length; j++) {
                        if (report.calculatedFieldSettings[j].name === calcInfo.name) {
                            report.calculatedFieldSettings[j].formula = calcInfo.formula;
                            this.parent.lastCalcFieldInfo = report.calculatedFieldSettings[j];
                            this.updateFormatSettings(report, calcInfo.name, calcInfo.formatString);
                        }
                    }
                }
            }
        }
        this.addFormula(report, calcInfo.name);
        this.removeErrorDialog();
    }
    removeErrorDialog() {
        if (this.confirmPopUp && !this.confirmPopUp.isDestroyed) {
            this.confirmPopUp.destroy();
        }
        if (select('#' + this.parentID + '_CalculatedFieldErrorDialog', document) !== null) {
            remove(select('#' + this.parentID + '_CalculatedFieldErrorDialog', document));
        }
    }
    closeErrorDialog() {
        this.confirmPopUp.close();
    }
    /**
     * To add event listener.
     *
     * @returns {void}
     * @hidden
     */
    addEventListener() {
        if (this.parent.isDestroyed) {
            return;
        }
        this.parent.on(initCalculatedField, this.createCalculatedFieldDialog, this);
    }
    /**
     * To remove event listener.
     *
     * @returns {void}
     * @hidden
     */
    removeEventListener() {
        if (this.parent.isDestroyed) {
            return;
        }
        this.parent.off(initCalculatedField, this.createCalculatedFieldDialog);
    }
    /**
     * To destroy the calculated field dialog
     *
     * @returns {void}
     * @hidden
     */
    destroy() {
        if (this.menuObj && !this.menuObj.isDestroyed) {
            this.menuObj.destroy();
        }
        if (this.treeObj && !this.treeObj.isDestroyed) {
            this.treeObj.destroy();
        }
        if (this.dialog && !this.dialog.isDestroyed) {
            this.dialog.destroy();
        }
        if (this.inputObj && !this.inputObj.isDestroyed) {
            this.inputObj.destroy();
        }
        if (this.confirmPopUp && !this.confirmPopUp.isDestroyed) {
            this.confirmPopUp.destroy();
        }
        if (this.accordion && !this.accordion.isDestroyed) {
            this.accordion.destroy();
        }
        if (this.menuObj) {
            this.menuObj = null;
        }
        if (this.treeObj) {
            this.treeObj = null;
        }
        if (this.dialog) {
            this.dialog = null;
        }
        if (this.inputObj) {
            this.inputObj = null;
        }
        if (this.newFields) {
            this.newFields = null;
        }
        if (this.confirmPopUp) {
            this.confirmPopUp = null;
        }
        if (this.accordion) {
            this.accordion = null;
        }
        if (this.curMenu) {
            this.curMenu = null;
        }
    }
}

PivotFieldList.Inject(CalculatedField);
/**
 * Module for Field List rendering
 */
/** @hidden */
class FieldList {
    /**
     * Constructor for Field List module.
     *
     * @param {PivotView} parent - It represent the parent
     */
    constructor(parent) {
        this.parent = parent;
        this.addEventListener();
    }
    /**
     * For internal use only - Get the module name.
     *
     * @returns {string} - It returns a ModuleName
     * @private
     */
    getModuleName() {
        return 'fieldList';
    }
    initiateModule() {
        if (!select('#' + this.parent.element.id + '_PivotFieldList', this.parent.element)) {
            this.element = createElement('div', {
                id: this.parent.element.id + '_PivotFieldList',
                styles: 'position:' + (this.parent.enableRtl ? 'static' : 'absolute') + ';height:0;width:' + this.parent.element.style.width +
                    ';display:none'
            });
            if (select('#' + this.parent.element.id + 'containerwrapper', document) === null) {
                const containerWrapper = createElement('div', {
                    id: this.parent.element.id + 'containerwrapper',
                    styles: 'height:' + (isNaN(this.parent.height) ? this.parent.height : (this.parent.height + 'px'))
                });
                this.parent.element.parentElement.appendChild(containerWrapper);
                containerWrapper.appendChild(this.element);
                containerWrapper.appendChild(this.parent.element);
            }
            else {
                select('#' + this.parent.element.id + 'containerwrapper', document).appendChild(this.element);
            }
            this.parent.pivotFieldListModule = new PivotFieldList({
                dataSourceSettings: {
                    providerType: this.parent.dataSourceSettings.providerType,
                    rows: [],
                    columns: [],
                    values: [],
                    filters: []
                },
                spinnerTemplate: this.parent.spinnerTemplate,
                allowDeferLayoutUpdate: this.parent.allowDeferLayoutUpdate,
                renderMode: 'Popup',
                allowCalculatedField: this.parent.allowCalculatedField,
                showValuesButton: this.parent.showValuesButton,
                enableRtl: this.parent.enableRtl,
                locale: this.parent.locale,
                target: this.parent.element.parentElement,
                aggregateTypes: this.parent.aggregateTypes,
                maxNodeLimitInMemberEditor: this.parent.maxNodeLimitInMemberEditor,
                aggregateCellInfo: this.parent.bindTriggerEvents.bind(this.parent),
                onHeadersSort: this.parent.bindTriggerEvents.bind(this.parent),
                cssClass: this.parent.cssClass,
                enableFieldSearching: this.parent.enableFieldSearching,
                enableHtmlSanitizer: this.parent.enableHtmlSanitizer
            });
            this.parent.pivotFieldListModule.isPopupView = true;
            this.parent.pivotFieldListModule.pivotGridModule = this.parent;
            this.parent.pivotFieldListModule.appendTo('#' + this.element.id);
        }
    }
    updateControl() {
        if (this.parent.allowDeferLayoutUpdate) {
            this.parent.actionObj.actionName = 'Field list refreshed';
        }
        if (this.element) {
            this.element.style.display = 'block';
            prepend([this.element], this.parent.element);
            if (this.parent.showGroupingBar && this.parent.groupingBarModule) {
                clearTimeout(this.timeOutObj);
                this.timeOutObj = setTimeout(this.update.bind(this));
            }
            else if (!isNullOrUndefined((this.element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS)))) {
                setStyleAttribute(this.element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS), {
                    left: 'auto'
                });
                if (this.parent.enableRtl) {
                    removeClass([this.element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS)], 'e-fieldlist-left');
                }
                else {
                    addClass([this.element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS)], 'e-fieldlist-left');
                }
            }
            setStyleAttribute(this.element, {
                width: formatUnit(this.parent.element.offsetWidth)
            });
        }
        this.parent.pivotFieldListModule.update(this.parent);
    }
    update() {
        let currentWidth;
        if (this.parent.currentView !== 'Table') {
            currentWidth = this.parent.chart ? this.parent.pivotChartModule.getCalulatedWidth() : currentWidth;
        }
        else {
            currentWidth = this.parent.grid ? this.parent.grid.element.offsetWidth : currentWidth;
        }
        if (currentWidth && (!isNullOrUndefined((this.element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS))))) {
            const actualWidth = currentWidth < 400 ? 400 : currentWidth;
            setStyleAttribute(this.element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS), {
                left: formatUnit(this.parent.enableRtl ?
                    -Math.abs((actualWidth) -
                        this.element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS).offsetWidth) :
                    (actualWidth) -
                        this.element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS).offsetWidth),
                top: this.parent.element.querySelector('.' + FIELD_PANEL_SCROLL_CLASS) ? this.parent.element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS).offsetHeight.toString() + 'px' : ''
            });
            if (this.parent.enableRtl) {
                addClass([this.element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS)], 'e-fieldlist-left');
            }
            else {
                removeClass([this.element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS)], 'e-fieldlist-left');
            }
        }
    }
    /**
     *
     * @returns {void}
     * @hidden
     */
    addEventListener() {
        this.handlers = {
            load: this.initiateModule,
            update: this.updateControl
        };
        if (this.parent.isDestroyed) {
            return;
        }
        this.parent.on(initSubComponent, this.handlers.load, this);
        this.parent.on(uiUpdate, this.handlers.update, this);
    }
    /**
     *
     * @returns {void}
     * @hidden
     */
    removeEventListener() {
        if (this.parent.isDestroyed) {
            return;
        }
        this.parent.off(initSubComponent, this.handlers.load);
        this.parent.off(uiUpdate, this.handlers.update);
    }
    /**
     * To destroy the Field List.
     *
     * @returns {void}
     * @hidden
     */
    destroy() {
        this.removeEventListener();
        if (this.parent.pivotFieldListModule && !this.parent.pivotFieldListModule.isDestroyed) {
            this.parent.pivotFieldListModule.destroy();
            this.parent.pivotFieldListModule = null;
            if (!isNullOrUndefined(select('#' + this.parent.element.id + '_PivotFieldList', document))) {
                remove(select('#' + this.parent.element.id + '_PivotFieldList', document));
            }
        }
        else {
            return;
        }
    }
}

/**
 * Module to render Axis Fields
 */
/** @hidden */
class AxisFields {
    /** Constructor for render module
     *
     * @param {PivotView} parent - Instance.
     */
    constructor(parent) {
        this.parent = parent;
    }
    /**
     * Initialize the grouping bar pivot button rendering
     *
     * @returns {void}
     * @private
     */
    render() {
        if ((!this.parent.pivotButtonModule || (this.parent.pivotButtonModule && this.parent.pivotButtonModule.isDestroyed))) {
            new PivotButton(this.parent);
        }
        this.createPivotButtons();
        let pivotButtons = []; // eslint-disable-next-line @typescript-eslint/no-explicit-any
        for (const element of this.parent.element.querySelectorAll('.' + GROUP_ROW_CLASS)) {
            if (!element.classList.contains(GROUP_CHART_ROW)) {
                pivotButtons = pivotButtons.concat([].slice.call(element.querySelectorAll('.' + PIVOT_BUTTON_WRAPPER_CLASS)));
            }
        }
        const vlen = pivotButtons.length;
        for (let j = 0; j < vlen; j++) {
            const indentWidth = 24;
            const indentDiv = createElement('span', {
                className: 'e-indent-div',
                styles: 'width:' + j * indentWidth + 'px'
            });
            prepend([indentDiv], pivotButtons[j]);
        }
    }
    createPivotButtons() {
        const fields = [this.parent.dataSourceSettings.rows, this.parent.dataSourceSettings.columns,
            this.parent.dataSourceSettings.values, this.parent.dataSourceSettings.filters];
        for (const element of this.parent.element.querySelectorAll('.' + GROUP_ALL_FIELDS_CLASS + ',.' + GROUP_ROW_CLASS + ',.' + GROUP_COLUMN_CLASS + ',.'
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            + GROUP_VALUE_CLASS + ',.' + GROUP_FILTER_CLASS)) {
            if ((this.parent.dataSourceSettings.values.length > 0 ? !element.classList.contains(GROUP_CHART_VALUE) : true) ||
                (this.parent.dataSourceSettings.columns.length > 0 ? !element.classList.contains(GROUP_CHART_COLUMN) : true)) {
                element.innerHTML = '';
            }
        }
        if ((this.parent.dataType === 'pivot' && this.parent.dataSourceSettings.dataSource && this.parent.dataSourceSettings.dataSource.length > 0) ||
            (this.parent.dataType === 'olap' && this.parent.dataSourceSettings.url && this.parent.dataSourceSettings.url !== '') ||
            (this.parent.dataSourceSettings.mode === 'Server' && this.parent.dataSourceSettings.url && this.parent.dataSourceSettings.url !== '')) {
            /* eslint-enable @typescript-eslint/no-explicit-any */
            const axis = ['rows', 'columns', 'values', 'filters'];
            if (this.parent.dataType === 'pivot' && this.parent.groupingBarSettings.showFieldsPanel) {
                axis.push('all-fields');
                fields.push([]);
                for (const key of (this.parent.engineModule && this.parent.engineModule.fieldList ?
                    Object.keys(this.parent.engineModule.fieldList) : [])) {
                    if (this.parent.engineModule.fieldList[key] &&
                        !this.parent.engineModule.fieldList[key].isSelected) {
                        fields[fields.length - 1].push(PivotUtil.getFieldInfo(key, this.parent, true).fieldItem);
                    }
                }
            }
            for (let i = 0, lnt = fields.length; i < lnt; i++) {
                if (fields[i]) {
                    const args = {
                        field: fields[i],
                        axis: axis[i].toString()
                    };
                    this.parent.notify(pivotButtonUpdate, args);
                }
            }
        }
    }
}

/**
 * Module for GroupingBar rendering
 */
/** @hidden */
class GroupingBar {
    /** Constructor for GroupingBar module */
    constructor(parent) {
        /* eslint-enable */
        this.parent = parent;
        this.parent.groupingBarModule = this;
        this.resColWidth = (this.parent.isAdaptive ? 180 : 249);
        this.addEventListener();
        this.parent.axisFieldModule = new AxisFields(this.parent);
        this.touchObj = new Touch(this.parent.element, {
            tapHold: this.tapHoldHandler.bind(this)
        });
    }
    /**
     * For internal use only - Get the module name.
     *
     * @returns {string} - Module name.
     * @private
     */
    getModuleName() {
        return 'groupingBar';
    }
    /* eslint-disable-next-line */
    /** @hidden */
    renderLayout() {
        this.groupingTable = createElement('div', { className: GROUPING_BAR_CLASS });
        this.leftAxisPanel = createElement('div', { className: LEFT_AXIS_PANEL_CLASS });
        this.rightAxisPanel = createElement('div', { className: RIGHT_AXIS_PANEL_CLASS });
        const rowAxisPanel = createElement('div', { className: AXIS_ROW_CLASS + ' ' + AXIS_ICON_CLASS + 'container' });
        const columnAxisPanel = createElement('div', {
            className: AXIS_COLUMN_CLASS + ' ' + AXIS_ICON_CLASS + 'container'
        });
        const valueAxisPanel = createElement('div', {
            className: AXIS_VALUE_CLASS + ' ' + AXIS_ICON_CLASS + 'container'
        });
        const filterAxisPanel = createElement('div', {
            className: AXIS_FILTER_CLASS + ' ' + AXIS_ICON_CLASS + 'container'
        });
        this.rowPanel = createElement('div', { className: GROUP_ROW_CLASS + ' ' + ROW_AXIS_CLASS });
        this.columnPanel = createElement('div', { className: GROUP_COLUMN_CLASS + ' ' + COLUMN_AXIS_CLASS });
        this.valuePanel = createElement('div', { className: GROUP_VALUE_CLASS + ' ' + VALUE_AXIS_CLASS });
        this.filterPanel = createElement('div', { className: GROUP_FILTER_CLASS + ' ' + FILTER_AXIS_CLASS });
        rowAxisPanel.appendChild(this.rowPanel);
        columnAxisPanel.appendChild(this.columnPanel);
        valueAxisPanel.appendChild(this.valuePanel);
        filterAxisPanel.appendChild(this.filterPanel);
        this.rowAxisPanel = rowAxisPanel;
        this.columnAxisPanel = columnAxisPanel;
        this.valueAxisPanel = valueAxisPanel;
        this.filterAxisPanel = filterAxisPanel;
        this.leftAxisPanel.appendChild(valueAxisPanel);
        this.leftAxisPanel.appendChild(rowAxisPanel);
        this.rightAxisPanel.appendChild(filterAxisPanel);
        this.rightAxisPanel.appendChild(columnAxisPanel);
        this.groupingTable.appendChild(createElement('div', { styles: 'display:flex;' }));
        this.groupingTable.firstElementChild.appendChild(this.leftAxisPanel);
        this.groupingTable.firstElementChild.appendChild(this.rightAxisPanel);
        if (this.parent.dataType === 'pivot' && this.parent.groupingBarSettings != null && this.parent.groupingBarSettings.showFieldsPanel) {
            this.gridPanel = this.createToolbarUI(this.groupingTable);
        }
        this.groupingTable.classList.add(GRID_GROUPING_BAR_CLASS);
        this.groupingTable.querySelector('.' + GROUP_ROW_CLASS).classList.add(GROUP_PIVOT_ROW);
        const axisPanels = [this.rowPanel, this.columnPanel, this.valuePanel, this.filterPanel];
        for (const element of axisPanels) {
            if (this.parent.groupingBarSettings.allowDragAndDrop) {
                new Droppable(element, {});
            }
            this.unWireEvent(element);
            this.wireEvent(element);
        }
        if (this.parent.displayOption.view !== 'Table' && this.parent.groupingBarSettings.displayMode !== 'Table') {
            this.groupingChartTable = this.groupingTable.cloneNode(true);
            if (select('#' + this.parent.element.id + '_AllFields', this.groupingChartTable)) {
                select('#' + this.parent.element.id + '_AllFields', this.groupingChartTable).remove();
                this.chartPanel = this.createToolbarUI(this.groupingChartTable);
            }
            this.groupingChartTable.classList.add(CHART_GROUPING_BAR_CLASS);
            this.groupingChartTable.classList.remove(GRID_GROUPING_BAR_CLASS);
            this.groupingChartTable.querySelector('.' + GROUP_ROW_CLASS).classList.add(GROUP_CHART_ROW);
            this.groupingChartTable.querySelector('.' + GROUP_ROW_CLASS).classList.remove(GROUP_PIVOT_ROW);
            if (this.parent.chartSettings.enableMultipleAxis && this.parent.chartSettings.chartSeries &&
                ['Pie', 'Pyramid', 'Doughnut', 'Funnel'].indexOf(this.parent.chartSettings.chartSeries.type) < 0) {
                this.groupingChartTable.querySelector('.' + GROUP_VALUE_CLASS).classList.add(GROUP_CHART_MULTI_VALUE);
            }
            else {
                this.groupingChartTable.querySelector('.' + GROUP_VALUE_CLASS).classList.add(GROUP_CHART_VALUE);
            }
            if (this.parent.chartSettings.chartSeries &&
                ['Pie', 'Pyramid', 'Doughnut', 'Funnel'].indexOf(this.parent.chartSettings.chartSeries.type) > -1) {
                this.groupingChartTable.querySelector('.' + GROUP_COLUMN_CLASS).classList.add(GROUP_CHART_COLUMN);
            }
            else {
                this.groupingChartTable.querySelector('.' + GROUP_COLUMN_CLASS).classList.add(GROUP_CHART_ACCUMULATION_COLUMN);
            }
            this.groupingChartTable.querySelector('.' + GROUP_FILTER_CLASS).classList.add(GROUP_CHART_FILTER);
        }
        else {
            this.groupingChartTable = undefined;
        }
        if (this.parent.displayOption.view === 'Chart' || this.parent.groupingBarSettings.displayMode === 'Chart') {
            this.groupingTable = undefined;
        }
    }
    /* eslint-disable  */
    appendToElement() {
        if (this.parent.element.querySelector('.' + GRID_CLASS) || this.parent.element.querySelector('.' + PIVOTCHART)) {
            if (this.parent.showGroupingBar) {
                if (this.parent.element.querySelector('.' + GROUPING_BAR_CLASS)) {
                    for (let element of this.parent.element.querySelectorAll('.' + GROUPING_BAR_CLASS)) {
                        remove(element);
                    }
                }
                if (this.groupingChartTable) {
                    if (select('#' + this.parent.element.id + '_chart', this.parent.element)) {
                        setStyleAttribute(this.groupingChartTable, {
                            width: formatUnit(this.parent.grid ? this.parent.getGridWidthAsNumber() : this.parent.getWidthAsNumber())
                        });
                        this.parent.element.insertBefore(this.groupingChartTable, select('#' + this.parent.element.id + '_chart', this.parent.element));
                        if (this.groupingChartTable.querySelector('.' + ALL_FIELDS_PANEL_CLASS) && this.chartPanel != null && !this.chartPanel.isDestroyed) {
                            let chartPanelWidth = this.parent.grid ? (this.parent.getGridWidthAsNumber() - 2) : (this.parent.getWidthAsNumber() - 2);
                            this.chartPanel.width = chartPanelWidth < 400 ? '398px' : chartPanelWidth;
                            this.chartPanel.refreshOverflow();
                            if (this.parent.showFieldList && this.parent.pivotFieldListModule && this.parent.pivotFieldListModule.element) {
                                clearTimeout(this.timeOutObj);
                                this.timeOutObj = setTimeout(this.alignIcon.bind(this));
                            }
                        }
                    }
                    else {
                        this.groupingChartTable = undefined;
                    }
                }
                if (this.parent.displayOption.view !== 'Chart' && this.groupingTable) {
                    if (this.parent.isAdaptive) {
                        this.leftAxisPanel.style.minWidth = '180px';
                        this.valuePanel.style.minWidth = '180px';
                    }
                    if (this.parent.firstColWidth) {
                        this.leftAxisPanel.style.minWidth = 'auto';
                        this.valuePanel.style.minWidth = 'auto';
                    }
                    this.filterPanel.removeAttribute('style');
                    this.columnPanel.removeAttribute('style');
                    this.rowPanel.removeAttribute('style');
                    this.filterPanel.removeAttribute('style');
                    let emptyRowCount;
                    if (this.parent.dataType === 'olap') {
                        emptyRowCount = this.parent.olapEngineModule.headerContent ?
                            Object.keys(this.parent.olapEngineModule.headerContent).length : 0;
                    }
                    else {
                        emptyRowCount = this.parent.engineModule.headerContent ?
                            Object.keys(this.parent.engineModule.headerContent).length : 0;
                    }
                    if (!isNullOrUndefined(emptyRowCount)) {
                        let emptyHeader = this.parent.element.querySelector('.e-frozenheader').querySelector('.e-columnheader');
                        emptyHeader.removeAttribute('style');
                        addClass([emptyHeader.querySelector('.e-headercell')], 'e-group-row');
                        emptyHeader.querySelector('.e-group-row').appendChild(this.rowAxisPanel);
                        emptyHeader.querySelector('.e-group-row').querySelector('.e-headercelldiv').style.display = 'none';
                        emptyHeader.querySelector('.e-group-row').querySelector('.e-sortfilterdiv').style.display = 'none';
                    }
                    this.parent.element.insertBefore(this.groupingTable, this.parent.element.querySelector('.' + GRID_CLASS));
                    setStyleAttribute(this.groupingTable, {
                        width: formatUnit(this.parent.grid ? this.parent.getGridWidthAsNumber() : this.parent.getWidthAsNumber())
                    });
                    if (this.groupingTable && this.groupingTable.querySelector('.' + ALL_FIELDS_PANEL_CLASS) && this.gridPanel != null && !this.gridPanel.isDestroyed) {
                        let gridPanelWidth = this.parent.grid ? (this.parent.getGridWidthAsNumber() - 2) : (this.parent.getWidthAsNumber() - 2);
                        this.gridPanel.width = gridPanelWidth < 400 ? '398px' : gridPanelWidth;
                        this.gridPanel.refreshOverflow();
                    }
                    this.groupingTable.style.minWidth = '400px';
                    this.parent.axisFieldModule.render();
                    this.setGridRowWidth();
                    let colGroupElement = this.parent.element.querySelector('.e-frozenheader').querySelector('colgroup').children[0];
                    let rightAxisPanelWidth = formatUnit(this.groupingTable.offsetWidth - parseInt(colGroupElement.style.width, 10));
                    setStyleAttribute(this.valuePanel, { width: colGroupElement.style.width });
                    setStyleAttribute(this.rightAxisPanel, { width: rightAxisPanelWidth });
                    let rightPanelHeight = (this.valuePanel.offsetHeight / 2);
                    if (rightPanelHeight > this.columnPanel.offsetHeight) {
                        setStyleAttribute(this.filterPanel, { height: formatUnit(rightPanelHeight) });
                        setStyleAttribute(this.columnPanel, { height: formatUnit(rightPanelHeight + 2) });
                    }
                    let topLeftHeight = this.parent.element.querySelector('.e-headercontent').offsetHeight;
                    setStyleAttribute(this.rowPanel, {
                        height: topLeftHeight + 'px'
                    });
                    if (this.parent.element.querySelector('.e-frozenheader').querySelector('.e-rhandler')) {
                        this.parent.element.querySelector('.e-frozenheader').querySelector('.e-rhandler').style.height =
                            topLeftHeight + 'px';
                    }
                    let colRows = [].slice.call(this.parent.element.querySelector('.e-movableheader').querySelector('thead').querySelectorAll('tr'));
                    let columnRows = colRows.filter((trCell) => {
                        return (trCell.childNodes.length > 0);
                    });
                    let colHeight = topLeftHeight / columnRows.length;
                    for (let element of columnRows) {
                        setStyleAttribute(element, { 'height': colHeight + 'px' });
                        let rowHeader = [].slice.call(element.querySelectorAll('.e-rhandler'));
                        for (let rhElement of rowHeader) {
                            setStyleAttribute(rhElement, { 'height': colHeight + 'px' });
                        }
                    }
                }
                else {
                    this.parent.axisFieldModule.render();
                    this.updateChartAxisHeight();
                }
                if (this.parent.showToolbar && this.parent.displayOption.view === 'Both') {
                    if (this.parent.currentView === 'Table') {
                        this.parent.element.querySelector('.e-chart-grouping-bar').style.display = 'none';
                    }
                    else {
                        this.parent.element.querySelector('.e-pivot-grouping-bar').style.display = 'none';
                    }
                }
            }
        }
    }
    updateChartAxisHeight() {
        if (this.groupingChartTable && select('#' + this.parent.element.id + '_chart', this.parent.element)) {
            let rowPanel = this.groupingChartTable.querySelector('.' + GROUP_ROW_CLASS);
            let valuePanel = this.groupingChartTable.querySelector('.' + GROUP_VALUE_CLASS);
            let filterPanel = this.groupingChartTable.querySelector('.' + GROUP_FILTER_CLASS);
            let columnPanel = this.groupingChartTable.querySelector('.' + GROUP_COLUMN_CLASS);
            if (rowPanel && columnPanel) {
                rowPanel.style.height = 'auto';
                columnPanel.style.height = 'auto';
                if (rowPanel.offsetHeight > 0 && columnPanel.offsetHeight > 0) {
                    let maxHeight = rowPanel.offsetHeight > columnPanel.offsetHeight ? rowPanel.offsetHeight : columnPanel.offsetHeight;
                    setStyleAttribute(rowPanel, { height: formatUnit(maxHeight) });
                    setStyleAttribute(columnPanel, { height: formatUnit(maxHeight) });
                }
            }
            if (valuePanel && filterPanel) {
                valuePanel.style.height = 'auto';
                filterPanel.style.height = 'auto';
                if (valuePanel.offsetHeight > 0 && filterPanel.offsetHeight > 0) {
                    let maxHeight = valuePanel.offsetHeight > filterPanel.offsetHeight ? valuePanel.offsetHeight : filterPanel.offsetHeight;
                    setStyleAttribute(valuePanel, { height: formatUnit(maxHeight) });
                    setStyleAttribute(filterPanel, { height: formatUnit(maxHeight) });
                }
            }
        }
    }
    /**
     * @hidden
     */
    refreshUI() {
        if (this.groupingChartTable) {
            setStyleAttribute(this.groupingChartTable, {
                width: formatUnit(this.parent.grid ? this.parent.getGridWidthAsNumber() : this.parent.getWidthAsNumber())
            });
            if (this.groupingChartTable.querySelector('.' + ALL_FIELDS_PANEL_CLASS) && this.chartPanel != null && !this.chartPanel.isDestroyed) {
                let chartPanelWidth = this.parent.grid ? (this.parent.getGridWidthAsNumber() - 2) : (this.parent.getWidthAsNumber() - 2);
                this.chartPanel.width = chartPanelWidth < 400 ? '398px' : chartPanelWidth;
                this.chartPanel.refreshOverflow();
            }
            this.updateChartAxisHeight();
            if (this.parent.showFieldList && this.parent.pivotFieldListModule && this.parent.pivotFieldListModule.element) {
                clearTimeout(this.timeOutObj);
                this.timeOutObj = setTimeout(this.alignIcon.bind(this));
            }
        }
        if (this.groupingTable) {
            setStyleAttribute(this.groupingTable, {
                width: formatUnit(this.parent.grid ? this.parent.getGridWidthAsNumber() : this.parent.getWidthAsNumber())
            });
            if (this.groupingTable && this.groupingTable.querySelector('.' + ALL_FIELDS_PANEL_CLASS) && this.gridPanel != null && !this.gridPanel.isDestroyed) {
                let gridPanelWidth = this.parent.grid ? (this.parent.getGridWidthAsNumber() - 2) : (this.parent.getWidthAsNumber() - 2);
                this.gridPanel.width = gridPanelWidth < 400 ? '398px' : gridPanelWidth;
                this.gridPanel.refreshOverflow();
            }
            this.groupingTable.style.minWidth = '400px';
            let colGroupElement = this.parent.element.querySelector('.e-frozenheader').querySelector('colgroup').children[0];
            let rightAxisWidth = formatUnit(this.groupingTable.offsetWidth - parseInt(colGroupElement.style.width, 10));
            setStyleAttribute(this.valuePanel, { width: colGroupElement.style.width });
            setStyleAttribute(this.rightAxisPanel, { width: rightAxisWidth });
            if (this.parent.showFieldList && this.parent.pivotFieldListModule && this.parent.pivotFieldListModule.element) {
                clearTimeout(this.timeOutObj);
                this.timeOutObj = setTimeout(this.alignIcon.bind(this));
            }
            if (!this.parent.grid.element.querySelector('.e-group-row')) {
                let emptyRowHeader = this.parent.element.querySelector('.e-frozenheader').querySelector('.e-columnheader');
                addClass([emptyRowHeader.querySelector('.e-headercell')], 'e-group-row');
                setStyleAttribute(this.rowPanel, {
                    height: this.parent.element.querySelector('.e-headercontent').offsetHeight + 'px'
                });
                emptyRowHeader.querySelector('.e-group-row').appendChild(this.rowAxisPanel);
                setStyleAttribute(emptyRowHeader.querySelector('.e-group-row').querySelector('.e-headercelldiv'), {
                    display: 'none'
                });
                setStyleAttribute(emptyRowHeader.querySelector('.e-group-row').querySelector('.e-sortfilterdiv'), {
                    display: 'none'
                });
                let groupHeight = this.parent.element.querySelector('.e-headercontent').offsetHeight;
                setStyleAttribute(this.rowPanel, {
                    height: groupHeight + 'px'
                });
                if (this.parent.element.querySelector('.e-frozenheader').querySelector('.e-rhandler')) {
                    this.parent.element.querySelector('.e-frozenheader').querySelector('.e-rhandler').style.height =
                        groupHeight + 'px';
                }
                let colRowElements = [].slice.call(this.parent.element.querySelector('.e-movableheader').querySelector('thead').querySelectorAll('tr'));
                let columnRows = colRowElements.filter((trCell) => {
                    return (trCell.childNodes.length > 0);
                });
                let colHeight = groupHeight / columnRows.length;
                for (let element of columnRows) {
                    setStyleAttribute(element, { 'height': colHeight + 'px' });
                    let rowHeader = [].slice.call(element.querySelectorAll('.e-rhandler'));
                    for (let handlerElement of rowHeader) {
                        setStyleAttribute(handlerElement, { 'height': colHeight + 'px' });
                    }
                }
            }
        }
    }
    /** @hidden */
    alignIcon() {
        let element = this.parent.pivotFieldListModule.element;
        let currentWidth;
        if (this.parent.currentView === 'Table') {
            currentWidth = this.parent.grid ? this.parent.grid.element.offsetWidth : currentWidth;
        }
        else {
            currentWidth = this.parent.chart ? this.parent.pivotChartModule.getCalulatedWidth() : currentWidth;
        }
        if (currentWidth) {
            let actWidth = currentWidth < 400 ? 400 : currentWidth;
            setStyleAttribute(element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS), {
                left: formatUnit(this.parent.enableRtl ?
                    -Math.abs((actWidth) -
                        element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS).offsetWidth) :
                    (actWidth) -
                        element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS).offsetWidth),
                top: this.parent.element.querySelector('.' + FIELD_PANEL_SCROLL_CLASS) ? this.parent.element.querySelector('.' + TOGGLE_FIELD_LIST_CLASS).offsetHeight.toString() + 'px' : ""
            });
        }
    }
    /**
     * @hidden
     */
    setGridRowWidth() {
        let colGroupElement = this.parent.element.querySelector('.e-frozenheader').querySelector('colgroup').children[0];
        if (this.rowPanel.querySelector('.' + PIVOT_BUTTON_CLASS)) {
            if (!this.parent.isAdaptive) {
                let pivotButtons = [].slice.call(this.rowPanel.querySelectorAll('.' + PIVOT_BUTTON_WRAPPER_CLASS));
                let lastButton = pivotButtons[pivotButtons.length - 1];
                let lastButtonWidth = (lastButton.querySelector('.' + PIVOT_BUTTON_CLASS).offsetWidth +
                    lastButton.querySelector('.e-indent-div').offsetWidth + 20);
                let buttonWidth = formatUnit(lastButtonWidth < this.resColWidth ? this.resColWidth : lastButtonWidth);
                let rowHeaderTable = this.parent.element.querySelector('.e-frozenheader').querySelector('table');
                let rowContentTable = this.parent.element.querySelector('.e-frozencontent').querySelector('table');
                let rowContent = this.parent.element.querySelector('.e-frozencontent').querySelector('colgroup').children[0];
                let colwidth = parseInt(buttonWidth, 10);
                let hasPivotColumns = this.parent.pivotColumns.length > 0;
                let gridColumn = this.parent.grid.columns;
                if (gridColumn && gridColumn.length > 0) {
                    gridColumn[0].width = gridColumn[0].autoFit ? gridColumn[0].width : (gridColumn[0].width >= this.resColWidth ?
                        (colwidth > this.resColWidth ? colwidth : this.resColWidth) :
                        (colwidth > this.resColWidth ? colwidth : this.resColWidth));
                }
                let valueColWidth;
                if (this.parent.dataType === 'olap') {
                    valueColWidth = this.parent.renderModule.calculateColWidth(this.parent.olapEngineModule.pivotValues.length > 0 ?
                        this.parent.olapEngineModule.pivotValues[0].length : 2);
                }
                else {
                    valueColWidth = this.parent.renderModule.calculateColWidth((this.parent.dataSourceSettings.values.length > 0 &&
                        this.parent.engineModule.pivotValues.length > 0) ?
                        this.parent.engineModule.pivotValues[0].length : 2);
                }
                for (let cCnt = 0; cCnt < gridColumn.length; cCnt++) {
                    if (cCnt !== 0) {
                        if (gridColumn[cCnt].columns) {
                            this.setColWidth(this.parent.renderModule.pivotColumns[cCnt].columns, valueColWidth);
                        }
                        else {
                            if (gridColumn[cCnt].width !== 'auto') {
                                /* eslint-disable @typescript-eslint/no-explicit-any */
                                let levelName = gridColumn[cCnt].customAttributes ?
                                    gridColumn[cCnt].customAttributes.cell.valueSort.levelName : '';
                                gridColumn[cCnt].width = (gridColumn[cCnt].autoFit || (hasPivotColumns && this.parent.pivotColumns[cCnt].autoFit)) ? gridColumn[cCnt].width : this.parent.renderModule.setSavedWidth(levelName, valueColWidth);
                                /* eslint-enable @typescript-eslint/no-explicit-any */
                            }
                            else {
                                gridColumn[cCnt].minWidth = valueColWidth;
                            }
                        }
                    }
                }
                this.parent.posCount = 0;
                this.parent.setGridColumns(this.parent.grid.columns);
                this.parent.grid.headerModule.refreshUI();
                if (!this.parent.firstColWidth) {
                    buttonWidth = gridColumn[0].autoFit ? gridColumn[0].width.toString() : buttonWidth;
                    colGroupElement.style.width = buttonWidth;
                    rowContent.style.width = buttonWidth;
                    rowHeaderTable.style.width = buttonWidth;
                    rowContentTable.style.width = buttonWidth;
                    setStyleAttribute(rowHeaderTable, { 'width': buttonWidth });
                    setStyleAttribute(rowContentTable, { 'width': buttonWidth });
                }
            }
            else {
                if (!this.parent.firstColWidth) {
                    let gridColumn = this.parent.grid.columns;
                    if (gridColumn && gridColumn.length > 0) {
                        gridColumn[0].width = this.resColWidth;
                    }
                    this.parent.posCount = 0;
                    this.parent.grid.headerModule.refreshUI();
                }
            }
        }
        else {
            if (this.parent.grid.columns && this.parent.grid.columns.length > 0) {
                this.parent.grid.columns[0].width = this.parent.grid.columns[0].width > this.resColWidth ?
                    this.parent.grid.columns[0].width : this.resColWidth;
            }
            this.parent.grid.headerModule.refreshUI();
        }
        if (this.groupingTable) {
            this.refreshUI();
        }
    }
    setColWidth(columns, width) {
        for (let cCnt = 0; cCnt < columns.length; cCnt++) {
            if (columns[cCnt].columns) {
                this.setColWidth(columns[cCnt].columns, width);
            }
            else {
                if (!columns[cCnt].autoFit) {
                    if (columns[cCnt].width !== "auto") {
                        columns[cCnt].width = width;
                    }
                    else {
                        columns[cCnt].minWidth = width;
                    }
                }
            }
        }
    }
    wireEvent(element) {
        EventHandler.add(element, 'mouseover', this.dropIndicatorUpdate, this);
        EventHandler.add(element, 'mouseleave', this.dropIndicatorUpdate, this);
    }
    unWireEvent(element) {
        EventHandler.remove(element, 'mouseover', this.dropIndicatorUpdate);
        EventHandler.remove(element, 'mouseleave', this.dropIndicatorUpdate);
    }
    dropIndicatorUpdate(e) {
        if ((this.parent.isDragging && e.target.classList.contains(DROPPABLE_CLASS) && e.type === 'mouseover') ||
            (!this.parent.isDragging || (!e.target.classList.contains(DROPPABLE_CLASS) && e.type === 'mouseleave'))) {
            removeClass([].slice.call(this.parent.element.querySelectorAll('.' + DROP_INDICATOR_CLASS)), INDICATOR_HOVER_CLASS);
            removeClass([].slice.call(this.parent.element.querySelectorAll('.' + DROP_INDICATOR_CLASS + '-last')), INDICATOR_HOVER_CLASS);
        }
    }
    tapHoldHandler(e) {
        let target = closest(e.originalEvent.target, '.' + PIVOT_BUTTON_CLASS);
        if (!isNullOrUndefined(target) && this.parent.isAdaptive) {
            let pos = target.getBoundingClientRect();
            this.parent.contextMenuModule.fieldElement = target;
            this.parent.contextMenuModule.menuObj.open(pos.top, pos.left);
            return;
        }
    }
    /**
     * @hidden
     */
    RefreshFieldsPanel() {
        if (this.parent.dataType === 'pivot' && this.parent.groupingBarSettings != null) {
            if (selectAll('#' + this.parent.element.id + '_AllFields', this.parent.element).length > 0) {
                for (let element of selectAll('#' + this.parent.element.id + '_AllFields', this.parent.element)) {
                    element.remove();
                }
            }
            if (this.parent.groupingBarSettings.showFieldsPanel) {
                if (this.groupingChartTable && this.parent.displayOption.view !== 'Table' && this.parent.groupingBarSettings.displayMode !== 'Table') {
                    this.chartPanel = this.createToolbarUI(this.groupingChartTable);
                }
                if (this.groupingTable) {
                    this.gridPanel = this.createToolbarUI(this.groupingTable);
                }
                this.parent.axisFieldModule.render();
                this.refreshUI();
            }
        }
    }
    createToolbarUI(element) {
        if (select('#' + this.parent.element.id + '_AllFields', element)) {
            select('#' + this.parent.element.id + '_AllFields', element).remove();
        }
        element.prepend(createElement('div', { id: this.parent.element.id + '_AllFields' }));
        let toolbarObj = new Toolbar$1({
            cssClass: ALL_FIELDS_PANEL_CLASS + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
            enableRtl: this.parent.enableRtl, enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
            items: [{ template: '<div class=' + GROUP_ALL_FIELDS_CLASS + '></div>' }],
            allowKeyboard: false,
            width: this.parent.grid ? (this.parent.getGridWidthAsNumber() - 2) : (this.parent.getWidthAsNumber() - 2)
        });
        toolbarObj.appendTo(select('#' + this.parent.element.id + '_AllFields', element));
        return toolbarObj;
    }
    /**
     * @hidden
     */
    addEventListener() {
        this.handlers = {
            load: this.renderLayout,
            end: this.appendToElement,
        };
        if (this.parent.isDestroyed) {
            return;
        }
        this.parent.on(initSubComponent, this.handlers.load, this); //For initial rendering
        this.parent.on(uiUpdate, this.handlers.end, this);
    }
    /**
     * @hidden
     */
    removeEventListener() {
        if (this.parent.isDestroyed) {
            return;
        }
        this.parent.off(uiUpdate, this.handlers.end);
        this.parent.off(initSubComponent, this.handlers.load);
    }
    /**
     * To destroy the groupingbar
     * @returns {void}
     * @hidden
     */
    destroy() {
        this.removeEventListener();
        if (this.parent.pivotButtonModule) {
            this.parent.pivotButtonModule.destroy();
        }
        if (this.groupingTable && this.groupingTable.querySelector('.' + ALL_FIELDS_PANEL_CLASS) && this.gridPanel != null && !this.gridPanel.isDestroyed) {
            this.gridPanel.destroy();
            this.gridPanel = null;
        }
        if (this.groupingChartTable && this.groupingChartTable.querySelector('.' + ALL_FIELDS_PANEL_CLASS) && this.chartPanel != null && !this.chartPanel.isDestroyed) {
            this.chartPanel.destroy();
            this.chartPanel = null;
        }
        if (this.touchObj && !this.touchObj.isDestroyed) {
            this.touchObj.destroy();
        }
        if (this.parent.element.querySelector('.' + GROUPING_BAR_CLASS)) {
            remove(this.parent.element.querySelector('.' + GROUPING_BAR_CLASS));
        }
    }
}

/**
 * Module to render Conditional Formatting Dialog
 */
/** @hidden */
class ConditionalFormatting {
    /** Constructor for conditionalformatting module
     *
     * @param {PivotView} parent - Instance of pivot table.
     */
    constructor(parent) {
        this.parent = parent;
        this.parent.conditionalFormattingModule = this;
        this.parentID = this.parent.element.id;
        this.dialog = null;
        this.fieldsDropDown = [];
        this.conditionsDropDown = [];
        this.fontNameDropDown = [];
        this.fontSizeDropDown = [];
        this.fontColor = [];
        this.backgroundColor = [];
        this.newFormat = [];
    }
    /**
     * To get module name.
     *
     * @returns {string} - Module name.
     */
    getModuleName() {
        return 'conditionalFormatting';
    }
    createDialog() {
        if (select('#' + this.parentID + 'conditionalformatting', document) !== null) {
            remove(select('#' + this.parentID + 'conditionalformatting', document));
        }
        this.parent.element.appendChild(createElement('div', {
            id: this.parentID + 'conditionalformatting',
            className: FORMAT_DIALOG
        }));
        const buttonModel = [
            {
                click: this.addButtonClick.bind(this),
                buttonModel: {
                    cssClass: (this.parent.isAdaptive ? (FORMAT_ROUND_BUTTON + ' ' + FORMAT_CONDITION_BUTTON) :
                        FORMAT_CONDITION_BUTTON) + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
                    iconCss: ICON + ' ' + ADD_ICON_CLASS,
                    content: this.parent.isAdaptive ? '' : this.parent.localeObj.getConstant('condition')
                }
            },
            {
                click: this.applyButtonClick.bind(this),
                isFlat: true,
                buttonModel: {
                    isPrimary: true, cssClass: FORMAT_APPLY_BUTTON + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
                    content: this.parent.localeObj.getConstant('apply')
                }
            },
            {
                click: this.cancelButtonClick.bind(this),
                isFlat: true,
                buttonModel: {
                    cssClass: FORMAT_CANCEL_BUTTON + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
                    content: this.parent.localeObj.getConstant('cancel')
                }
            }
        ];
        if (this.parent.isAdaptive) {
            this.dialog = new Dialog({
                animationSettings: { effect: 'Zoom' }, isModal: true, width: '100%', height: '100%',
                showCloseIcon: false, closeOnEscape: false, enableRtl: this.parent.enableRtl, locale: this.parent.locale,
                enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
                position: { X: 'center', Y: 'center' }, allowDragging: true, buttons: buttonModel,
                beforeOpen: this.beforeOpen.bind(this), close: this.removeDialog.bind(this),
                cssClass: this.parent.cssClass, header: this.parent.localeObj.getConstant('conditionalFormating'), target: document.body
            });
        }
        else {
            this.dialog = new Dialog({
                allowDragging: true, position: { X: 'center', Y: this.parent.element.offsetTop }, buttons: buttonModel,
                beforeOpen: this.beforeOpen.bind(this), close: this.removeDialog.bind(this),
                cssClass: this.parent.cssClass, isModal: true, closeOnEscape: true,
                enableRtl: this.parent.enableRtl, locale: this.parent.locale, enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
                showCloseIcon: true, header: this.parent.localeObj.getConstant('conditionalFormating'), target: this.parent.element
            });
        }
        this.dialog.isStringTemplate = true;
        this.dialog.appendTo('#' + this.parentID + 'conditionalformatting');
        // this.dialog.element.querySelector('.e-dlg-header').innerText = this.parent.localeObj.getConstant('conditionalFormating');
    }
    beforeOpen() {
        this.dialog.element.querySelector('.' + DIALOG_HEADER).
            setAttribute('title', this.parent.localeObj.getConstant('conditionalFormating'));
    }
    addButtonClick() {
        const format = {
            conditions: 'LessThan',
            value1: 0,
            applyGrandTotals: true,
            style: {
                backgroundColor: 'white',
                color: 'black',
                fontFamily: 'Arial',
                fontSize: '12px'
            }
        }; // eslint-disable-next-line @typescript-eslint/no-this-alias
        const conditionalFormating = this;
        this.parent.trigger(conditionalFormatting, format, (observedArgs) => {
            conditionalFormating.refreshConditionValues();
            this.destroyColorPickers();
            conditionalFormating.newFormat.push(observedArgs);
            conditionalFormating.addFormat();
        });
    }
    applyButtonClick() {
        if (this.refreshConditionValues()) {
            this.parent.setProperties({ dataSourceSettings: { conditionalFormatSettings: this.newFormat } }, true);
            const actionInfo = {
                conditionalFormattingInfo: this.parent.dataSourceSettings.conditionalFormatSettings
            };
            this.parent.actionObj.actionInfo = actionInfo;
            if (this.parent.dataSourceSettings.values.length > 0) {
                this.parent.renderPivotGrid();
            }
            this.dialog.close();
        }
    }
    cancelButtonClick() {
        this.dialog.close();
        this.newFormat = [];
    }
    refreshConditionValues() {
        for (let i = 0; i < this.newFormat.length; i++) {
            if (select('#' + this.parentID + 'conditionvalue1' + i, document).value === '' ||
                select('#' + this.parentID + 'conditionvalue2' + i, document).value === '') {
                if (select('#' + this.parentID + 'conditionvalue1' + i, document).value === '') {
                    select('#' + this.parentID + 'conditionvalue1' + i, document).focus();
                }
                else {
                    select('#' + this.parentID + 'conditionvalue2' + i, document).focus();
                }
                return false;
            }
            this.newFormat[i].value1 =
                Number(select('#' + this.parentID + 'conditionvalue1' + i, document).value);
            this.newFormat[i].value2 =
                Number(select('#' + this.parentID + 'conditionvalue2' + i, document).value);
        }
        return true;
    }
    addFormat() {
        const format = createElement('div', { id: this.parentID + 'formatDiv', className: FORMAT_NEW });
        for (let i = 0; i < this.newFormat.length; i++) {
            format.appendChild(this.createDialogElements(i));
        }
        if (this.newFormat.length === 0) {
            const outerDiv = this.createDialogElements();
            const element = createElement('p', {
                id: this.parentID + 'emptyFormat',
                className: EMPTY_FORMAT
            });
            element.innerText = this.parent.localeObj.getConstant('emptyFormat');
            outerDiv.appendChild(element);
            format.appendChild(outerDiv);
        }
        this.dialog.setProperties({ 'content': format }, false);
        for (let i = 0; i < this.newFormat.length; i++) {
            this.renderDropDowns(i);
            this.renderColorPicker(i);
        }
    }
    createDialogElements(i) {
        const outerDiv = createElement('div', {
            id: this.parentID + 'outerDiv' + i, className: FORMAT_OUTER
        });
        if (i !== undefined) {
            const format = this.newFormat[i];
            const button = createElement('button', {
                id: this.parentID + 'removeButton' + i, className: FORMAT_DELETE_BUTTON,
                attrs: { type: 'button', 'title': this.parent.localeObj.getConstant('delete') }
            });
            outerDiv.appendChild(button);
            const innerDiv = createElement('div', { id: this.parentID + 'innerDiv' + i, className: FORMAT_INNER });
            let table = createElement('table', { id: this.parentID + 'cftable' + i, className: FORMAT_TABLE, attrs: { 'role': 'table' } });
            let tRow = createElement('tr');
            let td = createElement('td');
            const valuelabel = createElement('span', {
                id: this.parentID + 'valuelabel' + i, className: FORMAT_VALUE_LABEL
            });
            valuelabel.innerText = this.parent.localeObj.getConstant('value');
            td.appendChild(valuelabel);
            tRow.appendChild(td);
            table.appendChild(tRow);
            tRow = createElement('tr');
            td = createElement('td');
            const measureDropdown = createElement('div', { id: this.parentID + 'measure' + i });
            const measureInput = createElement('input', {
                id: this.parentID + 'measureinput' + i,
                attrs: { 'type': 'text', 'tabindex': '0' }
            });
            measureDropdown.appendChild(measureInput);
            td.appendChild(measureDropdown);
            tRow.appendChild(td);
            td = createElement('td');
            const conditionDropdown = createElement('div', { id: this.parentID + 'condition' + i });
            const conditionInput = createElement('input', {
                id: this.parentID + 'conditioninput' + i,
                attrs: { 'type': 'text', 'tabindex': '0' }
            });
            conditionDropdown.appendChild(conditionInput);
            td.appendChild(conditionDropdown);
            tRow.appendChild(td);
            td = createElement('td');
            const style = !(format.conditions === 'Between' || format.conditions === 'NotBetween') ? 'display:none; width:10px' : '';
            const value1 = createElement('input', {
                id: this.parentID + 'conditionvalue1' + i,
                attrs: {
                    'type': 'text', 'tabindex': '0', 'value': !isNullOrUndefined(format.value1) ? format.value1.toString() : '0',
                    'placeholder': this.parent.localeObj.getConstant('emptyInput')
                },
                styles: this.parent.isAdaptive ? style === '' ? 'width: 35%' : 'width: 100%' : style === '' ? 'width: 45px' :
                    'width: 120px',
                className: INPUT + ' ' + FORMAT_VALUE1
            });
            td.appendChild(value1);
            const valuespan = createElement('span', {
                id: this.parentID + 'valuespan' + i, className: FORMAT_VALUE_SPAN,
                innerHTML: '&', styles: style
            });
            td.appendChild(valuespan);
            const value2 = createElement('input', {
                id: this.parentID + 'conditionvalue2' + i,
                attrs: {
                    'type': 'text', 'tabindex': '0', 'value': !isNullOrUndefined(format.value2) ? format.value2.toString() : '0',
                    'placeholder': this.parent.localeObj.getConstant('emptyInput')
                },
                styles: (this.parent.isAdaptive && style === '') ? 'width: 35%' : style === '' ? 'width: 45px' : style,
                className: INPUT + ' ' + FORMAT_VALUE2
            });
            td.appendChild(value2);
            tRow.appendChild(td);
            table.appendChild(tRow);
            if (this.parent.isAdaptive) {
                innerDiv.appendChild(table);
                table = createElement('table', { id: this.parentID + 'cftable', className: FORMAT_TABLE, attrs: { 'role': 'table' } });
            }
            tRow = createElement('tr');
            td = createElement('td');
            const formatlabel = createElement('span', {
                id: this.parentID + 'formatlabel' + i, className: FORMAT_LABEL
            });
            formatlabel.innerText = this.parent.localeObj.getConstant('formatLabel');
            td.appendChild(formatlabel);
            tRow.appendChild(td);
            table.appendChild(tRow);
            tRow = createElement('tr');
            td = createElement('td');
            const fontNameDropdown = createElement('div', { id: this.parentID + 'fontname' + i });
            const fontNameInput = createElement('input', {
                id: this.parentID + 'fontnameinput' + i, attrs: { 'type': 'text', 'tabindex': '0' }
            });
            fontNameDropdown.appendChild(fontNameInput);
            td.appendChild(fontNameDropdown);
            tRow.appendChild(td);
            td = createElement('td');
            const fontSizeDropdown = createElement('div', { id: this.parentID + 'fontsize' + i });
            const fontSizeInput = createElement('input', {
                id: this.parentID + 'fontsizeinput' + i, attrs: { 'type': 'text', 'tabindex': '0' }
            });
            fontSizeDropdown.appendChild(fontSizeInput);
            td.appendChild(fontSizeDropdown);
            tRow.appendChild(td);
            if (this.parent.isAdaptive) {
                table.appendChild(tRow);
                tRow = createElement('tr');
                table.appendChild(tRow);
                tRow = createElement('tr');
            }
            td = createElement('td');
            const colorPicker1 = createElement('input', {
                id: this.parentID + 'fontcolor' + i, attrs: { 'type': 'color', 'tabindex': '0' }, className: FORMAT_FONT_COLOR
            });
            td.appendChild(colorPicker1);
            const colorPicker2 = createElement('input', {
                id: this.parentID + 'backgroundcolor' + i, attrs: { 'type': 'color', 'tabindex': '0' }, className: FORMAT_BACK_COLOR
            });
            td.appendChild(colorPicker2);
            tRow.appendChild(td);
            td = createElement('td');
            const valuePreview = createElement('div', {
                id: this.parentID + 'valuepreview' + i, className: INPUT + ' ' + FORMAT_VALUE_PREVIEW,
                innerHTML: '123.45'
            });
            td.appendChild(valuePreview);
            tRow.appendChild(td);
            table.appendChild(tRow);
            innerDiv.appendChild(table);
            outerDiv.appendChild(innerDiv);
        }
        return outerDiv;
    }
    renderDropDowns(i) {
        const format = this.newFormat[i];
        const fields = [];
        fields.push({
            index: 0, name: this.parent.localeObj.getConstant('AllValues'),
            field: this.parent.localeObj.getConstant('AllValues')
        });
        for (let i = 0; i < this.parent.dataSourceSettings.values.length; i++) {
            let caption = this.parent.dataSourceSettings.values[i].caption ||
                this.parent.dataSourceSettings.values[i].name;
            caption = this.parent.enableHtmlSanitizer ? SanitizeHtmlHelper.sanitize(caption) : caption;
            fields.push({
                index: i + 1,
                name: caption,
                field: this.parent.dataSourceSettings.values[i].name
            });
        }
        let value = isNullOrUndefined(format.measure) ? this.parent.localeObj.getConstant('AllValues') : format.measure;
        this.fieldsDropDown[i] = new DropDownList({
            dataSource: fields, fields: { text: 'name', value: 'field' },
            value: value, width: this.parent.isAdaptive ? '100%' : '120px',
            cssClass: this.parent.cssClass,
            popupHeight: '200px', popupWidth: 'auto', locale: this.parent.locale, enableRtl: this.parent.enableRtl,
            change: this.measureChange.bind(this, i)
        });
        this.fieldsDropDown[i].isStringTemplate = true;
        this.fieldsDropDown[i].appendTo('#' + this.parentID + 'measureinput' + i);
        const conditions = [
            { value: 'LessThan', name: this.parent.localeObj.getConstant('LessThan') },
            { value: 'LessThanOrEqualTo', name: this.parent.localeObj.getConstant('LessThanOrEqualTo') },
            { value: 'GreaterThan', name: this.parent.localeObj.getConstant('GreaterThan') },
            { value: 'GreaterThanOrEqualTo', name: this.parent.localeObj.getConstant('GreaterThanOrEqualTo') },
            { value: 'Equals', name: this.parent.localeObj.getConstant('Equals') },
            { value: 'NotEquals', name: this.parent.localeObj.getConstant('NotEquals') },
            { value: 'Between', name: this.parent.localeObj.getConstant('Between') },
            { value: 'NotBetween', name: this.parent.localeObj.getConstant('NotBetween') }
        ];
        value = isNullOrUndefined(format.conditions) ? 'LessThan' : format.conditions;
        this.conditionsDropDown[i] = new DropDownList({
            dataSource: conditions, fields: { value: 'value', text: 'name' },
            value: value, width: this.parent.isAdaptive ? '100%' : '120px',
            cssClass: this.parent.cssClass,
            popupHeight: '200px', popupWidth: 'auto', locale: this.parent.locale, enableRtl: this.parent.enableRtl,
            change: this.conditionChange.bind(this, i)
        });
        this.conditionsDropDown[i].isStringTemplate = true;
        this.conditionsDropDown[i].appendTo('#' + this.parentID + 'conditioninput' + i);
        const fontNames = [
            { index: 0, name: 'Arial' }, { index: 1, name: 'San Serif' }, { index: 2, name: 'Impact' },
            { index: 3, name: 'Trebuchet MS' }, { index: 4, name: 'Serif' }, { index: 5, name: 'Verdana' },
            { index: 6, name: 'Courier New' }, { index: 7, name: 'Times New Roman' }, { index: 8, name: 'Tahoma' },
            { index: 9, name: 'Gerogia' }
        ];
        value = isNullOrUndefined(format.style.fontFamily) ? 'Arial' : format.style.fontFamily;
        this.fontNameDropDown[i] = new DropDownList({
            dataSource: fontNames, fields: { text: 'name' },
            value: value, width: this.parent.isAdaptive ? '100%' : '120px',
            cssClass: this.parent.cssClass,
            popupWidth: '150px', popupHeight: '200px', locale: this.parent.locale, enableRtl: this.parent.enableRtl,
            change: this.fontNameChange.bind(this, i)
        });
        this.fontNameDropDown[i].isStringTemplate = true;
        this.fontNameDropDown[i].appendTo('#' + this.parentID + 'fontnameinput' + i);
        const fontSize = [
            { index: 0, name: '9px' }, { index: 1, name: '10px' }, { index: 2, name: '11px' }, { index: 3, name: '12px' },
            { index: 4, name: '13px' }, { index: 5, name: '14px' }, { index: 6, name: '15px' }, { index: 6, name: '16px' }
        ];
        value = isNullOrUndefined(format.style.fontSize) ? '12px' : format.style.fontSize;
        this.fontSizeDropDown[i] = new DropDownList({
            dataSource: fontSize, fields: { text: 'name' }, popupHeight: '200px',
            value: value, width: this.parent.isAdaptive ? '100%' : '120px',
            change: this.fontSizeChange.bind(this, i),
            locale: this.parent.locale, enableRtl: this.parent.enableRtl,
            cssClass: this.parent.cssClass
        });
        this.fontSizeDropDown[i].isStringTemplate = true;
        this.fontSizeDropDown[i].appendTo('#' + this.parentID + 'fontsizeinput' + i);
    }
    conditionChange(i, args) {
        this.newFormat[i].conditions = args.value;
        if (args.value === 'Between' || args.value === 'NotBetween') {
            select('#' + this.parentID + 'valuespan' + i, document).style.display = 'inline-block';
            select('#' + this.parentID + 'valuespan' + i, document).style.width =
                this.parent.isAdaptive ? '10%' : '10px';
            select('#' + this.parentID + 'conditionvalue2' + i, document).style.display = 'inline-block';
            select('#' + this.parentID + 'conditionvalue2' + i, document).style.width =
                this.parent.isAdaptive ? '35%' : '45px';
            select('#' + this.parentID + 'conditionvalue1' + i, document).style.width =
                this.parent.isAdaptive ? '35%' : '45px';
        }
        else {
            select('#' + this.parentID + 'valuespan' + i, document).style.display = 'none';
            select('#' + this.parentID + 'conditionvalue2' + i, document).style.display = 'none';
            select('#' + this.parentID + 'conditionvalue1' + i, document).style.width =
                this.parent.isAdaptive ? '100%' : '120px';
        }
    }
    fontNameChange(i, args) {
        this.newFormat[i].style.fontFamily = args.value.toString();
        select('#' + this.parentID + 'valuepreview' + i, document).style.fontFamily = args.value;
    }
    fontSizeChange(i, args) {
        this.newFormat[i].style.fontSize = args.value.toString();
        select('#' + this.parentID + 'valuepreview' + i, document).style.fontSize = args.value;
    }
    measureChange(i, args) {
        this.newFormat[i].measure = args.value.toString() === this.parent.localeObj.getConstant('AllValues') ?
            undefined : args.value.toString();
    }
    renderColorPicker(i) {
        const format = this.newFormat[i];
        let value = isNullOrUndefined(format.style.color) ? 'black' : format.style.color;
        let color = this.isHex(value.substr(1)) ? value : this.colourNameToHex(value);
        select('#' + this.parentID + 'valuepreview' + i, document).style.color = color;
        this.fontColor[i] = new ColorPicker({
            cssClass: FORMAT_COLOR_PICKER + ' ' + FORMAT_FONT_COLOR_PICKER + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
            value: color, mode: 'Palette',
            change: this.fontColorChange.bind(this, i),
            locale: this.parent.locale, enableRtl: this.parent.enableRtl
        });
        this.fontColor[i].isStringTemplate = true;
        this.fontColor[i].appendTo('#' + this.parentID + 'fontcolor' + i);
        addClass([this.fontColor[i].element.nextElementSibling.querySelector('.' + SELECTED_COLOR)], ICON);
        value = isNullOrUndefined(format.style.backgroundColor) ? 'white' : format.style.backgroundColor;
        color = this.isHex(value.substr(1)) ? value : this.colourNameToHex(value);
        select('#' + this.parentID + 'valuepreview' + i, document).style.backgroundColor = color;
        select('#' + this.parentID + 'valuepreview' + i, document).style.fontFamily = format.style.fontFamily;
        select('#' + this.parentID + 'valuepreview' + i, document).style.fontSize = format.style.fontSize;
        this.backgroundColor[i] = new ColorPicker({
            cssClass: FORMAT_COLOR_PICKER + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''), value: color, mode: 'Palette',
            change: this.backColorChange.bind(this, i),
            locale: this.parent.locale, enableRtl: this.parent.enableRtl
        });
        this.backgroundColor[i].isStringTemplate = true;
        this.backgroundColor[i].appendTo('#' + this.parentID + 'backgroundcolor' + i);
        addClass([this.backgroundColor[i].element.nextElementSibling.querySelector('.e-selected-color')], ICON);
        const toggleBtn = new Button({
            iconCss: ICON + ' ' + FORMAT_DELETE_ICON,
            cssClass: FLAT + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''), locale: this.parent.locale, enableRtl: this.parent.enableRtl,
            enableHtmlSanitizer: this.parent.enableHtmlSanitizer
        });
        toggleBtn.isStringTemplate = true;
        toggleBtn.appendTo('#' + this.parentID + 'removeButton' + i);
        toggleBtn.element.onclick = this.toggleButtonClick.bind(this, i);
    }
    backColorChange(i, args) {
        this.newFormat[i].style.backgroundColor = args.currentValue.hex;
        select('#' + this.parentID + 'valuepreview' + i, document).style.backgroundColor =
            args.currentValue.hex;
    }
    fontColorChange(i, args) {
        this.newFormat[i].style.color = args.currentValue.hex;
        select('#' + this.parentID + 'valuepreview' + i, document).style.color =
            args.currentValue.hex;
    }
    toggleButtonClick(i) {
        this.destroyColorPickers();
        this.newFormat.splice(i, 1);
        this.addFormat();
    }
    /**
     * To check is Hex or not.
     *
     * @param {string} h - It represent the hex value.
     * @returns {boolean} - It returns the isHex value as boolean.
     * @hidden
     */
    isHex(h) {
        const a = parseInt(h, 16);
        while (h.charAt(0) === '0') {
            h = h.substr(1);
        }
        return (a.toString(16) === h.toLowerCase() || (a === 0 && h === ''));
    }
    /**
     * To convert hex to RGB.
     *
     * @param {string} hex - hex value.
     * @returns { { r: number, g: number, b: number } | null } - Hex value.
     * @hidden
     */
    hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : null;
    }
    /**
     * To convert color to hex.
     *
     * @param {string} colour - It contains the color value.
     * @returns {string} - It returns the colour Name To Hex.
     * @hidden
     */
    colourNameToHex(colour) {
        const colours = {
            'aliceblue': '#f0f8ff', 'antiquewhite': '#faebd7', 'aqua': '#00ffff', 'aquamarine': '#7fffd4',
            'azure': '#f0ffff', 'beige': '#f5f5dc', 'bisque': '#ffe4c4', 'black': '#000000',
            'blanchedalmond': '#ffebcd', 'blue': '#0000ff',
            'blueviolet': '#8a2be2', 'brown': '#a52a2a', 'burlywood': '#deb887', 'cadetblue': '#5f9ea0',
            'chartreuse': '#7fff00', 'chocolate': '#d2691e',
            'coral': '#ff7f50', 'cornflowerblue': '#6495ed', 'cornsilk': '#fff8dc', 'crimson': '#dc143c', 'cyan': '#00ffff',
            'darkblue': '#00008b', 'darkcyan': '#008b8b', 'darkgoldenrod': '#b8860b', 'darkgray': '#a9a9a9', 'darkgreen': '#006400',
            'darkkhaki': '#bdb76b', 'darkmagenta': '#8b008b', 'darkolivegreen': '#556b2f',
            'darkorange': '#ff8c00', 'darkorchid': '#9932cc', 'darkred': '#8b0000', 'darksalmon': '#e9967a', 'darkseagreen': '#8fbc8f',
            'darkslateblue': '#483d8b', 'darkslategray': '#2f4f4f', 'darkturquoise': '#00ced1',
            'darkviolet': '#9400d3', 'deeppink': '#ff1493', 'deepskyblue': '#00bfff', 'dimgray': '#696969', 'dodgerblue': '#1e90ff',
            'firebrick': '#b22222', 'floralwhite': '#fffaf0', 'forestgreen': '#228b22', 'fuchsia': '#ff00ff',
            'gainsboro': '#dcdcdc', 'ghostwhite': '#f8f8ff', 'gold': '#ffd700', 'goldenrod': '#daa520',
            'gray': '#808080', 'green': '#008000',
            'greenyellow': '#adff2f', 'honeydew': '#f0fff0', 'hotpink': '#ff69b4', 'indianred ': '#cd5c5c',
            'indigo': '#4b0082', 'ivory': '#fffff0',
            'khaki': '#f0e68c', 'lavender': '#e6e6fa', 'lavenderblush': '#fff0f5', 'lawngreen': '#7cfc00', 'lemonchiffon': '#fffacd',
            'lightblue': '#add8e6', 'lightcoral': '#f08080', 'lightcyan': '#e0ffff', 'lightgoldenrodyellow': '#fafad2',
            'lightgrey': '#d3d3d3', 'lightgreen': '#90ee90', 'lightpink': '#ffb6c1', 'lightsalmon': '#ffa07a', 'lightseagreen': '#20b2aa',
            'lightskyblue': '#87cefa', 'lightslategray': '#778899', 'lightsteelblue': '#b0c4de',
            'lightyellow': '#ffffe0', 'lime': '#00ff00', 'limegreen': '#32cd32', 'linen': '#faf0e6',
            'magenta': '#ff00ff', 'maroon': '#800000', 'mediumaquamarine': '#66cdaa', 'mediumblue': '#0000cd', 'mediumorchid': '#ba55d3',
            'mediumpurple': '#9370d8', 'mediumseagreen': '#3cb371', 'mediumslateblue': '#7b68ee',
            'mediumspringgreen': '#00fa9a', 'mediumturquoise': '#48d1cc', 'mediumvioletred': '#c71585', 'midnightblue': '#191970',
            'mintcream': '#f5fffa', 'mistyrose': '#ffe4e1', 'moccasin': '#ffe4b5', 'navajowhite': '#ffdead', 'navy': '#000080',
            'oldlace': '#fdf5e6', 'olive': '#808000', 'olivedrab': '#6b8e23', 'orange': '#ffa500', 'orangered': '#ff4500',
            'orchid': '#da70d6',
            'palegoldenrod': '#eee8aa', 'palegreen': '#98fb98', 'paleturquoise': '#afeeee', 'palevioletred': '#d87093',
            'papayawhip': '#ffefd5',
            'peachpuff': '#ffdab9', 'peru': '#cd853f', 'pink': '#ffc0cb', 'plum': '#dda0dd', 'powderblue': '#b0e0e6', 'purple': '#800080',
            'rebeccapurple': '#663399', 'red': '#ff0000', 'rosybrown': '#bc8f8f', 'royalblue': '#4169e1',
            'saddlebrown': '#8b4513', 'salmon': '#fa8072', 'sandybrown': '#f4a460', 'seagreen': '#2e8b57',
            'seashell': '#fff5ee', 'sienna': '#a0522d',
            'silver': '#c0c0c0', 'skyblue': '#87ceeb', 'slateblue': '#6a5acd', 'slategray': '#708090', 'snow': '#fffafa',
            'springgreen': '#00ff7f',
            'steelblue': '#4682b4', 'tan': '#d2b48c', 'teal': '#008080', 'thistle': '#d8bfd8', 'tomato': '#ff6347', 'turquoise': '#40e0d0',
            'violet': '#ee82ee', 'wheat': '#f5deb3', 'white': '#ffffff', 'whitesmoke': '#f5f5f5', 'yellow': '#ffff00',
            'yellowgreen': '#9acd32'
        };
        if (typeof colours[colour.toLowerCase()] !== 'undefined') {
            return colours[colour.toLowerCase()];
        }
        else if (colour.search('rgba') === 0) {
            const value = colour.substr(5).split(')')[0].split(',');
            let rgb = '';
            let a = '';
            for (let i = 0; i < value.length - 1; i++) {
                value[i] = (+value[i]).toString(16);
                if (value[i].length === 1) {
                    value[i] = '0' + value[i];
                }
                rgb = rgb + value[i];
            }
            a = (Math.round(+value[3] * 255)).toString(16);
            return '#' + rgb + a;
        }
        else if (colour.search('rgb') === 0) {
            const value = colour.substr(4).split(')')[0].split(',');
            let rgb = '';
            for (let i = 0; i < value.length; i++) {
                value[i] = (+value[i]).toString(16);
                if (value[i].length === 1) {
                    value[i] = '0' + value[i];
                }
                rgb = rgb + value[i];
            }
            return '#' + rgb;
        }
        return '#d5d5d5';
    }
    removeDialog() {
        if (this.dialog && !this.dialog.isDestroyed) {
            this.destroyColorPickers();
            this.dialog.destroy();
        }
        if (select('#' + this.parentID + 'conditionalformatting', document)) {
            remove(select('#' + this.parentID + 'conditionalformatting', document));
        }
    }
    destroyColorPickers() {
        for (let i = 0; i < (this.newFormat ? this.newFormat.length : 0); i++) {
            if (this.fontColor && this.fontColor[i] && !this.fontColor[i].isDestroyed) {
                this.fontColor[i].destroy();
            }
            if (this.backgroundColor && this.backgroundColor[i] && !this.backgroundColor[i].isDestroyed) {
                this.backgroundColor[i].destroy();
            }
        }
    }
    /**
     * To create Conditional Formatting dialog.
     *
     * @returns {void}
     * @hidden
     */
    showConditionalFormattingDialog() {
        this.newFormat = [];
        for (let i = 0; i < this.parent.dataSourceSettings.conditionalFormatSettings.length; i++) {
            this.newFormat.push(extend({}, this.parent.dataSourceSettings.conditionalFormatSettings[i].properties, null, true));
        }
        this.createDialog();
        this.dialog.refresh();
        this.addFormat();
    }
    /**
     * To destroy the Conditional Formatting dialog
     *
     * @returns {void}
     * @hidden
     */
    destroy() {
        if (this.dialog && !this.dialog.isDestroyed) {
            this.dialog.close();
        }
        else {
            return;
        }
    }
}

/**
 * Module for Toolbar
 */
/** @hidden */
class Toolbar$2 {
    constructor(parent) {
        /** @hidden */
        this.isMultiAxisChange = false;
        /** @hidden */
        this.isReportChange = false;
        this.currentReport = '';
        this.parent = parent;
        this.parent.toolbarModule = this;
        this.addEventListener();
    }
    /**
     * It returns the Module name.
     *
     * @returns {string} - string
     * @hidden
     */
    getModuleName() {
        return 'toolbar';
    }
    createToolbar() {
        this.parent.isModified = false;
        this.renderDialog();
        if (select('#' + this.parent.element.id + 'pivot-toolbar', document) !== null) {
            remove(select('#' + this.parent.element.id + 'pivot-toolbar', document));
        }
        const element = createElement('div', {
            id: this.parent.element.id + 'pivot-toolbar',
            className: GRID_TOOLBAR
        });
        if (this.parent.showFieldList && select('#' + this.parent.element.id + '_PivotFieldList', this.parent.element)) {
            this.parent.element.insertBefore(element, select('#' + this.parent.element.id + '_PivotFieldList', this.parent.element));
        }
        else if (this.parent.showGroupingBar &&
            select('#' + this.parent.element.id + ' .' + 'e-pivot-grouping-bar', this.parent.element)) {
            this.parent.element.insertBefore(element, select('#' + this.parent.element.id + ' .' + 'e-pivot-grouping-bar', this.parent.element));
        }
        else {
            this.parent.element.insertBefore(element, select('#' + this.parent.element.id + '_grid', this.parent.element));
        }
        this.toolbar = new Toolbar$1({
            created: this.create.bind(this),
            enableRtl: this.parent.enableRtl,
            locale: this.parent.locale,
            enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
            items: this.getItems(),
            allowKeyboard: false,
            cssClass: this.parent.cssClass,
            width: !this.parent.gridSettings.allowAutoResizing ? (this.parent.grid ? (this.parent.getGridWidthAsNumber() - 2) : (this.parent.getWidthAsNumber() - 2)) : 'auto'
        });
        this.toolbar.isStringTemplate = true;
        const viewStr = 'viewContainerRef';
        const registerTemp = 'registeredTemplate';
        /* eslint-disable @typescript-eslint/no-explicit-any */
        if (this.parent[viewStr]) {
            this.toolbar[registerTemp] = {};
            this.toolbar[viewStr] = this.parent[viewStr];
        } /* eslint-enable @typescript-eslint/no-explicit-any */
        if (this.parent.toolbarTemplate && typeof (this.parent.toolbarTemplate) === 'string') {
            this.toolbar.appendTo(this.parent.toolbarTemplate);
            this.parent.element.replaceChild(this.toolbar.element, this.parent.element.querySelector('.' + GRID_TOOLBAR));
            this.toolbar.element.classList.add(GRID_TOOLBAR);
        }
        else {
            this.toolbar.appendTo('#' + this.parent.element.id + 'pivot-toolbar');
        }
        this.toolbar.width = this.parent.grid ? (this.parent.getGridWidthAsNumber() - 2) : (this.parent.getWidthAsNumber() - 2);
        if (this.parent.chart) {
            this.parent.chart.setProperties({ width: this.parent.grid ? this.parent.getGridWidthAsNumber().toString() : this.parent.getWidthAsNumber().toString() }, true);
        }
        if (this.parent.showGroupingBar && this.parent.groupingBarModule &&
            this.parent.element.querySelector('.' + GROUPING_BAR_CLASS)) {
            this.parent.groupingBarModule.refreshUI();
        }
    }
    fetchReports() {
        const reports = { reportName: [] }; // eslint-disable-line @typescript-eslint/no-explicit-any
        this.parent.trigger(fetchReport, reports);
        return reports;
    }
    fetchReportsArgs() {
        const callbackPromise = new Deferred();
        const reports = { reportName: [] };
        this.parent.trigger(fetchReport, reports, (observedArgs) => {
            callbackPromise.resolve(observedArgs);
        });
        return callbackPromise;
    }
    getItems() {
        const toolbar = this.parent.toolbar.filter((v, i, a) => a.indexOf(v) === i);
        const items = [];
        for (const item of toolbar) {
            switch (item) {
                case 'New':
                    items.push({
                        prefixIcon: GRID_NEW + ' ' + ICON, tooltipText: this.parent.localeObj.getConstant('new'),
                        click: this.actionClick.bind(this), id: this.parent.element.id + 'new'
                    });
                    break;
                case 'Save':
                    items.push({
                        prefixIcon: GRID_SAVE + ' ' + ICON, tooltipText: this.parent.localeObj.getConstant('save'),
                        click: this.actionClick.bind(this), id: this.parent.element.id + 'save'
                    });
                    break;
                case 'SaveAs':
                    items.push({
                        prefixIcon: GRID_SAVEAS + ' ' + ICON, tooltipText: this.parent.localeObj.getConstant('saveAs'),
                        click: this.actionClick.bind(this), id: this.parent.element.id + 'saveas'
                    });
                    break;
                case 'Rename':
                    items.push({
                        prefixIcon: GRID_RENAME + ' ' + ICON, tooltipText: this.parent.localeObj.getConstant('rename'),
                        click: this.actionClick.bind(this), id: this.parent.element.id + 'rename'
                    });
                    break;
                case 'Remove':
                    items.push({
                        prefixIcon: GRID_REMOVE + ' ' + ICON, tooltipText: this.parent.localeObj.getConstant('deleteReport'),
                        click: this.actionClick.bind(this), id: this.parent.element.id + 'remove'
                    });
                    break;
                case 'Load':
                    items.push({
                        template: '<div><input class=' + GRID_LOAD + ' id=' + this.parent.element.id + '_reportlist></input></div>',
                        click: this.actionClick.bind(this),
                        id: this.parent.element.id + 'load'
                    });
                    break;
                case 'Grid':
                    {
                        const toDisable = this.parent.displayOption.view === 'Chart';
                        items.push({
                            prefixIcon: TOOLBAR_GRID + ' ' + ICON, tooltipText: this.parent.localeObj.getConstant('grid'),
                            id: this.parent.element.id + 'grid', cssClass: (toDisable ? MENU_DISABLE : '') + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
                            click: this.menuItemClick.bind(this)
                        });
                    }
                    break;
                case 'Chart':
                    {
                        const validTypes = (this.parent.displayOption.view === 'Table');
                        items.push({
                            template: '<ul id="' + this.parent.element.id + 'chart_menu"></ul>',
                            id: this.parent.element.id + 'chartmenu', cssClass: (validTypes ? MENU_DISABLE : '') + (this.parent.cssClass ? (' ' + this.parent.cssClass) : '')
                        });
                    }
                    break;
                case 'MDX':
                    if (this.parent.dataType === 'olap') {
                        items.push({
                            prefixIcon: GRID_MDX + ' ' + ICON, id: this.parent.element.id + 'mdxQuery',
                            click: this.actionClick.bind(this), tooltipText: this.parent.localeObj.getConstant('mdxQuery')
                        });
                    }
                    break;
                case 'Export':
                    items.push({
                        template: '<ul id="' + this.parent.element.id + 'export_menu"></ul>',
                        id: this.parent.element.id + 'exportmenu'
                    });
                    break;
                case 'SubTotal':
                    items.push({
                        template: '<ul id="' + this.parent.element.id + 'subtotal_menu"></ul>',
                        id: this.parent.element.id + 'subtotalmenu'
                    });
                    break;
                case 'GrandTotal':
                    items.push({
                        template: '<ul id="' + this.parent.element.id + 'grandtotal_menu"></ul>',
                        id: this.parent.element.id + 'grandtotalmenu'
                    });
                    break;
                case 'ConditionalFormatting':
                    items.push({
                        prefixIcon: GRID_FORMATTING + ' ' + ICON, id: this.parent.element.id + 'formatting',
                        click: this.actionClick.bind(this), tooltipText: this.parent.localeObj.getConstant('toolbarFormatting')
                    });
                    break;
                case 'NumberFormatting':
                    items.push({
                        prefixIcon: FORMATTING_TOOLBAR + ' ' + ICON, id: this.parent.element.id + 'numberFormatting',
                        click: this.actionClick.bind(this), tooltipText: this.parent.localeObj.getConstant('numberFormat')
                    });
                    break;
                case 'Formatting':
                    items.push({
                        template: '<ul id="' + this.parent.element.id + 'formatting_menu"></ul>',
                        id: this.parent.element.id + 'formattingmenu'
                    });
                    break;
                case 'FieldList':
                    items.push({
                        prefixIcon: TOOLBAR_FIELDLIST + ' ' + ICON, tooltipText: this.parent.localeObj.getConstant('fieldList'),
                        click: this.actionClick.bind(this), align: 'Right', id: this.parent.element.id + 'fieldlist'
                    });
                    if (this.parent.element.querySelector('.e-toggle-field-list')) {
                        this.parent.element.querySelector('.e-toggle-field-list').style.display = 'none';
                    }
                    break;
                default:
                    if (typeof (item) === 'object') {
                        items.push(item);
                    }
            }
        }
        if (this.parent.showFieldList && toolbar.indexOf('FieldList') === -1 && select('#' + this.parent.element.id + '_PivotFieldList', this.parent.element) &&
            select('#' + this.parent.element.id + '_PivotFieldList', this.parent.element).style.display === 'none') {
            select('#' + this.parent.element.id + '_PivotFieldList', this.parent.element).style.display = 'block';
        }
        const toolbarArgs = { customToolbar: items };
        this.parent.trigger(toolbarRender, toolbarArgs);
        return items;
    }
    reportChange(args) {
        this.parent.actionObj.actionName = reportChange;
        this.isReportChange = true;
        if (this.parent.actionBeginMethod()) {
            args.cancel = true;
            return;
        }
        try {
            this.dropArgs = args;
            if (this.parent.isModified && this.currentReport !== '') {
                this.createConfirmDialog(this.parent.localeObj.getConstant('alert'), this.parent.localeObj.getConstant('newReportConfirm'));
            }
            else {
                this.reportLoad(args);
            }
        }
        catch (execption) {
            this.parent.actionFailureMethod(execption);
        }
    }
    reportLoad(args) {
        if (this.action !== 'Save' && this.action !== 'Rename' && this.action !== 'New') {
            const loadArgs = {
                reportName: args.itemData.value
            };
            const actionInfo = {
                reportName: args.itemData.value
            };
            this.parent.actionObj.actionInfo = actionInfo;
            this.parent.trigger(loadReport, loadArgs, (observedArgs) => {
                this.currentReport = observedArgs.reportName;
                this.parent.isModified = false;
            });
        }
    }
    saveReport(args) {
        if (this.currentReport && this.currentReport !== '' && args.item.id === (this.parent.element.id + 'save')) {
            const saveArgs = {
                report: this.getCurrentReport(),
                reportName: this.currentReport
            };
            this.parent.actionObj.actionName = this.parent.getActionCompleteName();
            const actionInfo = {
                reportName: this.currentReport
            };
            this.parent.actionObj.actionInfo = actionInfo;
            this.parent.trigger(saveReport, saveArgs);
            if (this.parent.actionObj.actionName) {
                this.parent.actionCompleteMethod();
            }
            this.parent.isModified = false;
        }
        else if (this.currentReport === '' && (args.item.id === (this.parent.element.id + 'save') || args.item.id === (this.parent.element.id + 'saveas'))) {
            this.parent.pivotCommon.errorDialog.createErrorDialog(this.parent.localeObj.getConstant('error'), this.parent.localeObj.getConstant('emptyReport'));
            return;
        }
        else {
            this.dialogShow(args, 'saveAs');
        }
    }
    mdxQueryDialog() {
        if (!(this.mdxDialog && !this.mdxDialog.isDestroyed)) {
            this.renderMDXDialog();
        }
        const outerDiv = createElement('div', {
            className: MDX_QUERY
        });
        const textarea = createElement('textarea', {
            className: MDX_QUERY_CONTENT,
            attrs: { 'readonly': 'readonly', 'aria-label': this.parent.localeObj.getConstant('mdxQuery') }
        });
        textarea.innerText = this.parent.olapEngineModule.getMDXQuery(this.parent.dataSourceSettings).trim();
        outerDiv.appendChild(textarea);
        this.mdxDialog.content = outerDiv;
        this.mdxDialog.show();
    }
    dialogShow(args, action) {
        if (args) {
            this.dialog.header = args.item.tooltipText;
            const outerDiv = createElement('div', {
                className: GRID_REPORT_OUTER
            });
            const label = createElement('div', {
                className: GRID_REPORT_LABEL
            });
            label.innerText = this.parent.localeObj.getConstant('reportName');
            const input = createElement('input', {
                className: GRID_REPORT_INPUT + ' ' + INPUT,
                attrs: {
                    'placeholder': this.parent.localeObj.getConstant('emptyReportName'),
                    'value': (action && action === 'rename' ? this.currentReport : '')
                }
            });
            input.innerText = (action && action === 'rename' ? this.currentReport : '');
            input.setSelectionRange(input.textContent.length, input.textContent.length);
            outerDiv.appendChild(label);
            outerDiv.appendChild(input);
            this.dialog.content = outerDiv;
            this.dialog.refresh();
            this.dialog.show();
        }
    }
    renameReport(args) {
        this.parent.trigger(toolbarClick, args);
        if (this.currentReport && this.currentReport !== '') {
            this.dialogShow(args, 'rename');
        }
        else {
            this.parent.pivotCommon.errorDialog.createErrorDialog(this.parent.localeObj.getConstant('error'), this.parent.localeObj.getConstant('emptyReport'));
            return;
        }
    }
    actionClick(args) {
        const actionName = (args.item.id === this.parent.element.id + 'new') ? addNewReport : (args.item.id === this.parent.element.id + 'save') ? saveCurrentReport : (args.item.id === this.parent.element.id + 'saveas') ? saveAsCurrentReport
            : (args.item.id === this.parent.element.id + 'rename') ? renameCurrentReport : (args.item.id === this.parent.element.id + 'remove') ? removeCurrentReport : (args.item.id === this.parent.element.id + 'load') ? loadReports
                : (args.item.id === this.parent.element.id + 'formatting') ? openConditionalFormatting : (args.item.id === this.parent.element.id + 'numberFormatting') ? openNumberFormatting
                    : (args.item.id === this.parent.element.id + 'mdxQuery') ? MdxQuery : (args.item.id === this.parent.element.id + 'fieldlist') ? showFieldList : '';
        this.parent.actionObj.actionName = actionName;
        if (this.parent.actionBeginMethod()) {
            return;
        }
        try {
            switch (args.item.id) {
                case (this.parent.element.id + 'save'):
                case (this.parent.element.id + 'saveas'):
                    this.saveReport(args);
                    break;
                case (this.parent.element.id + 'remove'):
                    this.action = 'Remove';
                    if (this.currentReport && this.currentReport !== '') {
                        this.createConfirmDialog(this.parent.localeObj.getConstant('alert'), this.parent.localeObj.getConstant('removeConfirm'));
                    }
                    else {
                        this.parent.pivotCommon.errorDialog.createErrorDialog(this.parent.localeObj.getConstant('error'), this.parent.localeObj.getConstant('emptyReport'));
                    }
                    return;
                case (this.parent.element.id + 'rename'):
                    this.renameReport(args);
                    break;
                case (this.parent.element.id + 'new'):
                    this.action = 'New';
                    this.newArgs = args;
                    if (this.parent.isModified && this.currentReport && this.currentReport !== '') {
                        this.createConfirmDialog(this.parent.localeObj.getConstant('alert'), this.parent.localeObj.getConstant('newReportConfirm'));
                    }
                    else {
                        this.createNewReport(args);
                    }
                    break;
                case (this.parent.element.id + 'load'):
                    this.action = 'Load';
                    break;
                case (this.parent.element.id + 'fieldlist'):
                    if (this.parent.pivotFieldListModule && this.parent.pivotFieldListModule.dialogRenderer) {
                        this.parent.pivotFieldListModule.dialogRenderer.onShowFieldList();
                    }
                    break;
                case (this.parent.element.id + 'formatting'):
                    if (this.parent.conditionalFormattingModule) {
                        this.parent.conditionalFormattingModule.showConditionalFormattingDialog();
                    }
                    break;
                case (this.parent.element.id + 'mdxQuery'):
                    this.mdxQueryDialog();
                    break;
                case (this.parent.element.id + 'numberFormatting'):
                    if (this.parent.numberFormattingModule) {
                        this.parent.numberFormattingModule.showNumberFormattingDialog();
                    }
                    break;
            }
        }
        catch (execption) {
            this.parent.actionFailureMethod(execption);
        }
    }
    renderDialog() {
        if (select('#' + this.parent.element.id + 'report-dialog', document) !== null) {
            remove(select('#' + this.parent.element.id + 'report-dialog', document));
        }
        this.parent.element.appendChild(createElement('div', {
            id: this.parent.element.id + 'report-dialog',
            className: GRID_REPORT_DIALOG
        }));
        this.dialog = new Dialog({
            animationSettings: { effect: 'Fade' },
            allowDragging: true,
            position: { X: 'center', Y: 'center' },
            buttons: [
                {
                    click: this.okBtnClick.bind(this),
                    buttonModel: {
                        content: this.parent.localeObj.getConstant('ok'),
                        isPrimary: true
                    }
                },
                {
                    click: this.cancelBtnClick.bind(this),
                    buttonModel: {
                        content: this.parent.localeObj.getConstant('cancel')
                    }
                }
            ],
            isModal: true,
            visible: false,
            showCloseIcon: true,
            enableRtl: this.parent.enableRtl,
            locale: this.parent.locale,
            enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
            width: 'auto',
            height: 'auto',
            zIndex: 1000001,
            closeOnEscape: true,
            target: document.body,
            cssClass: this.parent.cssClass
        });
        this.dialog.isStringTemplate = true;
        this.dialog.appendTo('#' + this.parent.element.id + 'report-dialog');
    }
    renderMDXDialog() {
        if (select('#' + this.parent.element.id + 'mdx-dialog', document) !== null) {
            remove(select('#' + this.parent.element.id + 'mdx-dialog', document));
        }
        this.parent.element.appendChild(createElement('div', {
            id: this.parent.element.id + 'mdx-dialog',
            className: GRID_MDX_DIALOG
        }));
        this.mdxDialog = new Dialog({
            animationSettings: { effect: 'Fade' },
            allowDragging: true,
            position: { X: 'center', Y: 'center' },
            buttons: [
                {
                    click: this.copyMDXQuery.bind(this),
                    buttonModel: {
                        content: this.parent.localeObj.getConstant('copy'),
                        isPrimary: true
                    }
                }
            ],
            header: this.parent.localeObj.getConstant('mdxQuery'),
            isModal: true,
            visible: false,
            showCloseIcon: true,
            enableRtl: this.parent.enableRtl,
            locale: this.parent.locale,
            enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
            width: 'auto',
            height: 'auto',
            zIndex: 1000001,
            closeOnEscape: true,
            target: document.body,
            cssClass: this.parent.cssClass
        });
        this.mdxDialog.isStringTemplate = true;
        this.mdxDialog.appendTo('#' + this.parent.element.id + 'mdx-dialog');
    }
    copyMDXQuery() {
        const textArea = this.mdxDialog.element.querySelector('.' + MDX_QUERY_CONTENT);
        try {
            textArea.select();
            document.execCommand('copy');
        }
        catch (err) {
            window.alert('Oops, unable to copy');
        }
        return;
    }
    okBtnClick() {
        const reportInput = this.dialog.element.querySelector('.' + GRID_REPORT_INPUT);
        if (reportInput && reportInput.value === '') {
            reportInput.focus();
            return;
        }
        if ((this.dialog.header === this.parent.localeObj.getConstant('save') ||
            this.dialog.header === this.parent.localeObj.getConstant('saveAs')) &&
            reportInput.value && reportInput.value !== '') {
            this.action = 'Save';
            this.currentReport = reportInput.value;
            let isExist = false;
            // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-this-alias
            const _this = this;
            const reports = { reportName: [] };
            this.parent.trigger(fetchReport, reports, (observedArgs) => {
                for (let i = 0; i < observedArgs.reportName.length; i++) {
                    if (reportInput.value === observedArgs.reportName[i]) {
                        isExist = true;
                        break;
                    }
                }
                if (isExist) {
                    _this.createConfirmDialog(_this.parent.localeObj.getConstant('alert'), _this.parent.localeObj.getConstant('replaceConfirmBefore') + '"' + reportInput.value + '"' +
                        _this.parent.localeObj.getConstant('replaceConfirmAfter'));
                    return;
                }
                const saveArgs = {
                    report: _this.getCurrentReport(),
                    reportName: reportInput.value
                };
                const actionInfo = {
                    reportName: reportInput.value
                };
                this.parent.actionObj.actionInfo = actionInfo;
                _this.parent.trigger(saveReport, saveArgs);
                _this.parent.isModified = false;
                _this.updateReportList();
                _this.dialog.hide();
            });
        }
        else if (this.dialog.header === this.parent.localeObj.getConstant('new') &&
            reportInput.value && reportInput.value !== '') {
            this.action = 'New';
            this.currentReport = reportInput.value;
            let isExist = false;
            // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-this-alias
            const _this = this;
            const reports = { reportName: [] };
            this.parent.trigger(fetchReport, reports, (observedArgs) => {
                for (let i = 0; i < observedArgs.reportName.length; i++) {
                    if (reportInput.value === reports.reportName[i]) {
                        isExist = true;
                        break;
                    }
                }
                if (isExist) {
                    _this.createConfirmDialog(_this.parent.localeObj.getConstant('alert'), _this.parent.localeObj.getConstant('replaceConfirmBefore') + '"' + reportInput.value + '"' +
                        _this.parent.localeObj.getConstant('replaceConfirmAfter'));
                    return;
                }
                _this.parent.trigger(newReport);
                const saveArgs = {
                    report: _this.getCurrentReport(),
                    reportName: reportInput.value
                };
                const actionInfo = {
                    reportName: reportInput.value
                };
                this.parent.actionObj.actionInfo = actionInfo;
                _this.parent.trigger(saveReport, saveArgs);
                _this.parent.isModified = false;
                _this.updateReportList();
                _this.dialog.hide();
            });
        }
        else if (this.dialog.header === this.parent.localeObj.getConstant('rename') && reportInput.value && reportInput.value !== '') {
            if (this.currentReport === reportInput.value) {
                this.dialog.hide();
                return;
            }
            this.action = 'Rename';
            let isExist = false;
            this.renameText = reportInput.value;
            for (let i = 0; i < this.reportList.dataSource.length; i++) {
                if (reportInput.value === this.reportList.dataSource[i]) {
                    isExist = true;
                    break;
                }
            }
            if (isExist) {
                this.createConfirmDialog(this.parent.localeObj.getConstant('alert'), this.parent.localeObj.getConstant('replaceConfirmBefore') + '"' + reportInput.value + '"' +
                    this.parent.localeObj.getConstant('replaceConfirmAfter'));
                return;
            }
            const renameArgs = {
                reportName: this.currentReport,
                rename: reportInput.value
            };
            const actionInfo = {
                reportName: { oldName: this.currentReport, newName: reportInput.value }
            };
            this.parent.actionObj.actionInfo = actionInfo;
            this.parent.trigger(renameReport, renameArgs);
            this.currentReport = reportInput.value;
            this.updateReportList();
            this.dialog.hide();
        }
        this.parent.actionObj.actionName = this.parent.getActionCompleteName();
        if (this.parent.actionObj.actionName) {
            this.parent.actionCompleteMethod();
        }
    }
    createNewReport(args) {
        this.dialogShow(args);
    }
    cancelBtnClick() {
        this.dialog.hide();
    }
    createConfirmDialog(title, description) {
        if (document.getElementById(this.parent.element.id + '_ConfirmDialog')) {
            remove(document.getElementById(this.parent.element.id + '_ConfirmDialog').parentElement);
        }
        const errorDialog = createElement('div', {
            id: this.parent.element.id + '_ConfirmDialog',
            className: ERROR_DIALOG_CLASS
        });
        this.parent.element.appendChild(errorDialog);
        this.confirmPopUp = new Dialog({
            animationSettings: { effect: 'Fade' },
            allowDragging: true,
            showCloseIcon: true,
            enableRtl: this.parent.enableRtl,
            locale: this.parent.locale,
            enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
            header: title,
            content: description,
            isModal: true,
            visible: true,
            closeOnEscape: true,
            target: document.body,
            cssClass: this.parent.cssClass,
            width: 'auto',
            height: 'auto',
            position: { X: 'center', Y: 'center' },
            buttons: [
                {
                    buttonModel: {
                        content: this.parent.localeObj.getConstant('yes'), isPrimary: true,
                        cssClass: OK_BUTTON_CLASS + (this.parent.cssClass ? (' ' + this.parent.cssClass) : '')
                    },
                    click: this.okButtonClick.bind(this)
                },
                {
                    buttonModel: {
                        content: this.parent.localeObj.getConstant('no'),
                        cssClass: CANCEL_BUTTON_CLASS + (this.parent.cssClass ? (' ' + this.parent.cssClass) : '')
                    },
                    click: this.cancelButtonClick.bind(this)
                }
            ]
        });
        this.confirmPopUp.isStringTemplate = true;
        this.confirmPopUp.appendTo(errorDialog);
        this.confirmPopUp.element.querySelector('.e-dlg-header').innerText = this.parent.enableHtmlSanitizer ? SanitizeHtmlHelper.sanitize(title) : title;
    }
    okButtonClick() {
        if (this.action === 'Remove') {
            const removeArgs = {
                reportName: this.currentReport
            };
            const actionInfo = {
                reportName: this.currentReport
            };
            this.parent.actionObj.actionInfo = actionInfo;
            this.parent.trigger(removeReport, removeArgs);
            const reports = this.fetchReports();
            if (reports.reportName && reports.reportName.length > 0) {
                const loadArgs = {
                    reportName: reports.reportName[reports.reportName.length - 1]
                };
                this.parent.trigger(loadReport, loadArgs, (observedArgs) => {
                    this.currentReport = observedArgs.reportName;
                    this.parent.isModified = false;
                });
                this.currentReport = reports.reportName[reports.reportName.length - 1];
            }
            else {
                this.currentReport = '';
                this.parent.isModified = false;
                this.action = '';
            }
            this.updateReportList();
            this.parent.actionObj.actionName = reportRemoved;
            if (this.parent.actionObj.actionName) {
                this.parent.actionCompleteMethod();
            }
        }
        else if (this.action === 'New' || (this.action !== 'Save' && this.action !== 'Rename' && this.action !== 'New')) {
            if (this.currentReport && this.currentReport !== '' && this.parent.isModified) {
                const saveArgs = {
                    report: this.getCurrentReport(),
                    reportName: this.currentReport
                };
                const actionInfo = {
                    reportName: this.currentReport
                };
                this.parent.actionObj.actionInfo = actionInfo;
                this.parent.actionObj.actionName = reportSaved;
                if (this.parent.actionObj.actionName) {
                    this.parent.actionCompleteMethod();
                }
                this.parent.trigger(saveReport, saveArgs);
                this.parent.isModified = false;
                if (this.action === 'New') {
                    this.parent.actionObj.actionName = addNewReport;
                    this.createNewReport(this.newArgs);
                }
                else {
                    this.parent.actionObj.actionName = reportChange;
                    this.reportLoad(this.dropArgs);
                }
            }
            else if (this.action === 'New') {
                this.parent.trigger(newReport);
                const saveArgs = {
                    report: this.getCurrentReport(),
                    reportName: this.currentReport
                };
                this.parent.trigger(saveReport, saveArgs);
                this.parent.isModified = false;
                this.updateReportList();
                this.dialog.hide();
            }
        }
        else if (this.action === 'Save') {
            const saveArgs = {
                report: this.getCurrentReport(),
                reportName: this.currentReport
            };
            this.parent.trigger(saveReport, saveArgs);
            this.parent.isModified = false;
            this.updateReportList();
            this.dialog.hide();
        }
        else if (this.action === 'Rename') {
            const renameArgs = {
                reportName: this.currentReport,
                rename: this.renameText,
                isReportExists: true
            };
            this.parent.trigger(renameReport, renameArgs);
            this.currentReport = this.renameText;
            this.parent.isModified = false;
            this.updateReportList();
            this.dialog.hide();
        }
        this.confirmPopUp.hide();
    }
    cancelButtonClick() {
        if (this.action === 'New') {
            if (this.parent.isModified) {
                this.createNewReport(this.newArgs);
            }
            else {
                this.dialog.hide();
            }
        }
        else if (this.action === 'Save') {
            this.currentReport = this.reportList.value;
            this.dialog.hide();
        }
        else if (this.action === 'Rename') {
            this.dialog.hide();
        }
        else if (this.dropArgs && this.action !== 'Remove') {
            this.reportLoad(this.dropArgs);
        }
        this.confirmPopUp.hide();
    }
    /**
     *
     * @returns {void}
     * @hidden
     */
    createChartMenu() {
        if (select('#' + this.parent.element.id + 'chart_menu', document)) {
            const menuItems = [];
            const types = this.getValidChartType();
            for (let i = 0; (i < types.length && i < 7); i++) {
                const type = types[i];
                menuItems.push({
                    text: this.parent.localeObj.getConstant(type.toLowerCase()),
                    id: this.parent.element.id + '_' + type
                });
            }
            if (menuItems.length === 7) {
                menuItems.splice(6);
                menuItems.push({
                    text: this.parent.localeObj.getConstant('MoreOption'),
                    id: this.parent.element.id + '_' + 'ChartMoreOption'
                });
            }
            const toDisable = (menuItems.length <= 0 || this.parent.displayOption.view === 'Table');
            menuItems.push({
                separator: true
            });
            menuItems.push({
                text: this.parent.localeObj.getConstant('multipleAxes'),
                id: this.parent.element.id + '_' + 'multipleAxes'
            });
            menuItems.push({
                text: this.parent.localeObj.getConstant('showLegend'),
                id: this.parent.element.id + '_' + 'showLegend'
            });
            const menu = [{
                    iconCss: TOOLBAR_CHART + ' ' + ICON,
                    items: toDisable ? [] : menuItems
                }];
            if (this.chartMenu && !this.chartMenu.isDestroyed) {
                this.chartMenu.destroy();
            }
            this.chartMenu = new Menu({
                items: menu, enableRtl: this.parent.enableRtl,
                locale: this.parent.locale,
                enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
                cssClass: TOOLBAR_MENU + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
                select: this.menuItemClick.bind(this),
                beforeOpen: this.whitespaceRemove.bind(this),
                onClose: () => {
                    this.focusToolBar();
                },
                beforeItemRender: this.multipleAxesCheckbox.bind(this)
            });
            this.chartMenu.isStringTemplate = true;
            this.chartMenu.appendTo('#' + this.parent.element.id + 'chart_menu');
        }
    }
    create() {
        if (select('#' + this.parent.element.id + 'chart_menu', this.parent.element)) {
            this.createChartMenu();
        }
        if (select('#' + this.parent.element.id + 'export_menu', this.parent.element)) {
            const menu = [{
                    iconCss: GRID_EXPORT + ' ' + ICON,
                    items: [
                        {
                            text: this.parent.localeObj.getConstant('pdf'),
                            iconCss: GRID_PDF_EXPORT + ' ' + ICON,
                            id: this.parent.element.id + 'pdf'
                        },
                        {
                            text: this.parent.localeObj.getConstant('excel'),
                            iconCss: GRID_EXCEL_EXPORT + ' ' + ICON,
                            id: this.parent.element.id + 'excel'
                        },
                        {
                            text: this.parent.localeObj.getConstant('csv'),
                            iconCss: GRID_CSV_EXPORT + ' ' + ICON,
                            id: this.parent.element.id + 'csv'
                        },
                        {
                            text: this.parent.localeObj.getConstant('png'),
                            iconCss: GRID_PNG_EXPORT + ' ' + ICON,
                            id: this.parent.element.id + 'png'
                        },
                        {
                            text: this.parent.localeObj.getConstant('jpeg'),
                            iconCss: GRID_JPEG_EXPORT + ' ' + ICON,
                            id: this.parent.element.id + 'jpeg'
                        },
                        {
                            text: this.parent.localeObj.getConstant('svg'),
                            iconCss: GRID_SVG_EXPORT + ' ' + ICON,
                            id: this.parent.element.id + 'svg'
                        }
                    ]
                }];
            this.exportMenu = new Menu({
                items: menu, enableRtl: this.parent.enableRtl,
                locale: this.parent.locale, enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
                cssClass: TOOLBAR_MENU + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
                select: this.menuItemClick.bind(this), beforeOpen: this.updateExportMenu.bind(this),
                onClose: () => {
                    this.focusToolBar();
                }
            });
            this.exportMenu.isStringTemplate = true;
            this.exportMenu.appendTo('#' + this.parent.element.id + 'export_menu');
        }
        if (select('#' + this.parent.element.id + 'subtotal_menu', this.parent.element)) {
            const menu = [{
                    iconCss: GRID_SUB_TOTAL + ' ' + ICON,
                    items: [
                        {
                            text: this.parent.localeObj.getConstant('showSubTotals'),
                            id: this.parent.element.id + 'subtotal',
                            iconCss: PIVOT_SELECT_ICON + ' ' + ICON
                        },
                        {
                            text: this.parent.localeObj.getConstant('doNotShowSubTotals'),
                            id: this.parent.element.id + 'notsubtotal',
                            iconCss: PIVOT_SELECT_ICON + ' ' + ICON
                        },
                        {
                            text: this.parent.localeObj.getConstant('showSubTotalsRowsOnly'),
                            id: this.parent.element.id + 'subtotalrow',
                            iconCss: PIVOT_SELECT_ICON + ' ' + ICON
                        },
                        {
                            text: this.parent.localeObj.getConstant('showSubTotalsColumnsOnly'),
                            id: this.parent.element.id + 'subtotalcolumn',
                            iconCss: PIVOT_SELECT_ICON + ' ' + ICON
                        },
                        {
                            separator: true
                        },
                        {
                            text: this.parent.localeObj.getConstant('subTotalPosition'),
                            id: this.parent.element.id + 'subtotalpositions',
                            iconCss: PIVOT_DISABLE_ICON + ' ' + ICON,
                            items: [
                                {
                                    text: this.parent.localeObj.getConstant('auto'),
                                    id: this.parent.element.id + 'sub-none-position',
                                    iconCss: PIVOT_SELECT_ICON + ' ' + ICON
                                },
                                {
                                    text: this.parent.localeObj.getConstant('top'),
                                    id: this.parent.element.id + 'sub-top-position',
                                    iconCss: PIVOT_SELECT_ICON + ' ' + ICON
                                },
                                {
                                    text: this.parent.localeObj.getConstant('bottom'),
                                    id: this.parent.element.id + 'sub-bottom-position',
                                    iconCss: PIVOT_SELECT_ICON + ' ' + ICON
                                }
                            ]
                        }
                    ]
                }];
            this.subTotalMenu = new Menu({
                items: menu, enableRtl: this.parent.enableRtl,
                locale: this.parent.locale, enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
                cssClass: TOOLBAR_MENU + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
                select: this.menuItemClick.bind(this), beforeOpen: this.updateSubtotalSelection.bind(this),
                onClose: () => {
                    this.focusToolBar();
                }
            });
            this.subTotalMenu.isStringTemplate = true;
            this.subTotalMenu.appendTo('#' + this.parent.element.id + 'subtotal_menu');
        }
        if (select('#' + this.parent.element.id + 'grandtotal_menu', this.parent.element)) {
            const menu = [{
                    iconCss: GRID_GRAND_TOTAL + ' ' + ICON,
                    items: [
                        {
                            text: this.parent.localeObj.getConstant('showGrandTotals'),
                            id: this.parent.element.id + 'grandtotal',
                            iconCss: PIVOT_SELECT_ICON + ' ' + ICON
                        },
                        {
                            text: this.parent.localeObj.getConstant('doNotShowGrandTotals'),
                            id: this.parent.element.id + 'notgrandtotal',
                            iconCss: PIVOT_SELECT_ICON + ' ' + ICON
                        },
                        {
                            text: this.parent.localeObj.getConstant('showGrandTotalsRowsOnly'),
                            id: this.parent.element.id + 'grandtotalrow',
                            iconCss: PIVOT_SELECT_ICON + ' ' + ICON
                        },
                        {
                            text: this.parent.localeObj.getConstant('showGrandTotalsColumnsOnly'),
                            id: this.parent.element.id + 'grandtotalcolumn',
                            iconCss: PIVOT_SELECT_ICON + ' ' + ICON
                        },
                        {
                            separator: true
                        },
                        {
                            text: this.parent.localeObj.getConstant('grandTotalPosition'),
                            id: this.parent.element.id + 'grandtotalpositions',
                            iconCss: PIVOT_DISABLE_ICON + ' ' + ICON,
                            items: [
                                {
                                    text: this.parent.localeObj.getConstant('top'),
                                    id: this.parent.element.id + 'top-position',
                                    iconCss: PIVOT_SELECT_ICON + ' ' + ICON
                                },
                                {
                                    text: this.parent.localeObj.getConstant('bottom'),
                                    id: this.parent.element.id + 'bottom-position',
                                    iconCss: PIVOT_SELECT_ICON + ' ' + ICON
                                }
                            ]
                        }
                    ]
                }];
            this.grandTotalMenu = new Menu({
                items: menu, enableRtl: this.parent.enableRtl,
                locale: this.parent.locale, enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
                cssClass: TOOLBAR_MENU + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
                select: this.menuItemClick.bind(this), beforeOpen: this.updateGrandtotalSelection.bind(this),
                onClose: () => {
                    this.focusToolBar();
                }
            });
            this.grandTotalMenu.isStringTemplate = true;
            this.grandTotalMenu.appendTo('#' + this.parent.element.id + 'grandtotal_menu');
        }
        if (select('#' + this.parent.element.id + 'formatting_menu', this.parent.element)) {
            const menu = [{
                    iconCss: FORMATTING_MENU + ' ' + ICON,
                    items: [
                        {
                            text: this.parent.localeObj.getConstant('numberFormatMenu'),
                            iconCss: NUMBER_FORMATTING_MENU + ' ' + ICON,
                            id: this.parent.element.id + 'numberFormattingMenu'
                        },
                        {
                            text: this.parent.localeObj.getConstant('conditionalFormatingMenu'),
                            iconCss: CONDITIONAL_FORMATTING_MENU + ' ' + ICON,
                            id: this.parent.element.id + 'conditionalFormattingMenu'
                        }
                    ]
                }];
            this.formattingMenu = new Menu({
                items: menu, enableRtl: this.parent.enableRtl,
                locale: this.parent.locale, enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
                cssClass: TOOLBAR_MENU + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
                select: this.menuItemClick.bind(this)
            });
            this.formattingMenu.isStringTemplate = true;
            this.formattingMenu.appendTo('#' + this.parent.element.id + 'formatting_menu');
        }
        if (select('#' + this.parent.element.id + '_reportlist', this.parent.element)) {
            const saveArgs = {
                report: this.parent.getPersistData(),
                reportName: this.parent.localeObj.getConstant('defaultReport')
            };
            this.currentReport = this.parent.localeObj.getConstant('defaultReport');
            this.parent.trigger(saveReport, saveArgs);
            const reports = this.fetchReports();
            this.reportList = new DropDownList({
                dataSource: reports.reportName,
                width: '150px',
                popupHeight: '200px',
                placeholder: this.currentReport === '' ? this.parent.localeObj.getConstant('reportList') : '',
                enableRtl: this.parent.enableRtl,
                locale: this.parent.locale,
                cssClass: REPORT_LIST_DROP + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
                select: this.reportChange.bind(this),
                value: this.currentReport
            });
            this.reportList.isStringTemplate = true;
            this.reportList.appendTo('#' + this.parent.element.id + '_reportlist');
        }
        this.updateItemElements();
    }
    getCurrentReport() {
        let reportStr = this.parent.getPersistData();
        if (this.parent.dataSourceSettings.type === 'CSV') {
            const reportSettings = JSON.parse(reportStr);
            reportSettings.dataSourceSettings.dataSource.splice(0, 0, this.parent.engineModule.fields);
            reportStr = JSON.stringify(reportSettings);
        }
        return reportStr;
    }
    updateItemElements() {
        const itemElements = [].slice.call(this.toolbar.element.querySelectorAll('.e-toolbar-item'));
        for (const element of itemElements) {
            if (element.querySelector('button')) {
                element.querySelector('button').setAttribute('tabindex', '0');
            }
            else if (element.querySelector('.e-menu.e-menu-parent')) {
                element.querySelector('.e-menu.e-menu-parent').setAttribute('tabindex', '-1');
                if (element.querySelector('.e-menu-item.e-menu-caret-icon')) {
                    element.querySelector('.e-menu-item.e-menu-caret-icon').setAttribute('tabindex', '0');
                }
            }
        }
    }
    whitespaceRemove(args) {
        args.element.style.padding = '0px';
        const separator = args.element.querySelector('.e-separator');
        if (separator) {
            separator.style.margin = '0px';
        }
    }
    multipleAxesCheckbox(args) {
        if (this.parent.element.id + '_' + 'multipleAxes' === args.element.id) {
            const inputCheckbox = createElement('input', {
                id: this.parent.element.id + '_' + 'checkBox'
            });
            inputCheckbox.style.display = 'none';
            this.parent.element.appendChild(inputCheckbox);
            const checkbox = new CheckBox({
                label: this.parent.localeObj.getConstant('multipleAxes'),
                cssClass: 'e-multipleAxes' + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
                checked: this.parent.chartSettings.enableMultipleAxis,
                change: () => {
                    document.getElementById(this.parent.element.id + '_' + 'multipleAxes').click();
                },
                enableRtl: this.parent.enableRtl,
                locale: this.parent.locale,
                enableHtmlSanitizer: this.parent.enableHtmlSanitizer
            });
            args.element.innerText = '';
            checkbox.appendTo('#' + this.parent.element.id + '_' + 'checkBox');
            if ((['Pie', 'Funnel', 'Pyramid', 'Doughnut', 'Pareto'].indexOf(this.parent.chartSettings.chartSeries.type) > -1) &&
                !args.element.classList.contains(MENU_DISABLE)) {
                args.element.classList.add(MENU_DISABLE);
                checkbox.disabled = true;
            }
            else if ((['Pie', 'Funnel', 'Pyramid', 'Doughnut', 'Pareto'].indexOf(this.parent.chartSettings.chartSeries.type) < 0) &&
                args.element.classList.contains(MENU_DISABLE)) {
                args.element.classList.remove(MENU_DISABLE);
                checkbox.disabled = false;
            }
            const checkboxObj = this.parent.element.querySelector('.e-checkbox-wrapper.e-multipleAxes');
            args.element.appendChild(checkboxObj);
        }
        else if (this.parent.element.id + '_' + 'showLegend' === args.element.id) {
            const inputCheckbox = createElement('input', {
                id: this.parent.element.id + '_' + 'showLegendCheckBox'
            });
            inputCheckbox.style.display = 'none';
            this.parent.element.appendChild(inputCheckbox);
            const checkbox = new CheckBox({
                label: this.parent.localeObj.getConstant('showLegend'),
                checked: this.getLableState(),
                cssClass: 'e-showLegend' + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
                change: () => {
                    document.getElementById(this.parent.element.id + '_' + 'showLegend').click();
                },
                enableRtl: this.parent.enableRtl,
                locale: this.parent.locale,
                enableHtmlSanitizer: this.parent.enableHtmlSanitizer
            });
            args.element.innerText = '';
            checkbox.appendTo('#' + this.parent.element.id + '_' + 'showLegendCheckBox');
            const checkboxObj = this.parent.element.querySelector('.e-checkbox-wrapper.e-showLegend');
            args.element.appendChild(checkboxObj);
        }
    }
    getLableState() {
        const chartSettings = JSON.parse(this.parent.getPersistData()).chartSettings;
        if (chartSettings && chartSettings.legendSettings && chartSettings.legendSettings.visible !== undefined) {
            this.showLableState = chartSettings.legendSettings.visible;
        }
        else {
            this.showLableState = true;
        }
        return this.showLableState;
    }
    getAllChartItems() {
        return ['Line', 'Column', 'Area', 'Bar', 'StackingColumn', 'StackingArea', 'StackingBar', 'StackingLine', 'StepLine', 'StepArea',
            'SplineArea', 'Scatter', 'Spline', 'StackingColumn100', 'StackingBar100', 'StackingArea100', 'StackingLine100', 'Bubble', 'Pareto',
            'Polar', 'Radar', 'Pie', 'Pyramid', 'Funnel', 'Doughnut'];
    }
    updateExportMenu(args) {
        const items = [].slice.call(args.element.querySelectorAll('li'));
        if (this.parent.currentView === 'Table') {
            addClass(items.slice(3), MENU_HIDE);
            removeClass(items.slice(1, 3), MENU_HIDE);
        }
        else {
            addClass(items.slice(1, 3), MENU_HIDE);
            removeClass(items.slice(3), MENU_HIDE);
        }
    }
    updateSubtotalSelection(args) {
        if (!(args.parentItem.id === this.parent.element.id + 'subtotalpositions')) {
            if (!select('#' + this.parent.element.id + 'subtotal' + ' .' + PIVOT_SELECT_ICON, args.element).classList.contains(PIVOT_DISABLE_ICON)) {
                select('#' + this.parent.element.id + 'subtotal' + ' .' + PIVOT_SELECT_ICON, args.element).classList.add(PIVOT_DISABLE_ICON);
            }
            if (!select('#' + this.parent.element.id + 'notsubtotal' + ' .' + PIVOT_SELECT_ICON, args.element).classList.contains(PIVOT_DISABLE_ICON)) {
                select('#' + this.parent.element.id + 'notsubtotal' + ' .' + PIVOT_SELECT_ICON, args.element).classList.add(PIVOT_DISABLE_ICON);
            }
            if (!select('#' + this.parent.element.id + 'subtotalrow' + ' .' + PIVOT_SELECT_ICON, args.element).classList.contains(PIVOT_DISABLE_ICON)) {
                select('#' + this.parent.element.id + 'subtotalrow' + ' .' + PIVOT_SELECT_ICON, args.element).classList.add(PIVOT_DISABLE_ICON);
            }
            if (!select('#' + this.parent.element.id + 'subtotalcolumn' + ' .' + PIVOT_SELECT_ICON, args.element).classList.contains(PIVOT_DISABLE_ICON)) {
                select('#' + this.parent.element.id + 'subtotalcolumn' + ' .' + PIVOT_SELECT_ICON, args.element).classList.add(PIVOT_DISABLE_ICON);
            }
            if (this.parent.dataSourceSettings.showSubTotals && this.parent.dataSourceSettings.showRowSubTotals &&
                !this.parent.dataSourceSettings.showColumnSubTotals) {
                select('#' + this.parent.element.id + 'subtotalrow' + ' .' + PIVOT_SELECT_ICON, args.element).classList.remove(PIVOT_DISABLE_ICON);
            }
            else if (this.parent.dataSourceSettings.showSubTotals && !this.parent.dataSourceSettings.showRowSubTotals &&
                this.parent.dataSourceSettings.showColumnSubTotals) {
                select('#' + this.parent.element.id + 'subtotalcolumn' + ' .' + PIVOT_SELECT_ICON, args.element).classList.remove(PIVOT_DISABLE_ICON);
            }
            else if (this.parent.dataSourceSettings.showSubTotals && this.parent.dataSourceSettings.showRowSubTotals &&
                this.parent.dataSourceSettings.showColumnSubTotals) {
                select('#' + this.parent.element.id + 'subtotal' + ' .' + PIVOT_SELECT_ICON, args.element).classList.remove(PIVOT_DISABLE_ICON);
            }
            else if (!this.parent.dataSourceSettings.showSubTotals || (!this.parent.dataSourceSettings.showRowSubTotals &&
                !this.parent.dataSourceSettings.showColumnSubTotals)) {
                select('#' + this.parent.element.id + 'notsubtotal' + ' .' + PIVOT_SELECT_ICON, args.element).classList.remove(PIVOT_DISABLE_ICON);
            }
        }
        else {
            select('#' + this.parent.element.id + 'sub-none-position' + ' .' + PIVOT_SELECT_ICON, args.element).classList.add(PIVOT_DISABLE_ICON);
            if (this.parent.dataSourceSettings.subTotalsPosition === 'Auto') {
                select('#' + this.parent.element.id + 'sub-none-position' + ' .' + PIVOT_SELECT_ICON, args.element).classList.remove(PIVOT_DISABLE_ICON);
            }
            select('#' + this.parent.element.id + 'sub-top-position' + ' .' + PIVOT_SELECT_ICON, args.element).classList.add(PIVOT_DISABLE_ICON);
            if (this.parent.dataSourceSettings.subTotalsPosition === 'Top') {
                select('#' + this.parent.element.id + 'sub-top-position' + ' .' + PIVOT_SELECT_ICON, args.element).classList.remove(PIVOT_DISABLE_ICON);
            }
            select('#' + this.parent.element.id + 'sub-bottom-position' + ' .' + PIVOT_SELECT_ICON, args.element).classList.add(PIVOT_DISABLE_ICON);
            if (this.parent.dataSourceSettings.subTotalsPosition === 'Bottom') {
                select('#' + this.parent.element.id + 'sub-bottom-position' + ' .' + PIVOT_SELECT_ICON, args.element).classList.remove(PIVOT_DISABLE_ICON);
            }
        }
    }
    updateGrandtotalSelection(args) {
        if (!(args.parentItem.id === this.parent.element.id + 'grandtotalpositions')) {
            if (!select('#' + this.parent.element.id + 'grandtotal' + ' .' + PIVOT_SELECT_ICON, args.element).classList.contains(PIVOT_DISABLE_ICON)) {
                select('#' + this.parent.element.id + 'grandtotal' + ' .' + PIVOT_SELECT_ICON, args.element).classList.add(PIVOT_DISABLE_ICON);
            }
            if (!select('#' + this.parent.element.id + 'notgrandtotal' + ' .' + PIVOT_SELECT_ICON, args.element).classList.contains(PIVOT_DISABLE_ICON)) {
                select('#' + this.parent.element.id + 'notgrandtotal' + ' .' + PIVOT_SELECT_ICON, args.element).classList.add(PIVOT_DISABLE_ICON);
            }
            if (!select('#' + this.parent.element.id + 'grandtotalrow' + ' .' + PIVOT_SELECT_ICON, args.element).classList.contains(PIVOT_DISABLE_ICON)) {
                select('#' + this.parent.element.id + 'grandtotalrow' + ' .' + PIVOT_SELECT_ICON, args.element).classList.add(PIVOT_DISABLE_ICON);
            }
            if (!select('#' + this.parent.element.id + 'grandtotalcolumn' + ' .' + PIVOT_SELECT_ICON, args.element).classList.contains(PIVOT_DISABLE_ICON)) {
                select('#' + this.parent.element.id + 'grandtotalcolumn' + ' .' + PIVOT_SELECT_ICON, args.element).classList.add(PIVOT_DISABLE_ICON);
            }
            if (this.parent.dataSourceSettings.showGrandTotals && this.parent.dataSourceSettings.showRowGrandTotals &&
                !this.parent.dataSourceSettings.showColumnGrandTotals) {
                select('#' + this.parent.element.id + 'grandtotalrow' + ' .' + PIVOT_SELECT_ICON, args.element).classList.remove(PIVOT_DISABLE_ICON);
            }
            else if (this.parent.dataSourceSettings.showGrandTotals && !this.parent.dataSourceSettings.showRowGrandTotals &&
                this.parent.dataSourceSettings.showColumnGrandTotals) {
                select('#' + this.parent.element.id + 'grandtotalcolumn' + ' .' + PIVOT_SELECT_ICON, args.element).classList.remove(PIVOT_DISABLE_ICON);
            }
            else if (this.parent.dataSourceSettings.showGrandTotals && this.parent.dataSourceSettings.showRowGrandTotals &&
                this.parent.dataSourceSettings.showColumnGrandTotals) {
                select('#' + this.parent.element.id + 'grandtotal' + ' .' + PIVOT_SELECT_ICON, args.element).classList.remove(PIVOT_DISABLE_ICON);
            }
            else if (!this.parent.dataSourceSettings.showGrandTotals || (!this.parent.dataSourceSettings.showRowGrandTotals &&
                !this.parent.dataSourceSettings.showColumnGrandTotals)) {
                select('#' + this.parent.element.id + 'notgrandtotal' + ' .' + PIVOT_SELECT_ICON, args.element).classList.remove(PIVOT_DISABLE_ICON);
            }
        }
        else {
            select('#' + this.parent.element.id + 'top-position' + ' .' + PIVOT_SELECT_ICON, args.element).classList.add(PIVOT_DISABLE_ICON);
            if (this.parent.dataSourceSettings.grandTotalsPosition === 'Top') {
                select('#' + this.parent.element.id + 'top-position' + ' .' + PIVOT_SELECT_ICON, args.element).classList.remove(PIVOT_DISABLE_ICON);
            }
            select('#' + this.parent.element.id + 'bottom-position' + ' .' + PIVOT_SELECT_ICON, args.element).classList.add(PIVOT_DISABLE_ICON);
            if (this.parent.dataSourceSettings.grandTotalsPosition === 'Bottom') {
                select('#' + this.parent.element.id + 'bottom-position' + ' .' + PIVOT_SELECT_ICON, args.element).classList.remove(PIVOT_DISABLE_ICON);
            }
        }
    }
    updateReportList() {
        const reports = this.fetchReports();
        this.reportList.dataSource = reports.reportName;
        if (this.currentReport === '' && this.reportList.dataSource.length > 0) {
            this.reportList.value = this.reportList.dataSource[this.reportList.dataSource.length - 1];
            this.reportList.text = this.reportList.dataSource[this.reportList.dataSource.length - 1];
            this.currentReport = this.reportList.dataSource[this.reportList.dataSource.length - 1];
        }
        else {
            this.reportList.value = this.currentReport;
            this.reportList.text = this.currentReport;
        }
        this.reportList.refresh();
    }
    menuItemClick(args) {
        let exportArgs = {};
        let type;
        const actionName = (args.item.id === this.parent.element.id + 'grid') ? tableView : (args.item.id === this.parent.element.id + '_' + 'Column') ? chartView : (args.item.id === this.parent.element.id + '_' + 'Bar') ? chartView : (args.item.id === this.parent.element.id + '_' + 'Line') ? chartView
            : (args.item.id === this.parent.element.id + '_' + 'Area') ? chartView : (args.item.id === this.parent.element.id + '_' + 'Scatter') ? chartView : (args.item.id === this.parent.element.id + '_' + 'Polar') ? chartView : (args.item.id === this.parent.element.id + '_' + 'ChartMoreOption') ? chartView
                : (args.item.id === this.parent.element.id + '_' + 'multipleAxes') ? multipleAxis : (args.item.id === this.parent.element.id + '_' + 'showLegend') ? showLegend : (args.item.id === this.parent.element.id + 'pdf') ? pdfExport : (args.item.id === this.parent.element.id + 'png') ? pngExport
                    : (args.item.id === this.parent.element.id + 'excel') ? excelExport : (args.item.id === this.parent.element.id + 'csv') ? csvExport : (args.item.id === this.parent.element.id + 'jpeg') ? jpegExport : (args.item.id === this.parent.element.id + 'svg') ? svgExport
                        : (args.item.id === this.parent.element.id + 'notsubtotal') ? hideSubTotals : (args.item.id === this.parent.element.id + 'subtotalrow') ? subTotalsRow : (args.item.id === this.parent.element.id + 'subtotalcolumn') ? subTotalsColumn
                            : (args.item.id === this.parent.element.id + 'subtotal') ? showSubTotals : (args.item.id === this.parent.element.id + 'notgrandtotal') ? hideGrandTotals : (args.item.id === this.parent.element.id + 'grandtotalrow') ? grandTotalsRow
                                : (args.item.id === this.parent.element.id + 'grandtotalcolumn') ? grandTotalsColumn : (args.item.id === this.parent.element.id + 'grandtotal') ? showGrandTotals
                                    : (args.item.id === this.parent.element.id + 'numberFormattingMenu') ? numberFormattingMenu : (args.item.id === this.parent.element.id + 'conditionalFormattingMenu') ? conditionalFormattingMenu : '';
        this.parent.actionObj.actionName = actionName;
        if (this.parent.actionBeginMethod()) {
            return;
        }
        if (this.getAllChartItems().indexOf(args.item.id.split(this.parent.element.id + '_')[1]) > -1 ||
            (args.item.id.split(this.parent.element.id + '_')[1] === 'ChartMoreOption') ||
            (args.item.id.split(this.parent.element.id + '_')[1] === 'multipleAxes') ||
            (args.item.id.split(this.parent.element.id + '_')[1] === 'showLegend')) {
            type = args.item.id.split(this.parent.element.id + '_')[1];
        }
        try {
            switch (args.item.id) {
                case (this.parent.element.id + 'grid'):
                    if (this.parent.grid && this.parent.chart) {
                        this.parent.grid.element.style.display = '';
                        this.parent.chart.element.style.display = 'none';
                        if (this.parent.chartSettings.enableMultipleAxis && this.parent.chartSettings.enableScrollOnMultiAxis) {
                            this.parent.element.querySelector('.e-pivotchart').style.display = 'none';
                        }
                        this.parent.currentView = 'Table';
                        this.parent.setProperties({ displayOption: { primary: 'Table' } }, true);
                        if (this.parent.showGroupingBar && this.parent.groupingBarModule) {
                            this.parent.element.querySelector('.e-pivot-grouping-bar').style.display = '';
                            this.parent.element.querySelector('.e-chart-grouping-bar').style.display = 'none';
                        }
                        const actionInfo = {
                            toolbarInfo: {
                                displayOption: this.parent.displayOption,
                                gridSettings: this.parent.gridSettings
                            }
                        };
                        this.parent.actionObj.actionInfo = actionInfo;
                        this.parent.layoutRefresh();
                    }
                    break;
                case (this.parent.element.id + 'pdf'):
                    if (this.parent.currentView === 'Table') {
                        this.parent.pdfExport({ fileName: 'Export.pdf' }, false, undefined, false);
                    }
                    else {
                        this.parent.chartExport('PDF', { fileName: 'result' }, undefined, null, undefined);
                    }
                    break;
                case (this.parent.element.id + 'excel'):
                    exportArgs = {
                        excelExportProperties: { fileName: 'Export.xlsx' },
                        isBlob: undefined,
                        isMultipleExport: undefined,
                        workbook: undefined
                    };
                    this.parent.trigger(beforeExport, exportArgs, (observedArgs) => {
                        if (this.parent.dataSourceSettings.mode === 'Server') {
                            this.parent.getEngine('onExcelExport', null, null, null, null, null, null, null, null, observedArgs.excelExportProperties);
                        }
                        else {
                            this.parent.excelExport(observedArgs.excelExportProperties, observedArgs.isMultipleExport, observedArgs.workbook, observedArgs.isBlob);
                        }
                    });
                    break;
                case (this.parent.element.id + 'csv'):
                    exportArgs = {
                        excelExportProperties: { fileName: 'Export.csv' },
                        isBlob: false,
                        isMultipleExport: false,
                        workbook: undefined
                    };
                    this.parent.trigger(beforeExport, exportArgs, (observedArgs) => {
                        if (this.parent.dataSourceSettings.mode === 'Server') {
                            this.parent.getEngine('onCsvExport', null, null, null, null, null, null, null, null, observedArgs.excelExportProperties);
                        }
                        else {
                            this.parent.csvExport(observedArgs.excelExportProperties, observedArgs.isMultipleExport, observedArgs.workbook, observedArgs.isBlob);
                        }
                    });
                    break;
                case (this.parent.element.id + 'png'):
                    this.parent.chartExport('PNG', { fileName: 'result' }, undefined, null, undefined);
                    break;
                case (this.parent.element.id + 'jpeg'):
                    this.parent.chartExport('JPEG', { fileName: 'result' }, undefined, null, undefined);
                    break;
                case (this.parent.element.id + 'svg'):
                    this.parent.chartExport('SVG', { fileName: 'result' }, undefined, null, undefined);
                    break;
                case (this.parent.element.id + 'notsubtotal'):
                    this.parent.setProperties({ dataSourceSettings: { showSubTotals: false, showColumnSubTotals: false, showRowSubTotals: false } }, true);
                    this.parent.refreshData();
                    break;
                case (this.parent.element.id + 'subtotalrow'):
                    this.parent.setProperties({ dataSourceSettings: { showSubTotals: true, showColumnSubTotals: false, showRowSubTotals: true } }, true);
                    this.parent.refreshData();
                    break;
                case (this.parent.element.id + 'subtotalcolumn'):
                    this.parent.setProperties({ dataSourceSettings: { showSubTotals: true, showColumnSubTotals: true, showRowSubTotals: false } }, true);
                    this.parent.refreshData();
                    break;
                case (this.parent.element.id + 'subtotal'):
                    this.parent.setProperties({ dataSourceSettings: { showSubTotals: true, showColumnSubTotals: true, showRowSubTotals: true } }, true);
                    this.parent.refreshData();
                    break;
                case (this.parent.element.id + 'notgrandtotal'):
                    this.parent.setProperties({ dataSourceSettings: { showGrandTotals: false, showColumnGrandTotals: false, showRowGrandTotals: false } }, true);
                    this.parent.refreshData();
                    break;
                case (this.parent.element.id + 'grandtotalrow'):
                    this.parent.setProperties({ dataSourceSettings: { showGrandTotals: true, showColumnGrandTotals: false, showRowGrandTotals: true } }, true);
                    this.parent.refreshData();
                    break;
                case (this.parent.element.id + 'grandtotalcolumn'):
                    this.parent.setProperties({ dataSourceSettings: { showGrandTotals: true, showColumnGrandTotals: true, showRowGrandTotals: false } }, true);
                    this.parent.refreshData();
                    break;
                case (this.parent.element.id + 'grandtotal'):
                    this.parent.setProperties({ dataSourceSettings: { showGrandTotals: true, showColumnGrandTotals: true, showRowGrandTotals: true } }, true);
                    this.parent.refreshData();
                    break;
                case (this.parent.element.id + 'top-position'):
                    this.parent.setProperties({ dataSourceSettings: { grandTotalsPosition: 'Top' } }, true);
                    this.parent.refreshData();
                    break;
                case (this.parent.element.id + 'bottom-position'):
                    this.parent.setProperties({ dataSourceSettings: { grandTotalsPosition: 'Bottom' } }, true);
                    this.parent.refreshData();
                    break;
                case (this.parent.element.id + 'sub-top-position'):
                    this.parent.setProperties({ dataSourceSettings: { subTotalsPosition: 'Top' } }, true);
                    this.parent.refreshData();
                    break;
                case (this.parent.element.id + 'sub-bottom-position'):
                    this.parent.setProperties({ dataSourceSettings: { subTotalsPosition: 'Bottom' } }, true);
                    this.parent.refreshData();
                    break;
                case (this.parent.element.id + 'sub-none-position'):
                    this.parent.setProperties({ dataSourceSettings: { subTotalsPosition: 'Auto' } }, true);
                    this.parent.refreshData();
                    break;
                case (this.parent.element.id + 'numberFormattingMenu'):
                    if (this.parent.numberFormattingModule) {
                        this.parent.numberFormattingModule.showNumberFormattingDialog();
                    }
                    break;
                case (this.parent.element.id + 'conditionalFormattingMenu'):
                    if (this.parent.conditionalFormattingModule) {
                        this.parent.conditionalFormattingModule.showConditionalFormattingDialog();
                    }
                    break;
                case (this.parent.element.id + '_' + type):
                    if (args.item && args.item.text) {
                        if (type === 'ChartMoreOption') {
                            this.createChartTypeDialog();
                        }
                        else if (type === 'multipleAxes') {
                            if (this.parent.chartSettings.enableScrollOnMultiAxis) {
                                this.isMultiAxisChange = true;
                            }
                            this.parent.chartSettings.enableMultipleAxis = !this.parent.chartSettings.enableMultipleAxis;
                            this.updateChartType(this.parent.chartSettings.chartSeries.type, true);
                        }
                        else if (this.getAllChartItems().indexOf(type) > -1) {
                            this.updateChartType(type, false);
                        }
                        else if (type === 'showLegend') {
                            this.parent.chart.legendSettings.visible = !this.showLableState;
                            if (this.parent.chartSettings.legendSettings) {
                                this.parent.chartSettings.legendSettings.visible = !this.showLableState;
                            }
                            else {
                                this.parent.setProperties({ chartSettings: { legendSettings: { visible: !this.showLableState } } }, true);
                            }
                            this.updateChartType(this.parent.chartSettings.chartSeries.type, true);
                        }
                    }
                    break;
            }
        }
        catch (execption) {
            this.parent.actionFailureMethod(execption);
        }
    }
    /**
     *
     * @returns {void}
     * @hidden
     */
    addEventListener() {
        if (this.parent.isDestroyed) {
            return;
        }
        this.parent.on(initToolbar, this.createToolbar, this);
    }
    getValidChartType() {
        const menuItems = [];
        for (let i = 0; (i <= this.parent.chartTypes.length); i++) {
            const type = this.parent.chartTypes[i];
            if ((this.getAllChartItems().indexOf(type) > -1) && (menuItems.indexOf(type) < 0)) {
                menuItems.push(type);
            }
        }
        return menuItems;
    }
    createChartTypeDialog() {
        const chartDialog = this.parent.element.appendChild(createElement('div', {
            id: this.parent.element.id + '_ChartTypeDialog',
            className: PIVOTCHART_TYPE_DIALOG
        }));
        this.chartTypesDialog = new Dialog({
            animationSettings: { effect: 'Fade' },
            allowDragging: true,
            header: this.parent.localeObj.getConstant('chartTypeSettings'),
            content: this.getDialogContent(),
            isModal: true,
            beforeOpen: this.beforeOpen.bind(this),
            visible: true,
            showCloseIcon: true,
            enableRtl: this.parent.enableRtl,
            locale: this.parent.locale,
            enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
            width: 'auto',
            height: 'auto',
            position: { X: 'center', Y: 'center' },
            buttons: [
                {
                    click: () => { this.chartTypeDialogUpdate(); },
                    buttonModel: { cssClass: OK_BUTTON_CLASS + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''), content: this.parent.localeObj.getConstant('ok'), isPrimary: true }
                },
                {
                    click: () => { this.removeDialog(); },
                    buttonModel: { cssClass: CANCEL_BUTTON_CLASS + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''), content: this.parent.localeObj.getConstant('cancel') }
                }
            ],
            closeOnEscape: true,
            target: this.parent.element,
            cssClass: this.parent.cssClass,
            close: this.removeDialog.bind(this)
        });
        this.chartTypesDialog.isStringTemplate = true;
        this.chartTypesDialog.appendTo(chartDialog);
    }
    removeDialog() {
        if (this.chartTypesDialog && !this.chartTypesDialog.isDestroyed) {
            this.chartTypesDialog.destroy();
        }
        if (document.getElementById(this.parent.element.id + '_ChartTypeDialog')) {
            remove(document.getElementById(this.parent.element.id + '_ChartTypeDialog'));
        }
    }
    chartTypeDialogUpdate() {
        const chartType = getInstance(select('#' + this.parent.element.id + '_ChartTypeOption'), DropDownList).value;
        const checked = getInstance(select('#' + this.parent.element.id + '_DialogMultipleAxis'), CheckBox).checked;
        const checkedShow = getInstance(select('#' + this.parent.element.id + '_DialogShowLabel'), CheckBox).checked;
        this.parent.chart.legendSettings.visible = checkedShow;
        if (this.chartLableState) {
            this.parent.chart.legendSettings.visible = checkedShow;
            if (this.parent.chartSettings.legendSettings) {
                this.parent.chartSettings.legendSettings.visible = checkedShow;
            }
            else {
                this.parent.setProperties({ chartSettings: { legendSettings: { visible: checkedShow } } }, true);
            }
        }
        this.updateChartType(chartType, false);
        this.parent.chartSettings.enableMultipleAxis = checked;
        this.parent.chartSettings.multipleAxisMode = getInstance(select('#' + this.parent.element.id + '_AxisModeOption'), DropDownList).value;
        this.chartTypesDialog.close();
    }
    updateChartType(type, isMultiAxis) {
        if (this.getAllChartItems().indexOf(type) > -1) {
            if (this.parent.chart) {
                this.parent.currentView = 'Chart';
                this.parent.setProperties({ displayOption: { primary: 'Chart' } }, true);
                if (this.parent.chartSettings.enableScrollOnMultiAxis && this.parent.chartSettings.enableMultipleAxis) {
                    this.parent.element.querySelector('.' + PIVOTCHART).style.width = formatUnit(this.parent.grid ? this.parent.getGridWidthAsNumber() : this.parent.getWidthAsNumber());
                }
                this.parent.chart.setProperties({
                    width: formatUnit(this.parent.grid ? this.parent.getGridWidthAsNumber() : this.parent.getWidthAsNumber())
                }, true);
                if (this.parent.chartSettings.chartSeries.type === type && !isMultiAxis) {
                    this.parent.chart.refresh();
                }
                else {
                    this.parent.chartSettings.chartSeries.type = type;
                }
                const actionInfo = {
                    toolbarInfo: {
                        displayOption: this.parent.displayOption,
                        chartSettings: this.parent.chartSettings
                    }
                };
                this.parent.actionObj.actionInfo = actionInfo;
            }
        }
    }
    getDialogContent() {
        const mainWrapper = createElement('div', { className: 'e-chart-type-div-content' });
        const optionWrapperDiv = createElement('div', { className: 'e-chart-type-option-container' });
        const axisModeWrapperDiv = createElement('div', { className: 'e-multiple-axes-mode-container' });
        const optionTextDiv = createElement('div', {
            className: 'e-chart-type-option-text'
        });
        optionTextDiv.innerText = this.parent.localeObj.getConstant('ChartType');
        const axisModeTextDiv = createElement('div', {
            className: 'e-multiple-axes-mode-text'
        });
        axisModeTextDiv.innerText = this.parent.localeObj.getConstant('multipleAxisMode');
        const dropOptionDiv = createElement('div', { id: this.parent.element.id + '_ChartTypeOption' });
        const dropModeOptionDiv = createElement('div', { id: this.parent.element.id + '_AxisModeOption' });
        optionWrapperDiv.appendChild(optionTextDiv);
        optionWrapperDiv.appendChild(dropOptionDiv);
        const chartTypeDatasource = [];
        const multipleAxisModeDatasource = [
            { value: 'Stacked', text: this.parent.localeObj.getConstant('stacked') },
            { value: 'Single', text: this.parent.localeObj.getConstant('single') },
            { value: 'Combined', text: this.parent.localeObj.getConstant('combined') }
        ];
        const chartType = this.getValidChartType();
        for (let i = 0; i < chartType.length; i++) {
            chartTypeDatasource.push({
                value: chartType[i], text: this.parent.localeObj.getConstant(chartType[i].toLowerCase())
            });
        }
        const optionWrapper = new DropDownList({
            dataSource: chartTypeDatasource, enableRtl: this.parent.enableRtl,
            locale: this.parent.locale,
            fields: { value: 'value', text: 'text' },
            value: this.parent.chartSettings.chartSeries.type ? this.parent.chartSettings.chartSeries.type : this.getValidChartType()[0],
            width: '100%',
            change: this.changeDropDown.bind(this),
            cssClass: this.parent.cssClass
        });
        optionWrapper.isStringTemplate = true;
        optionWrapper.appendTo(dropOptionDiv);
        mainWrapper.appendChild(optionWrapperDiv);
        const checkboxWrap = createElement('input', {
            id: this.parent.element.id + '_DialogMultipleAxis',
            attrs: { 'type': 'checkbox' }
        });
        mainWrapper.appendChild(checkboxWrap);
        const labelCheckboxWrap = createElement('input', {
            id: this.parent.element.id + '_DialogShowLabel',
            attrs: { 'type': 'checkbox' }
        });
        mainWrapper.appendChild(labelCheckboxWrap);
        axisModeWrapperDiv.appendChild(axisModeTextDiv);
        axisModeWrapperDiv.appendChild(dropModeOptionDiv);
        mainWrapper.appendChild(axisModeWrapperDiv);
        const axisModeWrapper = new DropDownList({
            dataSource: multipleAxisModeDatasource, enableRtl: this.parent.enableRtl,
            locale: this.parent.locale,
            fields: { value: 'value', text: 'text' },
            value: this.parent.chartSettings.multipleAxisMode ? this.parent.chartSettings.multipleAxisMode : 'Stacked',
            width: '100%',
            enabled: this.parent.chartSettings.enableMultipleAxis,
            cssClass: this.parent.cssClass
        });
        axisModeWrapper.isStringTemplate = true;
        axisModeWrapper.appendTo(dropModeOptionDiv);
        return mainWrapper;
    }
    changeDropDown(args) {
        const chartSettings = JSON.parse(this.parent.getPersistData()).chartSettings;
        if (!(chartSettings && chartSettings.legendSettings && chartSettings.legendSettings.visible !== undefined)) {
            getInstance(select('#' + this.parent.element.id + '_DialogShowLabel'), CheckBox).checked = true;
        }
        if (['Pie', 'Funnel', 'Pyramid', 'Doughnut', 'Pareto'].indexOf(args.value.toString()) > -1) {
            getInstance(select('#' + this.parent.element.id + '_DialogMultipleAxis'), CheckBox).disabled = true;
            getInstance(select('#' + this.parent.element.id + '_AxisModeOption'), DropDownList).enabled = false;
        }
        else {
            const multipleAxisCheckBox = getInstance(select('#' + this.parent.element.id + '_DialogMultipleAxis'), CheckBox);
            multipleAxisCheckBox.disabled = false;
            getInstance(select('#' + this.parent.element.id + '_AxisModeOption'), DropDownList).enabled = multipleAxisCheckBox.checked;
        }
    }
    beforeOpen() {
        const checkbox = new CheckBox({
            label: this.parent.localeObj.getConstant('multipleAxes'),
            cssClass: 'e-dialog-multiple-axis' + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
            checked: this.parent.chartSettings.enableMultipleAxis ? this.parent.chartSettings.enableMultipleAxis : false,
            change: (args) => {
                getInstance(select('#' + this.parent.element.id + '_AxisModeOption'), DropDownList).enabled = args.checked;
            },
            enableRtl: this.parent.enableRtl,
            locale: this.parent.locale,
            enableHtmlSanitizer: this.parent.enableHtmlSanitizer
        });
        const checkbox1 = new CheckBox({
            label: this.parent.localeObj.getConstant('showLegend'),
            checked: this.getLableState(),
            change: () => { this.chartLableState = true; },
            cssClass: 'e-dialog-show-legend' + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''),
            enableRtl: this.parent.enableRtl,
            locale: this.parent.locale,
            enableHtmlSanitizer: this.parent.enableHtmlSanitizer
        });
        checkbox1.appendTo(select('#' + this.parent.element.id + '_DialogShowLabel', this.chartTypesDialog.element));
        checkbox.appendTo(select('#' + this.parent.element.id + '_DialogMultipleAxis', this.chartTypesDialog.element));
        if (['Pie', 'Funnel', 'Pyramid', 'Doughnut', 'Pareto'].indexOf(this.parent.chartSettings.chartSeries.type) > -1) {
            checkbox.disabled = true;
            getInstance(select('#' + this.parent.element.id + '_AxisModeOption'), DropDownList).enabled = false;
        }
        const chartSettings = JSON.parse(this.parent.getPersistData()).chartSettings;
        if (chartSettings && chartSettings.legendSettings && chartSettings.legendSettings.visible !== undefined) {
            this.chartLableState = true;
        }
        else {
            this.chartLableState = false;
        }
    }
    /**
     * To refresh the toolbar
     *
     * @returns {void}
     * @hidden
     */
    refreshToolbar() {
        this.createToolbar();
    }
    /**
     *
     * @returns {void}
     * @hidden
     */
    removeEventListener() {
        if (this.parent.isDestroyed) {
            return;
        }
        this.parent.off(initToolbar, this.createToolbar);
    }
    /**
     * To destroy the toolbar
     *
     * @returns {void}
     * @hidden
     */
    destroy() {
        this.removeEventListener();
        if (this.confirmPopUp && !this.confirmPopUp.isDestroyed) {
            this.confirmPopUp.destroy();
        }
        if (this.dialog && !this.dialog.isDestroyed) {
            this.dialog.destroy();
        }
        if (this.mdxDialog && !this.mdxDialog.isDestroyed) {
            this.mdxDialog.destroy();
        }
        if (this.chartMenu && !this.chartMenu.isDestroyed) {
            this.chartMenu.destroy();
        }
        if (this.chartTypesDialog && !this.chartTypesDialog.isDestroyed) {
            this.chartTypesDialog.destroy();
        }
        if (this.exportMenu && !this.exportMenu.isDestroyed) {
            this.exportMenu.destroy();
        }
        if (this.subTotalMenu && !this.subTotalMenu.isDestroyed) {
            this.subTotalMenu.destroy();
        }
        if (this.grandTotalMenu && !this.grandTotalMenu.isDestroyed) {
            this.grandTotalMenu.destroy();
        }
        if (this.formattingMenu && !this.formattingMenu.isDestroyed) {
            this.formattingMenu.destroy();
        }
        if (this.reportList && !this.reportList.isDestroyed) {
            this.reportList.destroy();
        }
        if (this.toolbar && !this.toolbar.isDestroyed) {
            this.toolbar.destroy();
        }
        if (select('#' + this.parent.element.id + 'pivot-toolbar', document)) {
            remove(select('#' + this.parent.element.id + 'pivot-toolbar', document));
        }
    }
    focusToolBar() {
        removeClass(document.querySelector('.' + GRID_TOOLBAR).querySelectorAll('.e-menu-item.e-focused'), 'e-focused');
        removeClass(document.querySelector('.' + GRID_TOOLBAR).querySelectorAll('.e-menu-item.e-selected'), 'e-selected');
        if (document.querySelector('.e-toolbar-items')) {
            addClass([document.querySelector('.e-toolbar-items')], 'e-focused');
        }
    }
}

/**
 * Module to render NumberFormatting Dialog
 */
class NumberFormatting {
    constructor(parent) {
        this.parent = parent;
        this.parent.numberFormattingModule = this;
        this.removeEventListener();
        this.addEventListener();
        this.newFormat = [];
        this.lastFormattedValue = [];
    }
    /**
     * To get module name.
     *
     * @returns {string} - It returns Module Name
     */
    getModuleName() {
        return 'numberFormatting';
    }
    /**
     * To show Number Formatting dialog.
     *
     * @returns {void}
     * @hidden
     */
    showNumberFormattingDialog() {
        const valueDialog = createElement('div', {
            id: this.parent.element.id + '_FormatDialog',
            className: FORMATTING_DIALOG
        });
        this.parent.element.appendChild(valueDialog);
        this.dialog = new Dialog({
            animationSettings: { effect: 'Fade' },
            allowDragging: true,
            header: this.parent.localeObj.getConstant('numberFormat'),
            content: this.getDialogContent(),
            isModal: true,
            visible: true,
            showCloseIcon: true,
            enableRtl: this.parent.enableRtl,
            locale: this.parent.locale,
            enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
            width: '320px',
            height: 'auto',
            position: { X: 'center', Y: 'center' },
            buttons: [
                {
                    click: this.updateFormatting.bind(this),
                    buttonModel: { cssClass: OK_BUTTON_CLASS + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''), content: this.parent.localeObj.getConstant('apply'), isPrimary: true }
                },
                {
                    click: () => {
                        this.dialog.hide();
                    },
                    buttonModel: { cssClass: CANCEL_BUTTON_CLASS + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''), content: this.parent.localeObj.getConstant('cancel') }
                }
            ],
            closeOnEscape: true,
            cssClass: this.parent.cssClass,
            target: this.parent.element,
            overlayClick: () => {
                this.removeDialog();
            },
            close: this.removeDialog.bind(this)
        });
        this.dialog.isStringTemplate = true;
        this.dialog.appendTo(valueDialog);
        this.dialog.element.querySelector('.' + DIALOG_HEADER).innerText = this.parent.localeObj.getConstant('numberFormat');
        let formatObject;
        this.newFormat = [{ name: this.parent.localeObj.getConstant('AllValues'), format: 'N0', useGrouping: true, type: undefined }];
        const format = [];
        for (let i = 0; i < this.parent.dataSourceSettings.formatSettings.length; i++) {
            formatObject = {
                name: this.parent.dataSourceSettings.formatSettings[i].name,
                format: this.parent.dataSourceSettings.formatSettings[i].format,
                useGrouping: this.parent.dataSourceSettings.formatSettings[i].useGrouping,
                type: this.parent.dataSourceSettings.formatSettings[i].type
            };
            this.newFormat.push(formatObject);
        }
        for (let i = 0; i < this.newFormat.length; i++) {
            format.push(this.newFormat[i].name);
        }
        for (let j = 0; j < this.parent.dataSourceSettings.values.length; j++) {
            if (format.indexOf(this.parent.dataSourceSettings.values[j].name) === -1) {
                formatObject = {
                    name: this.parent.dataSourceSettings.values[j].name, format: 'N0',
                    useGrouping: true
                };
                this.newFormat.push(formatObject);
            }
        }
        this.renderControls();
    }
    getDialogContent() {
        const outerElement = createElement('div', {
            id: this.parent.element.id + '_FormatDialogOuter',
            className: FORMATTING_DIALOG_OUTER
        });
        const table = createElement('table', {
            id: this.parent.element.id + '_FormatTable',
            className: FORMATTING_TABLE,
            attrs: { 'role': 'tableItems' }
        });
        let tRow = createElement('tr');
        let tValue = createElement('td');
        const valueLable = createElement('div', {
            id: this.parent.element.id + '_FormatValueLable',
            className: FORMATTING_VALUE_LABLE
        });
        valueLable.innerText = this.parent.localeObj.getConstant('values');
        const valueDrop = createElement('div', {
            id: this.parent.element.id + '_FormatValueDrop'
        });
        tValue.appendChild(valueLable);
        tValue.appendChild(valueDrop);
        tRow.appendChild(tValue);
        table.appendChild(tRow);
        tRow = createElement('tr');
        tValue = createElement('td');
        const formatLable = createElement('div', {
            id: this.parent.element.id + '_FormatLable',
            className: FORMATTING_FORMAT_LABLE
        });
        formatLable.innerText = this.parent.localeObj.getConstant('formatType');
        const formatDrop = createElement('div', {
            id: this.parent.element.id + '_FormatDrop'
        });
        tValue.appendChild(formatLable);
        tValue.appendChild(formatDrop);
        tRow.appendChild(tValue);
        table.appendChild(tRow);
        tRow = createElement('tr');
        tValue = createElement('td');
        const groupingLable = createElement('div', {
            id: this.parent.element.id + '_GroupingLable',
            className: FORMATTING_GROUPING_LABLE
        });
        groupingLable.innerText = this.parent.localeObj.getConstant('grouping');
        const groupingDrop = createElement('div', {
            id: this.parent.element.id + '_GroupingDrop'
        });
        tValue.appendChild(groupingLable);
        tValue.appendChild(groupingDrop);
        tRow.appendChild(tValue);
        table.appendChild(tRow);
        tRow = createElement('tr');
        tValue = createElement('td');
        const decimalLable = createElement('div', {
            id: this.parent.element.id + '_DecimalLable',
            className: FORMATTING_DECIMAL_LABLE
        });
        decimalLable.innerText = this.parent.localeObj.getConstant('decimalPlaces');
        const decimalDrop = createElement('div', {
            id: this.parent.element.id + '_DecimalDrop'
        });
        tValue.appendChild(decimalLable);
        tValue.appendChild(decimalDrop);
        tRow.appendChild(tValue);
        table.appendChild(tRow);
        tRow = createElement('tr');
        tValue = createElement('td');
        this.customLable = createElement('div', {
            id: this.parent.element.id + '_CustomLable',
            className: FORMATTING_CUSTOM_LABLE
        });
        this.customLable.innerText = this.parent.localeObj.getConstant('customFormatString');
        this.customText = createElement('input', {
            id: this.parent.element.id + '_CustomText',
            attrs: {
                'type': 'text', 'tabindex': '0'
            },
            className: INPUT + ' ' + FORMATTING_CUSTOM_TEXT
        });
        tValue.appendChild(this.customLable);
        tValue.appendChild(this.customText);
        tRow.appendChild(tValue);
        table.appendChild(tRow);
        tRow = createElement('tr');
        table.appendChild(tRow);
        outerElement.appendChild(table);
        return outerElement;
    }
    renderControls() {
        if (select('#' + this.parent.element.id + '_FormatValueDrop', this.dialog.element)) {
            const valueFields = [];
            valueFields.push({
                index: 0, name: this.parent.localeObj.getConstant('AllValues'), field: this.parent.localeObj.getConstant('AllValues')
            });
            for (let i = 0; i < this.parent.dataSourceSettings.values.length; i++) {
                let caption = this.parent.dataSourceSettings.values[i].caption ||
                    this.parent.dataSourceSettings.values[i].name;
                caption = this.parent.enableHtmlSanitizer ? SanitizeHtmlHelper.sanitize(caption) : caption;
                valueFields.push({
                    index: i + 1, name: caption,
                    field: this.parent.dataSourceSettings.values[i].name
                });
            }
            this.valuesDropDown = new DropDownList({
                dataSource: valueFields, fields: { text: 'name', value: 'field' }, enableRtl: this.parent.enableRtl, locale: this.parent.locale,
                index: 0, cssClass: FORMATTING_VALUE_DROP + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''), change: this.valueChange.bind(this), width: '100%',
                open: this.customUpdate.bind(this)
            });
            this.valuesDropDown.isStringTemplate = true;
            this.valuesDropDown.appendTo('#' + this.parent.element.id + '_FormatValueDrop');
        }
        if (select('#' + this.parent.element.id + '_FormatDrop', this.dialog.element)) {
            const fields = [
                { index: 0, name: this.parent.localeObj.getConstant('number') },
                { index: 1, name: this.parent.localeObj.getConstant('currency') },
                { index: 2, name: this.parent.localeObj.getConstant('percentage') },
                { index: 3, name: this.parent.localeObj.getConstant('Custom') }
            ];
            this.formatDropDown = new DropDownList({
                dataSource: fields, fields: { text: 'name', value: 'name' },
                index: 0, change: this.dropDownChange.bind(this), enableRtl: this.parent.enableRtl, locale: this.parent.locale,
                cssClass: FORMATTING_FORMAT_DROP + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''), width: '100%'
            });
            this.formatDropDown.isStringTemplate = true;
            this.formatDropDown.appendTo('#' + this.parent.element.id + '_FormatDrop');
        }
        if (select('#' + this.parent.element.id + '_GroupingDrop', this.dialog.element)) {
            const fields = [
                { index: 0, name: this.parent.localeObj.getConstant('true') },
                { index: 1, name: this.parent.localeObj.getConstant('false') }
            ];
            this.groupingDropDown = new DropDownList({
                dataSource: fields, fields: { text: 'name', value: 'name' }, enableRtl: this.parent.enableRtl, locale: this.parent.locale,
                index: 0, cssClass: FORMATTING_GROUPING_DROP + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''), width: '100%', change: this.groupingChange.bind(this)
            });
            this.groupingDropDown.isStringTemplate = true;
            this.groupingDropDown.appendTo('#' + this.parent.element.id + '_GroupingDrop');
        }
        if (select('#' + this.parent.element.id + '_DecimalDrop', this.dialog.element)) {
            const fields = [
                { index: 0, name: 0 },
                { index: 1, name: 1 },
                { index: 2, name: 2 },
                { index: 3, name: 3 },
                { index: 4, name: 4 },
                { index: 5, name: 5 },
                { index: 6, name: 6 },
                { index: 7, name: 7 },
                { index: 8, name: 8 },
                { index: 9, name: 9 },
                { index: 10, name: 10 }
            ];
            this.decimalDropDown = new DropDownList({
                dataSource: fields, fields: { text: 'name', value: 'name' }, enableRtl: this.parent.enableRtl, locale: this.parent.locale,
                index: 0, cssClass: FORMATTING_DECIMAL_DROP + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''), popupHeight: 150, width: '100%', change: this.decimalChange.bind(this)
            });
            this.decimalDropDown.isStringTemplate = true;
            this.decimalDropDown.appendTo('#' + this.parent.element.id + '_DecimalDrop');
        }
        if (this.formatDropDown.value !== this.parent.localeObj.getConstant('Custom')) {
            this.customText.disabled = true;
        }
        if (this.lastFormattedValue.length !== 0) {
            this.valuesDropDown.value = this.lastFormattedValue[0].name;
            const fString = this.lastFormattedValue[0].format;
            const first = fString === '' ? '' : fString.split('')[0].toLowerCase();
            const group = this.lastFormattedValue[0].useGrouping ? this.parent.localeObj.getConstant('true') :
                this.parent.localeObj.getConstant('false');
            this.updateFormattingDialog(fString, first, group);
        }
    }
    valueChange(args) {
        const format = this.newFormat;
        let isExist = false;
        for (let i = 0; i < format.length; i++) {
            if (format[i].name === args.value) {
                const fString = format[i].format;
                const first = fString === '' ? '' : fString.split('')[0].toLowerCase();
                const group = format[i].useGrouping ? this.parent.localeObj.getConstant('true') :
                    this.parent.localeObj.getConstant('false');
                this.updateFormattingDialog(fString, first, group);
                isExist = true;
                break;
            }
        }
        if (!isExist) {
            this.formatDropDown.value = this.parent.localeObj.getConstant('number');
            this.decimalDropDown.value = 0;
            this.groupingDropDown.value = this.parent.localeObj.getConstant('true');
        }
    }
    updateFormattingDialog(fString, first, group) {
        if (fString.length === 2 && ['n', 'p', 'c'].indexOf(first) > -1) {
            this.formatDropDown.value = first === 'n' ? this.parent.localeObj.getConstant('number') : first === 'p' ?
                this.parent.localeObj.getConstant('percentage') : first === 'c' ? this.parent.localeObj.getConstant('currency') :
                this.parent.localeObj.getConstant('number');
            this.decimalDropDown.value = Number(fString.split('')[1]);
            this.groupingDropDown.value = group;
        }
        else {
            this.formatDropDown.value = this.parent.localeObj.getConstant('Custom');
            this.customText.value = fString;
        }
    }
    customUpdate() {
        if (this.formatDropDown.value === this.parent.localeObj.getConstant('Custom')) {
            const index = this.getIndexValue();
            this.newFormat[index].format = this.customText.value;
        }
    }
    dropDownChange(args) {
        const index = this.getIndexValue();
        if (args.value === this.parent.localeObj.getConstant('Custom')) {
            this.customText.disabled = false;
            this.groupingDropDown.enabled = false;
            this.decimalDropDown.enabled = false;
            this.newFormat[index].format = this.customText.value;
        }
        else {
            const text = this.formattedText();
            this.newFormat[index].format = text;
            this.customText.disabled = true;
            this.groupingDropDown.enabled = true;
            this.decimalDropDown.enabled = true;
            this.customText.value = '';
        }
    }
    groupingChange() {
        const index = this.getIndexValue();
        this.newFormat[index].useGrouping = this.groupingDropDown.value === this.parent.localeObj.getConstant('true') ? true : false;
    }
    getIndexValue() {
        const format = [];
        for (let i = 0; i < this.newFormat.length; i++) {
            format.push(this.newFormat[i].name);
        }
        const index = format.indexOf(this.valuesDropDown.value.toString());
        return index;
    }
    decimalChange() {
        const index = this.getIndexValue();
        const text = this.formattedText();
        this.newFormat[index].format = text;
    }
    formattedText() {
        let text;
        if (this.formatDropDown.value === this.parent.localeObj.getConstant('number') ||
            this.formatDropDown.value === this.parent.localeObj.getConstant('percentage') ||
            this.formatDropDown.value === this.parent.localeObj.getConstant('currency')) {
            text = this.formatDropDown.value === this.parent.localeObj.getConstant('number') ? 'N' :
                this.formatDropDown.value === this.parent.localeObj.getConstant('currency') ? 'C' : 'P';
            return text += this.decimalDropDown.value;
        }
        else {
            return text = this.customText.value;
        }
    }
    removeDialog() {
        if (this.dialog && !this.dialog.isDestroyed) {
            this.dialog.destroy();
        }
        if (document.getElementById(this.parent.element.id + '_FormatDialog')) {
            remove(document.getElementById(this.parent.element.id + '_FormatDialog'));
        }
    }
    updateFormatting() {
        const text = this.formattedText();
        const index = this.getIndexValue();
        this.newFormat.splice(index, 1);
        const format = extend([], this.newFormat, true);
        const formatSettings = this.parent.dataSourceSettings.formatSettings;
        for (let i = 0; i < formatSettings.length; i++) {
            this.insertFormat(formatSettings[i].name, formatSettings[i].format, formatSettings[i].type);
        }
        if (this.valuesDropDown.value === this.parent.localeObj.getConstant('AllValues')) {
            for (let i = 0; i < this.parent.dataSourceSettings.values.length; i++) {
                this.insertFormat(this.parent.dataSourceSettings.values[i].name, text);
            }
        }
        else {
            this.insertFormat(this.valuesDropDown.value.toString(), text);
        }
        const eventArgs = {
            formatSettings: PivotUtil.cloneFormatSettings(this.newFormat),
            formatName: this.valuesDropDown.value.toString(),
            cancel: false
        };
        this.parent.trigger(numberFormatting, eventArgs, (observedArgs) => {
            if (!observedArgs.cancel) {
                this.parent.setProperties({ dataSourceSettings: { formatSettings: observedArgs.formatSettings } }, true);
                const actionInfo = {
                    numberFormattingInfo: this.parent.dataSourceSettings.formatSettings
                };
                this.parent.actionObj.actionInfo = actionInfo;
                try {
                    this.parent.updateDataSource();
                    this.dialog.close();
                }
                catch (exception) {
                    this.parent.setProperties({ dataSourceSettings: { formatSettings: format } }, true);
                    this.parent.pivotCommon.errorDialog.createErrorDialog(this.parent.localeObj.getConstant('error'), this.parent.localeObj.getConstant('invalidFormat'), this.dialog.element);
                    this.parent.hideWaitingPopup();
                }
            }
            else {
                this.dialog.close();
                this.parent.setProperties({ dataSourceSettings: { formatSettings: format } }, true);
            }
        });
    }
    insertFormat(fieldName, text, formatType) {
        let isExist = false;
        const newFormat = {
            name: fieldName, format: text,
            useGrouping: this.groupingDropDown.value === this.parent.localeObj.getConstant('true') ? true : false,
            type: formatType
        };
        const format = this.newFormat;
        for (let i = 0; i < format.length; i++) {
            if (format[i].name === fieldName) {
                format[i] = newFormat;
                isExist = true;
            }
        }
        if (!isExist) {
            format.push(newFormat);
        }
        this.lastFormattedValue = [];
        this.lastFormattedValue.push(newFormat);
    }
    /**
     * To add event listener.
     *
     * @returns {void}
     * @hidden
     */
    addEventListener() {
        if (this.parent.isDestroyed) {
            return;
        }
        this.parent.on(initFormatting, this.showNumberFormattingDialog, this);
    }
    /**
     * To remove event listener.
     *
     * @returns {void}
     * @hidden
     */
    removeEventListener() {
        if (this.parent.isDestroyed) {
            return;
        }
        this.parent.off(initFormatting, this.showNumberFormattingDialog);
    }
    /**
     * To destroy the calculated field dialog
     *
     * @returns {void}
     * @hidden
     */
    destroy() {
        if (this.dialog && !this.dialog.isDestroyed) {
            this.dialog.destroy();
        }
        this.removeEventListener();
    }
}

/**
 * `Grouping` module to create grouping option for date, number and custom in popup.
 */
/** @hidden */
class Grouping {
    /**
     * Constructor for the group UI rendering.
     *
     * @param {PivotView} parent - Instance.
     * @hidden
     */
    constructor(parent) {
        this.dateGroup = /_date_group_years|_date_group_quarters|_date_group_quarterYear|_date_group_months|_date_group_days|_date_group_hours|_date_group_minutes|_date_group_seconds/g;
        this.parent = parent;
        this.parent.groupingModule = this;
        this.addEventListener();
    }
    /**
     * For internal use only - Get the module name.
     *
     * @returns {string} - string
     * @private
     */
    getModuleName() {
        return 'grouping';
    }
    render(args) {
        const target = args.target;
        const option = args.option;
        const parentElement = args.parentElement;
        this.parentElement = parentElement;
        this.selectedCellsInfo = [];
        this.isUpdate = false;
        const colIndex = Number(target.getAttribute('data-colindex'));
        const rowIndex = Number(target.getAttribute('index'));
        const cell = this.parent.engineModule.pivotValues[rowIndex][colIndex];
        const fieldName = cell.valueSort.axis.toString();
        this.selectedCellsInfo = this.getSelectedCells(cell.axis, fieldName, cell.actualText.toString());
        this.selectedCellsInfo.push({ axis: cell.axis, fieldName: fieldName, name: cell.actualText.toString(), cellInfo: cell });
        if (option.replace(parentElement.id, '').indexOf('_custom_group') !== -1) {
            this.createGroupSettings(fieldName);
        }
        else {
            this.updateUnGroupSettings(fieldName);
        }
    }
    /**
     * Returns the selected members/headers by checing the valid members from the pivot table.
     *
     * @function getSelectedOptions
     * @param  {SelectedCellsInfo[]} selectedCellsInfo - Get the members name from the given selected cells information
     * @returns {string[]} - string
     * @hidden
     */
    getSelectedOptions(selectedCellsInfo) {
        const selectedOptions = [];
        for (const option of selectedCellsInfo) {
            if (PivotUtil.inArray(option.name, selectedOptions) === -1) {
                selectedOptions.push(option.name);
            }
        }
        return selectedOptions;
    }
    createGroupSettings(fieldName) {
        const fieldList = this.parent.engineModule.fieldList[fieldName];
        const group = this.getGroupSettings(fieldName);
        if (this.selectedCellsInfo.length > 0) {
            let type;
            let isInvalid = false;
            if (fieldList.isCustomField) {
                if (!group) {
                    const dateGroup = this.getGroupSettings(fieldName.replace(this.dateGroup, ''));
                    const customGroup = this.getGroupSettings(fieldName.replace(/_custom_group/g, ''));
                    if (dateGroup) {
                        isInvalid = false;
                        type = 'date';
                        fieldName = fieldName.replace(this.dateGroup, '');
                    }
                    else if (customGroup) {
                        isInvalid = this.selectedCellsInfo.length === 1;
                        type = 'custom';
                    }
                }
                else if (group && group.type === 'Custom') {
                    if (this.selectedCellsInfo.length === 1) {
                        isInvalid = true;
                    }
                    else {
                        isInvalid = false;
                        type = 'custom';
                    }
                }
                else if (group && group.type === 'Number') {
                    isInvalid = false;
                    type = 'number';
                }
            }
            else {
                if (group) {
                    if (group.type === 'Number' || group.type === 'Date') {
                        isInvalid = false;
                        type = group.type === 'Date' ? 'date' : 'number';
                    }
                    else if (group.type === 'Custom') {
                        isInvalid = this.selectedCellsInfo.length === 1;
                        type = 'custom';
                    }
                }
                else {
                    if (fieldList.type === 'number' ||
                        (['datetime', 'date']).indexOf(fieldList.type) !== -1 || this.isDateType(fieldName)) {
                        isInvalid = false;
                        type = (this.selectedCellsInfo.length === 1 ? ((['datetime', 'date']).indexOf(fieldList.type) !== -1 ||
                            this.isDateType(fieldName)) ? 'date' : 'number' : 'custom');
                    }
                    else if (fieldList.type === 'string') {
                        isInvalid = this.selectedCellsInfo.length === 1;
                        type = 'custom';
                    }
                }
            }
            if (isInvalid) {
                this.parent.pivotCommon.errorDialog.createErrorDialog(this.parent.localeObj.getConstant('warning'), this.parent.localeObj.getConstant('invalidSelection'));
                this.parent.grid.clearSelection();
            }
            else if (type && type !== '') {
                this.createGroupDialog(fieldName, type);
            }
        }
    }
    updateUnGroupSettings(fieldName) {
        const fieldList = this.parent.engineModule.fieldList[fieldName];
        let groupFields = PivotUtil.cloneGroupSettings(this.parent.dataSourceSettings.groupSettings);
        const group = this.getGroupSettings(fieldName);
        if (this.selectedCellsInfo.length > 0) {
            let type;
            if (fieldList.isCustomField) {
                if (!group) {
                    const dateGroup = this.getGroupSettings(fieldName.replace(this.dateGroup, ''));
                    const customGroup = this.getGroupSettings(fieldName.replace(/_custom_group/g, ''));
                    if (dateGroup) {
                        type = 'date';
                        fieldName = fieldName.replace(this.dateGroup, '');
                    }
                    else if (customGroup) {
                        type = 'custom';
                    }
                }
                else if (group.type === 'Custom') {
                    type = 'custom';
                }
            }
            else {
                if (group) {
                    if (group.type === 'Number' || group.type === 'Date') {
                        type = group.type === 'Date' ? 'date' : 'number';
                    }
                }
            }
            if (type === 'date' || type === 'number') {
                groupFields = this.validateSettings(fieldName, groupFields, type, []);
            }
            else if (type === 'custom') {
                const selectedOptions = this.getSelectedOptions(this.selectedCellsInfo);
                groupFields = this.validateSettings(fieldName, groupFields, type, selectedOptions);
            }
            this.updateDateSource(groupFields, type);
        }
    }
    updateDateSource(groupFields, type) {
        if (this.isUpdate) {
            this.parent.setProperties({ dataSourceSettings: { groupSettings: groupFields } }, true);
            this.parent.updateGroupingReport(groupFields, (type === 'date' ? 'Date' : type === 'custom' ? 'Custom' : 'Number'));
            if (this.parent.dataSourceSettings.mode === 'Server') {
                this.parent.getEngine('onRefresh');
            }
            else {
                this.parent.initEngine();
            }
        }
    }
    removeGroupSettings(fieldName, selectedOptions, groupFields, groupNames) {
        const index = groupNames.indexOf(fieldName);
        if (index !== -1) {
            const field = groupFields[index];
            for (let j = 0, len = field.customGroups.length; j < len; j++) {
                if (field.customGroups[j]) {
                    const group = field.customGroups[j];
                    if (PivotUtil.inArray(group.groupName, selectedOptions) !== -1) {
                        groupFields = this.modifyParentGroupItems(fieldName, groupFields, [group.groupName], group.items, groupNames);
                        field.customGroups.splice(j, 1);
                        this.isUpdate = true;
                        j--;
                        len--;
                    }
                }
            }
        }
        // eslint-disable-next-line security/detect-object-injection
        delete this.parent.engineModule.groupingFieldsInfo[fieldName];
        return groupFields;
    }
    getGroupSettings(fieldName) {
        for (const group of this.parent.dataSourceSettings.groupSettings) {
            if (group.name === fieldName) {
                return group;
            }
        }
        return undefined;
    }
    isDateType(fieldName) {
        for (const format of this.parent.dataSourceSettings.formatSettings) {
            if (format.name === fieldName && format.type) {
                return true;
            }
        }
        return false;
    }
    /**
     * Returns the selected members/headers by checing the valid members from the pivot table.
     *
     * @function getSelectedCells
     * @param  {string} axis - Spicifies the axis name for the given field.
     * @param  {string} fieldName - Gets selected members for the given field name.
     * @param  {string} name - specifies the selected member name for the given field.
     * @returns {SelectedCellsInfo[]} - return type
     * @hidden
     */
    getSelectedCells(axis, fieldName, name) {
        const selectedCellsInfo = []; // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const selectedElements = this.parent.element.querySelectorAll('.' + CELL_SELECTED_BGCOLOR + ',.' + SELECTED_BGCOLOR);
        for (const element of selectedElements) {
            const colIndex = Number(element.getAttribute('data-colindex'));
            const rowIndex = Number(element.getAttribute('index'));
            const cell = this.parent.engineModule.pivotValues[rowIndex][colIndex];
            if (cell && (cell.axis === axis) && !(cell.type === 'grand sum' || cell.type === 'sum') &&
                cell.valueSort.axis === fieldName && name !== cell.actualText.toString()) {
                selectedCellsInfo.push({
                    axis: cell.axis,
                    fieldName: cell.valueSort.axis.toString(),
                    name: cell.actualText.toString(),
                    cellInfo: cell
                });
            }
        }
        return selectedCellsInfo;
    }
    createGroupDialog(fieldName, type) {
        const groupDialog = createElement('div', {
            id: this.parentElement.id + '_GroupDialog',
            className: 'e-group-field-settings',
            attrs: { 'data-field': fieldName, 'data-type': type }
        });
        this.parentElement.appendChild(groupDialog);
        this.groupDialog = new Dialog({
            animationSettings: { effect: 'Fade' },
            allowDragging: true,
            header: this.parent.localeObj.getConstant('grouping'),
            content: this.createGroupOptions(fieldName, type),
            isModal: true,
            visible: true,
            showCloseIcon: true,
            enableRtl: this.parent.enableRtl,
            locale: this.parent.locale,
            enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
            width: 300,
            height: 'auto',
            position: { X: 'center', Y: 'center' },
            buttons: [
                {
                    click: this.updateGroupSettings.bind(this),
                    buttonModel: { cssClass: OK_BUTTON_CLASS + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''), content: this.parent.localeObj.getConstant('ok'), isPrimary: true }
                },
                {
                    click: () => {
                        this.groupDialog.hide();
                    },
                    buttonModel: { cssClass: CANCEL_BUTTON_CLASS + (this.parent.cssClass ? (' ' + this.parent.cssClass) : ''), content: this.parent.localeObj.getConstant('cancel') }
                }
            ],
            overlayClick: () => {
                this.removeDialog();
            },
            closeOnEscape: true,
            close: this.removeDialog.bind(this),
            target: this.parentElement,
            cssClass: this.parent.cssClass
        });
        this.groupDialog.isStringTemplate = true;
        this.groupDialog.appendTo(groupDialog);
    }
    createGroupOptions(fieldName, type) {
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const groupInstance = this;
        const mainDiv = createElement('div', {
            className: 'e-group-field-div-content', id: this.parentElement.id + '_group_field_div_content',
            attrs: { 'data-fieldName': fieldName, 'data-type': type }
        });
        const groupWrapperDiv1 = createElement('div', { className: 'e-group-option-container' });
        mainDiv.appendChild(groupWrapperDiv1);
        // this.parentElement.appendChild(mainDiv);
        const dataSource = this.parent.dataSourceSettings;
        const groupField = PivotUtil.getFieldByName(fieldName, dataSource.groupSettings);
        switch (type) {
            case 'custom':
                {
                    let caption;
                    let dataFields = dataSource.rows;
                    dataFields = dataFields.concat(dataSource.columns, dataSource.values, dataSource.filters);
                    const actualField = PivotUtil.getFieldByName(fieldName.replace(/_custom_group/g, ''), dataFields);
                    const currentField = PivotUtil.getFieldByName(fieldName, dataFields);
                    const nextField = PivotUtil.getFieldByName(fieldName + '_custom_group', dataFields);
                    if (currentField) {
                        const newFieldName = fieldName + '_custom_group';
                        caption = nextField ? nextField.caption :
                            this.parent.engineModule.fieldList[actualField.name].caption + (newFieldName.match(/_custom_group/g).length + 1);
                    }
                    const captionInputTextDiv1 = createElement('div', {
                        className: 'e-caption-option-text'
                    });
                    captionInputTextDiv1.innerText = this.parent.localeObj.getConstant('groupFieldCaption');
                    const captionInputDiv1 = createElement('div', { className: 'e-group-caption-container' });
                    const captionInputField1 = createElement('input', {
                        id: this.parentElement.id + 'group_caption_option',
                        className: 'e-group-caption-text',
                        attrs: { 'type': 'text' }
                    });
                    captionInputDiv1.appendChild(captionInputTextDiv1);
                    captionInputDiv1.appendChild(captionInputField1);
                    groupWrapperDiv1.appendChild(captionInputDiv1);
                    const inputTextDiv1 = createElement('div', {
                        className: 'e-input-option-text'
                    });
                    inputTextDiv1.innerText = this.parent.localeObj.getConstant('groupTitle');
                    const inputDiv1 = createElement('div', { className: 'e-group-input-container' });
                    const inputField1 = createElement('input', {
                        id: this.parentElement.id + 'group_input_option',
                        className: 'e-group-input-text',
                        attrs: { 'type': 'text' }
                    });
                    inputDiv1.appendChild(inputTextDiv1);
                    inputDiv1.appendChild(inputField1);
                    groupWrapperDiv1.appendChild(inputDiv1);
                    const captionInputObj1 = new MaskedTextBox({
                        placeholder: this.parent.localeObj.getConstant('captionName'),
                        enableRtl: this.parent.enableRtl,
                        locale: this.parent.locale,
                        value: caption, width: '100%',
                        cssClass: this.parent.cssClass
                    });
                    captionInputObj1.isStringTemplate = true;
                    captionInputObj1.appendTo(captionInputField1);
                    const inputObj1 = new MaskedTextBox({
                        placeholder: this.parent.localeObj.getConstant('groupName'),
                        enableRtl: this.parent.enableRtl,
                        locale: this.parent.locale,
                        width: '100%',
                        cssClass: this.parent.cssClass
                    });
                    inputObj1.isStringTemplate = true;
                    inputObj1.appendTo(inputField1);
                }
                break;
            case 'date':
            case 'number':
                {
                    const startAtWrapper = createElement('div', {
                        className: 'e-group-start-option-container'
                    });
                    const startAtOptionDiv1 = createElement('input', {
                        id: this.parentElement.id + 'group_start_option',
                        className: 'e-group_start_option',
                        attrs: { 'type': 'checkbox' }
                    });
                    const startAtInputField1 = createElement('input', {
                        id: this.parentElement.id + 'group_start_input',
                        className: 'e-group_start_input',
                        attrs: { 'type': 'text' }
                    });
                    startAtWrapper.appendChild(startAtOptionDiv1);
                    startAtWrapper.appendChild(startAtInputField1);
                    groupWrapperDiv1.appendChild(startAtWrapper);
                    const endAtWrapper = createElement('div', {
                        className: 'e-group-end-option-container'
                    });
                    const endAtOptionDiv1 = createElement('input', {
                        id: this.parentElement.id + 'group_end_option',
                        className: 'e-group_end_option',
                        attrs: { 'type': 'checkbox' }
                    });
                    const endAtInputField1 = createElement('input', {
                        id: this.parentElement.id + 'group_end_input',
                        className: 'e-group_end_input',
                        attrs: { 'type': 'text' }
                    });
                    endAtWrapper.appendChild(endAtOptionDiv1);
                    endAtWrapper.appendChild(endAtInputField1);
                    groupWrapperDiv1.appendChild(endAtWrapper);
                    const intervalWrapper = createElement('div', {
                        className: 'e-group-interval-option-container'
                    });
                    const intervalTextDiv1 = createElement('div', {
                        className: 'e-group-inerval-option-text'
                    });
                    intervalTextDiv1.innerText = this.parent.localeObj.getConstant('groupBy');
                    const intervalInputField1 = createElement('input', {
                        id: this.parentElement.id + 'group_interval_input',
                        className: 'e-group_interval_input',
                        attrs: { 'type': 'text' }
                    });
                    intervalWrapper.appendChild(intervalTextDiv1);
                    intervalWrapper.appendChild(intervalInputField1);
                    groupWrapperDiv1.appendChild(intervalWrapper);
                    let startAt = undefined;
                    let endAt = undefined;
                    if (type === 'date') {
                        let selectedGroups = [];
                        const groupData = [
                            { value: 'Seconds', text: this.parent.localeObj.getConstant('Seconds') },
                            { value: 'Minutes', text: this.parent.localeObj.getConstant('Minutes') },
                            { value: 'Hours', text: this.parent.localeObj.getConstant('Hours') },
                            { value: 'Days', text: this.parent.localeObj.getConstant('Days') },
                            { value: 'Months', text: this.parent.localeObj.getConstant('Months') },
                            { value: 'QuarterYear', text: this.parent.localeObj.getConstant('QuarterYear') },
                            { value: 'Quarters', text: this.parent.localeObj.getConstant('Quarters') },
                            { value: 'Years', text: this.parent.localeObj.getConstant('Years') }
                        ];
                        if (groupField && groupField.type === 'Date') {
                            selectedGroups = groupField.groupInterval;
                            startAt = groupField.startingAt ? groupField.startingAt.toString() : undefined;
                            endAt = groupField.endingAt ? groupField.endingAt.toString() : undefined;
                        }
                        else {
                            selectedGroups = ['Months'];
                        }
                        const startAtInputObj = new DateTimePicker({
                            placeholder: this.parent.localeObj.getConstant('chooseDate'),
                            enableRtl: this.parent.enableRtl,
                            locale: this.parent.locale,
                            format: 'dd/MM/yyyy hh:mm:ss a',
                            enabled: !(startAt === undefined),
                            width: '100%',
                            cssClass: this.parent.cssClass
                        });
                        startAtInputObj.isStringTemplate = true;
                        startAtInputObj.appendTo(startAtInputField1);
                        const endAtInputObj = new DateTimePicker({
                            placeholder: this.parent.localeObj.getConstant('chooseDate'),
                            enableRtl: this.parent.enableRtl,
                            locale: this.parent.locale,
                            format: 'dd/MM/yyyy hh:mm:ss a',
                            enabled: !(endAt === undefined),
                            width: '100%',
                            cssClass: this.parent.cssClass
                        });
                        endAtInputObj.isStringTemplate = true;
                        endAtInputObj.appendTo(endAtInputField1);
                        MultiSelect.Inject(CheckBoxSelection);
                        const intervalObj = new MultiSelect({
                            dataSource: groupData,
                            value: selectedGroups,
                            fields: { text: 'text', value: 'value' },
                            mode: 'CheckBox',
                            showDropDownIcon: true,
                            enableSelectionOrder: false,
                            placeholder: this.parent.localeObj.getConstant('selectGroup'),
                            filterBarPlaceholder: this.parent.localeObj.getConstant('example') + ' ' + this.parent.localeObj.getConstant('Months'),
                            enableRtl: this.parent.enableRtl,
                            locale: this.parent.locale,
                            enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
                            cssClass: this.parent.cssClass,
                            select: () => {
                                groupInstance.groupDialog.element.querySelector('.' + OK_BUTTON_CLASS).removeAttribute('disabled');
                            },
                            removed: () => {
                                if (intervalObj.checkBoxSelectionModule.activeLi.length === 0) {
                                    groupInstance.groupDialog.element.querySelector('.' + OK_BUTTON_CLASS).setAttribute('disabled', 'disabled');
                                }
                            }
                        });
                        intervalObj.isStringTemplate = true;
                        intervalObj.appendTo(intervalInputField1);
                        startAtInputObj.value = startAt === undefined ? null : new Date(startAt);
                        startAtInputObj.dataBind();
                        endAtInputObj.value = endAt === undefined ? null : new Date(endAt);
                        endAtInputObj.dataBind();
                    }
                    else {
                        let selectedInterval = undefined;
                        if (groupField && groupField.type === 'Number') {
                            selectedInterval = groupField.rangeInterval;
                            startAt = groupField.startingAt ? groupField.startingAt.toString() : undefined;
                            endAt = groupField.endingAt ? groupField.endingAt.toString() : undefined;
                        }
                        else {
                            selectedInterval = 2;
                        }
                        const startAtInputObj = new NumericTextBox({
                            placeholder: this.parent.localeObj.getConstant('enterValue'),
                            enableRtl: this.parent.enableRtl,
                            locale: this.parent.locale,
                            showClearButton: true,
                            format: '###',
                            value: startAt === undefined ? undefined : parseInt(startAt, 10),
                            enabled: !(startAt === undefined),
                            width: '100%',
                            cssClass: this.parent.cssClass
                        });
                        startAtInputObj.isStringTemplate = true;
                        startAtInputObj.appendTo(startAtInputField1);
                        const endAtInputObj = new NumericTextBox({
                            placeholder: this.parent.localeObj.getConstant('enterValue'),
                            enableRtl: this.parent.enableRtl,
                            locale: this.parent.locale,
                            showClearButton: true,
                            format: '###',
                            value: endAt === undefined ? undefined : parseInt(endAt, 10),
                            enabled: !(endAt === undefined),
                            width: '100%',
                            cssClass: this.parent.cssClass
                        });
                        endAtInputObj.isStringTemplate = true;
                        endAtInputObj.appendTo(endAtInputField1);
                        const intervalObj = new NumericTextBox({
                            placeholder: this.parent.localeObj.getConstant('enterValue'),
                            enableRtl: this.parent.enableRtl,
                            locale: this.parent.locale,
                            showClearButton: true,
                            format: '###',
                            min: 1,
                            value: selectedInterval,
                            width: '100%',
                            cssClass: this.parent.cssClass
                        });
                        intervalObj.isStringTemplate = true;
                        intervalObj.appendTo(intervalInputField1);
                    }
                    const startAtObj = new CheckBox({
                        label: this.parent.localeObj.getConstant('startAt'),
                        checked: !(startAt === undefined),
                        enableRtl: this.parent.enableRtl,
                        locale: this.parent.locale,
                        enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
                        cssClass: this.parent.cssClass,
                        change: (args) => {
                            const startAtObj = (type === 'date' ?
                                getInstance(select('#' + this.parentElement.id + 'group_start_input'), DateTimePicker) :
                                getInstance(select('#' + this.parentElement.id + 'group_start_input'), NumericTextBox));
                            startAtObj.enabled = args.checked;
                            startAtObj.dataBind();
                        }
                    });
                    startAtObj.isStringTemplate = true;
                    startAtObj.appendTo(startAtOptionDiv1);
                    const endAtObj = new CheckBox({
                        label: this.parent.localeObj.getConstant('endAt'),
                        checked: !(endAt === undefined),
                        enableRtl: this.parent.enableRtl,
                        locale: this.parent.locale,
                        enableHtmlSanitizer: this.parent.enableHtmlSanitizer,
                        cssClass: this.parent.cssClass,
                        change: (args) => {
                            const endAtObj = (type === 'date' ?
                                getInstance(select('#' + this.parentElement.id + 'group_end_input'), DateTimePicker) :
                                getInstance(select('#' + this.parentElement.id + 'group_end_input'), NumericTextBox));
                            endAtObj.enabled = args.checked;
                            endAtObj.dataBind();
                        }
                    });
                    endAtObj.isStringTemplate = true;
                    endAtObj.appendTo(endAtOptionDiv1);
                }
                break;
        }
        return mainDiv;
    }
    updateGroupSettings() {
        const dialogElement = this.groupDialog.element;
        const groupType = dialogElement.getAttribute('data-type');
        const fieldName = dialogElement.getAttribute('data-field');
        let groupFields = PivotUtil.cloneGroupSettings(this.parent.dataSourceSettings.groupSettings);
        if (groupFields.length === 0 && !this.parent.clonedDataSet && !this.parent.clonedReport) {
            const dataSet = this.parent.engineModule.data;
            this.parent.clonedDataSet = PivotUtil.getClonedData(dataSet);
            this.parent.setProperties({ dataSourceSettings: { dataSource: [] } }, true);
            this.parent.clonedReport = extend({}, this.parent.dataSourceSettings, null, true);
            this.parent.setProperties({ dataSourceSettings: { dataSource: dataSet } }, true);
        }
        if (groupType === 'custom') {
            const inputInstance = getInstance(select('#' + this.parentElement.id + 'group_input_option'), MaskedTextBox);
            const captionInputInstance = getInstance(select('#' + this.parentElement.id + 'group_caption_option'), MaskedTextBox);
            removeClass([inputInstance.element], EMPTY_FIELD);
            if (inputInstance.value === null || inputInstance.value === '') {
                addClass([inputInstance.element], EMPTY_FIELD);
                inputInstance.element.focus();
                return;
            }
            const selectedOptions = this.getSelectedOptions(this.selectedCellsInfo);
            const customGroup = { groupName: inputInstance.value, items: selectedOptions };
            let splicedItems = [];
            let newItems = [];
            let field = { name: fieldName, caption: captionInputInstance.value, type: 'Custom', customGroups: [] };
            let isUpdated = false;
            for (let i = 0, len = groupFields.length; i < len; i++) {
                if (groupFields[i].name === fieldName) {
                    field = groupFields[i];
                    field.caption = captionInputInstance.value;
                    for (let j = 0, len = field.customGroups.length; j < len; j++) {
                        if (field.customGroups[j]) {
                            const group = field.customGroups[j];
                            if (group.items && PivotExportUtil.isContainCommonElements(group.items, selectedOptions)) {
                                splicedItems = this.mergeArray(splicedItems, [group.groupName]);
                                newItems = this.mergeArray(newItems, group.items);
                                field.customGroups.splice(j, 1);
                                j--;
                                len--;
                            }
                        }
                    }
                    for (const item of selectedOptions) {
                        const index = newItems.indexOf(item);
                        if (index !== -1) {
                            newItems.splice(index, 1);
                        }
                    }
                    newItems = this.mergeArray(newItems, [customGroup.groupName]);
                    field.customGroups.push(customGroup);
                    this.isUpdate = true;
                    isUpdated = true;
                    break;
                }
            }
            if (!isUpdated) {
                field.customGroups.push(customGroup);
                this.isUpdate = true;
                groupFields.push(field);
            }
            groupFields = this.validateSettings(fieldName, groupFields, groupType, (splicedItems.length === 0 ?
                customGroup.items : splicedItems), newItems);
        }
        else if (groupType === 'date' || groupType === 'number') {
            const startCheckBoxInstance = getInstance(select('#' + this.parentElement.id + 'group_start_option'), CheckBox);
            const endCheckBoxInstance = getInstance(select('#' + this.parentElement.id + 'group_end_option'), CheckBox);
            const startInputInstance = (groupType === 'date' ?
                getInstance(select('#' + this.parentElement.id + 'group_start_input'), DateTimePicker) :
                getInstance(select('#' + this.parentElement.id + 'group_start_input'), NumericTextBox));
            const endInputInstance = (groupType === 'date' ?
                getInstance(select('#' + this.parentElement.id + 'group_end_input'), DateTimePicker) :
                getInstance(select('#' + this.parentElement.id + 'group_end_input'), NumericTextBox));
            const intervalInstance = (groupType === 'date' ?
                getInstance(select('#' + this.parentElement.id + 'group_interval_input'), MultiSelect) :
                getInstance(select('#' + this.parentElement.id + 'group_interval_input'), NumericTextBox));
            const startAt = startCheckBoxInstance.checked ? startInputInstance.value.toString() : undefined;
            const endAt = endCheckBoxInstance.checked ? endInputInstance.value.toString() : undefined;
            const field = { name: fieldName, startingAt: startAt, endingAt: endAt };
            if (groupType === 'date') {
                const selectedItems = [];
                for (const list of intervalInstance.value) {
                    selectedItems.push(list);
                }
                field.type = 'Date';
                field.groupInterval = selectedItems;
            }
            else {
                field.type = 'Number';
                field.rangeInterval = intervalInstance.value;
            }
            let isUpdated = false;
            for (let i = 0, len = groupFields.length; i < len; i++) {
                if (groupFields[i].name === fieldName) {
                    groupFields.splice(i, 1, field);
                    this.isUpdate = true;
                    isUpdated = true;
                    break;
                }
            }
            if (!isUpdated) {
                this.isUpdate = true;
                groupFields.push(field);
            }
            groupFields = this.validateSettings(fieldName, groupFields, groupType, [], []);
        }
        this.groupDialog.close();
        this.updateDateSource(groupFields, groupType);
    }
    getGroupBasedSettings(groupFields) {
        const groups = {};
        for (const group of groupFields) {
            if (groups[group.type]) {
                groups[group.type].push(group);
            }
            else {
                groups[group.type] = [group];
            }
        }
        return groups;
    }
    getGroupByName(groupFields) {
        const customFields = {};
        for (const field of groupFields) {
            const name = field.name.replace(/_custom_group/g, '');
            if (customFields[name]) {
                customFields[name].push(field);
            }
            else {
                customFields[name] = [field];
            }
        }
        return customFields;
    }
    validateSettings(fieldName, groupFields, groupType, splicedItems, newItems) {
        let validatedSettings = [];
        const groups = this.getGroupBasedSettings(groupFields);
        const groupOrders = ['Date', 'Number', 'Custom'];
        if (groups[groupOrders[2]] && groupType === 'custom') {
            const customFields = this.getGroupByName(groups[groupOrders[2]]);
            if (customFields[fieldName.replace(/_custom_group/g, '')]) {
                let customGroups = customFields[fieldName.replace(/_custom_group/g, '')];
                const fields = customGroups.map((item) => item.name);
                if (newItems) {
                    customGroups = this.modifyParentGroupItems(fieldName, customGroups, splicedItems, newItems, fields);
                }
                else {
                    customGroups = this.removeGroupSettings(fieldName.replace('_custom_group', ''), splicedItems, customGroups, fields);
                }
            }
            let orderedGroups = [];
            for (const field of Object.keys(customFields)) {
                const fields = customFields[field].map((item) => item.name);
                orderedGroups = this.reOrderSettings(customFields[field], fields, orderedGroups, field);
            }
            groups[groupOrders[2]] = orderedGroups;
        }
        else if ((groupType === 'date' || groupType === 'number') && !newItems) {
            const groupFields = groupType === 'date' ? groups[groupOrders[0]] : groups[groupOrders[1]];
            if (groupType === 'date') {
                groups[groupOrders[0]] = groupFields.filter((field) => { return field.name !== fieldName; });
                if (groups[groupOrders[0]].length === 0) { // eslint-disable-next-line security/detect-object-injection
                    delete this.parent.engineModule.groupingFieldsInfo[fieldName];
                }
            }
            else {
                groups[groupOrders[1]] = groupFields.filter((field) => { return field.name !== fieldName; });
            }
            this.isUpdate = true;
        }
        for (const order of groupOrders) {
            if (groups[order]) {
                validatedSettings = validatedSettings.concat(groups[order]);
            }
        }
        return validatedSettings;
    }
    reOrderSettings(customGroups, fields, orderedSettings, fieldName) {
        const index = fields.indexOf(fieldName);
        if (index > -1 && customGroups[index].customGroups && customGroups[index].customGroups.length > 0) {
            orderedSettings.push(customGroups[index]);
            this.reOrderSettings(customGroups, fields, orderedSettings, fieldName + '_custom_group');
        }
        return orderedSettings;
    }
    modifyParentGroupItems(fieldName, groupFields, splicedItems, newItems, fields) {
        const index = fields.indexOf(fieldName + '_custom_group');
        if (index !== -1) {
            const field = groupFields[index];
            if (field.customGroups && field.customGroups.length > 0) {
                for (let i = 0, len = field.customGroups.length; i < len; i++) {
                    if (field.customGroups[i]) {
                        let isItemsUpdated = false;
                        const group = field.customGroups[i];
                        if (group.items) {
                            for (const item of splicedItems) {
                                const pos = group.items.indexOf(item);
                                if (pos !== -1) {
                                    group.items.splice(pos, 1);
                                    this.isUpdate = true;
                                    isItemsUpdated = true;
                                }
                            }
                            if (isItemsUpdated) {
                                group.items = this.mergeArray(group.items, newItems);
                            }
                        }
                    }
                }
            }
        }
        return groupFields;
    }
    mergeArray(collection1, collection2) {
        const resultArray = [];
        const array = collection1.concat(collection2);
        let len = array.length;
        const assoc = {};
        while (len--) {
            const item = String(array[len]);
            if (!assoc[item]) {
                resultArray.unshift(item);
                assoc[item] = true;
            }
        }
        return resultArray;
    }
    removeDialog() {
        if (this.parent.grid && this.parent.grid.isDestroyed) {
            return;
        }
        this.parent.grid.clearSelection();
        if (this.groupDialog && !this.groupDialog.isDestroyed) {
            this.groupDialog.destroy();
        }
        if (this.parentElement && document.getElementById(this.parentElement.id + '_GroupDialog')) {
            remove(document.getElementById(this.parentElement.id + '_GroupDialog'));
        }
    }
    /**
     *
     * @returns {void}
     * @hidden
     */
    addEventListener() {
        this.handlers = {
            load: this.render
        };
        if (this.parent.isDestroyed) {
            return;
        }
        this.parent.on(initGrouping, this.handlers.load, this); //For initial rendering
    }
    /**
     *
     * @returns {void}
     * @hidden
     */
    removeEventListener() {
        if (this.parent.isDestroyed) {
            return;
        }
        this.removeDialog();
        this.parent.off(initGrouping, this.handlers.load);
    }
    /**
     * To destroy the pivot button event listener
     *
     * @returns {void}
     * @hidden
     */
    destroy() {
        this.removeEventListener();
    }
}

/**
 * common exported items
 */

/**
 * olap engine exported items
 */

/**
 * Data modules
 */
/** @hidden */

/**
 * PivotGrid component exported items
 */

/**
 * Export PivotGrid components
 */

export { GroupingBarSettings, CellEditSettings, ConditionalSettings, HyperlinkSettings, PageSettings, PagerSettings, DisplayOption, PivotView, Render, ExcelExport$1 as ExcelExport, PDFExport, KeyboardInteraction, VirtualScroll$1 as VirtualScroll, DrillThrough, Pager$1 as Pager, PivotChart, PivotFieldList, TreeViewRenderer, AxisFieldRenderer, AxisTableRenderer, DialogRenderer, EventBase, NodeStateModified, DataSourceUpdate, FieldList, CommonKeyboardInteraction, Common, GroupingBar, CalculatedField, ConditionalFormatting, PivotCommon, load, enginePopulating, enginePopulated, onFieldDropped, fieldDrop, beforePivotTableRender, afterPivotTableRender, beforeExport, exportComplete, excelHeaderQueryCellInfo, pdfHeaderQueryCellInfo, excelQueryCellInfo, pdfQueryCellInfo, onPdfCellRender, dataBound, queryCellInfo, headerCellInfo, hyperlinkCellClick, resizing, resizeStop, cellClick, drillThrough, beforeColumnsRender, selected, cellSelecting, drill, cellSelected, cellDeselected, rowSelected, rowDeselected, beginDrillThrough, editCompleted, multiLevelLabelClick, saveReport, fetchReport, loadReport, renameReport, removeReport, newReport, toolbarRender, toolbarClick, chartTooltipRender, chartLegendClick, chartLoaded, chartLoad, chartResized, chartAxisLabelRender, chartSeriesCreated, aggregateCellInfo, onHeadersSort, contextMenuClick, contextMenuOpen, fieldListRefreshed, conditionalFormatting, beforePdfExport, beforeExcelExport, memberFiltering, calculatedFieldCreate, memberEditorOpen, fieldRemove, numberFormatting, aggregateMenuOpen, fieldDragStart, chartPointClick, beforeServiceInvoke, actionBegin, actionComplete, actionFailure, initialLoad, uiUpdate, scroll, verticalScroll, horizontalScroll, contentReady, dataReady, initSubComponent, treeViewUpdate, pivotButtonUpdate, initCalculatedField, click, initToolbar, initPivotPager, initFormatting, initGrouping, sortValue, drillUp, drillDown, addNewReport, saveCurrentReport, saveAsCurrentReport, renameCurrentReport, removeCurrentReport, loadReports, openConditionalFormatting, openNumberFormatting, MdxQuery, showFieldList, tableView, chartView, multipleAxis, showLegend, pdfExport, pngExport, excelExport, csvExport, jpegExport, svgExport, hideSubTotals, subTotalsRow, subTotalsColumn, showSubTotals, hideGrandTotals, grandTotalsRow, grandTotalsColumn, showGrandTotals, numberFormattingMenu, conditionalFormattingMenu, reportChange, sortFieldTree, editCalculatedField, sortField, filterField, removeField, openCalculatedField, editRecord, saveEditedRecords, addNewRecord, removeRecord, aggregateField, contextMenuCalculatedField, windowResize, rowPageNavigation, columnPageNavigation, calculatedFieldApplied, editedRecordsSaved, newRecordAdded, recordRemoved, closeFieldlist, fieldTreeSorted, reportSaved, newReportAdded, reportReSaved, reportRenamed, reportRemoved, excelExported, csvExported, pdfExported, pngExported, jpegExported, svgExported, conditionallyFormatted, numberFormatted, tableViewed, chartViewed, subTotalsHidden, subTotalsRowShown, subTotalsColumnShown, subTotalsShown, grandTotalsHidden, grandTotalsRowShown, grandTotalsColumnShown, grandTotalsShown, valueSorted, calculatedFieldEdited, fieldSorted, fieldFiltered, fieldRemoved, fieldAggregated, recordEdited, reportChanged, windowResized, recordUpdated, drillThroughClosed, verticalScrolled, horizontalScrolled, rowPageNavigated, columnPageNavigated, actionDropped, Theme, ErrorDialog, FilterDialog, PivotContextMenu, AggregateMenu, Toolbar$2 as Toolbar, NumberFormatting, Grouping, PivotEngine, PivotUtil, OlapEngine, MDXQuery, FieldOptions, FieldListFieldOptions, Style, Filter, ConditionalFormatSettings, Sort, FormatSettings, GroupSettings, CustomGroups, CalculatedFieldSettings, DrillOptions, ValueSortSettings, Authentication, DataSourceSettings };
//# sourceMappingURL=ej2-pivotview.es2015.js.map
