/**
 * Bundle of @devexpress/dx-grid-core
 * Generated: 2022-02-24
 * Version: 3.0.2
 * License: https://js.devexpress.com/Licensing
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@devexpress/dx-core')) :
  typeof define === 'function' && define.amd ? define(['exports', '@devexpress/dx-core'], factory) :
  (global = global || self, factory((global.DevExpress = global.DevExpress || {}, global.DevExpress.DXGridCore = {}), global.DevExpress.DXCore));
}(this, (function (exports, dxCore) { 'use strict';

  if (typeof process === "undefined") { var process = { env: {} }; }

  var GRID_GROUP_TYPE = Symbol('group');
  var GRID_GROUP_CHECK = Symbol(GRID_GROUP_TYPE.toString() + "_check");
  var GRID_GROUP_LEVEL_KEY = Symbol(GRID_GROUP_TYPE.toString() + "_levelKey");
  var GRID_GROUP_COLLAPSED_ROWS = Symbol(GRID_GROUP_TYPE.toString() + "_collapsedRows");

  var warnIfRowIdUndefined = function (getRowId) { return function (row) {
      var result = getRowId(row);
      if (!row[GRID_GROUP_CHECK] && result === undefined) {
          // tslint:disable-next-line: no-console
          console.warn('The row id is undefined. Check the getRowId function. The row is', row);
      }
      return result;
  }; };
  var rowIdGetter = function (getRowId, rows) {
      if (!getRowId) {
          var map_1 = new Map(rows.map(function (row, rowIndex) { return [row, rowIndex]; }));
          return function (row) { return map_1.get(row); };
      }
      return warnIfRowIdUndefined(getRowId);
  };
  var defaultGetCellValue = function (row, columnName) { return row[columnName]; };
  var cellValueGetter = function (getCellValue, columns) {
      if (getCellValue === void 0) { getCellValue = defaultGetCellValue; }
      var useFastAccessor = true;
      var map = columns.reduce(function (acc, column) {
          if (column.getCellValue) {
              useFastAccessor = false;
              acc[column.name] = column.getCellValue;
          }
          return acc;
      }, {});
      if (useFastAccessor) {
          return getCellValue;
      }
      return function (row, columnName) { return (map[columnName]
          ? map[columnName](row, columnName)
          : getCellValue(row, columnName)); };
  };

  var changeColumnSorting = function (state, _a) {
      var columnName = _a.columnName, direction = _a.direction, keepOther = _a.keepOther, sortIndex = _a.sortIndex;
      var sorting = state.sorting;
      var nextSorting = [];
      if (keepOther === true) {
          nextSorting = sorting;
      }
      if (Array.isArray(keepOther)) {
          nextSorting = dxCore.slice(sorting)
              .filter(function (s) {
              return keepOther.indexOf(s.columnName) > -1;
          });
      }
      var columnSortingIndex = sorting.findIndex(function (s) { return s.columnName === columnName; });
      var columnSorting = sorting[columnSortingIndex];
      var newColumnSorting = {
          columnName: columnName,
          direction: direction
              || (!columnSorting || columnSorting.direction === 'desc' ? 'asc' : 'desc'),
      };
      if (columnSortingIndex > -1) {
          nextSorting = dxCore.slice(nextSorting);
          nextSorting.splice(columnSortingIndex, 1);
      }
      if (direction !== null) {
          var newIndexFallback = columnSortingIndex > -1 ? columnSortingIndex : nextSorting.length;
          var newIndex = sortIndex !== undefined ? sortIndex : newIndexFallback;
          nextSorting = dxCore.slice(nextSorting);
          nextSorting.splice(newIndex, 0, newColumnSorting);
      }
      return {
          sorting: nextSorting,
      };
  };

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */

  var __assign = function() {
      __assign = Object.assign || function __assign(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
      };
      return __assign.apply(this, arguments);
  };

  function __rest(s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
              if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                  t[p[i]] = s[p[i]];
          }
      return t;
  }

  function __read(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      }
      catch (error) { e = { error: error }; }
      finally {
          try {
              if (r && !r.done && (m = i["return"])) m.call(i);
          }
          finally { if (e) throw e.error; }
      }
      return ar;
  }

  /** @deprecated */
  function __spread() {
      for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read(arguments[i]));
      return ar;
  }

  var unique = function (arr) { return __spread(Array.from(new Set(arr))); };
  var getColumnSortingDirection = function (sorting, columnName) {
      var columnSorting = sorting.filter(function (s) { return s.columnName === columnName; })[0];
      return columnSorting ? columnSorting.direction : null;
  };
  var getPersistentSortedColumns = function (sorting, columnExtensions) {
      if (columnExtensions === void 0) { columnExtensions = []; }
      return columnExtensions.reduce(function (acc, _a) {
          var columnName = _a.columnName, sortingEnabled = _a.sortingEnabled;
          if (sortingEnabled === false) {
              if (sorting.findIndex(function (sortItem) { return sortItem.columnName === columnName; }) > -1) {
                  acc.push(columnName);
              }
          }
          return acc;
      }, []);
  };
  var calculateKeepOther = function (sorting, keepOther, persistentSortedColumns) {
      if (persistentSortedColumns === void 0) { persistentSortedColumns = []; }
      if (!persistentSortedColumns.length)
          return keepOther;
      if (!keepOther)
          return persistentSortedColumns;
      return Array.isArray(keepOther)
          ? unique(__spread(keepOther, persistentSortedColumns))
          : unique(__spread(sorting.map(function (item) { return item.columnName; }), persistentSortedColumns));
  };

  /* eslint-disable no-plusplus, no-param-reassign, no-use-before-define, no-constant-condition */
  /* tslint:disable no-increment-decrement */
  var merge = function (array, auxiliary, lo, mid, hi, compare) {
      var i = lo;
      var j = mid + 1;
      var k = lo;
      while (true) {
          var cmp = compare(array[i], array[j]);
          if (cmp <= 0) {
              auxiliary[k++] = array[i++];
              if (i > mid) {
                  do {
                      auxiliary[k++] = array[j++];
                  } while (j <= hi);
                  break;
              }
          }
          else {
              auxiliary[k++] = array[j++];
              if (j > hi) {
                  do {
                      auxiliary[k++] = array[i++];
                  } while (i <= mid);
                  break;
              }
          }
      }
  };
  var sortArrayToAuxiliary = function (array, auxiliary, lo, hi, compare) {
      if (hi < lo)
          return;
      if (hi === lo) {
          auxiliary[lo] = array[lo];
          return;
      }
      var mid = Math.floor(lo + ((hi - lo) / 2));
      sortAuxiliaryToArray(array, auxiliary, lo, mid, compare);
      sortAuxiliaryToArray(array, auxiliary, mid + 1, hi, compare);
      merge(array, auxiliary, lo, mid, hi, compare);
  };
  var sortAuxiliaryToArray = function (array, auxiliary, lo, hi, compare) {
      if (hi <= lo)
          return;
      var mid = Math.floor(lo + ((hi - lo) / 2));
      sortArrayToAuxiliary(array, auxiliary, lo, mid, compare);
      sortArrayToAuxiliary(array, auxiliary, mid + 1, hi, compare);
      merge(auxiliary, array, lo, mid, hi, compare);
  };
  var mergeSort = (function (array, compare) {
      if (compare === void 0) { compare = function (a, b) {
          if (a < b)
              return -1;
          if (a > b)
              return 1;
          return 0;
      }; }
      var result = dxCore.slice(array);
      var auxiliary = dxCore.slice(array);
      sortAuxiliaryToArray(result, auxiliary, 0, result.length - 1, compare);
      return result;
  });

  var NODE_CHECK = Symbol('node');
  var rowsToTree = function (rows, getRowLevelKey) {
      if (!rows.length)
          return rows;
      var levels = [{ children: [] }];
      rows.forEach(function (row) {
          var _a;
          var levelKey = getRowLevelKey(row);
          if (levelKey) {
              var levelIndex = levels.slice(1)
                  .findIndex(function (level) { return getRowLevelKey(level.root) === levelKey; }) + 1;
              if (levelIndex > 0) {
                  levels.splice(levelIndex, levels.length - levelIndex);
              }
              var node = (_a = {}, _a[NODE_CHECK] = true, _a.root = row, _a.children = [], _a);
              levels[levels.length - 1].children.push(node);
              levels.push(node);
          }
          else {
              levels[levels.length - 1].children.push(row);
          }
      });
      return levels[0].children;
  };
  var treeToRows = function (tree, rows) {
      if (rows === void 0) { rows = []; }
      if (!tree.length)
          return tree;
      return tree.reduce(function (acc, node) {
          if (node[NODE_CHECK]) {
              acc.push(node.root);
              treeToRows(node.children, rows);
          }
          else {
              acc.push(node);
          }
          return acc;
      }, rows);
  };

  var defaultCompare = function (a, b) {
      if (a === b)
          return 0;
      if (a === null) {
          return b === undefined ? -1 : 1;
      }
      if (a === undefined) {
          return 1;
      }
      if (b === null || b === undefined) {
          return -1;
      }
      return a < b ? -1 : 1;
  };
  var createCompare = function (sorting, getColumnCompare, getComparableValue) { return sorting.reduceRight(function (prevCompare, columnSorting) {
      var columnName = columnSorting.columnName;
      var inverse = columnSorting.direction === 'desc';
      var columnCompare = (getColumnCompare && getColumnCompare(columnName)) || defaultCompare;
      return function (aRow, bRow) {
          var a = getComparableValue(aRow, columnName);
          var b = getComparableValue(bRow, columnName);
          var result = columnCompare(a, b);
          if (result !== 0) {
              return inverse ? -result : result;
          }
          return prevCompare(aRow, bRow);
      };
  }, function () {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
      }
      return 0;
  }); };
  var sortTree = function (tree, compare) {
      var sortedTree = tree.map(function (node) {
          if (node[NODE_CHECK]) {
              return __assign(__assign({}, node), { children: sortTree(node.children, compare) });
          }
          return node;
      });
      return mergeSort(sortedTree, function (a, b) { return compare(a[NODE_CHECK] ? a.root : a, b[NODE_CHECK] ? b.root : b); });
  };
  var sortHierarchicalRows = function (rows, compare, getRowLevelKey) {
      var tree = rowsToTree(rows, getRowLevelKey);
      var sortedTree = sortTree(tree, compare);
      return treeToRows(sortedTree);
  };
  var sortedRows = function (rows, sorting, getCellValue, getColumnCompare, isGroupRow, getRowLevelKey) {
      if (!sorting.length || !rows.length)
          return rows;
      var compare;
      if (!getRowLevelKey) {
          compare = createCompare(sorting, getColumnCompare, getCellValue);
          return mergeSort(rows.slice(), compare);
      }
      compare = createCompare(sorting, getColumnCompare, function (row, columnName) {
          if (isGroupRow && isGroupRow(row)) {
              if (row.groupedBy === columnName) {
                  return row.value;
              }
              return undefined;
          }
          return getCellValue(row, columnName);
      });
      return sortHierarchicalRows(rows, compare, getRowLevelKey);
  };

  var changeColumnFilter = function (filters, _a) {
      var columnName = _a.columnName, config = _a.config;
      var filterIndex = filters.findIndex(function (f) { return f.columnName === columnName; });
      var nextState = dxCore.slice(filters);
      if (config) {
          var filter = __assign({ columnName: columnName }, config);
          if (filterIndex > -1) {
              nextState.splice(filterIndex, 1, filter);
          }
          else {
              nextState.push(filter);
          }
      }
      else if (filterIndex > -1) {
          nextState.splice(filterIndex, 1);
      }
      return nextState;
  };

  var getColumnFilterConfig = function (filters, columnName) { return (filters.length && filters.filter(function (s) { return s.columnName === columnName; })[0] || null); };

  var filterExpression = function (filters, expression) {
      // tslint:disable-next-line: no-object-literal-type-assertion
      var selfFilterExpr = { filters: filters, operator: 'and' };
      if (!expression) {
          return selfFilterExpr;
      }
      return {
          operator: 'and',
          filters: [expression, selfFilterExpr],
      };
  };

  var operators = {
      or: function (predicates) { return function (row) { return (predicates.reduce(function (acc, predicate) { return acc || predicate(row); }, false)); }; },
      and: function (predicates) { return function (row) { return (predicates.reduce(function (acc, predicate) { return acc && predicate(row); }, true)); }; },
  };
  var toLowerCase = function (value) { return String(value).toLowerCase(); };
  var operationPredicates = {
      contains: function (value, filter) { return toLowerCase(value)
          .indexOf(toLowerCase(filter.value)) > -1; },
      notContains: function (value, filter) { return toLowerCase(value)
          .indexOf(toLowerCase(filter.value)) === -1; },
      startsWith: function (value, filter) { return toLowerCase(value)
          .startsWith(toLowerCase(filter.value)); },
      endsWith: function (value, filter) { return toLowerCase(value)
          .endsWith(toLowerCase(filter.value)); },
      equal: function (value, filter) { return String(value) === String(filter.value); },
      notEqual: function (value, filter) { return String(value) !== String(filter.value); },
      greaterThan: function (value, filter) { return value > filter.value; },
      greaterThanOrEqual: function (value, filter) { return value >= filter.value; },
      lessThan: function (value, filter) { return value < filter.value; },
      lessThanOrEqual: function (value, filter) { return value <= filter.value; },
  };
  var defaultFilterPredicate = function (value, filter) {
      var operation = filter.operation || 'contains';
      return operationPredicates[operation](value, filter);
  };
  var filterTree = function (tree, predicate) { return tree.reduce(function (acc, node) {
      if (node[NODE_CHECK]) {
          var filteredChildren = filterTree(node.children, predicate);
          if (filteredChildren.length > 0) {
              acc.push(__assign(__assign({}, node), { children: filteredChildren }));
              return acc;
          }
          if (predicate(node.root, true)) {
              acc.push(node.root);
              return acc;
          }
          return acc;
      }
      if (predicate(node)) {
          acc.push(node);
          return acc;
      }
      return acc;
  }, []); };
  var filterHierarchicalRows = function (rows, predicate, getRowLevelKey, getCollapsedRows) {
      var tree = rowsToTree(rows, getRowLevelKey);
      var collapsedRowsMeta = [];
      var filteredTree = filterTree(tree, function (row, isNode) {
          if (isNode) {
              var collapsedRows = getCollapsedRows && getCollapsedRows(row);
              if (collapsedRows && collapsedRows.length) {
                  var filteredCollapsedRows = collapsedRows.filter(predicate);
                  collapsedRowsMeta.push([row, filteredCollapsedRows]);
                  return !!filteredCollapsedRows.length || predicate(row);
              }
              if (predicate(row)) {
                  collapsedRowsMeta.push([row, []]);
                  return true;
              }
              return false;
          }
          return predicate(row);
      });
      return { rows: treeToRows(filteredTree), collapsedRowsMeta: new Map(collapsedRowsMeta) };
  };
  var buildPredicate = function (initialFilterExpression, getCellValue, getColumnPredicate) {
      var getSimplePredicate = function (filter) {
          var columnName = filter.columnName;
          var customPredicate = getColumnPredicate && getColumnPredicate(columnName);
          var predicate = customPredicate || defaultFilterPredicate;
          return function (row) { return predicate(getCellValue(row, columnName), filter, row); };
      };
      var getOperatorPredicate = function (filterExpression) {
          var build = operators[toLowerCase(filterExpression.operator)];
          return build && build(filterExpression.filters.map(getPredicate));
      };
      var getPredicate = function (filterExpression) { return (getOperatorPredicate(filterExpression)
          || getSimplePredicate(filterExpression)); };
      return getPredicate(initialFilterExpression);
  };
  var filteredRows = function (rows, filterExpression, getCellValue, getColumnPredicate, getRowLevelKey, getCollapsedRows) {
      if (!(filterExpression && Object.keys(filterExpression).length && rows.length)) {
          // tslint:disable-next-line:no-object-literal-type-assertion
          return { rows: rows };
      }
      var predicate = buildPredicate(filterExpression, getCellValue, getColumnPredicate);
      return getRowLevelKey
          ? filterHierarchicalRows(rows, predicate, getRowLevelKey, getCollapsedRows)
          : { rows: rows.filter(predicate) };
  };
  var filteredCollapsedRowsGetter = function (_a) {
      var collapsedRowsMeta = _a.collapsedRowsMeta;
      return function (row) { return collapsedRowsMeta && collapsedRowsMeta.get(row); };
  };
  var unwrappedFilteredRows = function (_a) {
      var rows = _a.rows;
      return rows;
  };

  var GROUP_KEY_SEPARATOR = '|';

  var applyColumnGrouping = function (grouping, _a) {
      var columnName = _a.columnName, groupIndex = _a.groupIndex;
      var nextGrouping = grouping;
      var groupingIndex = nextGrouping.findIndex(function (g) { return g.columnName === columnName; });
      var targetIndex = groupIndex;
      if (groupingIndex > -1) {
          nextGrouping = dxCore.slice(grouping);
          nextGrouping.splice(groupingIndex, 1);
      }
      else if (groupIndex === undefined) {
          targetIndex = nextGrouping.length;
      }
      if (targetIndex > -1) {
          nextGrouping = dxCore.slice(nextGrouping);
          nextGrouping.splice(targetIndex, 0, {
              columnName: columnName,
          });
      }
      return nextGrouping;
  };
  var changeColumnGrouping = function (_a, _b) {
      var grouping = _a.grouping, expandedGroups = _a.expandedGroups;
      var columnName = _b.columnName, groupIndex = _b.groupIndex;
      var nextGrouping = applyColumnGrouping(grouping, { columnName: columnName, groupIndex: groupIndex });
      var ungroupedColumnIndex = grouping.findIndex(function (group, index) { return !nextGrouping[index] || group.columnName !== nextGrouping[index].columnName; });
      if (ungroupedColumnIndex === -1) {
          return {
              grouping: nextGrouping,
          };
      }
      var filteredExpandedGroups = expandedGroups.filter(function (group) { return group.split(GROUP_KEY_SEPARATOR).length <= ungroupedColumnIndex; });
      if (filteredExpandedGroups.length === expandedGroups.length) {
          return {
              grouping: nextGrouping,
          };
      }
      return {
          grouping: nextGrouping,
          expandedGroups: filteredExpandedGroups,
      };
  };
  var toggleExpandedGroups = function (state, _a) {
      var groupKey = _a.groupKey;
      var expandedGroups = dxCore.slice(state.expandedGroups);
      var groupKeyIndex = expandedGroups.indexOf(groupKey);
      if (groupKeyIndex > -1) {
          expandedGroups.splice(groupKeyIndex, 1);
      }
      else {
          expandedGroups.push(groupKey);
      }
      return {
          expandedGroups: expandedGroups,
      };
  };
  var draftColumnGrouping = function (_a, _b) {
      var grouping = _a.grouping, draftGrouping = _a.draftGrouping;
      var columnName = _b.columnName, groupIndex = _b.groupIndex;
      return ({
          draftGrouping: applyColumnGrouping(draftGrouping || grouping, { columnName: columnName, groupIndex: groupIndex }),
      });
  };
  var cancelColumnGroupingDraft = function () { return ({
      draftGrouping: null,
  }); };

  var adjustSortIndex = function (groupingIndex, grouping, sorting) { return Math.max(grouping.slice(0, groupingIndex).reduce(function (acc, columnGrouping) {
      var columnSortingIndex = sorting.findIndex(function (columnSorting) { return columnSorting.columnName === columnGrouping.columnName; });
      return (columnSortingIndex === -1 ? acc - 1 : acc);
  }, groupingIndex), 0); };

  var defaultColumnCriteria = function (value) { return ({
      value: value,
      key: String(value),
  }); };
  var getGroupRows = function (rows, grouping, groupsGetter) {
      if (grouping.length === 0) {
          return rows;
      }
      var keyPrefixes = [{ prefix: '', level: 0, rows: rows }];
      var resultRows = [];
      var compoundKeys = {};
      var _loop_1 = function () {
          var _a = keyPrefixes.pop(), keyPrefix = _a.prefix, level = _a.level, currentRows = _a.rows;
          var currentCompoundKey = keyPrefix.slice(0, keyPrefix.length - 1);
          var groupIndex = (_a = compoundKeys[currentCompoundKey]) !== null && _a !== void 0 ? _a : -1;
          var groupRows = grouping[level] && currentRows.length
              ? groupsGetter(currentRows, grouping[level], keyPrefix)
                  .map(function (_a, rowIndex) {
                  var childRows = _a.childRows, params = __rest(_a, ["childRows"]);
                  var compoundKey = params.compoundKey;
                  compoundKeys[compoundKey] = groupIndex + rowIndex + 1;
                  keyPrefixes.push({
                      prefix: "" + compoundKey + GROUP_KEY_SEPARATOR,
                      level: level + 1,
                      rows: childRows || [],
                  });
                  return params;
              })
              : currentRows;
          if (groupIndex > -1) {
              resultRows.splice.apply(resultRows, __spread([groupIndex + 1, 0], groupRows));
          }
          else {
              groupRows.forEach(function (row) { return resultRows.push(row); });
          }
      };
      while (keyPrefixes.length) {
          _loop_1();
      }
      return resultRows;
  };
  var getIntegratedGroups = function (rows, grouping, keyPrefix, getCellValue, getColumnCriteria) {
      var columnName = grouping.columnName;
      var groupCriteria = (getColumnCriteria && getColumnCriteria(columnName))
          || defaultColumnCriteria;
      var groups = new Map();
      rows.forEach(function (row) {
          var rawValue = getCellValue(row, columnName);
          var _a = groupCriteria(rawValue, row), key = _a.key, value = _a.value;
          var sameKeyItems = groups.get(key);
          if (!sameKeyItems) {
              var groupingValue = value === rawValue ? value : value || key;
              groups.set(key, [groupingValue, key, [row]]);
          }
          else {
              sameKeyItems[2].push(row);
          }
      });
      var groupedBy = columnName;
      return __spread(groups.values()).map(function (_a) {
          var _b;
          var _c = __read(_a, 3), value = _c[0], key = _c[1], childRows = _c[2];
          return (_b = {
                  groupedBy: groupedBy,
                  compoundKey: "" + keyPrefix + key,
                  key: key,
                  value: value
              },
              _b[GRID_GROUP_CHECK] = true,
              _b[GRID_GROUP_LEVEL_KEY] = GRID_GROUP_TYPE.toString() + "_" + groupedBy,
              _b.childRows = childRows,
              _b);
      });
  };

  var groupRowChecker = function (row) { return row[GRID_GROUP_CHECK]; };
  var groupRowLevelKeyGetter = function (row) { return (row ? row[GRID_GROUP_LEVEL_KEY] : undefined); };
  var groupedRows = function (rows, grouping, getCellValue, getColumnCriteria) {
      var groupsGetter = function (currentRows, currentGrouping, prefix) {
          return getIntegratedGroups(currentRows, currentGrouping, prefix, getCellValue, getColumnCriteria);
      };
      return getGroupRows(rows, grouping, groupsGetter);
  };
  var expandedGroupRows = function (rows, grouping, expandedGroups, isExporting) {
      if (!grouping.length)
          return rows;
      var groupingColumnNames = grouping.map(function (columnGrouping) { return columnGrouping.columnName; });
      var expandedGroupsSet = new Set(expandedGroups);
      var currentGroupExpanded = true;
      var currentGroupLevel = 0;
      return rows.reduce(function (acc, row) {
          var _a;
          if (!row[GRID_GROUP_CHECK]) {
              if (currentGroupExpanded) {
                  acc.push(row);
              }
              else {
                  acc[acc.length - 1][GRID_GROUP_COLLAPSED_ROWS].push(row);
              }
              return acc;
          }
          var groupLevel = groupingColumnNames.indexOf(row.groupedBy);
          if (groupLevel > currentGroupLevel && !currentGroupExpanded) {
              return acc;
          }
          currentGroupExpanded = expandedGroupsSet.has(row.compoundKey) || isExporting;
          currentGroupLevel = groupLevel;
          if (currentGroupExpanded) {
              acc.push(row);
          }
          else {
              acc.push(__assign(__assign({}, row), (_a = {}, _a[GRID_GROUP_COLLAPSED_ROWS] = [], _a)));
          }
          return acc;
      }, []);
  };
  var groupCollapsedRowsGetter = function (getCollapsedRows) { return function (row) { return (row[GRID_GROUP_COLLAPSED_ROWS] || (getCollapsedRows && getCollapsedRows(row))); }; };

  var getCustomGroups = function (rows, grouping, keyPrefix, getChildGroups, rootRows) {
      var groupedBy = grouping.columnName;
      return getChildGroups(rows, grouping, rootRows)
          .map(function (_a) {
          var _b;
          var key = _a.key, _c = _a.value, value = _c === void 0 ? key : _c, childRows = _a.childRows;
          return (_b = {
                  groupedBy: groupedBy,
                  compoundKey: "" + keyPrefix + key,
                  key: key,
                  value: value
              },
              _b[GRID_GROUP_CHECK] = true,
              _b[GRID_GROUP_LEVEL_KEY] = GRID_GROUP_TYPE.toString() + "_" + groupedBy,
              _b.childRows = childRows,
              _b);
      });
  };

  var customGroupedRows = function (rows, grouping, getChildGroups, rootRows) {
      if (rootRows === void 0) { rootRows = rows; }
      var groupsGetter = function (currentRows, currentGrouping, prefix) {
          return getCustomGroups(currentRows, currentGrouping, prefix, getChildGroups, rootRows);
      };
      return getGroupRows(rows, grouping, groupsGetter);
  };
  var customGroupingRowIdGetter = function (getRowId, rows) {
      var firstRow = rows.find(function (row) { return !row[GRID_GROUP_CHECK]; });
      if (!firstRow || getRowId(firstRow) !== undefined) {
          return getRowId;
      }
      var map = new Map(rows
          .filter(function (row) { return !row[GRID_GROUP_CHECK]; })
          .map(function (row, rowIndex) { return [row, rowIndex]; }));
      return function (row) { return map.get(row); };
  };

  var groupingPanelItems = function (columns, grouping, draftGrouping) {
      var items = draftGrouping.map(function (_a) {
          var columnName = _a.columnName;
          return ({
              column: columns.find(function (c) { return c.name === columnName; }),
              draft: !grouping.some(function (columnGrouping) { return columnGrouping.columnName === columnName; }),
          });
      });
      grouping.forEach(function (_a, index) {
          var columnName = _a.columnName;
          if (draftGrouping.some(function (columnGrouping) { return columnGrouping.columnName === columnName; }))
              return;
          items.splice(index, 0, {
              column: columns.find(function (c) { return c.name === columnName; }),
              draft: true,
          });
      });
      return items;
  };

  var setCurrentPage = function (prevPage, page) { return page; };
  var setPageSize = function (prevPageSize, size) { return size; };

  var clamp = function (value, max) { return (Math.max(Math.min(value, max), 0)); };

  // tslint:disable-next-line:max-line-length
  var PAGE_HEADERS_OVERFLOW_ERROR = 'Max row level exceeds the page size. Consider increasing the page size.';
  var paginatedRows = function (rows, pageSize, page) { return (pageSize
      ? rows.slice(pageSize * page, pageSize * (page + 1))
      : rows); };
  var rowsWithPageHeaders = function (rows, pageSize, getRowLevelKey) {
      if (!pageSize || !getRowLevelKey)
          return rows;
      var result = rows.slice();
      var headerRows = [];
      var currentIndex = 0;
      var _loop_1 = function () {
          var row = result[currentIndex];
          var levelKey = getRowLevelKey(row);
          if (levelKey) {
              var headerIndex = headerRows.findIndex(function (headerRow) { return getRowLevelKey(headerRow) === levelKey; });
              // tslint:disable-next-line:prefer-conditional-expression
              if (headerIndex === -1) {
                  headerRows = __spread(headerRows, [row]);
              }
              else {
                  headerRows = __spread(headerRows.slice(0, headerIndex), [row]);
              }
              if (headerRows.length >= pageSize) {
                  throw new Error(PAGE_HEADERS_OVERFLOW_ERROR);
              }
          }
          var indexInPage = currentIndex % pageSize;
          if (indexInPage < headerRows.length && row !== headerRows[indexInPage]) {
              result = __spread(result.slice(0, currentIndex), [
                  headerRows[indexInPage]
              ], result.slice(currentIndex));
          }
          currentIndex += 1;
      };
      while (result.length > currentIndex) {
          _loop_1();
      }
      return result;
  };
  var rowCount = function (rows) { return rows.length; };
  var pageCount = function (count, pageSize) { return (pageSize ? Math.ceil(count / pageSize) : 1); };
  var currentPage = function (page, totalCount, pageSize, setCurrentPage) {
      var totalPages = pageCount(totalCount, pageSize);
      var adjustedCurrentPage = clamp(page, totalPages - 1);
      if (page !== adjustedCurrentPage) {
          setTimeout(function () { return setCurrentPage(adjustedCurrentPage); });
      }
      return adjustedCurrentPage;
  };

  var firstRowOnPage = function (currentPage, pageSize, totalCount) {
      if (totalCount === 0) {
          return 0;
      }
      return pageSize ? (currentPage * pageSize) + 1 : 1;
  };
  var lastRowOnPage = function (currentPage, pageSize, totalRowCount) {
      var result = totalRowCount;
      if (pageSize) {
          var index = (currentPage + 1) * pageSize;
          result = index > totalRowCount ? totalRowCount : index;
      }
      return result;
  };
  var calculateStartPage = function (currentPage, maxButtonCount, totalPageCount) { return (Math.max(Math.min(currentPage - Math.floor(maxButtonCount / 2), (totalPageCount - maxButtonCount) + 1), 1)); };

  var toggle = function (source, items, state) {
      var itemsSet = new Set(items);
      var sourceState = state;
      if (sourceState === undefined) {
          var availableSelection = source.filter(function (item) { return itemsSet.has(item); });
          sourceState = availableSelection.length !== itemsSet.size;
      }
      if (sourceState) {
          var sourceSet_1 = new Set(source);
          return __spread(source, items.filter(function (item) { return !sourceSet_1.has(item); }));
      }
      return source.filter(function (item) { return !itemsSet.has(item); });
  };

  var toggleSelection = function (selection, _a) {
      var rowIds = _a.rowIds, state = _a.state;
      return toggle(selection, rowIds, state);
  };

  var rowsWithAvailableToSelect = function (rows, getRowId, isGroupRow) {
      var dataRows = rows;
      if (isGroupRow) {
          dataRows = dataRows.filter(function (row) { return !isGroupRow(row); });
      }
      return { rows: rows, availableToSelect: dataRows.map(function (row) { return getRowId(row); }) };
  };
  var someSelected = function (_a, selection) {
      var availableToSelect = _a.availableToSelect;
      var selectionSet = new Set(selection);
      return availableToSelect.length !== 0 && selectionSet.size !== 0
          && availableToSelect.some(function (elem) { return selectionSet.has(elem); })
          && availableToSelect.some(function (elem) { return !selectionSet.has(elem); });
  };
  var allSelected = function (_a, selection) {
      var availableToSelect = _a.availableToSelect;
      var selectionSet = new Set(selection);
      return selectionSet.size !== 0 && availableToSelect.length !== 0
          && !availableToSelect.some(function (elem) { return !selectionSet.has(elem); });
  };
  var unwrapSelectedRows = function (_a) {
      var rows = _a.rows;
      return rows;
  };

  var startEditRows = function (prevEditingRowIds, _a) {
      var rowIds = _a.rowIds;
      return __spread(prevEditingRowIds, rowIds);
  };
  var stopEditRows = function (prevEditingRowIds, _a) {
      var rowIds = _a.rowIds;
      var rowIdSet = new Set(rowIds);
      return prevEditingRowIds.filter(function (id) { return !rowIdSet.has(id); });
  };
  var startEditCells = function (prevEditingCells, _a) {
      var editingCells = _a.editingCells;
      return __spread(prevEditingCells, editingCells);
  };
  var stopEditCells = function (prevEditingCells, _a) {
      var editingCells = _a.editingCells;
      return prevEditingCells.filter(function (_a) {
          var rowId = _a.rowId, columnName = _a.columnName;
          return (!editingCells.some(function (_a) {
              var currentRowId = _a.rowId, currentColumnName = _a.columnName;
              return (currentRowId === rowId && currentColumnName === columnName);
          }));
      });
  };
  var addRow = function (addedRows, _a) {
      var _b = _a === void 0 ? { row: {} } : _a, row = _b.row;
      return __spread(addedRows, [row]);
  };
  var changeAddedRow = function (addedRows, _a) {
      var rowId = _a.rowId, change = _a.change;
      var result = addedRows.slice();
      result[rowId] = __assign(__assign({}, result[rowId]), change);
      return result;
  };
  var cancelAddedRows = function (addedRows, _a) {
      var rowIds = _a.rowIds;
      var result = [];
      var indexSet = new Set(rowIds);
      addedRows.forEach(function (row, index) {
          if (!indexSet.has(index)) {
              result.push(row);
          }
      });
      return result;
  };
  var changeRow = function (prevRowChanges, _a) {
      var _b;
      var rowId = _a.rowId, change = _a.change;
      var prevChange = prevRowChanges[rowId] || {};
      return __assign(__assign({}, prevRowChanges), (_b = {}, _b[rowId] = __assign(__assign({}, prevChange), change), _b));
  };
  var cancelChanges = function (prevRowChanges, _a) {
      var rowIds = _a.rowIds;
      var result = __assign({}, prevRowChanges);
      rowIds.forEach(function (rowId) {
          delete result[rowId];
      });
      return result;
  };
  var deleteRows = function (deletedRowIds, _a) {
      var rowIds = _a.rowIds;
      return __spread(deletedRowIds, rowIds);
  };
  var cancelDeletedRows = function (deletedRowIds, _a) {
      var rowIds = _a.rowIds;
      var rowIdSet = new Set(rowIds);
      return deletedRowIds.filter(function (rowId) { return !rowIdSet.has(rowId); });
  };

  var changedRowsByIds = function (changes, rowIds) {
      var result = {};
      rowIds.forEach(function (rowId) {
          result[rowId] = changes[rowId];
      });
      return result;
  };
  var addedRowsByIds = function (addedRows, rowIds) {
      var rowIdSet = new Set(rowIds);
      var result = [];
      addedRows.forEach(function (row, index) {
          if (rowIdSet.has(index)) {
              result.push(row);
          }
      });
      return result;
  };
  var defaultCreateRowChange = function (row, value, columnName) {
      var _a;
      return (_a = {}, _a[columnName] = value, _a);
  };
  var createRowChangeGetter = function (createRowChange, columnExtensions) {
      if (createRowChange === void 0) { createRowChange = defaultCreateRowChange; }
      if (columnExtensions === void 0) { columnExtensions = []; }
      var map = columnExtensions.reduce(function (acc, columnExtension) {
          if (columnExtension.createRowChange) {
              acc[columnExtension.columnName] = columnExtension.createRowChange;
          }
          return acc;
      }, {});
      return function (row, value, columnName) {
          if (map[columnName]) {
              return map[columnName](row, value, columnName);
          }
          return createRowChange(row, value, columnName);
      };
  };

  var getRowChange = function (rowChanges, rowId) { return rowChanges[rowId] || {}; };

  var TABLE_REORDERING_TYPE = Symbol('reordering');

  var changeColumnOrder = function (order, _a) {
      var sourceColumnName = _a.sourceColumnName, targetColumnName = _a.targetColumnName;
      var sourceColumnIndex = order.indexOf(sourceColumnName);
      var targetColumnIndex = order.indexOf(targetColumnName);
      var newOrder = dxCore.slice(order);
      newOrder.splice(sourceColumnIndex, 1);
      newOrder.splice(targetColumnIndex, 0, sourceColumnName);
      return newOrder;
  };

  var TABLE_DATA_TYPE = Symbol('data');
  var TABLE_NODATA_TYPE = Symbol('nodata');
  var TABLE_FLEX_TYPE = Symbol('flex');

  var orderedColumns = function (tableColumns, order) {
      if (tableColumns === void 0) { tableColumns = []; }
      return mergeSort(tableColumns, function (a, b) {
          if (a.type !== TABLE_DATA_TYPE || b.type !== TABLE_DATA_TYPE)
              return 0;
          var aPos = order.indexOf(a.column.name);
          var bPos = order.indexOf(b.column.name);
          return aPos - bPos;
      });
  };
  var tableHeaderRowsWithReordering = function (tableHeaderRows) { return __spread(tableHeaderRows, [
      {
          key: TABLE_REORDERING_TYPE.toString(),
          type: TABLE_REORDERING_TYPE,
          height: 0,
      },
  ]); };
  var draftOrder = function (order, sourceColumnIndex, targetColumnIndex) {
      if (sourceColumnIndex === -1
          || targetColumnIndex === -1
          || sourceColumnIndex === targetColumnIndex) {
          return order;
      }
      var result = dxCore.slice(order);
      var sourceColumn = order[sourceColumnIndex];
      result.splice(sourceColumnIndex, 1);
      result.splice(targetColumnIndex, 0, sourceColumn);
      return result;
  };

  var getColumnWidth = function (columnWidths, name, _a) {
      var columnName = _a.columnName, cachedWidths = _a.cachedWidths, shift = _a.shift, minColumnWidth = _a.minColumnWidth, maxColumnWidth = _a.maxColumnWidth, _b = _a.columnExtensions, columnExtensions = _b === void 0 ? [] : _b;
      var change = name === columnName ? shift : -shift;
      var column = columnWidths.find(function (elem) { return elem.columnName === name; });
      var extension = columnExtensions.find(function (elem) { return elem.columnName === name; });
      var width = typeof column.width === 'number'
          ? column.width
          : cachedWidths[name];
      var minWidth = extension && extension.minWidth >= 0
          ? extension.minWidth
          : minColumnWidth;
      var maxWidth = extension && extension.maxWidth >= 0
          ? extension.maxWidth
          : maxColumnWidth;
      var size = Math.max(minWidth, Math.min(width + change, maxWidth));
      return ({ width: width, size: size });
  };
  var getColumnSizes = function (columnWidths, payload) {
      var columnName = payload.columnName, nextColumnName = payload.nextColumnName, resizingMode = payload.resizingMode, shift = payload.shift;
      var _a = getColumnWidth(columnWidths, columnName, payload), width = _a.width, size = _a.size;
      if (resizingMode === 'nextColumn') {
          var _b = getColumnWidth(columnWidths, nextColumnName, payload), nextWidth = _b.width, nextSize = _b.size;
          if (size + nextSize !== width + nextWidth) {
              var moreThanLimit = size + nextSize > width + nextWidth;
              var columnExpand = shift > 0;
              if (moreThanLimit !== columnExpand) {
                  return { size: size, nextSize: width + nextWidth - size };
              }
              return { size: width + nextWidth - nextSize, nextSize: nextSize };
          }
          return { size: size, nextSize: nextSize };
      }
      return { size: size };
  };
  var isValidValue = function (value, validUnits) {
      var numb = parseInt(value, 10);
      var unit = numb ? value.substr(numb.toString().length) : value;
      var sizeIsAuto = isNaN(numb) && unit === 'auto';
      var sizeIsValid = numb >= 0 && validUnits.some(function (validUnit) { return validUnit === unit; });
      return sizeIsAuto || sizeIsValid;
  };
  var convertWidth = function (value) {
      if (typeof value === 'string') {
          var numb = parseInt(value, 10);
          if (value.substr(numb.toString().length).length > 0) {
              return value;
          }
          return numb;
      }
      return value;
  };

  var VALID_UNITS = ['px', '%', 'em', 'rem', 'vm', 'vh', 'vmin', 'vmax', ''];
  var NOT_FOR_WIDGET_UNITS = ['%'];
  /* tslint:disable max-line-length */
  var COLUMN_RESIZING_ERROR = 'The columnWidths property of the TableColumnResizing plugin is given an invalid value.';
  var specifyWidths = function (tableColumns, widths, resizingMode, onError) {
      if (resizingMode !== 'widget' && resizingMode !== 'nextColumn') {
          onError();
      }
      if (!widths.length)
          return tableColumns;
      return tableColumns
          .reduce(function (acc, tableColumn) {
          if (tableColumn.type === TABLE_DATA_TYPE) {
              var columnName_1 = tableColumn.column.name;
              var column = widths.find(function (el) { return el.columnName === columnName_1; });
              var width = column && column.width;
              if (typeof width !== 'number') {
                  if (width === undefined) {
                      onError();
                  }
                  else if (!isValidValue(width, VALID_UNITS)) {
                      onError();
                  }
                  else if (resizingMode === 'widget' && isValidValue(width, NOT_FOR_WIDGET_UNITS)) {
                      onError();
                  }
              }
              else if (width < 0) {
                  onError();
              }
              if (width === undefined) {
                  acc.push(tableColumn);
              }
              else {
                  acc.push(__assign(__assign({}, tableColumn), { width: convertWidth(width) }));
              }
          }
          else {
              acc.push(tableColumn);
          }
          return acc;
      }, []);
  };
  var tableColumnsWithWidths = function (tableColumns, columnWidths, resizingMode) { return specifyWidths(tableColumns, columnWidths, resizingMode, throwError); };
  var tableColumnsWithDraftWidths = function (tableColumns, draftColumnWidths, resizingMode) { return specifyWidths(tableColumns, draftColumnWidths, resizingMode, function () { }); };
  var throwError = function () {
      throw new Error(COLUMN_RESIZING_ERROR);
  };

  var changeTableColumnWidth = function (state, payload) {
      var columnWidths = state.columnWidths;
      var columnName = payload.columnName, nextColumnName = payload.nextColumnName, resizingMode = payload.resizingMode;
      var nextColumnWidth = dxCore.slice(columnWidths);
      var index = nextColumnWidth.findIndex(function (elem) { return elem.columnName === columnName; });
      var nextIndex = nextColumnWidth.findIndex(function (elem) { return elem.columnName === nextColumnName; });
      var _a = getColumnSizes(columnWidths, payload), size = _a.size, nextSize = _a.nextSize;
      nextColumnWidth.splice(index, 1, { columnName: columnName, width: size });
      if (resizingMode === 'nextColumn') {
          nextColumnWidth.splice(nextIndex, 1, { columnName: nextColumnName, width: nextSize });
      }
      return {
          columnWidths: nextColumnWidth,
      };
  };
  var draftTableColumnWidth = function (state, payload) {
      var columnWidths = state.columnWidths;
      var columnName = payload.columnName, nextColumnName = payload.nextColumnName, resizingMode = payload.resizingMode;
      var _a = getColumnSizes(columnWidths, payload), size = _a.size, nextSize = _a.nextSize;
      if (resizingMode === 'nextColumn') {
          return { draftColumnWidths: [
                  { columnName: columnName, width: size }, { columnName: nextColumnName, width: nextSize },
              ] };
      }
      return { draftColumnWidths: [{ columnName: columnName, width: size }] };
  };
  var cancelTableColumnWidthDraft = function () { return ({
      draftColumnWidths: [],
  }); };

  var TABLE_EDIT_COMMAND_TYPE = Symbol('editCommand');

  var TABLE_ADDED_TYPE = Symbol('added');
  var TABLE_EDIT_TYPE = Symbol('edit');

  var TABLE_HEADING_TYPE = Symbol('heading');

  var isHeadingEditCommandsTableCell = function (tableRow, tableColumn) { return tableRow.type === TABLE_HEADING_TYPE && tableColumn.type === TABLE_EDIT_COMMAND_TYPE; };
  var isEditCommandsTableCell = function (tableRow, tableColumn) { return (tableRow.type === TABLE_DATA_TYPE || tableRow.type === TABLE_ADDED_TYPE
      || tableRow.type === TABLE_EDIT_TYPE) && tableColumn.type === TABLE_EDIT_COMMAND_TYPE; };

  var tableColumnsWithEditing = function (tableColumns, width) { return __spread([
      { width: convertWidth(width),
          key: TABLE_EDIT_COMMAND_TYPE.toString(), type: TABLE_EDIT_COMMAND_TYPE }
  ], tableColumns); };

  var isEditTableCell = function (tableRow, tableColumn) { return (tableRow.type === TABLE_ADDED_TYPE || tableRow.type === TABLE_EDIT_TYPE)
      && tableColumn.type === TABLE_DATA_TYPE; };
  var isAddedTableRow = function (tableRow) { return tableRow.type === TABLE_ADDED_TYPE; };
  var isEditTableRow = function (tableRow) { return tableRow.type === TABLE_EDIT_TYPE; };

  var tableRowsWithEditing = function (tableRows, editingRowIds, addedRows, rowHeight) {
      var rowIds = new Set(editingRowIds);
      var editedTableRows = tableRows
          .map(function (tableRow) { return (tableRow.type === TABLE_DATA_TYPE && rowIds.has(tableRow.rowId)
          ? __assign(__assign({}, tableRow), { type: TABLE_EDIT_TYPE, height: rowHeight }) : tableRow); });
      var addedTableRows = addedRows
          .map(function (row, rowIndex) { return ({
          row: row,
          key: TABLE_ADDED_TYPE.toString() + "_" + rowIndex,
          type: TABLE_ADDED_TYPE,
          rowId: rowIndex,
          height: rowHeight,
      }); });
      return __spread(dxCore.slice(addedTableRows).reverse(), editedTableRows);
  };

  var rowsWithEditingCells = function (tableBodyRows, editingCells) { return tableBodyRows.map(function (row) {
      var rowId = row.rowId, type = row.type;
      if (rowId !== undefined &&
          type === TABLE_DATA_TYPE &&
          editingCells.some(function (elem) { return elem.rowId === rowId; })) {
          return __assign(__assign({}, row), { hasEditCell: true });
      }
      return row;
  }); };
  var columnsWithEditingCells = function (tableColumns, editingCells) { return tableColumns.map(function (tableColumn) {
      var columnName = tableColumn.column ? tableColumn.column.name : undefined;
      if (columnName !== undefined && editingCells.some(function (elem) { return elem.columnName === columnName; })) {
          return __assign(__assign({}, tableColumn), { hasEditCell: true });
      }
      return tableColumn;
  }); };

  var TABLE_FILTER_TYPE = Symbol('filter');
  var DEFAULT_FILTER_OPERATIONS = [
      'contains',
      'notContains',
      'startsWith',
      'endsWith',
      'equal',
      'notEqual',
  ];

  var isFilterTableCell = function (tableRow, tableColumn) { return tableRow.type === TABLE_FILTER_TYPE && tableColumn.type === TABLE_DATA_TYPE; };
  var isFilterTableRow = function (tableRow) { return tableRow.type === TABLE_FILTER_TYPE; };
  var getColumnFilterOperations = function (getAvailableFilterOperations, columnName) { return (getAvailableFilterOperations && getAvailableFilterOperations(columnName))
      || DEFAULT_FILTER_OPERATIONS; };
  var isFilterValueEmpty = function (value) { return value === undefined || !String(value).length; };
  var getSelectedFilterOperation = function (filterOperations, columnName, columnFilter, columnFilterOperations) {
      if (columnFilter && columnFilter.operation) {
          return columnFilter.operation;
      }
      if (filterOperations[columnName]) {
          return filterOperations[columnName];
      }
      return columnFilterOperations[0];
  };

  var tableHeaderRowsWithFilter = function (headerRows, rowHeight) { return __spread(headerRows, [
      { key: TABLE_FILTER_TYPE.toString(), type: TABLE_FILTER_TYPE, height: rowHeight }
  ]); };

  var TABLE_GROUP_TYPE = Symbol('group');

  var TABLE_STUB_TYPE = Symbol('stub');
  var getVisibleBoundaryWithFixed = function (visibleBoundary, items) { return items.reduce(function (acc, item, index) {
      if (item.fixed && (index < visibleBoundary[0] || index > visibleBoundary[1])) {
          acc.push([index, index]);
      }
      return acc;
  }, [visibleBoundary]); };
  var getVisibleBoundary = function (items, viewportStart, viewportSize, getItemSize, offset, itemSize) {
      if (offset === void 0) { offset = 0; }
      if (itemSize === void 0) { itemSize = 0; }
      var start = null;
      var end = null;
      var index = 0;
      var beforePosition = offset * itemSize;
      var viewportEnd = viewportStart + viewportSize;
      while (end === null && index < items.length) {
          var item = items[index];
          var afterPosition = beforePosition + getItemSize(item);
          var isVisible = (beforePosition >= viewportStart && beforePosition < viewportEnd)
              || (afterPosition > viewportStart && afterPosition <= viewportEnd)
              || (beforePosition < viewportStart && afterPosition > viewportEnd);
          if (isVisible && start === null) {
              start = index;
          }
          if (!isVisible && start !== null) {
              end = index - 1;
              break;
          }
          index += 1;
          beforePosition = afterPosition;
      }
      if (start !== null && end === null) {
          end = index - 1;
      }
      start = start === null ? 0 : start;
      end = end === null ? 0 : end;
      return [start + offset, end + offset];
  };
  var getRenderBoundary = function (itemsCount, visibleBoundary, overscan) {
      var _a = __read(visibleBoundary, 2), start = _a[0], end = _a[1];
      start = Math.max(0, start - overscan);
      end = Math.min(itemsCount - 1, end + overscan);
      return [start, end];
  };
  var getColumnBoundaries = function (columns, left, width, getColumnWidth) { return (getVisibleBoundaryWithFixed(getColumnsRenderBoundary(columns.length, getVisibleBoundary(columns, left, width, getColumnWidth, 0)), columns)); };
  var getRowsVisibleBoundary = function (rows, top, height, getRowHeight, offset, rowHeight, isDataRemote) {
      var beforePosition = offset * rowHeight;
      var noVisibleRowsLoaded = rowHeight > 0 &&
          beforePosition + rows.length * rowHeight < top ||
          top < beforePosition;
      var boundaries;
      if (isDataRemote && noVisibleRowsLoaded) {
          var topIndex = Math.round(top / rowHeight);
          boundaries = [topIndex, topIndex];
      }
      else {
          boundaries = getVisibleBoundary(rows, top, height, getRowHeight, offset, rowHeight);
      }
      return boundaries;
  };
  var getColumnsRenderBoundary = function (columnCount, visibleBoundary) { return getRenderBoundary(columnCount, visibleBoundary, 1); };
  var getRowsRenderBoundary = function (rowsCount, visibleBoundary) { return getRenderBoundary(rowsCount, visibleBoundary, 3); };
  var getSpanBoundary = function (items, visibleBoundaries, getItemSpan) { return visibleBoundaries
      .map(function (visibleBoundary) {
      var endIndex = Math.min(visibleBoundary[1], items.length - 1);
      var end = endIndex;
      var start = visibleBoundary[0] <= end ? visibleBoundary[0] : 0;
      for (var index = 0; index <= endIndex; index += 1) {
          var span = getItemSpan(items[index]);
          if (index < visibleBoundary[0] && index + span > visibleBoundary[0]) {
              start = index;
          }
          if (index + (span - 1) > visibleBoundary[1]) {
              end = index + (span - 1);
          }
      }
      return [start, end];
  }); };
  var collapseBoundaries = function (itemsCount, visibleBoundaries, spanBoundaries) {
      var breakpoints = new Set([0, itemsCount]);
      spanBoundaries.forEach(function (rowBoundaries) { return rowBoundaries
          .forEach(function (boundary) {
          breakpoints.add(boundary[0]);
          // next interval starts after span end point
          breakpoints.add(Math.min(boundary[1] + 1, itemsCount));
      }); });
      visibleBoundaries
          .filter(function (boundary) { return boundary.every(function (bound) { return 0 <= bound && bound < itemsCount; }); })
          .forEach(function (boundary) {
          for (var point = boundary[0]; point <= boundary[1]; point += 1) {
              breakpoints.add(point);
          }
          if (boundary[1] + 1 < itemsCount) {
              // close last visible point
              breakpoints.add(boundary[1] + 1);
          }
      });
      var bp = __spread(breakpoints).sort(function (a, b) { return a - b; });
      var bounds = [];
      for (var i = 0; i < bp.length - 1; i += 1) {
          bounds.push([
              bp[i],
              bp[i + 1] - 1,
          ]);
      }
      return bounds;
  };
  var getColumnsSize = function (columns, startIndex, endIndex, getColumnSize) {
      var size = 0;
      for (var i = startIndex; i <= endIndex; i += 1) {
          size += getColumnSize(columns[i], 0) || 0;
      }
      return size;
  };
  var getCollapsedColumns = function (columns, visibleBoundaries, boundaries, getColumnWidth) {
      var collapsedColumns = [];
      boundaries.forEach(function (boundary) {
          var isVisible = visibleBoundaries.reduce(function (acc, visibleBoundary) { return (acc || (visibleBoundary[0] <= boundary[0] && boundary[1] <= visibleBoundary[1])); }, false);
          if (isVisible) {
              var column = columns[boundary[0]];
              collapsedColumns.push(__assign(__assign({}, column), { width: getColumnWidth(column) }));
          }
          else {
              collapsedColumns.push({
                  key: TABLE_STUB_TYPE.toString() + "_" + boundary[0] + "_" + boundary[1],
                  type: TABLE_STUB_TYPE,
                  width: getColumnsSize(columns, boundary[0], boundary[1], getColumnWidth),
              });
          }
      });
      return collapsedColumns;
  };
  var getCollapsedRows = function (rows, visibleBoundary, boundaries, getRowHeight, getCells, offset) {
      var collapsedRows = [];
      boundaries.forEach(function (boundary) {
          var isVisible = visibleBoundary[0] <= boundary[0] && boundary[1] <= visibleBoundary[1];
          if (isVisible) {
              var row = rows[boundary[0] - offset];
              collapsedRows.push({
                  row: row,
                  cells: getCells(row),
              });
          }
          else {
              var row = {};
              collapsedRows.push({
                  row: {
                      key: TABLE_STUB_TYPE.toString() + "_" + boundary[0] + "_" + boundary[1],
                      type: TABLE_STUB_TYPE,
                      height: getColumnsSize(rows, boundary[0], boundary[1], getRowHeight),
                  },
                  cells: getCells(row),
              });
          }
      });
      return collapsedRows;
  };
  var getCollapsedCells = function (columns, spanBoundaries, boundaries, getColSpan) {
      var collapsedCells = [];
      var index = 0;
      var _loop_1 = function () {
          var boundary = boundaries[index];
          var isSpan = spanBoundaries.reduce(function (acc, spanBoundary) { return (acc || (spanBoundary[0] <= boundary[0] && boundary[1] <= spanBoundary[1])); }, false);
          if (isSpan) {
              var column = columns[boundary[0]];
              var realColSpan = getColSpan(column);
              if (realColSpan + index - 1 !== columns.length) {
                  var realColSpanEnd_1 = (realColSpan + boundary[0]) - 1;
                  var colSpanEnd = boundaries.findIndex(function (colSpanBoundary) { return colSpanBoundary[0]
                      <= realColSpanEnd_1 && realColSpanEnd_1
                      <= colSpanBoundary[1]; });
                  collapsedCells.push({
                      column: column,
                      colSpan: (colSpanEnd - index) + 1,
                  });
              }
              else {
                  collapsedCells.push({
                      column: column,
                      colSpan: realColSpan,
                  });
              }
              index += 1;
          }
          else {
              collapsedCells.push({
                  column: {
                      key: TABLE_STUB_TYPE.toString() + "_" + boundary[0] + "_" + boundary[1],
                      type: TABLE_STUB_TYPE,
                  },
                  colSpan: 1,
              });
              index += 1;
          }
      };
      while (index < boundaries.length) {
          _loop_1();
      }
      return collapsedCells;
  };
  var getCollapsedGrid = function (_a) {
      var rows = _a.rows, columns = _a.columns, rowsVisibleBoundary = _a.rowsVisibleBoundary, columnsVisibleBoundary = _a.columnsVisibleBoundary, getColumnWidth = _a.getColumnWidth, getRowHeight = _a.getRowHeight, getColSpan = _a.getColSpan, totalRowCount = _a.totalRowCount, offset = _a.offset;
      if (!columns.length) {
          return {
              columns: [],
              rows: [],
          };
      }
      var boundaries = rowsVisibleBoundary || [0, rows.length - 1 || 1];
      var getSpanBoundaryByRow = function (row) { return getSpanBoundary(columns, columnsVisibleBoundary, function (column) { return getColSpan(row, column); }); };
      var rowSpanBoundaries = rows
          .slice(boundaries[0], boundaries[1] + 1)
          .map(function (row) { return getSpanBoundaryByRow(row); });
      var columnBoundaries = collapseBoundaries(columns.length, columnsVisibleBoundary, rowSpanBoundaries);
      var rowBoundaries = collapseBoundaries(totalRowCount, [boundaries], []);
      return {
          columns: getCollapsedColumns(columns, columnsVisibleBoundary, columnBoundaries, getColumnWidth),
          rows: getCollapsedRows(rows, boundaries, rowBoundaries, getRowHeight, function (row) { return getCollapsedCells(columns, getSpanBoundaryByRow(row), columnBoundaries, function (column) { return getColSpan(row, column); }); }, offset),
      };
  };
  var getColumnWidthGetter = function (tableColumns, tableWidth, minColumnWidth) {
      var colsHavingWidth = tableColumns.filter(function (col) { return typeof col.width === 'number'; });
      var columnsWidth = colsHavingWidth.reduce(function (acc, col) { return (acc + col.width); }, 0);
      var autoWidth = (tableWidth - columnsWidth) / (tableColumns.length - colsHavingWidth.length);
      var autoColWidth = Math.max(autoWidth, minColumnWidth);
      return function (column) { return (column.type === TABLE_FLEX_TYPE
          ? null
          : typeof column.width === 'number' ? column.width : autoColWidth); };
  };
  var getCollapsedGrids = function (_a) {
      var _b = _a.headerRows, headerRows = _b === void 0 ? [] : _b, _c = _a.bodyRows, bodyRows = _c === void 0 ? [] : _c, _d = _a.footerRows, footerRows = _d === void 0 ? [] : _d, columns = _a.columns, loadedRowsStart = _a.loadedRowsStart, totalRowCount = _a.totalRowCount, getCellColSpan = _a.getCellColSpan, viewport = _a.viewport, getRowHeight = _a.getRowHeight, getColumnWidth = _a.getColumnWidth;
      var getColSpan = function (tableRow, tableColumn) { return getCellColSpan({ tableRow: tableRow, tableColumn: tableColumn, tableColumns: columns }); };
      var getCollapsedGridBlock = function (rows, rowsVisibleBoundary, rowCount, offset) {
          if (rowCount === void 0) { rowCount = rows.length; }
          if (offset === void 0) { offset = 0; }
          return getCollapsedGrid({
              rows: rows,
              columns: columns,
              rowsVisibleBoundary: rowsVisibleBoundary,
              columnsVisibleBoundary: viewport.columns,
              getColumnWidth: getColumnWidth,
              getRowHeight: getRowHeight,
              getColSpan: getColSpan,
              totalRowCount: rowCount,
              offset: offset,
          });
      };
      var headerGrid = getCollapsedGridBlock(headerRows, getRowsRenderBoundary(headerRows.length, viewport.headerRows));
      var bodyGrid = getCollapsedGridBlock(bodyRows, adjustedRenderRowBounds(viewport.rows, bodyRows.length, loadedRowsStart), totalRowCount || 1, loadedRowsStart);
      var footerGrid = getCollapsedGridBlock(footerRows, getRowsRenderBoundary(footerRows.length, viewport.footerRows));
      return {
          headerGrid: headerGrid,
          bodyGrid: bodyGrid,
          footerGrid: footerGrid,
      };
  };
  var adjustedRenderRowBounds = function (visibleBounds, rowCount, loadedRowsStart) {
      var renderRowBoundaries = getRowsRenderBoundary(loadedRowsStart + rowCount, visibleBounds);
      var adjustedInterval = intervalUtil.intersect({ start: renderRowBoundaries[0], end: renderRowBoundaries[1] }, { start: loadedRowsStart, end: loadedRowsStart + rowCount });
      return [adjustedInterval.start, adjustedInterval.end];
  };

  var getGroupIndexByColumn = function (grouping, tableColumn) { return grouping.findIndex(function (columnGrouping) { return !!tableColumn.column && columnGrouping.columnName === tableColumn.column.name; }); };
  var isIndentCell = function (tableRow, tableColumn, grouping) {
      if (tableColumn.column && tableRow.row.groupedBy === tableColumn.column.name)
          return false;
      var rowGroupIndex = grouping.findIndex(function (columnGrouping) { return columnGrouping.columnName === tableRow.row.groupedBy; });
      var columnGroupIndex = getGroupIndexByColumn(grouping, tableColumn);
      return columnGroupIndex < rowGroupIndex;
  };
  var isGroupTableCell = function (tableRow, tableColumn) { return !!(tableRow.type === TABLE_GROUP_TYPE && tableColumn.type === TABLE_GROUP_TYPE
      && tableColumn.column
      && tableColumn.column.name === tableRow.row.groupedBy); };
  var isGroupIndentTableCell = function (tableRow, tableColumn, grouping) { return (tableRow.type === TABLE_GROUP_TYPE && tableColumn.type === TABLE_GROUP_TYPE &&
      isIndentCell(tableRow, tableColumn, grouping)); };
  var isGroupIndentStubTableCell = function (tableRow, tableColumn, grouping) { return ((tableRow.type === TABLE_GROUP_TYPE && tableColumn.type === TABLE_STUB_TYPE &&
      isIndentCell(tableRow, tableColumn, grouping))); };
  var isGroupTableRow = function (tableRow) { return tableRow.type === TABLE_GROUP_TYPE; };
  var isGroupRowOrdinaryCell = function (tableRow, tableColumn) { return (isGroupTableRow(tableRow) && !isGroupTableCell(tableRow, tableColumn)); };
  var columnHasGroupRowSummary = function (tableColumn, groupSummaryItems) { return (!!(groupSummaryItems && groupSummaryItems
      .some(function (item) { return ((!item.showInGroupFooter && item.alignByColumn)
      && item.columnName === (tableColumn.column && tableColumn.column.name)); }))); };
  var isRowSummaryCell = function (tableRow, tableColumn, grouping, groupSummaryItems) { return (columnHasGroupRowSummary(tableColumn, groupSummaryItems)
      && !isGroupIndentTableCell(tableRow, tableColumn, grouping)); };
  var isPreviousCellContainSummary = function (tableRow, tableColumn, tableColumns, grouping, groupSummaryItems) {
      var columnIndex = tableColumns.indexOf(tableColumn);
      return columnIndex > 0 && isRowSummaryCell(tableRow, tableColumns[columnIndex - 1], grouping, groupSummaryItems);
  };
  var calculateGroupCellIndent = function (tableColumn, grouping, indentWidth) { return (indentWidth * getGroupIndexByColumn(grouping, tableColumn)); };
  var sortAndSpliceColumns = function (tableColumns, firstVisibleColumnIndex) {
      var groupColumns = tableColumns.filter(function (col) { return col.type === TABLE_GROUP_TYPE; });
      var dataColumns = tableColumns.filter(function (col) { return col.type === TABLE_DATA_TYPE; });
      var otherColumns = tableColumns.filter(function (col) {
          return col.type !== TABLE_DATA_TYPE &&
              col.type !== TABLE_GROUP_TYPE &&
              col.type !== TABLE_FLEX_TYPE;
      });
      if (firstVisibleColumnIndex) {
          var firstGroupIndex = tableColumns.indexOf(groupColumns[0]);
          otherColumns.splice(0, Math.min(firstVisibleColumnIndex, firstGroupIndex));
      }
      return __spread(groupColumns, otherColumns, dataColumns);
  };

  var tableColumnsWithDraftGrouping = function (tableColumns, grouping, draftGrouping, showColumnWhenGrouped) { return tableColumns
      .reduce(function (acc, tableColumn) {
      if (tableColumn.type !== TABLE_DATA_TYPE) {
          acc.push(tableColumn);
          return acc;
      }
      var columnName = tableColumn.column && tableColumn.column.name || '';
      var columnGroupingExists = grouping
          .some(function (columnGrouping) { return columnGrouping.columnName === columnName; });
      var columnDraftGroupingExists = draftGrouping
          .some(function (columnGrouping) { return columnGrouping.columnName === columnName; });
      if ((!columnGroupingExists && !columnDraftGroupingExists)
          || showColumnWhenGrouped(columnName)) {
          acc.push(tableColumn);
      }
      else if ((!columnGroupingExists && columnDraftGroupingExists)
          || (columnGroupingExists && !columnDraftGroupingExists)) {
          acc.push(__assign(__assign({}, tableColumn), { draft: true }));
      }
      return acc;
      // tslint:disable-next-line: prefer-array-literal
  }, []); };
  var tableColumnsWithGrouping = function (columns, tableColumns, grouping, draftGrouping, indentColumnWidth, showColumnWhenGrouped) { return __spread(grouping.map(function (columnGrouping) {
      var groupedColumn = columns.find(function (column) { return column.name === columnGrouping.columnName; });
      return {
          key: TABLE_GROUP_TYPE.toString() + "_" + groupedColumn.name,
          type: TABLE_GROUP_TYPE,
          column: groupedColumn,
          width: indentColumnWidth,
      };
  }), tableColumnsWithDraftGrouping(tableColumns, grouping, draftGrouping, showColumnWhenGrouped)); };
  var tableRowsWithGrouping = function (tableRows, isGroupRow) { return tableRows.map(function (tableRow) {
      if (tableRow.type !== TABLE_DATA_TYPE || !isGroupRow(tableRow.row)) {
          return tableRow;
      }
      return __assign(__assign({}, tableRow), { key: TABLE_GROUP_TYPE.toString() + "_" + tableRow.row.compoundKey, type: TABLE_GROUP_TYPE });
  }); };
  var isRowLevelSummary = function (groupSummaryItems, colName) { return (groupSummaryItems.some(function (item) { return (!item.showInGroupFooter && item.alignByColumn && item.columnName === colName); })); };
  var groupSummaryChains = function (tableRow, tableColumns, groupSummaryItems, firstVisibleColumnIndex) {
      var captionStarted = false;
      return sortAndSpliceColumns(tableColumns, firstVisibleColumnIndex)
          .reduce(function (acc, col) {
          var colName = (col.column && col.column.name);
          var colKey = col.key;
          var isStartOfGroupCaption = col.type === TABLE_GROUP_TYPE
              && tableRow.row.groupedBy === colName;
          var isIndentColumn = col.type === TABLE_GROUP_TYPE
              && tableRow.row.groupedBy !== colName && !captionStarted;
          if (isStartOfGroupCaption) {
              captionStarted = true;
          }
          if (isStartOfGroupCaption || isIndentColumn) {
              acc.push([colKey]);
          }
          else if (groupSummaryItems && isRowLevelSummary(groupSummaryItems, colName)) {
              acc.push([colKey]);
              acc.push([]);
          }
          else {
              acc[acc.length - 1].push(colKey);
          }
          return acc;
      }, [[]]);
  };
  var tableGroupCellColSpanGetter = function (getTableCellColSpan, groupSummaryItems, firstVisibleColumnIndex) { return function (params) {
      var tableRow = params.tableRow, tableColumns = params.tableColumns, tableColumn = params.tableColumn;
      if (tableRow.type === TABLE_GROUP_TYPE) {
          var colKey_1 = tableColumn.key;
          var chains = groupSummaryChains(tableRow, tableColumns, groupSummaryItems, firstVisibleColumnIndex);
          var chain = chains.find(function (ch) { return ch[0] === colKey_1; });
          if (chain) {
              return chain.length;
          }
      }
      return getTableCellColSpan(params);
  }; };

  var isHeadingTableCell = function (tableRow, tableColumn) { return tableRow.type === TABLE_HEADING_TYPE && tableColumn.type === TABLE_DATA_TYPE; };
  var isHeadingTableRow = function (tableRow) { return (tableRow.type === TABLE_HEADING_TYPE); };
  var findChainByColumnIndex = function (chains, columnIndex) { return (chains.find(function (chain) { return (chain.start <= columnIndex && columnIndex < chain.start + chain.columns.length); })); };
  var splitHeaderColumnChains = function (tableColumnChains, tableColumns, shouldSplitChain, extendChainProps) { return (tableColumnChains.map(function (row, rowIndex) { return row
      .reduce(function (acc, chain) {
      var currentChain = null;
      chain.columns.forEach(function (col) {
          var column = tableColumns.find(function (c) { return c.key === col.key; });
          var isNewGroup = shouldSplitChain(currentChain, column, rowIndex);
          if (isNewGroup) {
              var start = currentChain
                  ? (currentChain.start + currentChain.columns.length)
                  : chain.start;
              acc.push(__assign(__assign(__assign({}, chain), extendChainProps(column)), { start: start, columns: [] }));
              currentChain = acc[acc.length - 1];
          }
          currentChain.columns.push(column);
      });
      return acc;
  }, []); })); };
  var generateSimpleChains = function (rows, columns) { return (rows.map(function () { return ([{
          columns: columns,
          start: 0,
      }]); })); };
  var nextColumnName = function (tableColumns, index) {
      var isNextColumnHasName = index < tableColumns.length - 1 && tableColumns[index + 1].column;
      return isNextColumnHasName
          ? tableColumns[index + 1].column.name
          : undefined;
  };
  var getNextColumnName = function (tableColumns, columnName) {
      var index = tableColumns.findIndex(function (elem) {
          return elem.column && elem.column.name === columnName;
      });
      return index >= 0
          ? nextColumnName(tableColumns, index)
          : undefined;
  };

  var tableRowsWithHeading = function (headerRows) { return __spread([
      { key: TABLE_HEADING_TYPE.toString(), type: TABLE_HEADING_TYPE }
  ], headerRows); };

  var TABLE_BAND_TYPE = Symbol('band');
  var BAND_GROUP_CELL = 'bandGroupCell';
  var BAND_HEADER_CELL = 'bandHeaderCell';
  var BAND_EMPTY_CELL = 'bandEmptyCell';
  var BAND_DUPLICATE_RENDER = 'bandDuplicateRender';
  var BAND_FILL_LEVEL_CELL = 'bandFillLevelCell';

  var isBandedTableRow = function (tableRow) { return (tableRow.type === TABLE_BAND_TYPE); };
  var isBandedOrHeaderRow = function (tableRow) { return isBandedTableRow(tableRow)
      || tableRow.type === TABLE_HEADING_TYPE; };
  var isNoDataColumn = function (columnType) { return columnType !== TABLE_DATA_TYPE; };
  var getColumnMeta = function (columnName, bands, tableRowLevel, key, level, title, result) {
      if (key === void 0) { key = ''; }
      if (level === void 0) { level = 0; }
      if (title === void 0) { title = null; }
      if (result === void 0) { result = null; }
      return bands.reduce(function (acc, band) {
          if (band.columnName === columnName) {
              return __assign(__assign({}, acc), { title: title, level: level, key: key });
          }
          if (band.children !== undefined) {
              var rowLevelPassed = level > tableRowLevel;
              var bandTitle = rowLevelPassed ? title : band.title;
              var bandKey = rowLevelPassed ? key : key + "_" + bandTitle;
              return getColumnMeta(columnName, band.children, tableRowLevel, bandKey, level + 1, bandTitle, acc);
          }
          return acc;
      }, result || { level: level, title: title, key: title });
  };
  var calculateBand = function (visibleBound, headerChain) {
      if (visibleBound) {
          var bandStart = Math.max(visibleBound[0], headerChain.start);
          var bandEnd = Math.min(visibleBound[1] + 1, headerChain.start + headerChain.columns.length);
          return [bandStart, bandEnd];
      }
      return [headerChain.start, headerChain.start + headerChain.columns.length];
  };
  var getBandComponent = function (_a, tableHeaderRows, tableColumns, columnBands, tableHeaderColumnChains, columnVisibleIntervals, bandLevelsVisibility) {
      var currentTableColumn = _a.tableColumn, tableRow = _a.tableRow, rowSpan = _a.rowSpan;
      if (rowSpan)
          return { type: BAND_DUPLICATE_RENDER, payload: null };
      var maxLevel = tableHeaderRows.filter(function (column) { return column.type === TABLE_BAND_TYPE; }).length + 1;
      var level = tableRow.level;
      var currentRowLevel = level === undefined
          ? maxLevel - 1 : level;
      var currentColumnMeta = currentTableColumn.type === TABLE_DATA_TYPE
          ? getColumnMeta(currentTableColumn.column.name, columnBands, currentRowLevel)
          : { level: 0, title: '' };
      var currentColumnIndex = tableColumns
          .findIndex(function (column) { return column.key === currentTableColumn.key; });
      var levelsCount = bandLevelsVisibility.length;
      var visibleLevelsCount = bandLevelsVisibility.filter(Boolean).length;
      if (currentColumnMeta.level < currentRowLevel) {
          var shouldFillLevel = currentRowLevel > 0 && visibleLevelsCount < levelsCount
              && !bandLevelsVisibility[currentRowLevel] && currentTableColumn.type === TABLE_STUB_TYPE;
          if (shouldFillLevel) {
              return { type: BAND_FILL_LEVEL_CELL, payload: null };
          }
          return { type: BAND_EMPTY_CELL, payload: null };
      }
      var previousTableColumn = tableColumns[currentColumnIndex - 1];
      var beforeBorder = false;
      if (currentColumnIndex > 0 && currentTableColumn.type === TABLE_DATA_TYPE
          && isNoDataColumn(previousTableColumn.type)) {
          beforeBorder = true;
      }
      var isStubColumn = currentTableColumn.type === TABLE_STUB_TYPE;
      var isColumnVisible = currentColumnIndex >= 0;
      if (currentColumnMeta.level === currentRowLevel) {
          if (isStubColumn) {
              var cellRowSpan = visibleLevelsCount < levelsCount
                  ? visibleLevelsCount || 1
                  : maxLevel;
              return {
                  type: BAND_FILL_LEVEL_CELL,
                  payload: {
                      rowSpan: cellRowSpan,
                  },
              };
          }
          if (isColumnVisible) {
              return {
                  type: BAND_HEADER_CELL,
                  payload: __assign({ tableRow: tableHeaderRows.find(function (row) { return row.type === TABLE_HEADING_TYPE; }), rowSpan: maxLevel - currentRowLevel }, beforeBorder && { beforeBorder: beforeBorder }),
              };
          }
      }
      if (!isColumnVisible)
          return { type: BAND_EMPTY_CELL, payload: null };
      var currentColumnChain = findChainByColumnIndex(tableHeaderColumnChains[currentRowLevel], currentColumnIndex);
      var columnVisibleBoundary = columnVisibleIntervals.find(function (_a) {
          var _b = __read(_a, 2), start = _b[0], end = _b[1];
          return (start <= currentColumnIndex && currentColumnIndex <= end);
      });
      var _b = __read(calculateBand(columnVisibleBoundary, currentColumnChain), 2), bandStart = _b[0], bandEnd = _b[1];
      if (bandStart < currentColumnIndex) {
          return { type: null, payload: null };
      }
      return {
          type: BAND_GROUP_CELL,
          payload: __assign({ colSpan: bandEnd - bandStart, value: currentColumnMeta.title, column: currentColumnMeta }, beforeBorder && { beforeBorder: beforeBorder }),
      };
  };

  var emptyVirtualRows = {
      skip: Number.POSITIVE_INFINITY,
      rows: [],
  };
  var pluckSubarray = function (source, sourceStart, left, right) { return (source.slice(left - sourceStart, right - sourceStart)); };
  var mergeRows = function (rowsInterval, cacheInterval, rows, cacheRows, rowsStart, cacheStart) {
      var breakpoints = [
          rowsInterval.start, rowsInterval.end,
          cacheInterval.start, cacheInterval.end,
      ]
          .filter(function (i) { return 0 <= i && i < Number.POSITIVE_INFINITY; })
          .sort(function (a, b) { return a - b; });
      var result = [];
      if (breakpoints.length > 1) {
          for (var i = 0; i < breakpoints.length - 1; i += 1) {
              var left = breakpoints[i];
              var right = breakpoints[i + 1];
              var chunk = rowsInterval.start <= left && right <= rowsInterval.end
                  ? pluckSubarray(rows, rowsStart, left, right) // rows have higher priority
                  : pluckSubarray(cacheRows, cacheStart, left, right);
              result = result.concat(chunk);
          }
      }
      return {
          skip: breakpoints[0],
          rows: result,
      };
  };
  var correctRequestedRange = function (calculatedRange, referenceIndex, pageSize) {
      var start = calculatedRange.start, end = calculatedRange.end;
      if (start - referenceIndex > pageSize / 2) {
          return { start: start - pageSize, end: start };
      }
      return { start: start, end: end };
  };
  var calculateRequestedRange = function (virtualRows, newRange, pageSize, referenceIndex, isInfiniteScroll) {
      var loadedInterval = intervalUtil.getRowsInterval(virtualRows);
      var isAdjacentPage = Math.abs(loadedInterval.start - newRange.start) < 2 * pageSize;
      if (isAdjacentPage) {
          var calculatedRange = intervalUtil.difference(newRange, loadedInterval);
          if (isInfiniteScroll && calculatedRange !== intervalUtil.empty) {
              return correctRequestedRange(calculatedRange, referenceIndex, pageSize);
          }
          return calculatedRange;
      }
      // load 3 pages at once because a missing page will be loaded anyway
      return newRange;
  };
  var rowToPageIndex = function (rowIndex, pageSize) { return Math.floor(rowIndex / pageSize); };
  var recalculateBounds = function (middleIndex, pageSize, totalCount) {
      var currentPageIndex = rowToPageIndex(middleIndex, pageSize);
      var prevPageIndex = currentPageIndex - 1;
      var nextPageIndex = currentPageIndex + 2;
      var start = Math.max(0, prevPageIndex * pageSize);
      var end = Math.min(nextPageIndex * pageSize, totalCount);
      return {
          start: start,
          end: end,
      };
  };
  var trimRowsToInterval = function (virtualRows, targetInterval) {
      var rowsInterval = intervalUtil.getRowsInterval(virtualRows);
      var intersection = intervalUtil.intersect(rowsInterval, targetInterval);
      if (intervalUtil.empty === intersection) {
          return emptyVirtualRows;
      }
      var rows = pluckSubarray(virtualRows.rows, virtualRows.skip, intersection.start, intersection.end);
      return {
          rows: rows,
          skip: intersection.start,
      };
  };
  var getAvailableRowCount = function (isInfiniteScroll, newRowCount, lastRowCount, totalRowCount) {
      return (isInfiniteScroll
          ? Math.min(Math.max(newRowCount, lastRowCount), totalRowCount)
          : totalRowCount);
  };
  var getForceReloadInterval = function (virtualRows, pageSize, totalRowCount) {
      var _a = intervalUtil.getRowsInterval(virtualRows), start = _a.start, intervalEnd = _a.end;
      var end = Math.min(Math.max(start + pageSize * 2, intervalEnd), Math.max(start + pageSize * 2, totalRowCount));
      return {
          start: start,
          end: end,
      };
  };
  var getRequestMeta = function (referenceIndex, virtualRows, pageSize, totalRowCount, forceReload, isInfiniteScroll) {
      var actualBounds = forceReload
          ? getForceReloadInterval(virtualRows, pageSize, totalRowCount)
          : recalculateBounds(referenceIndex, pageSize, totalRowCount);
      var requestedRange = forceReload
          ? actualBounds
          : calculateRequestedRange(virtualRows, actualBounds, pageSize, referenceIndex, isInfiniteScroll);
      return { requestedRange: requestedRange, actualBounds: actualBounds };
  };
  var needFetchMorePages = function (virtualRows, referenceIndex, pageSize) {
      var _a = intervalUtil.getRowsInterval(virtualRows), start = _a.start, end = _a.end;
      var loadCount = end - start;
      var topTriggerIndex = start > 0 ? start + pageSize : 0;
      var bottomTriggerIndex = Math.max(topTriggerIndex + pageSize, end - pageSize * 1.5);
      if (loadCount <= 0) {
          return false;
      }
      return (referenceIndex < topTriggerIndex || bottomTriggerIndex < referenceIndex);
  };
  var getReferenceIndex = function (_a) {
      var _b = __read(_a.rows, 2), top = _b[0], bottom = _b[1];
      return ((top + bottom) / 2);
  };
  var shouldSendRequest = function (_a, requestedPageIndex, requestedEndIndex) {
      var start = _a.start, end = _a.end;
      var loadCount = (end - start);
      return (start !== requestedPageIndex || end !== requestedEndIndex) && loadCount > 0;
  };

  var empty = {
      start: Number.POSITIVE_INFINITY,
      end: Number.NEGATIVE_INFINITY,
  };
  var getRowsInterval = function (r) { return (r === emptyVirtualRows
      ? empty
      : {
          start: r.skip,
          end: r.skip + r.rows.length,
      }); };
  var getLength = function (a) { return a.end - a.start; };
  var intersect = function (a, b) {
      if (a.end < b.start || b.end < a.start) {
          return empty;
      }
      return {
          start: Math.max(a.start, b.start),
          end: Math.min(a.end, b.end),
      };
  };
  var difference = function (a, b) {
      if (empty === intervalUtil.intersect(a, b)) {
          return a;
      }
      if (b.end < a.end) {
          return {
              start: b.end,
              end: a.end,
          };
      }
      if (a.start < b.start) {
          return {
              start: a.start,
              end: b.start,
          };
      }
      return empty;
  };
  var intervalUtil = {
      empty: empty,
      getRowsInterval: getRowsInterval,
      getLength: getLength,
      intersect: intersect,
      difference: difference,
  };

  var tableRowsWithBands = function (tableHeaderRows, columnBands, tableColumns) {
      var tableDataColumns = tableColumns.filter(function (column) { return column.type === TABLE_DATA_TYPE; });
      var getMaxNestedLevel = function (bands, level, result) {
          if (level === void 0) { level = 0; }
          if (result === void 0) { result = null; }
          return (bands.reduce(function (acc, column) {
              if (column.children !== undefined) {
                  return getMaxNestedLevel(column.children, level + 1, acc);
              }
              var isDataColumn = tableDataColumns.findIndex(function (dataColumn) { return !!dataColumn.column && dataColumn.column.name === column.columnName; }) > -1;
              if (level > acc.level && isDataColumn) {
                  return __assign(__assign({}, acc), { level: level });
              }
              return acc;
          }, result || { level: 0 }));
      };
      var tableBandHeaders = Array.from({
          length: getMaxNestedLevel(columnBands, 0).level,
      })
          .map(function (row, index) { return ({
          key: TABLE_BAND_TYPE.toString() + "_" + index,
          type: TABLE_BAND_TYPE,
          level: index,
      }); });
      return __spread(tableBandHeaders, tableHeaderRows);
  };
  var tableHeaderColumnChainsWithBands = function (tableHeaderRows, tableColumns, bands) {
      var chains = generateSimpleChains(tableHeaderRows, tableColumns);
      var maxBandRowIndex = tableHeaderRows
          .filter(function (row) { return row.type === TABLE_BAND_TYPE; })
          .length;
      var rawBandChains = chains.slice(0, maxBandRowIndex);
      var currentBand = null;
      var shouldSplitChain = function (chain, column, rowIndex) {
          if (rowIndex > maxBandRowIndex)
              return false;
          var columnName = column.column && column.column.name || '';
          currentBand = getColumnMeta(columnName, bands, rowIndex);
          return !chain
              || chain.key !== currentBand.key;
      };
      var extendChainProps = function () { return ({
          bandTitle: currentBand === null || currentBand === void 0 ? void 0 : currentBand.title,
          key: currentBand === null || currentBand === void 0 ? void 0 : currentBand.key,
      }); };
      var bandChains = splitHeaderColumnChains(rawBandChains, tableColumns, shouldSplitChain, extendChainProps);
      return __spread(bandChains, chains.slice(maxBandRowIndex));
  };
  var getBandLevels = function (columnsBands, levels, level) {
      if (levels === void 0) { levels = {}; }
      if (level === void 0) { level = 0; }
      columnsBands.forEach(function (band) {
          if (band.title) {
              levels[band.title] = level;
          }
          if (band.children) {
              getBandLevels(band.children, levels, level + 1);
          }
      });
      return levels;
  };
  var columnBandLevels = function (columnsBands) { return (getBandLevels(columnsBands)); };
  var bandLevelsVisibility = function (columnIntervals, tableHeaderColumnChains, bandLevels) {
      var rowsWithBands = tableHeaderColumnChains
          .filter(function (r) { return r.filter(function (ch) { return !!ch.bandTitle; }).length; });
      var visibleIntervals = columnIntervals.map(function (_a) {
          var _b = __read(_a, 2), start = _b[0], end = _b[1];
          return ({ start: start, end: end });
      });
      var isBandChainVisible = function (chain) { return (visibleIntervals.some(function (interval) { return (intervalUtil.intersect(interval, { start: chain.start, end: chain.start + chain.columns.length - 1 }) !== intervalUtil.empty); })); };
      var getVisibleBandsByLevel = function (level) { return (
      // Note: a visible band level always matches with it's row
      rowsWithBands[level]
          ? rowsWithBands[level].filter(function (chain) { return (bandLevels[chain.bandTitle] === level && isBandChainVisible(chain)); })
          : []); };
      return rowsWithBands.reduce(function (acc, _, index) {
          var rowBands = getVisibleBandsByLevel(index);
          return __spread(acc, [!!rowBands.length]);
      }, []);
  };
  var columnVisibleIntervals = function (viewport, tableColumns) { return (viewport ? viewport.columns : [[0, tableColumns.length]]); };

  var toggleDetailRowExpanded = function (prevExpanded, _a) {
      var rowId = _a.rowId, state = _a.state;
      return toggle(prevExpanded, [rowId], state);
  };

  var TABLE_DETAIL_TYPE = Symbol('detail');

  var isDetailRowExpanded = function (expandedDetailRowIds, rowId) { return expandedDetailRowIds.indexOf(rowId) > -1; };
  var isDetailToggleTableCell = function (tableRow, tableColumn) { return tableColumn.type === TABLE_DETAIL_TYPE && tableRow.type === TABLE_DATA_TYPE; };
  var isDetailTableRow = function (tableRow) { return tableRow.type === TABLE_DETAIL_TYPE; };
  var isDetailTableCell = function (tableColumn, tableColumns) { return tableColumns.indexOf(tableColumn) === 0; };

  var tableRowsWithExpandedDetail = function (tableRows, expandedDetailRowIds, rowHeight) {
      var result = tableRows;
      expandedDetailRowIds
          .forEach(function (expandedRowId) {
          var rowIndex = result.findIndex(function (tableRow) { return tableRow.type === TABLE_DATA_TYPE && tableRow.rowId === expandedRowId; });
          if (rowIndex === -1)
              return;
          var insertIndex = rowIndex + 1;
          var _a = result[rowIndex], row = _a.row, rowId = _a.rowId;
          result = __spread(result.slice(0, insertIndex), [
              {
                  rowId: rowId,
                  row: row,
                  key: TABLE_DETAIL_TYPE.toString() + "_" + rowId,
                  type: TABLE_DETAIL_TYPE,
                  height: rowHeight,
              }
          ], result.slice(insertIndex));
      });
      return result;
  };
  var tableColumnsWithDetail = function (tableColumns, toggleColumnWidth) { return __spread([
      { key: TABLE_DETAIL_TYPE.toString(), type: TABLE_DETAIL_TYPE, width: toggleColumnWidth }
  ], tableColumns); };
  var tableDetailCellColSpanGetter = function (getTableCellColSpan) { return function (params) {
      var tableRow = params.tableRow, tableColumns = params.tableColumns, tableColumn = params.tableColumn;
      if (tableRow.type === TABLE_DETAIL_TYPE && tableColumns.indexOf(tableColumn) === 0) {
          return tableColumns.length;
      }
      return getTableCellColSpan(params);
  }; };

  var TABLE_SELECT_TYPE = Symbol('select');

  var isSelectTableCell = function (tableRow, tableColumn) { return tableColumn.type === TABLE_SELECT_TYPE && tableRow.type === TABLE_DATA_TYPE; };
  var isSelectAllTableCell = function (tableRow, tableColumn) { return tableColumn.type === TABLE_SELECT_TYPE && tableRow.type === TABLE_HEADING_TYPE; };
  var isRowHighlighted = function (highlightRow, selection, tableRow, focused) {
      var highlightion = selection ? selection.concat(focused || []) : focused;
      return !!(highlightRow && highlightion && highlightion.includes(tableRow.rowId));
  };

  var tableColumnsWithSelection = function (tableColumns, selectionColumnWidth, showSelectionColumn) {
      if (showSelectionColumn) {
          return __spread([
              { key: TABLE_SELECT_TYPE.toString(), type: TABLE_SELECT_TYPE, width: selectionColumnWidth }
          ], tableColumns);
      }
      return tableColumns;
  };

  var VALID_UNITS$1 = ['px', '%', 'em', 'rem', 'vm', 'vh', 'vmin', 'vmax', ''];
  var TABLE_ERROR = 'The columnExtension property of the Table plugin is given an invalid value.';
  var isDataTableCell = function (tableRow, tableColumn) { return tableRow.type === TABLE_DATA_TYPE && tableColumn.type === TABLE_DATA_TYPE; };
  var isHeaderStubTableCell = function (tableRow, headerRows) { return headerRows.indexOf(tableRow) > -1; };
  var isDataTableRow = function (tableRow) { return tableRow.type === TABLE_DATA_TYPE; };
  var isNoDataTableRow = function (tableRow) { return tableRow.type === TABLE_NODATA_TYPE; };
  var isNoDataTableCell = function (tableColumn, tableColumns) { return tableColumns.indexOf(tableColumn) === 0; };
  var isStubTableCell = function (tableRow) { return (tableRow.type === TABLE_STUB_TYPE); };
  var checkTableColumnExtensions = function (columnExtensions) {
      if (columnExtensions) {
          columnExtensions.map(function (column) {
              var width = column.width;
              if (typeof width === 'string') {
                  if (!isValidValue(width, VALID_UNITS$1)) {
                      throw new Error(TABLE_ERROR);
                  }
              }
          });
      }
  };

  var getColumnExtension = function (columnExtensions, columnName) {
      if (!columnExtensions) {
          // tslint:disable-next-line:no-object-literal-type-assertion
          return {};
      }
      var columnExtension = columnExtensions.find(function (extension) { return extension.columnName === columnName; });
      if (!columnExtension) {
          // tslint:disable-next-line:no-object-literal-type-assertion
          return {};
      }
      return columnExtension;
  };
  var getColumnExtensionValueGetter = function (columnExtensions, extensionName, defaultValue) { return function (columnName) {
      if (columnExtensions) {
          var columnExtension = getColumnExtension(columnExtensions, columnName);
          var extensionValue = columnExtension[extensionName];
          return extensionValue !== undefined ? extensionValue : defaultValue;
      }
      return defaultValue;
  }; };

  var tableColumnsWithDataRows = function (columns, columnExtensions) { return columns.map(function (column) {
      var name = column.name;
      var columnExtension = getColumnExtension(columnExtensions, name);
      var width = convertWidth(columnExtension.width);
      return {
          column: column,
          key: TABLE_DATA_TYPE.toString() + "_" + name,
          type: TABLE_DATA_TYPE,
          width: width,
          align: columnExtension.align,
          wordWrapEnabled: columnExtension.wordWrapEnabled,
      };
  }); };
  var tableRowsWithDataRows = function (rows, getRowId, isRemoteRowsLoading) { return (!rows.length && !isRemoteRowsLoading
      ? [{ key: TABLE_NODATA_TYPE.toString(), type: TABLE_NODATA_TYPE }]
      : rows.map(function (row, dataIndex) {
          var rowId = getRowId(row);
          return {
              row: row,
              // dataIndex,
              rowId: rowId,
              type: TABLE_DATA_TYPE,
              key: TABLE_DATA_TYPE.toString() + "_" + rowId,
          };
      })); };
  var tableCellColSpanGetter = function (params) {
      var tableRow = params.tableRow, tableColumns = params.tableColumns, tableColumn = params.tableColumn;
      if (tableRow.type === TABLE_NODATA_TYPE && tableColumns.indexOf(tableColumn) === 0) {
          return tableColumns.length;
      }
      return 1;
  };

  var visibleTableColumns = function (tableColumns, hiddenColumnNames) {
      if (tableColumns === void 0) { tableColumns = []; }
      return tableColumns.filter(function (tableColumn) { return tableColumn.type !== TABLE_DATA_TYPE
          || hiddenColumnNames.indexOf(tableColumn.column.name) === -1; });
  };

  var tableDataColumnsExist = function (tableColumns) { return tableColumns.some(function (column) { return column.type === TABLE_DATA_TYPE; }); };

  var columnChooserItems = function (columns, hiddenColumnNames) { return columns.map(function (column) { return ({
      column: column,
      hidden: hiddenColumnNames.indexOf(column.name) !== -1,
  }); }); };

  var toggleColumn = function (hiddenColumnNames, columnName) { return (hiddenColumnNames.indexOf(columnName) === -1
      ? __spread(hiddenColumnNames, [columnName]) : hiddenColumnNames.filter(function (hiddenColumn) { return hiddenColumn !== columnName; })); };

  var toggleRowExpanded = function (prevExpanded, _a) {
      var rowId = _a.rowId, state = _a.state;
      return toggle(prevExpanded, [rowId], state);
  };

  var GRID_TREE_NODE_TYPE = Symbol('treeNode');

  var customTreeRowsWithMeta = function (rows, getChildRows) {
      var rowsToProcess = [{ row: null, level: -1 }];
      var treeRows = [];
      var _loop_1 = function () {
          var _a = rowsToProcess.shift(), currentRow = _a.row, level = _a.level;
          var rowIndex = treeRows.findIndex(function (_a) {
              var row = _a.row;
              return row === currentRow;
          });
          var nestedRows = (_a = getChildRows(currentRow, rows)) === null || _a === void 0 ? void 0 : _a.map(function (childRow) { return ({
              row: childRow,
              level: level + 1,
              leaf: !getChildRows(childRow, rows),
          }); });
          if (nestedRows) {
              if (rowIndex > -1) {
                  treeRows.splice.apply(treeRows, __spread([rowIndex + 1, 0], nestedRows));
              }
              else {
                  treeRows.push.apply(treeRows, __spread(nestedRows));
              }
              rowsToProcess.push.apply(rowsToProcess, __spread(nestedRows));
          }
      };
      while (rowsToProcess === null || rowsToProcess === void 0 ? void 0 : rowsToProcess.length) {
          _loop_1();
      }
      var result = treeRows.reduce(function (acc, _a) {
          var row = _a.row, level = _a.level, leaf = _a.leaf;
          acc.rows.push(row);
          acc.treeMeta.push([row, { level: level, leaf: leaf }]);
          return acc;
      }, { rows: [], treeMeta: [] });
      return {
          rows: result.rows,
          treeMeta: new Map(result.treeMeta),
      };
  };
  var customTreeRowIdGetter = function (getRowId, _a) {
      var rows = _a.rows, treeMeta = _a.treeMeta;
      var firstNestedRowIndex = rows.findIndex(function (row) { return treeMeta.get(row).level > 0; });
      if (firstNestedRowIndex === -1 || getRowId(rows[firstNestedRowIndex]) !== undefined) {
          return getRowId;
      }
      var map = new Map(rows
          .map(function (row, rowIndex) { return [row, rowIndex]; }));
      return function (row) { return map.get(row); };
  };
  var customTreeRowLevelKeyGetter = function (getRowLevelKey, _a) {
      var treeMeta = _a.treeMeta;
      return function (row) {
          var rowMeta = treeMeta.get(row);
          if (rowMeta !== undefined) {
              return GRID_TREE_NODE_TYPE.toString() + "_" + rowMeta.level;
          }
          return getRowLevelKey && getRowLevelKey();
      };
  };
  var expandedTreeRows = function (_a, getRowId, expandedRowIds) {
      var rows = _a.rows, treeMeta = _a.treeMeta;
      var expandedRowIdsSet = new Set(expandedRowIds);
      var currentExpanded = true;
      var currentLevel = 0;
      var collapsedRowsMeta = new Map();
      var resultRows = [];
      rows.forEach(function (row) {
          var rowMeta = treeMeta.get(row);
          var level = rowMeta && rowMeta.level;
          if (level === undefined && currentExpanded) {
              resultRows.push(row);
          }
          else if (!currentExpanded && (level === undefined || level > currentLevel)) {
              var lastRow = resultRows[resultRows.length - 1];
              var collapsedItems = collapsedRowsMeta.get(lastRow);
              if (!collapsedItems) {
                  collapsedItems = [];
                  collapsedRowsMeta.set(lastRow, collapsedItems);
              }
              collapsedItems.push(row);
          }
          else {
              currentExpanded = expandedRowIdsSet.has(getRowId(row));
              currentLevel = level;
              resultRows.push(row);
          }
      });
      return {
          treeMeta: treeMeta,
          collapsedRowsMeta: collapsedRowsMeta,
          rows: resultRows,
      };
  };
  var collapsedTreeRowsGetter = function (getCollapsedRows, _a) {
      var collapsedRowsMeta = _a.collapsedRowsMeta;
      return function (row) { return collapsedRowsMeta.get(row) || (getCollapsedRows && getCollapsedRows(row)); };
  };
  var isTreeRowLeafGetter = function (_a) {
      var treeMeta = _a.treeMeta;
      return function (row) {
          var rowMeta = treeMeta.get(row);
          return rowMeta && rowMeta.leaf;
      };
  };
  var getTreeRowLevelGetter = function (_a) {
      var treeMeta = _a.treeMeta;
      return function (row) {
          var rowMeta = treeMeta.get(row);
          return (rowMeta && rowMeta.level);
      };
  };
  var unwrappedCustomTreeRows = function (_a) {
      var rows = _a.rows;
      return rows;
  };

  var isTreeTableCell = function (tableRow, tableColumn, forColumnName) { return tableRow.type === TABLE_DATA_TYPE && tableColumn.type === TABLE_DATA_TYPE
      && tableColumn.column.name === forColumnName; };

  var changeSearchValue = function (prevSearchValue, searchValue) { return searchValue; };

  var searchFilterExpression = function (searchValue, columns, filterExpression) {
      var filters = columns.map(function (_a) {
          var name = _a.name;
          return ({ columnName: name, value: searchValue });
      });
      var selfFilterExpression = { filters: filters, operator: 'or' };
      if (!filterExpression) {
          return selfFilterExpression;
      }
      return {
          operator: 'and',
          filters: [filterExpression, selfFilterExpression],
      };
  };

  var getAvailableFilterOperationsGetter = function (getAvailableFilterOperations, availableFilterOperations, columnNames) { return function (columnName) { return (columnNames.indexOf(columnName) > -1 && availableFilterOperations)
      // tslint:disable-next-line: max-line-length
      || (typeof getAvailableFilterOperations === 'function' && getAvailableFilterOperations(columnName))
      || undefined; }; };

  var FIXED_COLUMN_LEFT_SIDE = 'left';
  var FIXED_COLUMN_RIGHT_SIDE = 'right';
  var TABLE_FIXED_TYPE = Symbol('fixed');

  var getFixedColumnKeys = function (tableColumns, fixedNames) { return tableColumns
      .filter(function (tableColumn) { return ((tableColumn.type === TABLE_DATA_TYPE && fixedNames.indexOf(tableColumn.column.name) !== -1)
      || fixedNames.indexOf(tableColumn.type) !== -1); })
      .map(function (_a) {
      var key = _a.key;
      return key;
  }); };
  var isFixedTableRow = function (tableRow) { return tableRow.type === TABLE_FIXED_TYPE; };
  var calculatePosition = function (array, index, tableColumnDimensions) { return (index === 0
      ? 0
      : array
          .slice(0, index)
          .reduce(function (acc, target) { return acc + tableColumnDimensions[target] || 0; }, 0)); };
  var calculateFixedColumnProps = function (_a, _b, tableColumns, tableColumnDimensions, tableHeaderColumnChains) {
      var tableColumn = _a.tableColumn;
      var leftColumns = _b.leftColumns, rightColumns = _b.rightColumns;
      var side = tableColumn.fixed;
      var targetArray = side === FIXED_COLUMN_LEFT_SIDE
          ? getFixedColumnKeys(tableColumns, leftColumns)
          : dxCore.slice(getFixedColumnKeys(tableColumns, rightColumns)).reverse();
      var index = tableColumns.findIndex(function (_a) {
          var key = _a.key;
          return key === tableColumn.key;
      });
      var fixedIndex = targetArray.indexOf(tableColumn.key);
      var columnChain = findChainByColumnIndex(tableHeaderColumnChains[0], index);
      var showLeftDivider = columnChain.start === index && index !== 0;
      var showRightDivider = columnChain.start + columnChain.columns.length - 1 === index
          && index < tableColumns.length - 1;
      var position = calculatePosition(targetArray, fixedIndex, tableColumnDimensions);
      return {
          showRightDivider: showRightDivider,
          showLeftDivider: showLeftDivider,
          position: position,
          side: side,
      };
  };

  var tableColumnsWithFixed = function (tableColumns, leftColumns, rightColumns) { return tableColumns
      .map(function (tableColumn) {
      var fixed;
      if ((tableColumn.type === TABLE_DATA_TYPE
          && leftColumns.indexOf(tableColumn.column.name) !== -1)
          || leftColumns.indexOf(tableColumn.type) !== -1) {
          fixed = FIXED_COLUMN_LEFT_SIDE;
      }
      if ((tableColumn.type === TABLE_DATA_TYPE
          && rightColumns.indexOf(tableColumn.column.name) !== -1)
          || rightColumns.indexOf(tableColumn.type) !== -1) {
          fixed = FIXED_COLUMN_RIGHT_SIDE;
      }
      return fixed ? __assign(__assign({}, tableColumn), { fixed: fixed }) : tableColumn;
  }); };
  var tableHeaderRowsWithFixed = function (tableHeaderRows) { return __spread(tableHeaderRows, [
      { key: TABLE_FIXED_TYPE.toString(), type: TABLE_FIXED_TYPE, height: 0 },
  ]); };
  var tableHeaderColumnChainsWithFixed = function (tableHeaderColumnChains, tableHeaderRows, tableColumns) {
      var chains = tableHeaderColumnChains
          || generateSimpleChains(tableHeaderRows, tableColumns);
      var shouldSplitChain = function (currentGroup, column) { return (!currentGroup || currentGroup.fixed !== column.fixed); };
      var extendChainProps = function (column) { return ({
          fixed: column.fixed,
      }); };
      return splitHeaderColumnChains(chains, tableColumns, shouldSplitChain, extendChainProps);
  };

  var defaultSummaryCalculators = {
      count: function (rows) { return rows.length; },
      sum: function (rows, getValue) { return rows.reduce(function (acc, row) { return acc + getValue(row); }, 0); },
      max: function (rows, getValue) { return (rows.length
          ? rows.reduce(function (acc, row) { return Math.max(acc, getValue(row)); }, -Infinity)
          : null); },
      min: function (rows, getValue) { return (rows.length
          ? rows.reduce(function (acc, row) { return Math.min(acc, getValue(row)); }, Infinity)
          : null); },
      avg: function (rows, getValue) { return (rows.length
          ? rows.reduce(function (acc, row) { return acc + getValue(row); }, 0) / rows.length
          : null); },
  };
  var defaultSummaryCalculator = function (type, rows, getValue) {
      var summaryCalculator = defaultSummaryCalculators[type];
      if (!summaryCalculator) {
          throw new Error("The summary type '" + type + "' is not defined");
      }
      return summaryCalculator(rows, getValue);
  };
  var rowsSummary = function (rows, summaryItems, getCellValue, calculator) { return summaryItems
      .reduce(function (acc, _a) {
      var type = _a.type, columnName = _a.columnName;
      var getValue = function (row) { return getCellValue(row, columnName); };
      acc.push(calculator(type, rows, getValue));
      return acc;
  }, []); };
  var expandRows = function (rows, getRowLevelKey, getCollapsedRows, isGroupRow, includeGroupRow) {
      if (includeGroupRow === void 0) { includeGroupRow = false; }
      var shouldIncludeRow = includeGroupRow || !isGroupRow
          ? function () { return true; }
          : function (row) { return !isGroupRow(row); };
      return rows
          .reduce(function (acc, row) {
          if (getRowLevelKey && getRowLevelKey(row)) {
              if (shouldIncludeRow(row)) {
                  acc.push(row);
              }
              var collapsedRows = getCollapsedRows && getCollapsedRows(row);
              if (collapsedRows) {
                  acc.push.apply(acc, __spread(collapsedRows));
              }
              return acc;
          }
          acc.push(row);
          return acc;
      }, []);
  };
  var totalSummaryValues = function (rows, summaryItems, getCellValue, getRowLevelKey, isGroupRow, getCollapsedRows, calculator) {
      if (calculator === void 0) { calculator = defaultSummaryCalculator; }
      var plainRows = expandRows(rows, getRowLevelKey, getCollapsedRows, isGroupRow);
      return rowsSummary(plainRows, summaryItems, getCellValue, calculator);
  };
  var groupSummaryValues = function (rows, summaryItems, getCellValue, getRowLevelKey, isGroupRow, getCollapsedRows, calculator) {
      if (calculator === void 0) { calculator = defaultSummaryCalculator; }
      var levels = [];
      var getLevelIndex = function (levelKey) { return (levels.findIndex(function (level) { return level.levelKey === levelKey; })); };
      var summaries = {};
      var anyRowLevelSummaryExist = summaryItems.some(function (item) { return (!item.showInGroupFooter); });
      var expandedRows = anyRowLevelSummaryExist
          ? expandRows(rows, getRowLevelKey, getCollapsedRows, isGroupRow, true)
          : rows;
      expandedRows.forEach(function (row) {
          var levelKey = getRowLevelKey(row);
          var collapsedRows = getCollapsedRows && getCollapsedRows(row);
          var levelIndex = getLevelIndex(levelKey);
          if (levelIndex > -1) {
              levels.forEach(function (level) {
                  summaries[level.row.compoundKey] = rowsSummary(level.rows, summaryItems, getCellValue, calculator);
              });
              levels = levels.slice(0, levelIndex);
          }
          if (isGroupRow(row)) {
              levels.push({
                  levelKey: levelKey,
                  row: row,
                  rows: [],
              });
              levelIndex = getLevelIndex(levelKey);
          }
          // when row level summary exists, these rows had already been expanded earlier
          var isCollapsedNestedGroupRow = collapsedRows && levelIndex > 0 && !anyRowLevelSummaryExist;
          var rowsToAppend = !levelKey ? [row] : collapsedRows;
          if (!levelKey || isCollapsedNestedGroupRow) {
              levels.forEach(function (level) {
                  var _a;
                  (_a = level.rows).push.apply(_a, __spread(rowsToAppend));
              });
          }
      }, {});
      levels.forEach(function (level) {
          summaries[level.row.compoundKey] = rowsSummary(level.rows, summaryItems, getCellValue, calculator);
      });
      return summaries;
  };
  var treeSummaryValues = function (rows, summaryItems, getCellValue, getRowLevelKey, isGroupRow, getRowId, calculator) {
      if (calculator === void 0) { calculator = defaultSummaryCalculator; }
      var levels = [];
      var summaries = {};
      rows.forEach(function (row) {
          var levelKey = getRowLevelKey(row);
          if (!levelKey) {
              levels[levels.length - 1].rows.push(row);
              return;
          }
          var levelIndex = levels.findIndex(function (level) { return level.levelKey === levelKey; });
          if (levelIndex > -1) {
              levels.slice(levelIndex).forEach(function (level) {
                  if (level.rows.length) {
                      summaries[getRowId(level.row)] = rowsSummary(level.rows, summaryItems, getCellValue, calculator);
                  }
              });
              levels = levels.slice(0, levelIndex);
          }
          if (!isGroupRow || !isGroupRow(row)) {
              if (levels.length) {
                  levels[levels.length - 1].rows.push(row);
              }
              levels.push({
                  levelKey: levelKey,
                  row: row,
                  rows: [],
              });
          }
      }, {});
      levels.forEach(function (level) {
          if (level.rows.length) {
              summaries[getRowId(level.row)] = rowsSummary(level.rows, summaryItems, getCellValue, calculator);
          }
      });
      return summaries;
  };

  var TABLE_TOTAL_SUMMARY_TYPE = Symbol('totalSummary');
  var TABLE_GROUP_SUMMARY_TYPE = Symbol('groupSummary');
  var TABLE_TREE_SUMMARY_TYPE = Symbol('treeSummary');
  var defaultFormatlessSummaries = ['count'];

  var isTotalSummaryTableCell = function (tableRow, tableColumn) { return tableRow.type === TABLE_TOTAL_SUMMARY_TYPE && tableColumn.type === TABLE_DATA_TYPE; };
  var isGroupSummaryTableCell = function (tableRow, tableColumn) { return tableRow.type === TABLE_GROUP_SUMMARY_TYPE && tableColumn.type === TABLE_DATA_TYPE; };
  var isTreeSummaryTableCell = function (tableRow, tableColumn) { return tableRow.type === TABLE_TREE_SUMMARY_TYPE && tableColumn.type === TABLE_DATA_TYPE; };
  var isTotalSummaryTableRow = function (tableRow) { return (tableRow.type === TABLE_TOTAL_SUMMARY_TYPE); };
  var isGroupSummaryTableRow = function (tableRow) { return (tableRow.type === TABLE_GROUP_SUMMARY_TYPE); };
  var isTreeSummaryTableRow = function (tableRow) { return (tableRow.type === TABLE_TREE_SUMMARY_TYPE); };
  var getColumnSummaries = function (summaryItems, columnName, summaryValues, predicate) {
      if (predicate === void 0) { predicate = function () { return true; }; }
      return summaryItems
          .map(function (item, index) { return [item, index]; })
          .filter(function (_a) {
          var _b = __read(_a, 1), item = _b[0];
          return item.columnName === columnName && predicate(item);
      })
          .map(function (_a) {
          var _b = __read(_a, 2), item = _b[0], index = _b[1];
          return ({
              type: item.type,
              value: summaryValues[index],
          });
      });
  };
  var isFooterSummary = function (summaryItem) { return (summaryItem.showInGroupFooter); };
  var isInlineGroupCaptionSummary = function (summaryItem) { return (!(summaryItem.showInGroupFooter ||
      summaryItem.alignByColumn)); };
  var groupFooterSummaryExists = function (groupSummaryItems) { return groupSummaryItems === null || groupSummaryItems === void 0 ? void 0 : groupSummaryItems.some(isFooterSummary); };
  var getGroupInlineSummaries = function (summaryItems, columns, summaryValues) {
      if (!summaryItems.some(isInlineGroupCaptionSummary)) {
          return [];
      }
      return columns.reduce(function (acc, column) {
          var colName = column.name;
          var summaries = getColumnSummaries(summaryItems, colName, summaryValues, isInlineGroupCaptionSummary);
          if (summaries.length) {
              acc.push({
                  column: column,
                  summaries: summaries,
              });
          }
          return acc;
      }, []);
  };

  var tableRowsWithTotalSummaries = function (footerRows) { return __spread([
      { key: TABLE_TOTAL_SUMMARY_TYPE.toString(), type: TABLE_TOTAL_SUMMARY_TYPE }
  ], footerRows); };
  var tableRowsWithSummaries = function (tableRows, groupSummaryItems, treeSummaryItems, getRowLevelKey, isGroupRow, getRowId) {
      var hasGroupFooterSummary = groupFooterSummaryExists(groupSummaryItems);
      if (!getRowLevelKey || !(hasGroupFooterSummary || treeSummaryItems.length))
          return tableRows;
      var result = [];
      var closeLevel = function (level) {
          if (!level.opened)
              return;
          if (hasGroupFooterSummary && isGroupRow && isGroupRow(level.row)) {
              var compoundKey = level.row.compoundKey;
              result.push({
                  key: TABLE_GROUP_SUMMARY_TYPE.toString() + "_" + compoundKey,
                  type: TABLE_GROUP_SUMMARY_TYPE,
                  row: level.row,
              });
          }
          else if (treeSummaryItems.length) {
              var rowId = getRowId(level.row);
              result.push({
                  key: TABLE_TREE_SUMMARY_TYPE.toString() + "_" + rowId,
                  type: TABLE_TREE_SUMMARY_TYPE,
                  row: level.row,
              });
          }
      };
      var levels = [];
      tableRows.forEach(function (tableRow) {
          var row = tableRow.row;
          var levelKey = getRowLevelKey(row);
          if (levelKey) {
              var levelIndex = levels.findIndex(function (level) { return level.levelKey === levelKey; });
              if (levelIndex > -1) {
                  levels.slice(levelIndex).reverse().forEach(closeLevel);
                  levels = levels.slice(0, levelIndex);
              }
              if (!isGroupRow || !isGroupRow(row)) {
                  levels = levels.map(function (level) { return (__assign(__assign({}, level), { opened: true })); });
              }
              levels.push({
                  levelKey: levelKey,
                  row: row,
                  opened: false,
              });
          }
          else {
              levels = levels.map(function (level) { return (__assign(__assign({}, level), { opened: true })); });
          }
          result.push(tableRow);
      });
      levels.slice().reverse().forEach(closeLevel);
      return result;
  };

  var prepareGroupSummaryItems = function (items) { return (!!items
      ? items.map(function (item) { return (__assign(__assign({}, item), { showInGroupFooter: (item.showInGroupFooter === undefined && !item.alignByColumn)
              ? true
              : item.showInGroupFooter })); })
      : items); };

  var HEADING_TYPE = TABLE_HEADING_TYPE.toString();
  var FILTER_TYPE = TABLE_FILTER_TYPE.toString();
  var DATA_TYPE = TABLE_DATA_TYPE.toString();
  var BAND_TYPE = TABLE_BAND_TYPE.toString();
  var TOTAL_SUMMARY_TYPE = TABLE_TOTAL_SUMMARY_TYPE.toString();
  var STUB_TYPE = TABLE_STUB_TYPE.toString();
  var GROUP_TYPE = TABLE_GROUP_TYPE.toString();
  var tableParts = [HEADING_TYPE, FILTER_TYPE, DATA_TYPE, TOTAL_SUMMARY_TYPE];
  var getIndex = function (arr, key) {
      return arr.findIndex(function (el) {
          return el.key === key;
      });
  };
  var isSpanInput = function (innerElements) {
      return innerElements[0].tagName === 'SPAN' ||
          innerElements[0].tagName === 'INPUT' && innerElements[0].type === 'text';
  };
  var isDefined = function (value) {
      return value !== undefined;
  };
  var hasInsideElements = function (innerElements, focusedElementIndex) {
      if ((innerElements.length && focusedElementIndex === undefined) ||
          (isDefined(focusedElementIndex) && focusedElementIndex < innerElements.length - 1)) {
          if (innerElements.length === 1 && focusedElementIndex === undefined) {
              return !isSpanInput(innerElements);
          }
          return true;
      }
      return false;
  };
  var getIndexInnerElement = function (elements, rowKey, columnKey, direction) {
      var innerElements = getInnerElements(elements, rowKey, columnKey);
      var index = direction > 0 ? 0 : innerElements.length - 1;
      return cellEmptyOrHasSpanAndInput(elements, rowKey, columnKey) ? undefined : index;
  };
  var getNextPrevClosestColumnKey = function (tableColumns, columnIndex, rowKey, elements, direction) {
      var columnKey;
      if (direction > 0) {
          for (var i = columnIndex; i <= tableColumns.length - 1; i += 1) {
              if (elements[rowKey][tableColumns[i].key]) {
                  columnKey = tableColumns[i].key;
                  break;
              }
          }
      }
      else {
          for (var i = columnIndex; i >= 0; i -= 1) {
              if (elements[rowKey][tableColumns[i].key]) {
                  columnKey = tableColumns[i].key;
                  break;
              }
          }
      }
      return columnKey;
  };
  var shouldBeScrolled = function (elements, key1, key2, scrollToColumn) {
      if (scrollToColumn && !elements[key1][key2]) {
          return Object.keys(elements[key1]).some(function (column) {
              return column.includes(STUB_TYPE);
          });
      }
      return false;
  };
  var convertPart = function (part, elements, tableBodyRows) {
      if (part === DATA_TYPE && elements[tableBodyRows[0].key]) {
          return DATA_TYPE;
      }
      if (elements[part]) {
          return part;
      }
      return;
  };
  var getLastPart = function (elements, tableBodyRows, partIndex) {
      var index = partIndex || tableParts.length;
      var part;
      do {
          index = index - 1;
          part = convertPart(tableParts[index], elements, tableBodyRows);
      } while (index > 0 && !part);
      return part;
  };
  var getRowKey = function (part, key, headerRowKey) {
      if (headerRowKey && part === HEADING_TYPE) {
          return headerRowKey;
      }
      return part === DATA_TYPE ? key : part;
  };
  var getPrevPart = function (focusedElement, elements, tableBodyRows) {
      var index = tableParts.findIndex(function (p) {
          return p === focusedElement.part;
      });
      if (index === 0) {
          return;
      }
      return getLastPart(elements, tableBodyRows, index);
  };
  var getNextPart = function (focusedElement, elements, tableBodyRows) {
      var index = tableParts.findIndex(function (p) {
          return p === focusedElement.part;
      });
      if (index === tableParts.length - 1) {
          return;
      }
      var part = tableParts.find(function (p, i) {
          if (i > index) {
              return convertPart(p, elements, tableBodyRows);
          }
          return false;
      });
      return part;
  };
  var getCellNextPart = function (focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn) {
      var part = getNextPart(focusedElement, elements, tableBodyRows);
      if (!part) {
          return {};
      }
      var rowKey = getRowKey(part, tableBodyRows[0].key);
      var columnKey = tableColumns[0].key;
      if (shouldBeScrolled(elements, rowKey, columnKey, scrollToColumn)) {
          return {
              element: {
                  rowKey: rowKey,
                  columnKey: columnKey,
                  part: part,
              },
              scrolling: 'left',
          };
      }
      return {
          element: {
              rowKey: rowKey,
              columnKey: columnKey,
              index: getIndexInnerElement(elements, rowKey, columnKey, 1),
              part: part,
          },
      };
  };
  var getCellPrevPart = function (focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn) {
      var part = getPrevPart(focusedElement, elements, tableBodyRows);
      if (!part) {
          return {};
      }
      var rowKey = getRowKey(part, tableBodyRows[tableBodyRows.length - 1].key);
      var columnKeyIndex = tableColumns.length - 1;
      var columnKey = tableColumns[columnKeyIndex].key;
      if (shouldBeScrolled(elements, rowKey, columnKey, scrollToColumn)) {
          return {
              element: {
                  rowKey: rowKey,
                  columnKey: columnKey,
                  part: part,
              },
              scrolling: 'right',
          };
      }
      var nextColumnKey = getNextPrevClosestColumnKey(tableColumns, columnKeyIndex, rowKey, elements, -1);
      return {
          element: nextColumnKey ? {
              rowKey: rowKey,
              columnKey: nextColumnKey,
              index: getIndexInnerElement(elements, rowKey, nextColumnKey, -1),
              part: part,
          } : undefined,
      };
  };
  var getPrevCellFromBody = function (columnIndex, rowIndex, tableColumns, tableBodyRows, focusedElement, elements, scrollToColumn) {
      var prevRowKey = focusedElement.rowKey;
      var prevColumnKey;
      if (columnIndex === 0 && rowIndex === 0) {
          return getCellPrevPart(focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn);
      }
      if (columnIndex === 0) {
          prevRowKey = tableBodyRows[rowIndex - 1].key;
          if (prevRowKey.includes(GROUP_TYPE)) {
              prevColumnKey = getNextPrevClosestColumnKey(tableColumns, tableColumns.length - 1, prevRowKey, elements, -1);
          }
          else {
              prevColumnKey = tableColumns[tableColumns.length - 1].key;
          }
          if (prevColumnKey && shouldBeScrolled(elements, prevRowKey, prevColumnKey, scrollToColumn)) {
              return {
                  element: {
                      rowKey: prevRowKey,
                      columnKey: prevColumnKey,
                      part: focusedElement.part,
                  },
                  scrolling: 'right',
              };
          }
      }
      else {
          prevColumnKey = getNextPrevClosestColumnKey(tableColumns, columnIndex - 1, prevRowKey, elements, -1);
      }
      return {
          element: prevColumnKey ? {
              rowKey: prevRowKey,
              columnKey: prevColumnKey,
              index: getIndexInnerElement(elements, prevRowKey, prevColumnKey, -1),
              part: focusedElement.part,
          } : undefined,
      };
  };
  var getPrevCellFromHeading = function (tableHeaderRows, tableColumns, columnIndex, _a, elements) {
      var rowKey = _a.rowKey, part = _a.part;
      var prevColumnKey;
      var prevRowKey;
      var headIndex = getIndex(tableHeaderRows, rowKey);
      prevColumnKey = getNextPrevClosestColumnKey(tableColumns, columnIndex - 1, rowKey, elements, -1);
      if (prevColumnKey) {
          return {
              element: {
                  columnKey: prevColumnKey,
                  rowKey: rowKey,
                  part: part,
                  index: getIndexInnerElement(elements, rowKey, prevColumnKey, -1),
              },
          };
      }
      if (headIndex > 0) {
          var abort = false;
          for (var i = headIndex - 1; i >= 0 && !abort; i -= 1) {
              for (var j = tableColumns.length - 1; j >= 0; j -= 1) {
                  if (elements[tableHeaderRows[i].key][tableColumns[j].key]) {
                      prevColumnKey = tableColumns[j].key;
                      prevRowKey = tableHeaderRows[i].key;
                      abort = true;
                      break;
                  }
              }
          }
          if (prevColumnKey && prevRowKey) {
              return {
                  element: {
                      columnKey: prevColumnKey,
                      rowKey: prevRowKey,
                      part: part,
                      index: getIndexInnerElement(elements, prevRowKey, prevColumnKey, -1),
                  },
              };
          }
      }
      return {};
  };
  var getPrevElement = function (focusedElement, tableBodyRows, tableColumns, tableHeaderRows, elements, scrollToColumn) {
      var columnIndex = getIndex(tableColumns, focusedElement.columnKey);
      var rowIndex = getIndex(tableBodyRows, focusedElement.rowKey);
      if (isDefined(focusedElement.index) && focusedElement.index > 0) {
          return { element: __assign(__assign({}, focusedElement), { index: focusedElement.index - 1 }) };
      }
      if (focusedElement.part === DATA_TYPE) {
          return getPrevCellFromBody(columnIndex, rowIndex, tableColumns, tableBodyRows, focusedElement, elements, scrollToColumn);
      }
      if (focusedElement.part === HEADING_TYPE) {
          var cell = getPrevCellFromHeading(tableHeaderRows, tableColumns, columnIndex, focusedElement, elements);
          if (cell.element) {
              return {
                  element: __assign(__assign({}, cell.element), { index: getIndexInnerElement(elements, cell.element.rowKey, cell.element.columnKey, -1) }),
              };
          }
          return { element: cell.element };
      }
      if (columnIndex === 0) {
          return getCellPrevPart(focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn);
      }
      var rowKey = focusedElement.part;
      var columnKey = tableColumns[columnIndex - 1].key;
      return {
          element: {
              rowKey: rowKey,
              columnKey: columnKey,
              index: getIndexInnerElement(elements, rowKey, columnKey, -1),
              part: focusedElement.part,
          },
      };
  };
  var getNextCellFromBody = function (columnIndex, rowIndex, tableColumns, tableBodyRows, focusedElement, elements, scrollToColumn) {
      var nextRowKey = focusedElement.rowKey;
      var nextColumnKey;
      if (columnIndex === tableColumns.length - 1 && rowIndex === tableBodyRows.length - 1) {
          return getCellNextPart(focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn);
      }
      if (columnIndex === tableColumns.length - 1) {
          nextRowKey = tableBodyRows[rowIndex + 1].key;
          nextColumnKey = tableColumns[0].key;
          if (shouldBeScrolled(elements, nextRowKey, nextColumnKey, scrollToColumn)) {
              return {
                  element: {
                      rowKey: nextRowKey,
                      columnKey: nextColumnKey,
                      part: focusedElement.part,
                  },
                  scrolling: 'left',
              };
          }
      }
      else {
          nextColumnKey = getNextPrevClosestColumnKey(tableColumns, columnIndex + 1, nextRowKey, elements, 1);
          if (!nextColumnKey) {
              if (rowIndex === tableBodyRows.length - 1) {
                  return getCellNextPart(focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn);
              }
              nextRowKey = tableBodyRows[rowIndex + 1].key;
              nextColumnKey = tableColumns[0].key;
          }
      }
      return {
          element: {
              rowKey: nextRowKey,
              columnKey: nextColumnKey,
              index: getIndexInnerElement(elements, nextRowKey, nextColumnKey, 1),
              part: focusedElement.part,
          },
      };
  };
  var getNextCellFromHeading = function (tableHeaderRows, tableBodyRows, tableColumns, columnIndex, focusedElement, elements, scrollToColumn) {
      var headIndex = getIndex(tableHeaderRows, focusedElement.rowKey);
      var nextRowKey;
      var nextColumnKey = getNextPrevClosestColumnKey(tableColumns, columnIndex + 1, focusedElement.rowKey, elements, 1);
      if (nextColumnKey) {
          return {
              element: {
                  columnKey: nextColumnKey,
                  rowKey: focusedElement.rowKey,
                  part: focusedElement.part,
                  index: getIndexInnerElement(elements, focusedElement.rowKey, nextColumnKey, 1),
              },
          };
      }
      if (headIndex !== tableHeaderRows.length - 1) {
          var abort = false;
          for (var i = headIndex + 1; i <= tableHeaderRows.length - 1 && !abort; i += 1) {
              for (var j = 0; j <= tableColumns.length - 1; j += 1) {
                  if (elements[tableHeaderRows[i].key][tableColumns[j].key]) {
                      nextColumnKey = tableColumns[j].key;
                      nextRowKey = tableHeaderRows[i].key;
                      abort = true;
                      break;
                  }
              }
          }
          if (nextColumnKey && nextRowKey) {
              return {
                  element: {
                      columnKey: nextColumnKey,
                      rowKey: nextRowKey,
                      part: focusedElement.part,
                      index: getIndexInnerElement(elements, nextRowKey, nextColumnKey, 1),
                  },
              };
          }
      }
      return getCellNextPart(focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn);
  };
  var getNextElement = function (focusedElement, tableBodyRows, tableColumns, tableHeaderRows, elements, scrollToColumn) {
      var innerElements = getInnerElements(elements, focusedElement.rowKey, focusedElement.columnKey);
      var columnIndex = getIndex(tableColumns, focusedElement.columnKey);
      var rowIndex = getIndex(tableBodyRows, focusedElement.rowKey);
      if (hasInsideElements(innerElements, focusedElement.index)) {
          return {
              element: __assign(__assign({}, focusedElement), { index: !isDefined(focusedElement.index) ? 0 : focusedElement.index + 1 }),
          };
      }
      if (focusedElement.part === DATA_TYPE) {
          return getNextCellFromBody(columnIndex, rowIndex, tableColumns, tableBodyRows, focusedElement, elements, scrollToColumn);
      }
      if (focusedElement.part === HEADING_TYPE) {
          return getNextCellFromHeading(tableHeaderRows, tableBodyRows, tableColumns, columnIndex, focusedElement, elements, scrollToColumn);
      }
      if (columnIndex === tableColumns.length - 1) {
          return getCellNextPart(focusedElement, elements, tableBodyRows, tableColumns, scrollToColumn);
      }
      var rowKey = focusedElement.rowKey;
      var columnKey = tableColumns[columnIndex + 1].key;
      return {
          element: {
              rowKey: rowKey,
              columnKey: columnKey,
              part: focusedElement.part,
              index: getIndexInnerElement(elements, rowKey, columnKey, 1),
          },
      };
  };
  var hasCellInput = function (innerElements) {
      return innerElements.length ? innerElements[0].tagName === 'INPUT' : false;
  };
  var cellEmptyOrHasSpanAndInput = function (elements, key1, key2) {
      var innerElements = getInnerElements(elements, key1, key2);
      if (innerElements.length) {
          return isSpanInput(innerElements);
      }
      return true;
  };
  var getCellRightLeft = function (direction, focusedElement, tableColumns, elements) {
      if (focusedElement.part !== DATA_TYPE) {
          return;
      }
      var columnIndex = getIndex(tableColumns, focusedElement.columnKey);
      if (tableColumns[columnIndex + direction]) {
          var columnKey = getNextPrevClosestColumnKey(tableColumns, columnIndex + direction, focusedElement.rowKey, elements, direction);
          if (columnKey) {
              return {
                  rowKey: focusedElement.rowKey,
                  columnKey: columnKey,
                  part: focusedElement.part,
              };
          }
      }
      return;
  };
  var getFirstCell = function (elements, tableBodyRows, tableColumns, tableHeaderRows, scrollToColumn, withInnerElements) {
      var part = tableParts.find(function (p) {
          return convertPart(p, elements, tableBodyRows);
      });
      if (!part) {
          return {};
      }
      var rowKey = getRowKey(part, tableBodyRows[0].key, tableHeaderRows[0].key);
      var columnKey = tableColumns[0].key;
      if (shouldBeScrolled(elements, rowKey, columnKey, scrollToColumn)) {
          return {
              element: {
                  rowKey: rowKey,
                  columnKey: columnKey,
                  part: part,
              },
              scrolling: 'left',
          };
      }
      return {
          element: {
              rowKey: rowKey,
              columnKey: columnKey,
              index: withInnerElements ? getIndexInnerElement(elements, rowKey, columnKey, 1) : undefined,
              part: part,
          },
      };
  };
  var getLastCell = function (elements, tableBodyRows, tableColumns) {
      var part = getLastPart(elements, tableBodyRows);
      if (!part) {
          return {};
      }
      var rowKey = getRowKey(part, tableBodyRows[tableBodyRows.length - 1].key);
      var columnKey = getNextPrevClosestColumnKey(tableColumns, tableColumns.length - 1, rowKey, elements, -1);
      return {
          element: columnKey ? {
              rowKey: rowKey,
              columnKey: columnKey,
              index: getIndexInnerElement(elements, rowKey, columnKey, 1),
              part: part,
          } : undefined,
      };
  };
  var getToolbarPagingElements = function (elements) {
      return {
          toolbarElements: elements.toolbar && getInnerElements(elements, 'toolbar', 'none'),
          pagingElements: elements.paging && getInnerElements(elements, 'paging', 'none')
              .filter(function (el) {
              return !el.hasAttribute('disabled') && el.getAttribute('tabindex') !== '-1';
          }),
      };
  };
  var getFirstCellInLastPart = function (elements, tableBodyRows, tableColumns, scrollToColumn, withInnerElements) {
      var lastPart = getLastPart(elements, tableBodyRows);
      if (lastPart) {
          var columnKey = tableColumns[0].key;
          var rowKey = getRowKey(lastPart, tableBodyRows[0].key);
          if (shouldBeScrolled(elements, rowKey, columnKey, scrollToColumn)) {
              return {
                  element: {
                      rowKey: rowKey,
                      columnKey: columnKey,
                      part: lastPart,
                  },
                  scrolling: 'left',
              };
          }
          return {
              element: {
                  columnKey: columnKey,
                  rowKey: rowKey,
                  index: withInnerElements ? getIndexInnerElement(elements, rowKey, columnKey, 1) : undefined,
                  part: lastPart,
              },
          };
      }
      return {};
  };
  var applyEnterAction = function (elements, _a, tableColumns, tableBodyRows, focusedElement) {
      var commitChangedRows = _a.commitChangedRows, stopEditCells = _a.stopEditCells, startEditCells = _a.startEditCells;
      if (!focusedElement) {
          return;
      }
      var innerElements = getInnerElements(elements, focusedElement.rowKey, focusedElement.columnKey);
      var columnIndex = getIndex(tableColumns, focusedElement.columnKey);
      var rowIndex = getIndex(tableBodyRows, focusedElement.rowKey);
      if (focusedElement.part === DATA_TYPE && commitChangedRows) {
          if (focusedElement.index === 0) {
              commitChangedRows({ rowIds: [tableBodyRows[rowIndex].rowId] });
              stopEditCells({
                  editingCells: [{
                          rowId: tableBodyRows[rowIndex].rowId,
                          columnName: tableColumns[columnIndex].column.name,
                      }],
              });
              return {
                  part: focusedElement.part,
                  columnKey: focusedElement.columnKey,
                  rowKey: focusedElement.rowKey,
              };
          }
          startEditCells({
              editingCells: [{
                      rowId: tableBodyRows[rowIndex].rowId,
                      columnName: tableColumns[columnIndex].column.name,
                  }],
          });
          return {
              part: focusedElement.part,
              columnKey: focusedElement.columnKey,
              rowKey: focusedElement.rowKey,
              index: 0,
          };
      }
      if (!isDefined(focusedElement.index) && innerElements.length && isSpanInput(innerElements)) {
          if (innerElements[0].tagName === 'SPAN') {
              innerElements[0].click();
          }
          return {
              part: focusedElement.part,
              columnKey: focusedElement.columnKey,
              rowKey: focusedElement.rowKey,
              index: 0,
          };
      }
      if (focusedElement.index === 0 && hasCellInput(innerElements)) {
          return {
              part: focusedElement.part,
              columnKey: focusedElement.columnKey,
              rowKey: focusedElement.rowKey,
          };
      }
      return;
  };
  var applyEscapeAction = function (elements, _a, tableColumns, tableBodyRows, focusedElement) {
      var cancelChangedRows = _a.cancelChangedRows, stopEditCells = _a.stopEditCells;
      if (!focusedElement) {
          return;
      }
      var innerElements = getInnerElements(elements, focusedElement.rowKey, focusedElement.columnKey);
      var columnIndex = getIndex(tableColumns, focusedElement.columnKey);
      var rowIndex = getIndex(tableBodyRows, focusedElement.rowKey);
      if (focusedElement.index === 0 && hasCellInput(innerElements)) {
          if (focusedElement.part === DATA_TYPE && cancelChangedRows) {
              cancelChangedRows({
                  rowIds: [tableBodyRows[rowIndex].rowId],
              });
              stopEditCells({
                  editingCells: [{
                          rowId: tableBodyRows[rowIndex].rowId,
                          columnName: tableColumns[columnIndex].column.name,
                      }],
              });
          }
          return {
              part: focusedElement.part,
              columnKey: focusedElement.columnKey,
              rowKey: focusedElement.rowKey,
          };
      }
      return;
  };
  var actionOnCheckbox = function (elements, focusedElement) {
      if (!focusedElement || isDefined(focusedElement.index)) {
          return;
      }
      var el = getInnerElements(elements, focusedElement.rowKey, focusedElement.columnKey, 'input')
          .filter(function (element) {
          return element.type === 'checkbox';
      });
      if (el[0]) {
          el[0].click();
      }
  };
  var actionOnTreeMode = function (elements, expandedRowIds, direction, focusedElement) {
      if (!focusedElement || isDefined(focusedElement.index) || !expandedRowIds) {
          return;
      }
      var el = getInnerElements(elements, focusedElement.rowKey, focusedElement.columnKey, 'button, i');
      var index = getIndexFromKey(focusedElement.rowKey);
      if (direction > 0 && expandedRowIds.indexOf(index) === -1 ||
          direction < 0 && expandedRowIds.indexOf(index) > -1) {
          if (el[0]) {
              el[0].click();
          }
      }
  };
  var getInnerElements = function (elements, key1, key2, query) {
      if (query === void 0) { query = '[tabIndex], input, button, a'; }
      return Array.from(elements[key1][key2][0].current.querySelectorAll(query)).filter(function (el) {
          return !el.hasAttribute('disabled') && el.getAttribute('tabindex') !== '-1';
      });
  };
  var getCellTopBottom = function (direction, focusedElement, tableBodyRows, tableColumns, elements) {
      if (focusedElement.part !== DATA_TYPE) {
          return;
      }
      var columnIndex = getIndex(tableColumns, focusedElement.columnKey);
      var rowIndex = getIndex(tableBodyRows, focusedElement.rowKey);
      if (tableBodyRows[rowIndex + direction]) {
          var columnKey = getNextPrevClosestColumnKey(tableColumns, columnIndex, tableBodyRows[rowIndex + direction].key, elements, -1);
          if (columnKey) {
              return {
                  rowKey: tableBodyRows[rowIndex + direction].key,
                  columnKey: columnKey,
                  part: focusedElement.part,
              };
          }
      }
      return;
  };
  var isCtrlMetaKey = function (event) {
      return event.ctrlKey || event.metaKey;
  };
  var getIndexFromKey = function (key) {
      var array = key.split('_');
      return Number(array[array.length - 1]);
  };
  var getCellNextPrevPart = function (focusedElement, elements, tableBodyRows, tableColumns, direction, scrollToColumn) {
      var part = direction > 0 ? getNextPart(focusedElement, elements, tableBodyRows) :
          getPrevPart(focusedElement, elements, tableBodyRows);
      if (part) {
          var rowKey = getRowKey(part, tableBodyRows[0].key);
          var columnKey = tableColumns[0].key;
          return {
              element: {
                  part: part,
                  rowKey: rowKey,
                  columnKey: columnKey,
              },
              scrolling: shouldBeScrolled(elements, rowKey, columnKey, scrollToColumn) ? 'left' : undefined,
          };
      }
      return {};
  };
  var applyFocusOnToolbarPaging = function (elements, direction) {
      if (direction > 0 && elements.paging) {
          getInnerElements(elements, 'paging', 'none')[0].focus();
      }
      if (direction < 0 && elements.toolbar) {
          getInnerElements(elements, 'toolbar', 'none')[0].focus();
      }
  };
  var getClosestCellByRow = function (tableBodyRows, focusedElement, elements) {
      var currentIndex = getIndexFromKey(focusedElement.rowKey);
      var bodyRow = tableBodyRows.find(function (row) {
          return getIndexFromKey(row.key) > currentIndex;
      });
      var rowKey = bodyRow ? bodyRow.key : tableBodyRows[tableBodyRows.length - 1].key;
      var columnKey = focusedElement.columnKey;
      return {
          rowKey: rowKey,
          columnKey: columnKey,
          part: focusedElement.part,
          index: getIndexInnerElement(elements, rowKey, columnKey, 1),
      };
  };
  var getNextFocusedCell = function (tableColumns, tableBodyRows, tableHeaderRows, expandedRowIds, elements, event, inlineEditing, focusedElement, scrollToColumn) {
      if (!focusedElement) {
          var _a = getToolbarPagingElements(elements), toolbarElements = _a.toolbarElements, pagingElements = _a.pagingElements;
          var hasFocus = function (innerElements) {
              return innerElements.some(function (el) {
                  return event.target === el;
              });
          };
          if (isCtrlMetaKey(event)) {
              if (event.key === 'ArrowDown' &&
                  (toolbarElements && hasFocus(toolbarElements) || !toolbarElements)) {
                  return getFirstCell(elements, tableBodyRows, tableColumns, tableHeaderRows, scrollToColumn);
              }
              if (event.key === 'ArrowUp' &&
                  (pagingElements && hasFocus(pagingElements) || !pagingElements)) {
                  return getFirstCellInLastPart(elements, tableBodyRows, tableColumns, scrollToColumn);
              }
          }
          else if (event.key === 'Tab') {
              if (toolbarElements && event.target === toolbarElements[toolbarElements.length - 1] &&
                  !event.shiftKey) {
                  return getFirstCell(elements, tableBodyRows, tableColumns, tableHeaderRows, scrollToColumn, true);
              }
              if (pagingElements && event.target === pagingElements[0] && event.shiftKey) {
                  if (scrollToColumn) {
                      return getFirstCellInLastPart(elements, tableBodyRows, tableColumns, scrollToColumn, true);
                  }
                  return getLastCell(elements, tableBodyRows, tableColumns);
              }
              var element = (!event.shiftKey ? getFirstCell(elements, tableBodyRows, tableColumns, tableHeaderRows, undefined, true) :
                  getLastCell(elements, tableBodyRows, tableColumns)).element;
              if (element &&
                  event.target === elements[element.rowKey][element.columnKey][0].current) {
                  return { element: element };
              }
          }
          return {};
      }
      var cell;
      switch (event.key) {
          case 'Enter':
              cell = {
                  element: applyEnterAction(elements, inlineEditing, tableColumns, tableBodyRows, focusedElement),
              };
              break;
          case 'Escape':
              cell = {
                  element: applyEscapeAction(elements, inlineEditing, tableColumns, tableBodyRows, focusedElement),
              };
              break;
          case ' ':
              actionOnCheckbox(elements, focusedElement);
              break;
          case 'Tab':
              if (event.shiftKey) {
                  cell = getPrevElement(focusedElement, tableBodyRows, tableColumns, tableHeaderRows, elements, scrollToColumn);
              }
              else {
                  cell = getNextElement(focusedElement, tableBodyRows, tableColumns, tableHeaderRows, elements, scrollToColumn);
              }
              break;
          case 'ArrowUp':
              if (isCtrlMetaKey(event)) {
                  cell = getCellNextPrevPart(focusedElement, elements, tableBodyRows, tableColumns, -1, scrollToColumn);
                  if (!cell.element) {
                      applyFocusOnToolbarPaging(elements, -1);
                  }
              }
              else {
                  cell = {
                      element: getCellTopBottom(-1, focusedElement, tableBodyRows, tableColumns, elements),
                  };
              }
              break;
          case 'ArrowDown':
              if (isCtrlMetaKey(event)) {
                  cell = getCellNextPrevPart(focusedElement, elements, tableBodyRows, tableColumns, 1, scrollToColumn);
                  if (!cell.element) {
                      applyFocusOnToolbarPaging(elements, 1);
                  }
              }
              else {
                  cell = {
                      element: getCellTopBottom(1, focusedElement, tableBodyRows, tableColumns, elements),
                  };
              }
              break;
          case 'ArrowLeft':
              if (isCtrlMetaKey(event)) {
                  actionOnTreeMode(elements, expandedRowIds, -1, focusedElement);
              }
              else {
                  cell = { element: getCellRightLeft(-1, focusedElement, tableColumns, elements) };
              }
              break;
          case 'ArrowRight':
              if (isCtrlMetaKey(event)) {
                  actionOnTreeMode(elements, expandedRowIds, 1, focusedElement);
              }
              else {
                  cell = { element: getCellRightLeft(1, focusedElement, tableColumns, elements) };
              }
              break;
      }
      return cell || {};
  };
  var getPart = function (key) {
      if (tableParts.find(function (t) { return t === key; })) {
          return key;
      }
      if (key.includes(BAND_TYPE)) {
          return HEADING_TYPE;
      }
      return DATA_TYPE;
  };
  var getIndexToFocus = function (key1, key2, elements, event, _a, part) {
      var startEditCells = _a.startEditCells;
      if (startEditCells && part === DATA_TYPE) {
          return 0;
      }
      var innerElements = getInnerElements(elements, key1, key2);
      var index = innerElements.findIndex(function (el) {
          return event.target === el;
      });
      return index !== -1 ? index : undefined;
  };
  var filterHeaderRows = function (tableHeaderRows) {
      return tableHeaderRows.filter(function (row) {
          return row.key.includes(BAND_TYPE) || row.key.includes(HEADING_TYPE);
      });
  };
  var isRowFocused = function (tableRow, focusedRowKey) {
      if (focusedRowKey) {
          return tableRow.key === focusedRowKey;
      }
      return false;
  };
  var isCellExist = function (elements, focusedElement) {
      return !!(elements[focusedElement.rowKey] &&
          elements[focusedElement.rowKey][focusedElement.columnKey]);
  };
  var isTabArrowUpDown = function (event) {
      return event.key === 'Tab' || isCtrlMetaKey(event) && (event.key === 'ArrowDown' || event.key === 'ArrowUp');
  };
  var focus = function (elements, focusedElement, prevFocusedElement, onFocusedCellChange) {
      if (!focusedElement || !elements[focusedElement.rowKey] ||
          !elements[focusedElement.rowKey][focusedElement.columnKey]) {
          return;
      }
      var el = focusedElement.index === undefined ?
          elements[focusedElement.rowKey][focusedElement.columnKey][0] :
          getInnerElements(elements, focusedElement.rowKey, focusedElement.columnKey)[focusedElement.index];
      if (el) {
          el.focus ? el.focus() : el.current.focus();
          if (onFocusedCellChange &&
              ((prevFocusedElement === null || prevFocusedElement === void 0 ? void 0 : prevFocusedElement.rowKey) !== focusedElement.rowKey ||
                  (prevFocusedElement === null || prevFocusedElement === void 0 ? void 0 : prevFocusedElement.columnKey) !== focusedElement.columnKey)) {
              onFocusedCellChange({
                  rowKey: focusedElement.rowKey, columnKey: focusedElement.columnKey,
              });
          }
      }
  };
  var isCellFocused = function (row, column, focusedElement) {
      if (!focusedElement || isDefined(focusedElement.index)) {
          return false;
      }
      return focusedElement.rowKey === row.key && focusedElement.columnKey === column.key;
  };

  var getFocusing = function (tableBodyRows, focusedElement) {
      if (!focusedElement) {
          return [];
      }
      var focusedRow = tableBodyRows.find(function (row) {
          return row.key === focusedElement.rowKey;
      });
      return focusedRow ? [focusedRow.rowId] : [];
  };

  var getTargetColumnGeometries = function (columnGeometries, sourceIndex) {
      var sourceWidth = columnGeometries[sourceIndex].right - columnGeometries[sourceIndex].left;
      var getWidthDifference = function (index) { return columnGeometries[index].right
          - columnGeometries[index].left
          - sourceWidth; };
      return columnGeometries
          .map(function (_a, targetIndex) {
          var top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left;
          var leftBorder = left;
          if (targetIndex > 0 && targetIndex <= sourceIndex) {
              leftBorder = Math.min(leftBorder, leftBorder - getWidthDifference(targetIndex - 1));
          }
          if (targetIndex > sourceIndex) {
              leftBorder = Math.max(leftBorder, leftBorder + getWidthDifference(targetIndex));
          }
          var rightBorder = right;
          if (targetIndex < columnGeometries.length - 1 && targetIndex >= sourceIndex) {
              rightBorder = Math.max(rightBorder, rightBorder + getWidthDifference(targetIndex + 1));
          }
          if (targetIndex < sourceIndex) {
              rightBorder = Math.min(rightBorder, rightBorder - getWidthDifference(targetIndex));
          }
          return {
              top: top,
              bottom: bottom,
              right: rightBorder,
              left: leftBorder,
          };
      });
  };
  var getCellGeometries = function (node) {
      var _a, _b;
      var _c = node.getBoundingClientRect(), left = _c.left, right = _c.right, width = _c.width;
      var styleLeft = parseInt((_a = node.style.left) === null || _a === void 0 ? void 0 : _a.toString().replace('px', ''), 10);
      var styleRight = parseInt((_b = node.style.right) === null || _b === void 0 ? void 0 : _b.toString().replace('px', ''), 10);
      if (!isNaN(styleLeft)) {
          var calculatedLeft = Math.max(styleLeft, left);
          return {
              left: calculatedLeft,
              right: calculatedLeft + width,
              isFixed: true,
          };
      }
      if (!isNaN(styleRight)) {
          // NOTE: get tableContainer (parent of first DIV element) to calculate 'right' value
          var tableContainer = node;
          while (tableContainer && tableContainer.nodeName !== 'DIV') {
              tableContainer = tableContainer.parentNode;
          }
          tableContainer = tableContainer === null || tableContainer === void 0 ? void 0 : tableContainer.parentNode;
          if (tableContainer) {
              var tableWidth = tableContainer.getBoundingClientRect().width;
              var calculatedRight = Math.min(tableWidth - styleRight, right);
              return {
                  left: calculatedRight - width,
                  right: calculatedRight,
                  isFixed: true,
              };
          }
      }
      return { left: left, right: right };
  };

  var getTableColumnGeometries = function (columns, tableWidth) {
      var columnWidths = columns
          .map(function (column) { return column.width; });
      var freeSpace = tableWidth;
      var restrictedSpace = columnWidths
          .reduce(function (accum, width) { return accum + (typeof width === 'number' ? width : 0); }, 0);
      var freeSpacePortions = columnWidths
          .reduce(function (accum, width) { return accum + (typeof width !== 'number' ? 1 : 0); }, 0);
      var freeSpacePortion = (freeSpace - restrictedSpace) / freeSpacePortions;
      var lastRightPosition = 0;
      return columnWidths
          .map(function (width) { return (typeof width !== 'number' ? freeSpacePortion : width); })
          .map(function (width) {
          lastRightPosition += width;
          return {
              left: lastRightPosition - width,
              right: lastRightPosition,
          };
      });
  };
  var getTableTargetColumnIndex = function (columnGeometries, offset) {
      var indexes = columnGeometries.reduce(function (acc, _a, index) {
          var left = _a.left, right = _a.right;
          if (offset >= left && offset < right) {
              acc.push(index);
          }
          return acc;
      }, []);
      if (columnGeometries.some(function (_a) {
          var left = _a.left, right = _a.right;
          return left <= 0 && right <= 0;
      })) {
          if (indexes.some(function (index) { return columnGeometries[index].isFixed ||
              columnGeometries[index].left <= 0 && columnGeometries[index].right <= 0; })) {
              return -1;
          }
      }
      if (indexes.length === 2) {
          return indexes.find(function (index) { return columnGeometries[index].isFixed; });
      }
      if (indexes.length === 1) {
          return indexes[0];
      }
      return -1;
  };
  var ANIMATION_DURATION = 200;
  var getAnimationProgress = function (animation) { return (new Date().getTime() - animation.startTime) / ANIMATION_DURATION; };
  var getAnimations = function (prevColumns, nextColumns, tableWidth, prevAnimations) {
      var resizing = prevColumns.map(function (column) { return column.key; }).join()
          === nextColumns.map(function (column) { return column.key; }).join();
      var prevColumnGeometries = new Map(getTableColumnGeometries(prevColumns, tableWidth)
          .map(function (geometry, index) { return [prevColumns[index].key, geometry]; })
          .map(function (_a) {
          var _b = __read(_a, 2), key = _b[0], geometry = _b[1];
          var animation = prevAnimations.get(key);
          if (!animation)
              return [key, geometry];
          var progress = dxCore.easeOutCubic(getAnimationProgress(animation));
          var _c = animation.left, to = _c.to, from = _c.from;
          var left = ((to - from) * progress) + from;
          return [key, {
                  left: left,
                  right: geometry.right - (geometry.left - left),
              }];
          // tslint:disable-next-line:array-type
      }));
      var nextColumnGeometries = new Map(getTableColumnGeometries(nextColumns, tableWidth)
          // tslint:disable-next-line:array-type
          .map(function (geometry, index) { return [nextColumns[index].key, geometry]; }));
      return new Map(__spread(nextColumnGeometries.keys()).map(function (key) {
          var prev = prevColumnGeometries.get(key);
          var next = nextColumnGeometries.get(key);
          var result = { startTime: new Date().getTime(), style: {} };
          var takePrevColumnIntoAccount = !!prevAnimations.get(key) || (prev && !resizing);
          if (Math.abs((takePrevColumnIntoAccount ? prev.left : next.left) - next.left) > 1) {
              result.left = { from: prev.left, to: next.left };
          }
          return [key, result];
      })
          .filter(function (animation) { return animation[1].left; }));
  };
  var filterActiveAnimations = function (animations) { return new Map(__spread(animations.entries()).filter(function (_a) {
      var _b = __read(_a, 2), animation = _b[1];
      return getAnimationProgress(animation) < 1;
  })); };
  var evalAnimations = function (animations) { return new Map(__spread(animations.entries()).map(function (_a) {
      var _b = __read(_a, 2), key = _b[0], animation = _b[1];
      var progress = dxCore.easeOutCubic(getAnimationProgress(animation));
      var result = __assign({}, animation.style);
      if (animation.left) {
          var offset = (animation.left.to - animation.left.from) * (progress - 1);
          result.transform = "translateX(" + offset + "px)";
      }
      return [key, result];
  })); };

  var isOnTheSameLine = function (geometry, y) { return (y >= geometry.top && y <= geometry.bottom); };
  var rectToObject = function (_a) {
      var top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left;
      return ({
          top: top, right: right, bottom: bottom, left: left,
      });
  };
  var collapseGapsBetweenItems = function (geometries) { return (geometries.map(function (geometry, index) {
      if (index !== geometries.length - 1 && geometry.top === geometries[index + 1].top) {
          return __assign(__assign({}, geometry), { right: geometries[index + 1].left });
      }
      return geometry;
  })); };
  var getGroupCellTargetIndex = function (geometries, sourceIndex, _a) {
      var x = _a.x, y = _a.y;
      if (geometries.length === 0)
          return 0;
      var targetGeometries = sourceIndex !== -1
          ? getTargetColumnGeometries(geometries, sourceIndex)
          : geometries.map(rectToObject);
      var targetIndex = collapseGapsBetweenItems(targetGeometries)
          .findIndex(function (geometry, index) {
          var inVerticalBounds = isOnTheSameLine(geometry, y);
          var inHorizontalBounds = x >= geometry.left && x <= geometry.right;
          var shouldGoFirst = index === 0 && x < geometry.left;
          var shouldGoOnLineBreak = !inVerticalBounds
              && !!geometries[index - 1]
              && isOnTheSameLine(geometries[index - 1], y);
          return (inVerticalBounds && inHorizontalBounds)
              || shouldGoFirst
              || shouldGoOnLineBreak;
      });
      return targetIndex === -1 ? geometries.length : targetIndex;
  };

  /** @internal */
  var arraysEqual = function (arrA, arrB, comparator) {
      if (comparator === void 0) { comparator = function (a, b) { return a === b; }; }
      if (arrA.length !== arrB.length) {
          return false;
      }
      for (var i = 0; i < arrA.length; i += 1) {
          if (!comparator(arrA[i], arrB[i])) {
              return false;
          }
      }
      return true;
  };

  /** @internal */
  var emptyViewport = {
      columns: [[0, 0]],
      rows: [0, 0],
      headerRows: [0, 0],
      footerRows: [0, 0],
      top: 0,
      left: 0,
      width: 800,
      height: 600,
  };
  var TOP_POSITION = Symbol('top');
  var BOTTOM_POSITION = Symbol('bottom');
  var LEFT_POSITION = Symbol('left');
  var RIGHT_POSITION = Symbol('right');

  var VALID_UNITS$2 = ['px', ''];
  /* tslint:disable max-line-length */
  var VIRTUAL_TABLE_ERROR = 'The columnExtension property of the VirtualTable plugin is given an invalid value.';
  var getViewport = function (state, getters, estimatedRowHeight, getRowHeight, getColumnWidth) {
      var viewportTop = state.viewportTop, viewportLeft = state.viewportLeft, containerWidth = state.containerWidth, containerHeight = state.containerHeight;
      var loadedRowsStart = getters.loadedRowsStart, tableBodyRows = getters.bodyRows, tableColumns = getters.columns, _a = getters.headerRows, tableHeaderRows = _a === void 0 ? [] : _a, _b = getters.footerRows, tableFooterRows = _b === void 0 ? [] : _b, isDataRemote = getters.isDataRemote, viewport = getters.viewport;
      var rows = getRowsVisibleBoundary(tableBodyRows, viewportTop, containerHeight, getRowHeight, loadedRowsStart, estimatedRowHeight, isDataRemote);
      var headerRows = getRowsVisibleBoundary(tableHeaderRows, 0, 0, getRowHeight, 0, estimatedRowHeight, false);
      var footerRows = getRowsVisibleBoundary(tableFooterRows, 0, 0, getRowHeight, 0, estimatedRowHeight, false);
      var columns = getColumnBoundaries(tableColumns, viewportLeft, containerWidth, getColumnWidth);
      // NOTE: prevent unnecessary updates
      // e.g. when rows changed but bounds remain the same.
      var result = viewport;
      if (viewportTop !== viewport.top) {
          result = __assign(__assign({}, result), { top: viewportTop });
      }
      if (viewportLeft !== viewport.left) {
          result = __assign(__assign({}, result), { left: viewportLeft });
      }
      if (containerWidth !== viewport.width) {
          result = __assign(__assign({}, result), { width: containerWidth });
      }
      if (containerHeight !== viewport.height) {
          result = __assign(__assign({}, result), { height: containerHeight });
      }
      if (!arraysEqual(rows, viewport.rows)) {
          result = __assign(__assign({}, result), { rows: rows });
      }
      if (!arraysEqual(headerRows, viewport.headerRows)) {
          result = __assign(__assign({}, result), { headerRows: headerRows });
      }
      if (!arraysEqual(footerRows, viewport.footerRows)) {
          result = __assign(__assign({}, result), { footerRows: footerRows });
      }
      if (!arraysEqual(columns, viewport.columns, arraysEqual)) {
          result = __assign(__assign({}, result), { columns: columns });
      }
      return result;
  };
  var checkColumnWidths = function (tableColumns) {
      return tableColumns.reduce(function (acc, tableColumn) {
          var width = tableColumn.width;
          if (typeof width === 'string') {
              var numb = parseInt(width, 10);
              var unit_1 = numb ? width.substr(numb.toString().length) : width;
              var isValidUnit = VALID_UNITS$2.some(function (validUnit) { return validUnit === unit_1; });
              if (!isValidUnit) {
                  throw new Error(VIRTUAL_TABLE_ERROR);
              }
              acc.push(__assign(__assign({}, tableColumn), { width: numb }));
          }
          else {
              acc.push(tableColumn);
          }
          return acc;
      }, []);
  };
  var calculateScrollHeight = function (rowHeight, index) {
      return index > -1 ? rowHeight * index : undefined;
  };
  var getScrollTop = function (rows, rowsCount, rowId, rowHeight, isDataRemote) {
      if (rowId === TOP_POSITION) {
          return 0;
      }
      if (rowId === BOTTOM_POSITION) {
          return rowsCount * rowHeight;
      }
      var searchIndexRequired = !isDataRemote && rowId !== undefined;
      var indexById = searchIndexRequired
          ? rows.findIndex(function (row) { return row.rowId === rowId; })
          : undefined;
      return calculateScrollHeight(rowHeight, indexById);
  };
  var getScrollLeft = function (columnCount, columnWidth, columnId) {
      if (!columnId) {
          return;
      }
      if (columnId === LEFT_POSITION) {
          return 0;
      }
      return columnCount * columnWidth;
  };
  var getTopRowId = function (viewport, tableBodyRows, isDataRemote) {
      var hasViewportRows = viewport && viewport.rows;
      var hasBodyRows = tableBodyRows && tableBodyRows.length;
      if (hasViewportRows && hasBodyRows && !isDataRemote) {
          var index = viewport.rows[0];
          return index < tableBodyRows.length ? tableBodyRows[index].rowId : undefined;
      }
      return undefined;
  };

  var virtualRowsWithCache = function (skip, rows, cache) {
      var rowsInterval = intervalUtil.getRowsInterval({ skip: skip, rows: rows });
      var cacheInterval = intervalUtil.getRowsInterval(cache);
      return mergeRows(rowsInterval, cacheInterval, rows, cache.rows, skip, cache.skip);
  };
  var plainRows = function (virtualRows, availableRowCount) {
      return virtualRows.rows.length > availableRowCount
          ? virtualRows.rows.slice(0, availableRowCount)
          : virtualRows.rows;
  };
  var loadedRowsStart = function (virtualRows) { return virtualRows.skip; };

  var ROOT_GROUP = '__root__';
  var DEFAULT_COLUMN_WIDTH = 150;

  var exportHeader = function (worksheet, columns) {
      var cols = columns
          .map(function (_a) {
          var column = _a.column, width = _a.width;
          return ({
              width: (width || DEFAULT_COLUMN_WIDTH) / 8,
              key: column === null || column === void 0 ? void 0 : column.name,
          });
      });
      worksheet.columns = cols;
      var headerRow = columns.reduce(function (acc, _a) {
          var _b;
          var _c = _a.column, _d = _c === void 0 ? {} : _c, name = _d.name, title = _d.title;
          return (__assign(__assign({}, acc), (_b = {}, _b[name] = title, _b)));
      }, {});
      worksheet.addRow(headerRow);
      worksheet.views.push({
          state: 'frozen',
          ySplit: worksheet.lastRow.number,
      });
  };
  var findRanges = function (groupTree, compoundKey, level, maxLevel, result) {
      if (result === void 0) { result = []; }
      if (level !== maxLevel) {
          var ranges = groupTree[compoundKey].reduce(function (acc, groupKey) { return (__spread(acc, findRanges(groupTree, groupKey, level + 1, maxLevel, result))); }, []);
          return __spread(result, ranges);
      }
      return __spread(result, [groupTree[compoundKey]]);
  };
  var exportRows = function (worksheet, allRows, dataColumns, columns, isGroupRow, outlineLevels, rowsOffset, getCellValue, getCloseGroup, customizeCell) {
      var currentLevel = 0;
      var openGroups = [];
      var closeGroup = getCloseGroup(rowsOffset);
      allRows.forEach(function (row) {
          var _a;
          var _b;
          var excelRow;
          if (isGroupRow && isGroupRow(row)) {
              currentLevel = outlineLevels[row.groupedBy];
              // close nested groups first
              openGroups.slice(currentLevel).reverse().forEach(closeGroup);
              openGroups = openGroups.slice(0, currentLevel);
              openGroups[currentLevel] = { groupedBy: row.groupedBy, compoundKey: row.compoundKey };
              // add group row
              var title = (_b = dataColumns.find(function (_a) {
                  var name = _a.name;
                  return name === row.groupedBy;
              })) === null || _b === void 0 ? void 0 : _b.title;
              excelRow = (_a = {}, _a[columns[0].column.name] = title + ": " + row.value, _a);
              worksheet.addRow(excelRow);
              var lastIndex = worksheet.lastRow.number;
              // merge into single cell
              worksheet.mergeCells(lastIndex, 1, lastIndex, columns.length);
              worksheet.lastRow.getCell(1).font = { bold: true };
              if (currentLevel > 0) {
                  worksheet.lastRow.outlineLevel = currentLevel;
              }
              currentLevel += 1;
          }
          else {
              excelRow = columns.reduce(function (acc, _a) {
                  var _b;
                  var column = _a.column;
                  return (__assign(__assign({}, acc), (column ? (_b = {}, _b[column.name] = getCellValue(row, column.name), _b) : null)));
              }, {});
              worksheet.addRow(excelRow);
              worksheet.lastRow.outlineLevel = currentLevel;
          }
          worksheet.lastRow.eachCell(function (cell, colNumber) {
              customizeCell(cell, row, columns[colNumber - 1].column);
          });
      });
      openGroups.reverse().forEach(closeGroup);
  };
  var closeSheet = function (worksheet, groupTree, maxGroupLevel, rowsOffset, totalSummaryItems, exportSummary) {
      exportSummaryItems(worksheet, groupTree, totalSummaryItems, ROOT_GROUP, -1, rowsOffset, maxGroupLevel, exportSummary);
  };
  var normalizeRanges = function (ranges, offset) { return (ranges.map(function (range) { return range.map(function (index) { return +index + offset; }); })); };
  var exportSummaryItems = function (worksheet, groupTree, summaryItems, groupKey, groupLevel, rowsOffset, maxGroupLevel, exportSummary) {
      if (!summaryItems)
          return;
      worksheet.addRow({});
      var ranges = normalizeRanges(findRanges(groupTree, groupKey, groupLevel, maxGroupLevel), rowsOffset);
      summaryItems.forEach(function (s) {
          exportSummary(s, ranges);
      });
  };
  var removeEmptyGroups = function (rows, grouping, isGroupRow) {
      if (!grouping)
          return rows;
      var groupingColumns = grouping.map(function (_a) {
          var columnName = _a.columnName;
          return columnName;
      });
      var result = [];
      var groupChain = [];
      rows.forEach(function (row) {
          if (isGroupRow(row)) {
              var level = groupingColumns.indexOf(row.groupedBy);
              if (level === groupChain.length) {
                  groupChain.push(row);
              }
              else {
                  groupChain = __spread(groupChain.slice(0, level), [row]);
              }
          }
          else {
              if (groupChain.length > 0) {
                  result.push.apply(result, __spread(groupChain));
                  groupChain = Array.from({ length: groupChain.length });
              }
              result.push(row);
          }
      });
      return result.filter(function (row) { return !!row; });
  };

  var groupOutlineLevels = function (grouping) { return ((grouping === null || grouping === void 0 ? void 0 : grouping.reduce(function (acc, _a, index) {
      var _b;
      var columnName = _a.columnName;
      return (__assign(__assign({}, acc), (_b = {}, _b[columnName] = index, _b)));
  }, {})) || {}); };
  var filterSelectedRows = function (rows, selection, getRowId, isGroupRow) {
      var selectionSet = new Set(selection);
      return rows.filter(function (row) { return (isGroupRow && isGroupRow(row)) || selectionSet.has(getRowId(row)); });
  };
  var rowsToExport = function (rows, selection, grouping, getCollapsedRows, getRowId, isGroupRow) {
      var expandRows = function (collapsedRows) { return (collapsedRows.reduce(function (acc, row) { return (__spread(acc, [row], (expandRows(getCollapsedRows(row) || [])))); }, [])); };
      var expandedRows = getCollapsedRows ? expandRows(rows) : rows;
      if (!selection) {
          return expandedRows;
      }
      var filteredRows = filterSelectedRows(expandedRows, selection, getRowId, isGroupRow);
      return removeEmptyGroups(filteredRows, grouping, isGroupRow);
  };
  var buildGroupTree = function (rows, outlineLevels, grouping, isGroupRow, groupSummaryItems) {
      var _a;
      var groupTree = (_a = {}, _a[ROOT_GROUP] = [], _a);
      if (!(grouping === null || grouping === void 0 ? void 0 : grouping.length)) {
          groupTree[ROOT_GROUP] = [0, rows.length - 1];
          return groupTree;
      }
      var maxLevel = Object.keys(outlineLevels).length - 1;
      var groupSummaryExists = !!groupSummaryItems;
      var parentChain = { '-1': ROOT_GROUP };
      var lastDataIndex = 0;
      var openGroup = '';
      var index = 0;
      var level = 0;
      var prevLevel = 0;
      rows.forEach(function (row) {
          var groupedBy = row.groupedBy, compoundKey = row.compoundKey;
          if (isGroupRow(row)) {
              level = outlineLevels[groupedBy];
              groupTree[compoundKey] = [];
              parentChain[level] = compoundKey;
              if (level <= maxLevel) {
                  groupTree[parentChain[level - 1]].push(compoundKey);
              }
              if (level === maxLevel) {
                  if (openGroup) {
                      // close previous group
                      groupTree[openGroup].push(lastDataIndex);
                  }
                  openGroup = compoundKey;
                  if (groupSummaryExists && lastDataIndex > 0) {
                      index += 1;
                  }
                  groupTree[compoundKey].push(index + 1); // first row index
              }
              else if (groupSummaryExists && level < prevLevel) {
                  // jump over summary rows
                  index += maxLevel - level;
              }
              prevLevel = level;
          }
          else {
              lastDataIndex = index;
          }
          index += 1;
      });
      if (openGroup) {
          groupTree[openGroup].push(lastDataIndex);
      }
      return groupTree;
  };
  var operations = {
      count: 'COUNTA',
  };
  var exportSummaryGetter = function (worksheet, tableColumns, customizeSummaryCell, defaultSummaryMessages) { return function (_a, ranges) {
      var columnName = _a.columnName, type = _a.type;
      var column = (tableColumns.find(function (_a) {
          var dataColumn = _a.column, columnType = _a.type;
          return (columnType === TABLE_DATA_TYPE && dataColumn && dataColumn.name === columnName);
      }) || {}).column;
      // NOTE: column is hidden or the grid grouped by this column
      if (!column) {
          return;
      }
      var row = worksheet.lastRow;
      var letter = worksheet.getColumn(columnName).letter;
      var operation = operations[type] || type.toUpperCase();
      var rangesStr = ranges.map(function (range) { return (range
          .map(function (r) { return "" + letter + r; })
          .filter(function (val, index, arr) { return arr.indexOf(val) === index; })
          .join(':')); }).join(',');
      var cell = row.getCell(columnName);
      cell.value = {
          formula: operation + "(" + rangesStr + ")",
          date1904: false,
      };
      cell.numFmt = "\"" + defaultSummaryMessages[type] + ":\" 0";
      var summary = {
          type: type,
          ranges: ranges,
      };
      customizeSummaryCell(cell, column, summary);
  }; };
  var closeGroupGetter = function (worksheet, groupTree, outlineLevels, maxGroupLevel, groupSummaryItems, exportSummary) { return function (rowsOffset) { return function (group) {
      var groupedBy = group.groupedBy, compoundKey = group.compoundKey;
      exportSummaryItems(worksheet, groupTree, groupSummaryItems, compoundKey, outlineLevels[groupedBy], rowsOffset, maxGroupLevel, exportSummary);
  }; }; };
  var maximumGroupLevel = function (grouping) { return ((grouping || []).length - 1); };

  exports.BAND_DUPLICATE_RENDER = BAND_DUPLICATE_RENDER;
  exports.BAND_EMPTY_CELL = BAND_EMPTY_CELL;
  exports.BAND_FILL_LEVEL_CELL = BAND_FILL_LEVEL_CELL;
  exports.BAND_GROUP_CELL = BAND_GROUP_CELL;
  exports.BAND_HEADER_CELL = BAND_HEADER_CELL;
  exports.BOTTOM_POSITION = BOTTOM_POSITION;
  exports.DEFAULT_COLUMN_WIDTH = DEFAULT_COLUMN_WIDTH;
  exports.DEFAULT_FILTER_OPERATIONS = DEFAULT_FILTER_OPERATIONS;
  exports.FIXED_COLUMN_LEFT_SIDE = FIXED_COLUMN_LEFT_SIDE;
  exports.FIXED_COLUMN_RIGHT_SIDE = FIXED_COLUMN_RIGHT_SIDE;
  exports.GROUP_KEY_SEPARATOR = GROUP_KEY_SEPARATOR;
  exports.LEFT_POSITION = LEFT_POSITION;
  exports.RIGHT_POSITION = RIGHT_POSITION;
  exports.ROOT_GROUP = ROOT_GROUP;
  exports.TABLE_ADDED_TYPE = TABLE_ADDED_TYPE;
  exports.TABLE_BAND_TYPE = TABLE_BAND_TYPE;
  exports.TABLE_DATA_TYPE = TABLE_DATA_TYPE;
  exports.TABLE_DETAIL_TYPE = TABLE_DETAIL_TYPE;
  exports.TABLE_EDIT_COMMAND_TYPE = TABLE_EDIT_COMMAND_TYPE;
  exports.TABLE_EDIT_TYPE = TABLE_EDIT_TYPE;
  exports.TABLE_FILTER_TYPE = TABLE_FILTER_TYPE;
  exports.TABLE_FIXED_TYPE = TABLE_FIXED_TYPE;
  exports.TABLE_FLEX_TYPE = TABLE_FLEX_TYPE;
  exports.TABLE_GROUP_SUMMARY_TYPE = TABLE_GROUP_SUMMARY_TYPE;
  exports.TABLE_GROUP_TYPE = TABLE_GROUP_TYPE;
  exports.TABLE_HEADING_TYPE = TABLE_HEADING_TYPE;
  exports.TABLE_NODATA_TYPE = TABLE_NODATA_TYPE;
  exports.TABLE_REORDERING_TYPE = TABLE_REORDERING_TYPE;
  exports.TABLE_SELECT_TYPE = TABLE_SELECT_TYPE;
  exports.TABLE_STUB_TYPE = TABLE_STUB_TYPE;
  exports.TABLE_TOTAL_SUMMARY_TYPE = TABLE_TOTAL_SUMMARY_TYPE;
  exports.TABLE_TREE_SUMMARY_TYPE = TABLE_TREE_SUMMARY_TYPE;
  exports.TOP_POSITION = TOP_POSITION;
  exports.addRow = addRow;
  exports.addedRowsByIds = addedRowsByIds;
  exports.adjustSortIndex = adjustSortIndex;
  exports.allSelected = allSelected;
  exports.bandLevelsVisibility = bandLevelsVisibility;
  exports.buildGroupTree = buildGroupTree;
  exports.calculateBand = calculateBand;
  exports.calculateFixedColumnProps = calculateFixedColumnProps;
  exports.calculateGroupCellIndent = calculateGroupCellIndent;
  exports.calculateKeepOther = calculateKeepOther;
  exports.calculateRequestedRange = calculateRequestedRange;
  exports.calculateScrollHeight = calculateScrollHeight;
  exports.calculateStartPage = calculateStartPage;
  exports.cancelAddedRows = cancelAddedRows;
  exports.cancelChanges = cancelChanges;
  exports.cancelColumnGroupingDraft = cancelColumnGroupingDraft;
  exports.cancelDeletedRows = cancelDeletedRows;
  exports.cancelTableColumnWidthDraft = cancelTableColumnWidthDraft;
  exports.cellValueGetter = cellValueGetter;
  exports.changeAddedRow = changeAddedRow;
  exports.changeColumnFilter = changeColumnFilter;
  exports.changeColumnGrouping = changeColumnGrouping;
  exports.changeColumnOrder = changeColumnOrder;
  exports.changeColumnSorting = changeColumnSorting;
  exports.changeRow = changeRow;
  exports.changeSearchValue = changeSearchValue;
  exports.changeTableColumnWidth = changeTableColumnWidth;
  exports.changedRowsByIds = changedRowsByIds;
  exports.checkColumnWidths = checkColumnWidths;
  exports.checkTableColumnExtensions = checkTableColumnExtensions;
  exports.clamp = clamp;
  exports.closeGroupGetter = closeGroupGetter;
  exports.closeSheet = closeSheet;
  exports.collapsedTreeRowsGetter = collapsedTreeRowsGetter;
  exports.columnBandLevels = columnBandLevels;
  exports.columnChooserItems = columnChooserItems;
  exports.columnVisibleIntervals = columnVisibleIntervals;
  exports.columnsWithEditingCells = columnsWithEditingCells;
  exports.convertWidth = convertWidth;
  exports.createRowChangeGetter = createRowChangeGetter;
  exports.currentPage = currentPage;
  exports.customGroupedRows = customGroupedRows;
  exports.customGroupingRowIdGetter = customGroupingRowIdGetter;
  exports.customTreeRowIdGetter = customTreeRowIdGetter;
  exports.customTreeRowLevelKeyGetter = customTreeRowLevelKeyGetter;
  exports.customTreeRowsWithMeta = customTreeRowsWithMeta;
  exports.defaultFilterPredicate = defaultFilterPredicate;
  exports.defaultFormatlessSummaries = defaultFormatlessSummaries;
  exports.defaultSummaryCalculator = defaultSummaryCalculator;
  exports.deleteRows = deleteRows;
  exports.draftColumnGrouping = draftColumnGrouping;
  exports.draftOrder = draftOrder;
  exports.draftTableColumnWidth = draftTableColumnWidth;
  exports.emptyViewport = emptyViewport;
  exports.emptyVirtualRows = emptyVirtualRows;
  exports.evalAnimations = evalAnimations;
  exports.expandedGroupRows = expandedGroupRows;
  exports.expandedTreeRows = expandedTreeRows;
  exports.exportHeader = exportHeader;
  exports.exportRows = exportRows;
  exports.exportSummaryGetter = exportSummaryGetter;
  exports.exportSummaryItems = exportSummaryItems;
  exports.filterActiveAnimations = filterActiveAnimations;
  exports.filterExpression = filterExpression;
  exports.filterHeaderRows = filterHeaderRows;
  exports.filteredCollapsedRowsGetter = filteredCollapsedRowsGetter;
  exports.filteredRows = filteredRows;
  exports.findChainByColumnIndex = findChainByColumnIndex;
  exports.findRanges = findRanges;
  exports.firstRowOnPage = firstRowOnPage;
  exports.focus = focus;
  exports.generateSimpleChains = generateSimpleChains;
  exports.getAnimations = getAnimations;
  exports.getAvailableFilterOperationsGetter = getAvailableFilterOperationsGetter;
  exports.getAvailableRowCount = getAvailableRowCount;
  exports.getBandComponent = getBandComponent;
  exports.getCellGeometries = getCellGeometries;
  exports.getClosestCellByRow = getClosestCellByRow;
  exports.getCollapsedGrid = getCollapsedGrid;
  exports.getCollapsedGrids = getCollapsedGrids;
  exports.getColumnBoundaries = getColumnBoundaries;
  exports.getColumnExtension = getColumnExtension;
  exports.getColumnExtensionValueGetter = getColumnExtensionValueGetter;
  exports.getColumnFilterConfig = getColumnFilterConfig;
  exports.getColumnFilterOperations = getColumnFilterOperations;
  exports.getColumnMeta = getColumnMeta;
  exports.getColumnSizes = getColumnSizes;
  exports.getColumnSortingDirection = getColumnSortingDirection;
  exports.getColumnSummaries = getColumnSummaries;
  exports.getColumnWidthGetter = getColumnWidthGetter;
  exports.getColumnsRenderBoundary = getColumnsRenderBoundary;
  exports.getFixedColumnKeys = getFixedColumnKeys;
  exports.getFocusing = getFocusing;
  exports.getForceReloadInterval = getForceReloadInterval;
  exports.getGroupCellTargetIndex = getGroupCellTargetIndex;
  exports.getGroupInlineSummaries = getGroupInlineSummaries;
  exports.getIndexToFocus = getIndexToFocus;
  exports.getInnerElements = getInnerElements;
  exports.getNextColumnName = getNextColumnName;
  exports.getNextFocusedCell = getNextFocusedCell;
  exports.getPart = getPart;
  exports.getPersistentSortedColumns = getPersistentSortedColumns;
  exports.getReferenceIndex = getReferenceIndex;
  exports.getRequestMeta = getRequestMeta;
  exports.getRowChange = getRowChange;
  exports.getRowsRenderBoundary = getRowsRenderBoundary;
  exports.getRowsVisibleBoundary = getRowsVisibleBoundary;
  exports.getScrollLeft = getScrollLeft;
  exports.getScrollTop = getScrollTop;
  exports.getSelectedFilterOperation = getSelectedFilterOperation;
  exports.getTableColumnGeometries = getTableColumnGeometries;
  exports.getTableTargetColumnIndex = getTableTargetColumnIndex;
  exports.getTopRowId = getTopRowId;
  exports.getTreeRowLevelGetter = getTreeRowLevelGetter;
  exports.getViewport = getViewport;
  exports.groupCollapsedRowsGetter = groupCollapsedRowsGetter;
  exports.groupFooterSummaryExists = groupFooterSummaryExists;
  exports.groupOutlineLevels = groupOutlineLevels;
  exports.groupRowChecker = groupRowChecker;
  exports.groupRowLevelKeyGetter = groupRowLevelKeyGetter;
  exports.groupSummaryValues = groupSummaryValues;
  exports.groupedRows = groupedRows;
  exports.groupingPanelItems = groupingPanelItems;
  exports.intervalUtil = intervalUtil;
  exports.isAddedTableRow = isAddedTableRow;
  exports.isBandedOrHeaderRow = isBandedOrHeaderRow;
  exports.isBandedTableRow = isBandedTableRow;
  exports.isCellExist = isCellExist;
  exports.isCellFocused = isCellFocused;
  exports.isDataTableCell = isDataTableCell;
  exports.isDataTableRow = isDataTableRow;
  exports.isDetailRowExpanded = isDetailRowExpanded;
  exports.isDetailTableCell = isDetailTableCell;
  exports.isDetailTableRow = isDetailTableRow;
  exports.isDetailToggleTableCell = isDetailToggleTableCell;
  exports.isEditCommandsTableCell = isEditCommandsTableCell;
  exports.isEditTableCell = isEditTableCell;
  exports.isEditTableRow = isEditTableRow;
  exports.isFilterTableCell = isFilterTableCell;
  exports.isFilterTableRow = isFilterTableRow;
  exports.isFilterValueEmpty = isFilterValueEmpty;
  exports.isFixedTableRow = isFixedTableRow;
  exports.isFooterSummary = isFooterSummary;
  exports.isGroupIndentStubTableCell = isGroupIndentStubTableCell;
  exports.isGroupIndentTableCell = isGroupIndentTableCell;
  exports.isGroupRowOrdinaryCell = isGroupRowOrdinaryCell;
  exports.isGroupSummaryTableCell = isGroupSummaryTableCell;
  exports.isGroupSummaryTableRow = isGroupSummaryTableRow;
  exports.isGroupTableCell = isGroupTableCell;
  exports.isGroupTableRow = isGroupTableRow;
  exports.isHeaderStubTableCell = isHeaderStubTableCell;
  exports.isHeadingEditCommandsTableCell = isHeadingEditCommandsTableCell;
  exports.isHeadingTableCell = isHeadingTableCell;
  exports.isHeadingTableRow = isHeadingTableRow;
  exports.isInlineGroupCaptionSummary = isInlineGroupCaptionSummary;
  exports.isNoDataColumn = isNoDataColumn;
  exports.isNoDataTableCell = isNoDataTableCell;
  exports.isNoDataTableRow = isNoDataTableRow;
  exports.isPreviousCellContainSummary = isPreviousCellContainSummary;
  exports.isRowFocused = isRowFocused;
  exports.isRowHighlighted = isRowHighlighted;
  exports.isRowSummaryCell = isRowSummaryCell;
  exports.isSelectAllTableCell = isSelectAllTableCell;
  exports.isSelectTableCell = isSelectTableCell;
  exports.isStubTableCell = isStubTableCell;
  exports.isTabArrowUpDown = isTabArrowUpDown;
  exports.isTotalSummaryTableCell = isTotalSummaryTableCell;
  exports.isTotalSummaryTableRow = isTotalSummaryTableRow;
  exports.isTreeRowLeafGetter = isTreeRowLeafGetter;
  exports.isTreeSummaryTableCell = isTreeSummaryTableCell;
  exports.isTreeSummaryTableRow = isTreeSummaryTableRow;
  exports.isTreeTableCell = isTreeTableCell;
  exports.isValidValue = isValidValue;
  exports.lastRowOnPage = lastRowOnPage;
  exports.loadedRowsStart = loadedRowsStart;
  exports.maximumGroupLevel = maximumGroupLevel;
  exports.mergeRows = mergeRows;
  exports.needFetchMorePages = needFetchMorePages;
  exports.normalizeRanges = normalizeRanges;
  exports.orderedColumns = orderedColumns;
  exports.pageCount = pageCount;
  exports.paginatedRows = paginatedRows;
  exports.plainRows = plainRows;
  exports.prepareGroupSummaryItems = prepareGroupSummaryItems;
  exports.recalculateBounds = recalculateBounds;
  exports.removeEmptyGroups = removeEmptyGroups;
  exports.rowCount = rowCount;
  exports.rowIdGetter = rowIdGetter;
  exports.rowToPageIndex = rowToPageIndex;
  exports.rowsToExport = rowsToExport;
  exports.rowsWithAvailableToSelect = rowsWithAvailableToSelect;
  exports.rowsWithEditingCells = rowsWithEditingCells;
  exports.rowsWithPageHeaders = rowsWithPageHeaders;
  exports.searchFilterExpression = searchFilterExpression;
  exports.setCurrentPage = setCurrentPage;
  exports.setPageSize = setPageSize;
  exports.shouldSendRequest = shouldSendRequest;
  exports.someSelected = someSelected;
  exports.sortAndSpliceColumns = sortAndSpliceColumns;
  exports.sortedRows = sortedRows;
  exports.splitHeaderColumnChains = splitHeaderColumnChains;
  exports.startEditCells = startEditCells;
  exports.startEditRows = startEditRows;
  exports.stopEditCells = stopEditCells;
  exports.stopEditRows = stopEditRows;
  exports.tableCellColSpanGetter = tableCellColSpanGetter;
  exports.tableColumnsWithDataRows = tableColumnsWithDataRows;
  exports.tableColumnsWithDetail = tableColumnsWithDetail;
  exports.tableColumnsWithDraftWidths = tableColumnsWithDraftWidths;
  exports.tableColumnsWithEditing = tableColumnsWithEditing;
  exports.tableColumnsWithFixed = tableColumnsWithFixed;
  exports.tableColumnsWithGrouping = tableColumnsWithGrouping;
  exports.tableColumnsWithSelection = tableColumnsWithSelection;
  exports.tableColumnsWithWidths = tableColumnsWithWidths;
  exports.tableDataColumnsExist = tableDataColumnsExist;
  exports.tableDetailCellColSpanGetter = tableDetailCellColSpanGetter;
  exports.tableGroupCellColSpanGetter = tableGroupCellColSpanGetter;
  exports.tableHeaderColumnChainsWithBands = tableHeaderColumnChainsWithBands;
  exports.tableHeaderColumnChainsWithFixed = tableHeaderColumnChainsWithFixed;
  exports.tableHeaderRowsWithFilter = tableHeaderRowsWithFilter;
  exports.tableHeaderRowsWithFixed = tableHeaderRowsWithFixed;
  exports.tableHeaderRowsWithReordering = tableHeaderRowsWithReordering;
  exports.tableRowsWithBands = tableRowsWithBands;
  exports.tableRowsWithDataRows = tableRowsWithDataRows;
  exports.tableRowsWithEditing = tableRowsWithEditing;
  exports.tableRowsWithExpandedDetail = tableRowsWithExpandedDetail;
  exports.tableRowsWithGrouping = tableRowsWithGrouping;
  exports.tableRowsWithHeading = tableRowsWithHeading;
  exports.tableRowsWithSummaries = tableRowsWithSummaries;
  exports.tableRowsWithTotalSummaries = tableRowsWithTotalSummaries;
  exports.toggleColumn = toggleColumn;
  exports.toggleDetailRowExpanded = toggleDetailRowExpanded;
  exports.toggleExpandedGroups = toggleExpandedGroups;
  exports.toggleRowExpanded = toggleRowExpanded;
  exports.toggleSelection = toggleSelection;
  exports.totalSummaryValues = totalSummaryValues;
  exports.treeSummaryValues = treeSummaryValues;
  exports.trimRowsToInterval = trimRowsToInterval;
  exports.unwrapSelectedRows = unwrapSelectedRows;
  exports.unwrappedCustomTreeRows = unwrappedCustomTreeRows;
  exports.unwrappedFilteredRows = unwrappedFilteredRows;
  exports.virtualRowsWithCache = virtualRowsWithCache;
  exports.visibleTableColumns = visibleTableColumns;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=dx-grid-core.umd.js.map
